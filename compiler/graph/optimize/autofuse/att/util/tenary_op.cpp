/**
 * Copyright (c) Huawei Technologies Co., Ltd. 2024 All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "tenary_op.h"

namespace att {
namespace {
void AddUsedArgs(const Expr &expr, std::vector<Expr> &used_args) {
  for (const auto &arg : expr.FreeSymbols()) {
    used_args.emplace_back(arg);
  }
}
}  // namespace

std::string IfCase::GetStr() const {
  if (choice_b_ == nullptr) {
    return Str(expr_);
  } else {
    std::string cond_str;
    if (cond_type_ == CondType::K_EQ) {
      cond_str = "IsEqual(" + Str(cond_left_) + ", " + Str(cond_right_) + ")";
    } else if (cond_type_ == CondType::K_LT) {
      cond_str = Str(cond_left_) + " < " + Str(cond_right_);
    } else if (cond_type_ == CondType::K_GT) {
      cond_str = Str(cond_left_) + " > " + Str(cond_right_);
    } else if (cond_type_ == CondType::K_GE) {
      cond_str = Str(cond_left_) + " <= " + Str(cond_right_);
    } else if (cond_type_ == CondType::K_LE) {
      cond_str = Str(cond_left_) + " >= " + Str(cond_right_);
    }
    return "TenaryOp(" + cond_str + ", " + choice_a_->GetStr() + ", " + choice_b_->GetStr() + ")";
  }
}

void IfCase::Replace(const std::vector<std::pair<Expr, Expr>> &replace_vars) {
  if (choice_b_ != nullptr) {
    cond_left_ = cond_left_.Replace(replace_vars);
    cond_right_ = cond_right_.Replace(replace_vars);
    choice_a_->Replace(replace_vars);
    choice_b_->Replace(replace_vars);
  } else {
    expr_ = expr_.Replace(replace_vars);
  }
}

std::shared_ptr<IfCase> IfCase::DeepCopy() const {
  if (choice_b_ == nullptr) {
    return std::make_shared<IfCase>(expr_);
  }
  return std::make_shared<IfCase>(cond_type_, cond_left_, cond_right_, choice_a_->DeepCopy(), choice_b_->DeepCopy());
}

void IfCase::GetUsedArgs(std::vector<Expr> &used_args) {
  if (choice_b_ != nullptr) {
    AddUsedArgs(cond_left_, used_args);
    AddUsedArgs(cond_right_, used_args);
    choice_a_->GetUsedArgs(used_args);
    choice_b_->GetUsedArgs(used_args);
  } else {
    AddUsedArgs(expr_, used_args);
  }
}

TenaryOp::TenaryOp(const Expr &expr) {
  tenary_op_ = std::make_shared<IfCase>(expr);
  AddUsedArgs(expr, related_vars_);
}

TenaryOp::TenaryOp(const CondType &cond_type, const Expr &cond_left, const Expr &cond_right, const Expr &choice_a,
                   const Expr &choice_b) {
  tenary_op_ = std::make_shared<IfCase>(cond_type, cond_left, cond_right, std::make_shared<IfCase>(choice_a), std::make_shared<IfCase>(choice_b));
  AddUsedArgs(cond_left, related_vars_);
  AddUsedArgs(cond_right, related_vars_);
  AddUsedArgs(choice_a, related_vars_);
  AddUsedArgs(choice_b, related_vars_);
}

TenaryOp::TenaryOp(const CondType &cond_type, const Expr &cond_left, const Expr &cond_right, 
                   std::shared_ptr<IfCase> &&if_case_a, std::shared_ptr<IfCase> &&if_case_b) {
  tenary_op_ = std::make_shared<IfCase>(cond_type, cond_left, cond_right, std::move(if_case_a), std::move(if_case_b));
  tenary_op_->GetUsedArgs(related_vars_);
}

TenaryOp::TenaryOp(const Expr &var, std::shared_ptr<IfCase> &&op, const std::vector<Expr> &related) {
  variable_ = var;
  tenary_op_ = std::move(op);
  for (const auto &arg : related) {
    related_vars_.emplace_back(arg);
  }
}

TenaryOp::TenaryOp(const CondType &cond_type, const Expr &cond_left, const Expr &cond_right, 
                   const TenaryOp &tenary_op_a, const TenaryOp &tenary_op_b) {
  tenary_op_ = std::make_shared<IfCase>(cond_type, cond_left, cond_right, 
                                       tenary_op_a.DeepCopyIfCase(), tenary_op_b.DeepCopyIfCase());
  for (const auto &var : tenary_op_a.GetRelatedVars()) {
    related_vars_.emplace_back(var);
  }
  for (const auto &var : tenary_op_b.GetRelatedVars()) {
    related_vars_.emplace_back(var);
  }
  AddUsedArgs(cond_left, related_vars_);
  AddUsedArgs(cond_right, related_vars_);
}

void TenaryOp::SetVariable(const Expr &expr) {
  variable_ = expr;
}

Expr TenaryOp::GetVariable() const {
  return variable_;
}

std::string TenaryOp::GetTenaryOpStr() const {
  return tenary_op_->GetStr();
}

void TenaryOp::UpdateRelatedVars(const std::vector<std::pair<Expr, Expr>> &replace_vars) {
  ExprExprMap replace_ops;
  for (const auto &pair : replace_vars) {
    replace_ops[pair.first] = pair.second;
  }
  std::vector<Expr> new_related_vars;
  for (const auto &var : related_vars_) {
    auto iter = replace_ops.find(var);
    if (iter != replace_ops.end()) {
      new_related_vars.emplace_back(iter->second);
    } else {
      new_related_vars.emplace_back(var);
    }
  }
  related_vars_ = new_related_vars;
}

void TenaryOp::Replace(const std::vector<std::pair<Expr, Expr>> &replace_vars) {
  tenary_op_->Replace(replace_vars);
  ExprExprMap vars_map;
  std::vector<Expr> new_related_vars;
  for (const auto &pair : replace_vars) {
    vars_map[pair.first] = pair.second;
  }
  for (const auto &var : related_vars_) {
    auto iter = vars_map.find(var);
    if (iter != vars_map.end()) {
      for (const auto &arg : iter->second.FreeSymbols()) {
        new_related_vars.emplace_back(arg);
      }
    } else {
      new_related_vars.emplace_back(var);
    }
  }
  related_vars_ = new_related_vars;
}

std::vector<Expr> TenaryOp::GetRelatedVars() const {
  std::vector<Expr> res;
  for (const auto &var : related_vars_) {
    res.emplace_back(var);
  }
  return res;
}

TenaryOp TenaryOp::DeepCopy() const {
  return TenaryOp(variable_, tenary_op_->DeepCopy(), related_vars_);
}

std::shared_ptr<IfCase> TenaryOp::DeepCopyIfCase() const {
  return tenary_op_->DeepCopy();
}

namespace {
bool InTenaryOps(const TenaryOp &tenary_op, const std::map<Expr, TenaryOp, ExprCmp> &tenary_ops, const ExprExprMap &res,
                 std::stack<Expr> &replace_stack) {
  bool ret = false;
  for (const auto &args : tenary_op.GetRelatedVars()) {
    if (tenary_ops.find(args) != tenary_ops.end() && res.find(args) == res.end()) {
      ret = true;
      replace_stack.push(args);
    }
  }
  return ret;
}

void AddRelatedVars(const Expr &expr, const TenaryOp &tenary_op, const std::map<Expr, TenaryOp, ExprCmp> &tenary_ops,
                    std::map<Expr, std::vector<Expr>, ExprCmp> &res) {
  std::vector<Expr> related_vars;
  for (const auto &arg : tenary_op.GetRelatedVars()) {
    auto iter = tenary_ops.find(arg);
    if (iter != tenary_ops.end()) {
      if (res.find(arg) == res.end()) {
        AddRelatedVars(arg, iter->second, tenary_ops, res);
      }
      for (const auto &var : res.at(arg)) {
        related_vars.emplace_back(var);
      }
    } else {
      related_vars.emplace_back(arg);
    }
  }
  res[expr] = related_vars;
}
} // namespace

std::vector<std::pair<Expr, Expr>> ConcursiveReplaceVars(const std::map<Expr, TenaryOp, ExprCmp> &tenary_ops) {
  Expr cur_var;
  Expr replace_var;
  ExprExprMap res;
  TenaryOp cur_tenary_op;
  std::stack<Expr> replace_stack;
  std::vector<std::pair<Expr, Expr>> replace_vars;
  for (const auto &pair : tenary_ops) {
    if (res.find(pair.first) != res.end()) {
      continue;
    }
    InTenaryOps(pair.second, tenary_ops, res, replace_stack);
    while (!replace_stack.empty()) {
      cur_var = replace_stack.top();
      cur_tenary_op = tenary_ops.at(cur_var).DeepCopy();
      if (!InTenaryOps(cur_tenary_op, tenary_ops, res, replace_stack)) {
        cur_tenary_op.Replace(replace_vars);
        replace_var = CreateExpr(cur_tenary_op.GetTenaryOpStr().c_str());
        res[cur_var] = replace_var;
        replace_vars.emplace_back(std::make_pair(cur_var, replace_var));
        GELOGD("Make concursive replace [%s] -> [%s].", Str(cur_var).c_str(), Str(replace_var).c_str());
        replace_stack.pop();
      }
    }
    cur_var = pair.first;
    cur_tenary_op = pair.second.DeepCopy();
    cur_tenary_op.Replace(replace_vars);
    replace_var = CreateExpr(cur_tenary_op.GetTenaryOpStr().c_str());
    res[cur_var] = replace_var;
    replace_vars.emplace_back(std::make_pair(cur_var, replace_var));
    GELOGD("Make concursive replace [%s] -> [%s].", Str(cur_var).c_str(), Str(replace_var).c_str());
  }
  return replace_vars;
}

std::map<Expr, std::vector<Expr>, ExprCmp> ConcursiveRelatedVars(const std::map<Expr, TenaryOp, ExprCmp> &tenary_ops) {
  std::vector<Expr> cur_related;
  std::map<Expr, std::vector<Expr>, ExprCmp> res;
  for (const auto &pair : tenary_ops) {
    if (res.find(pair.first) != res.end()) {
      continue;
    }
    AddRelatedVars(pair.first, pair.second, tenary_ops, res);
  }
  for (const auto &pair : res) {
    GELOGD("Make concursive vars [%s]:{%s}.", Str(pair.first).c_str(), GetVecString(pair.second).c_str());
  }
  return res;
}

void GetPerfVar(const std::string &prefix, Expr &res, const std::map<Expr, TenaryOp, ExprCmp> &tenary_ops) {
  uint32_t idx = 0;
  std::string perf_name = prefix;
  res = CreateExpr(perf_name.c_str());
  while (tenary_ops.find(res) != tenary_ops.end()) {
    perf_name = prefix + std::to_string(++idx);
    res = CreateExpr(perf_name.c_str());
  }
}
}  // namespace att