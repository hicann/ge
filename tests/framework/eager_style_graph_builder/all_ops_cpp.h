/**
 * Copyright (c) 2025 Huawei Technologies Co., Ltd.
 * This program is free software, you can redistribute it and/or modify it under the terms and conditions of 
 * CANN Open Software License Agreement Version 2.0 (the "License").
 * Please refer to the License for details. You may not use this file except in compliance with the License.
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
 * INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
 * See LICENSE in the root of the software repository for the full text of the License.
 */

/*********************************************************************************************************************
 This file is GENERATED by scripts/tensor_graph_generation/ops_collector/gen_esb, do not edit it manually
*********************************************************************************************************************/
#ifndef AIR_CXX_COMPILER_GRAPH_EAGER_STYLE_GRAPH_BUILDER_ALL_OPS_CPP_H
#define AIR_CXX_COMPILER_GRAPH_EAGER_STYLE_GRAPH_BUILDER_ALL_OPS_CPP_H
#include <utility>
#include "esb_funcs_cpp.h"
#include "all_ops.h"
namespace es {
inline Tensor AGLU(const Tensor &x, const Tensor &weight1, const Tensor &bias1, const Tensor &weight2, const Tensor &bias2, const char *activate_func, bool activate_left=false) {
  auto out = EsAGLU(x.GetEsbTensor(), weight1.GetEsbTensor(), bias1.GetEsbTensor(), weight2.GetEsbTensor(), bias2.GetEsbTensor(), activate_func, activate_left);
  return out;
}
struct AUGRUHiddenGradCellOutput {
  Tensor dh_prev;
  Tensor dgate_h;
  Tensor dnt_x;
  Tensor dw_att_t;
};
inline AUGRUHiddenGradCellOutput AUGRUHiddenGradCell(const Tensor &weight_att, const Tensor &dh_pre_t, const Tensor &h, const Tensor &dy, const Tensor &dh, const Tensor &update, const Tensor &update_att, const Tensor &reset, const Tensor &in_new, const Tensor &hidden_new, const Tensor &seq_length=nullptr, int64_t t_state=0, const char *gate_order="zrh") {
  auto out = EsAUGRUHiddenGradCell(weight_att.GetEsbTensor(), dh_pre_t.GetEsbTensor(), h.GetEsbTensor(), dy.GetEsbTensor(), dh.GetEsbTensor(), update.GetEsbTensor(), update_att.GetEsbTensor(), reset.GetEsbTensor(), in_new.GetEsbTensor(), hidden_new.GetEsbTensor(), seq_length.GetEsbTensor(), t_state, gate_order);
  return {out.dh_prev, out.dgate_h, out.dnt_x, out.dw_att_t};
}
inline Tensor Abs(const Tensor &x) {
  auto out = EsAbs(x.GetEsbTensor());
  return out;
}
inline Tensor AbsGrad(const Tensor &y, const Tensor &dy) {
  auto out = EsAbsGrad(y.GetEsbTensor(), dy.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor AbsGrad(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return AbsGrad(tensor, b_esb_tensor);
}
inline Tensor AccumulateNV2(const std::vector<Tensor> &x, int64_t N) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsAccumulateNV2(esb_x.data(), static_cast<int64_t>(esb_x.size()), N);
  return out;
}
inline Tensor AccumulatorApplyGradient(const Tensor &handle, const Tensor &local_step, const Tensor &gradient, ge::DataType dtype) {
  auto out = EsAccumulatorApplyGradient(handle.GetEsbTensor(), local_step.GetEsbTensor(), gradient.GetEsbTensor(), dtype);
  return out;
}
inline Tensor AccumulatorNumAccumulated(const Tensor &handle) {
  auto out = EsAccumulatorNumAccumulated(handle.GetEsbTensor());
  return out;
}
inline Tensor AccumulatorSetGlobalStep(const Tensor &handle, const Tensor &new_global_step) {
  auto out = EsAccumulatorSetGlobalStep(handle.GetEsbTensor(), new_global_step.GetEsbTensor());
  return out;
}
inline Tensor AccumulatorTakeGradient(const Tensor &handle, const Tensor &num_required, ge::DataType dtype) {
  auto out = EsAccumulatorTakeGradient(handle.GetEsbTensor(), num_required.GetEsbTensor(), dtype);
  return out;
}
inline Tensor Acos(const Tensor &x) {
  auto out = EsAcos(x.GetEsbTensor());
  return out;
}
inline Tensor AcosGrad(const Tensor &y, const Tensor &dy) {
  auto out = EsAcosGrad(y.GetEsbTensor(), dy.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor AcosGrad(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return AcosGrad(tensor, b_esb_tensor);
}
inline Tensor Acosh(const Tensor &x) {
  auto out = EsAcosh(x.GetEsbTensor());
  return out;
}
inline Tensor AcoshGrad(const Tensor &y, const Tensor &dy) {
  auto out = EsAcoshGrad(y.GetEsbTensor(), dy.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor AcoshGrad(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return AcoshGrad(tensor, b_esb_tensor);
}
inline Tensor ActULQClampMaxGrad(const Tensor &y_grad, const Tensor &clamp_max_mask, const Tensor &x_clamped_loss) {
  auto out = EsActULQClampMaxGrad(y_grad.GetEsbTensor(), clamp_max_mask.GetEsbTensor(), x_clamped_loss.GetEsbTensor());
  return out;
}
inline Tensor ActULQClampMinGrad(const Tensor &y_grad, const Tensor &clamp_min_mask, const Tensor &x_clamped_loss) {
  auto out = EsActULQClampMinGrad(y_grad.GetEsbTensor(), clamp_min_mask.GetEsbTensor(), x_clamped_loss.GetEsbTensor());
  return out;
}
inline Tensor ActiveRotatedFilter(const Tensor &x, const Tensor &indices) {
  auto out = EsActiveRotatedFilter(x.GetEsbTensor(), indices.GetEsbTensor());
  return out;
}
inline Tensor ActiveRotatedFilterGrad(const Tensor &y_grad, const Tensor &indices) {
  auto out = EsActiveRotatedFilterGrad(y_grad.GetEsbTensor(), indices.GetEsbTensor());
  return out;
}
struct ActsULQOutput {
  Tensor y;
  Tensor clamp_min_mask;
  Tensor clamp_max_mask;
  Tensor x_clamped_loss;
};
inline ActsULQOutput ActsULQ(const Tensor &x, const Tensor &clamp_min, const Tensor &clamp_max, bool fixed_min=false, int64_t num_bits=8) {
  auto out = EsActsULQ(x.GetEsbTensor(), clamp_min.GetEsbTensor(), clamp_max.GetEsbTensor(), fixed_min, num_bits);
  return {out.y, out.clamp_min_mask, out.clamp_max_mask, out.x_clamped_loss};
}
inline Tensor ActsULQInputGrad(const Tensor &y_grad, const Tensor &clamp_min_mask, const Tensor &clamp_max_mask) {
  auto out = EsActsULQInputGrad(y_grad.GetEsbTensor(), clamp_min_mask.GetEsbTensor(), clamp_max_mask.GetEsbTensor());
  return out;
}
inline Tensor AdaCast(const Tensor &x, int64_t pixel=65535) {
  auto out = EsAdaCast(x.GetEsbTensor(), pixel);
  return out;
}
struct AdaLayerNormOutput {
  Tensor y;
  Tensor ln_res;
  Tensor mean;
  Tensor rstd;
};
inline AdaLayerNormOutput AdaLayerNorm(const Tensor &x, const Tensor &scale, const Tensor &shift, float epsilon=0.000010) {
  auto out = EsAdaLayerNorm(x.GetEsbTensor(), scale.GetEsbTensor(), shift.GetEsbTensor(), epsilon);
  return {out.y, out.ln_res, out.mean, out.rstd};
}
struct AdaLayerNormGradOutput {
  Tensor dx;
  Tensor dshift;
  Tensor dscale;
};
inline AdaLayerNormGradOutput AdaLayerNormGrad(const Tensor &dy, const Tensor &x, const Tensor &mean, const Tensor &rstd, const Tensor &scale, const Tensor &ln_res) {
  auto out = EsAdaLayerNormGrad(dy.GetEsbTensor(), x.GetEsbTensor(), mean.GetEsbTensor(), rstd.GetEsbTensor(), scale.GetEsbTensor(), ln_res.GetEsbTensor());
  return {out.dx, out.dshift, out.dscale};
}
struct AdamApplyOneOutput {
  Tensor output0;
  Tensor output1;
  Tensor output2;
};
inline AdamApplyOneOutput AdamApplyOne(const Tensor &input0, const Tensor &input1, const Tensor &input2, const Tensor &input3, const Tensor &input4, const Tensor &mul0_x, const Tensor &mul1_x, const Tensor &mul2_x, const Tensor &mul3_x, const Tensor &add2_y) {
  auto out = EsAdamApplyOne(input0.GetEsbTensor(), input1.GetEsbTensor(), input2.GetEsbTensor(), input3.GetEsbTensor(), input4.GetEsbTensor(), mul0_x.GetEsbTensor(), mul1_x.GetEsbTensor(), mul2_x.GetEsbTensor(), mul3_x.GetEsbTensor(), add2_y.GetEsbTensor());
  return {out.output0, out.output1, out.output2};
}
struct AdamApplyOneAssignOutput {
  Tensor input1;
  Tensor input2;
  Tensor input3;
};
inline AdamApplyOneAssignOutput AdamApplyOneAssign(const Tensor &input0, const Tensor &input1, const Tensor &input2, const Tensor &input3, const Tensor &input4, const Tensor &mul0_x, const Tensor &mul1_x, const Tensor &mul2_x, const Tensor &mul3_x, const Tensor &add2_y) {
  auto out = EsAdamApplyOneAssign(input0.GetEsbTensor(), input1.GetEsbTensor(), input2.GetEsbTensor(), input3.GetEsbTensor(), input4.GetEsbTensor(), mul0_x.GetEsbTensor(), mul1_x.GetEsbTensor(), mul2_x.GetEsbTensor(), mul3_x.GetEsbTensor(), add2_y.GetEsbTensor());
  return {out.input1, out.input2, out.input3};
}
struct AdamApplyOneWithDecayOutput {
  Tensor output0;
  Tensor output1;
  Tensor output2;
};
inline AdamApplyOneWithDecayOutput AdamApplyOneWithDecay(const Tensor &input0, const Tensor &input1, const Tensor &input2, const Tensor &input3, const Tensor &input4, const Tensor &mul0_x, const Tensor &mul1_x, const Tensor &mul2_x, const Tensor &mul3_x, const Tensor &mul4_x, const Tensor &add2_y) {
  auto out = EsAdamApplyOneWithDecay(input0.GetEsbTensor(), input1.GetEsbTensor(), input2.GetEsbTensor(), input3.GetEsbTensor(), input4.GetEsbTensor(), mul0_x.GetEsbTensor(), mul1_x.GetEsbTensor(), mul2_x.GetEsbTensor(), mul3_x.GetEsbTensor(), mul4_x.GetEsbTensor(), add2_y.GetEsbTensor());
  return {out.output0, out.output1, out.output2};
}
struct AdamApplyOneWithDecayAssignOutput {
  Tensor input1;
  Tensor input2;
  Tensor input3;
};
inline AdamApplyOneWithDecayAssignOutput AdamApplyOneWithDecayAssign(const Tensor &input0, const Tensor &input1, const Tensor &input2, const Tensor &input3, const Tensor &input4, const Tensor &mul0_x, const Tensor &mul1_x, const Tensor &mul2_x, const Tensor &mul3_x, const Tensor &mul4_x, const Tensor &add2_y) {
  auto out = EsAdamApplyOneWithDecayAssign(input0.GetEsbTensor(), input1.GetEsbTensor(), input2.GetEsbTensor(), input3.GetEsbTensor(), input4.GetEsbTensor(), mul0_x.GetEsbTensor(), mul1_x.GetEsbTensor(), mul2_x.GetEsbTensor(), mul3_x.GetEsbTensor(), mul4_x.GetEsbTensor(), add2_y.GetEsbTensor());
  return {out.input1, out.input2, out.input3};
}
inline Tensor AdaptiveAvgPool(const Tensor &x, const Tensor &output_size) {
  auto out = EsAdaptiveAvgPool(x.GetEsbTensor(), output_size.GetEsbTensor());
  return out;
}
inline Tensor AdaptiveAvgPool2d(const Tensor &x, const std::vector<int64_t> &output_size) {
  auto out = EsAdaptiveAvgPool2d(x.GetEsbTensor(), output_size.data(), static_cast<int64_t>(output_size.size()));
  return out;
}
struct AdaptiveAvgPool2dAssistMatrixOutput {
  Tensor left_matrix;
  Tensor right_matrix;
  Tensor weight_matrix;
};
inline AdaptiveAvgPool2dAssistMatrixOutput AdaptiveAvgPool2dAssistMatrix(const Tensor &input_size, const std::vector<int64_t> &output_size) {
  auto out = EsAdaptiveAvgPool2dAssistMatrix(input_size.GetEsbTensor(), output_size.data(), static_cast<int64_t>(output_size.size()));
  return {out.left_matrix, out.right_matrix, out.weight_matrix};
}
inline Tensor AdaptiveAvgPool2dGrad(const Tensor &input_grad, const std::vector<int64_t> &orig_input_shape) {
  auto out = EsAdaptiveAvgPool2dGrad(input_grad.GetEsbTensor(), orig_input_shape.data(), static_cast<int64_t>(orig_input_shape.size()));
  return out;
}
inline Tensor AdaptiveAvgPool3d(const Tensor &x, const std::vector<int64_t> &output_size, const char *data_format="NDHWC") {
  auto out = EsAdaptiveAvgPool3d(x.GetEsbTensor(), output_size.data(), static_cast<int64_t>(output_size.size()), data_format);
  return out;
}
struct AdaptiveAvgPoolAssistMatrixOutput {
  Tensor left_matrix;
  Tensor right_matrix;
  Tensor weight_matrix;
};
inline AdaptiveAvgPoolAssistMatrixOutput AdaptiveAvgPoolAssistMatrix(const Tensor &input_size, const Tensor &output_size) {
  auto out = EsAdaptiveAvgPoolAssistMatrix(input_size.GetEsbTensor(), output_size.GetEsbTensor());
  return {out.left_matrix, out.right_matrix, out.weight_matrix};
}
struct AdaptiveMaxPool2dOutput {
  Tensor y;
  Tensor argmax;
};
inline AdaptiveMaxPool2dOutput AdaptiveMaxPool2d(const Tensor &x, const std::vector<int64_t> &output_size) {
  auto out = EsAdaptiveMaxPool2d(x.GetEsbTensor(), output_size.data(), static_cast<int64_t>(output_size.size()));
  return {out.y, out.argmax};
}
inline Tensor Add(const Tensor &x1, const Tensor &x2) {
  auto out = EsAdd(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor Add(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return Add(tensor, b_esb_tensor);
}
struct AddLayerNormOutput {
  Tensor y;
  Tensor mean;
  Tensor rstd;
  Tensor x;
};
inline AddLayerNormOutput AddLayerNorm(const Tensor &x1, const Tensor &x2, const Tensor &gamma, const Tensor &beta, const Tensor &bias=nullptr, float epsilon=0.000010, bool additional_output=false) {
  auto out = EsAddLayerNorm(x1.GetEsbTensor(), x2.GetEsbTensor(), gamma.GetEsbTensor(), beta.GetEsbTensor(), bias.GetEsbTensor(), epsilon, additional_output);
  return {out.y, out.mean, out.rstd, out.x};
}
struct AddLayerNormGradOutput {
  Tensor dx;
  Tensor dgamma;
  Tensor dbeta;
};
inline AddLayerNormGradOutput AddLayerNormGrad(const Tensor &dy, const Tensor &x1, const Tensor &x2, const Tensor &rstd, const Tensor &mean, const Tensor &gamma, const Tensor &dsum=nullptr) {
  auto out = EsAddLayerNormGrad(dy.GetEsbTensor(), x1.GetEsbTensor(), x2.GetEsbTensor(), rstd.GetEsbTensor(), mean.GetEsbTensor(), gamma.GetEsbTensor(), dsum.GetEsbTensor());
  return {out.dx, out.dgamma, out.dbeta};
}
struct AddLayerNormQuantOutput {
  Tensor y1;
  Tensor y2;
  Tensor x;
  Tensor out_scales1;
  Tensor out_scales2;
};
inline AddLayerNormQuantOutput AddLayerNormQuant(const Tensor &x1, const Tensor &x2, const Tensor &gamma, const Tensor &beta, const Tensor &bias=nullptr, const Tensor &scales1=nullptr, const Tensor &scales2=nullptr, const Tensor &zero_points1=nullptr, const Tensor &zero_points2=nullptr, const char *quant_mode="dynamic", float epsilon=0.000010, bool additional_output=false) {
  auto out = EsAddLayerNormQuant(x1.GetEsbTensor(), x2.GetEsbTensor(), gamma.GetEsbTensor(), beta.GetEsbTensor(), bias.GetEsbTensor(), scales1.GetEsbTensor(), scales2.GetEsbTensor(), zero_points1.GetEsbTensor(), zero_points2.GetEsbTensor(), quant_mode, epsilon, additional_output);
  return {out.y1, out.y2, out.x, out.out_scales1, out.out_scales2};
}
inline Tensor AddManySparseToTensorsMap(const Tensor &indices, const Tensor &values, const Tensor &shape, const char *container="", const char *shared_name="") {
  auto out = EsAddManySparseToTensorsMap(indices.GetEsbTensor(), values.GetEsbTensor(), shape.GetEsbTensor(), container, shared_name);
  return out;
}
inline Tensor AddMatMatElements(const Tensor &c, const Tensor &a, const Tensor &b, const Tensor &beta, const Tensor &alpha) {
  auto out = EsAddMatMatElements(c.GetEsbTensor(), a.GetEsbTensor(), b.GetEsbTensor(), beta.GetEsbTensor(), alpha.GetEsbTensor());
  return out;
}
inline Tensor AddN(const std::vector<Tensor> &x, int64_t N) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsAddN(esb_x.data(), static_cast<int64_t>(esb_x.size()), N);
  return out;
}
struct AddRmsNormOutput {
  Tensor y;
  Tensor rstd;
  Tensor x;
};
inline AddRmsNormOutput AddRmsNorm(const Tensor &x1, const Tensor &x2, const Tensor &gamma, float epsilon=0.000001) {
  auto out = EsAddRmsNorm(x1.GetEsbTensor(), x2.GetEsbTensor(), gamma.GetEsbTensor(), epsilon);
  return {out.y, out.rstd, out.x};
}
struct AddRmsNormDynamicQuantOutput {
  Tensor y1;
  Tensor y2;
  Tensor x;
  Tensor scale1;
  Tensor scale2;
};
inline AddRmsNormDynamicQuantOutput AddRmsNormDynamicQuant(const Tensor &x1, const Tensor &x2, const Tensor &gamma, const Tensor &smooth_scale1=nullptr, const Tensor &smooth_scale2=nullptr, float epsilon=0.000001) {
  auto out = EsAddRmsNormDynamicQuant(x1.GetEsbTensor(), x2.GetEsbTensor(), gamma.GetEsbTensor(), smooth_scale1.GetEsbTensor(), smooth_scale2.GetEsbTensor(), epsilon);
  return {out.y1, out.y2, out.x, out.scale1, out.scale2};
}
struct AddRmsNormQuantOutput {
  Tensor y1;
  Tensor y2;
  Tensor x;
};
inline AddRmsNormQuantOutput AddRmsNormQuant(const Tensor &x1, const Tensor &x2, const Tensor &gamma, const Tensor &scales1, const Tensor &scales2=nullptr, const Tensor &zero_points1=nullptr, const Tensor &zero_points2=nullptr, int64_t axis=-1, float epsilon=0.000001) {
  auto out = EsAddRmsNormQuant(x1.GetEsbTensor(), x2.GetEsbTensor(), gamma.GetEsbTensor(), scales1.GetEsbTensor(), scales2.GetEsbTensor(), zero_points1.GetEsbTensor(), zero_points2.GetEsbTensor(), axis, epsilon);
  return {out.y1, out.y2, out.x};
}
inline Tensor AddRowRanges(const Tensor &x, const Tensor &src, const Tensor &indices) {
  auto out = EsAddRowRanges(x.GetEsbTensor(), src.GetEsbTensor(), indices.GetEsbTensor());
  return out;
}
inline Tensor AddSparseToTensorsMap(const Tensor &indices, const Tensor &values, const Tensor &shape, const char *container="", const char *shared_name="") {
  auto out = EsAddSparseToTensorsMap(indices.GetEsbTensor(), values.GetEsbTensor(), shape.GetEsbTensor(), container, shared_name);
  return out;
}
inline Tensor AddV2(const Tensor &x1, const Tensor &x2) {
  auto out = EsAddV2(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor AddV2(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return AddV2(tensor, b_esb_tensor);
}
inline Tensor Addcdiv(const Tensor &input_data, const Tensor &x1, const Tensor &x2, const Tensor &value) {
  auto out = EsAddcdiv(input_data.GetEsbTensor(), x1.GetEsbTensor(), x2.GetEsbTensor(), value.GetEsbTensor());
  return out;
}
inline Tensor Addcmul(const Tensor &input_data, const Tensor &x1, const Tensor &x2, const Tensor &value) {
  auto out = EsAddcmul(input_data.GetEsbTensor(), x1.GetEsbTensor(), x2.GetEsbTensor(), value.GetEsbTensor());
  return out;
}
inline Tensor Adds(const Tensor &x, float value) {
  auto out = EsAdds(x.GetEsbTensor(), value);
  return out;
}
inline Tensor AdjustBrightness(const Tensor &images, const Tensor &delta) {
  auto out = EsAdjustBrightness(images.GetEsbTensor(), delta.GetEsbTensor());
  return out;
}
inline Tensor AdjustBrightnessV2(const Tensor &images, const Tensor &factor) {
  auto out = EsAdjustBrightnessV2(images.GetEsbTensor(), factor.GetEsbTensor());
  return out;
}
inline Tensor AdjustContrast(const Tensor &images, const Tensor &contrast_factor, const char *data_format="HWC", const char *mean_mode="chn_wise") {
  auto out = EsAdjustContrast(images.GetEsbTensor(), contrast_factor.GetEsbTensor(), data_format, mean_mode);
  return out;
}
inline Tensor AdjustContrastWithMean(const Tensor &images, const Tensor &mean, const Tensor &contrast_factor, const char *data_format="HWC") {
  auto out = EsAdjustContrastWithMean(images.GetEsbTensor(), mean.GetEsbTensor(), contrast_factor.GetEsbTensor(), data_format);
  return out;
}
inline Tensor AdjustHue(const Tensor &images, const Tensor &delta, const char *data_format="HWC") {
  auto out = EsAdjustHue(images.GetEsbTensor(), delta.GetEsbTensor(), data_format);
  return out;
}
inline Tensor AdjustSaturation(const Tensor &images, const Tensor &scale) {
  auto out = EsAdjustSaturation(images.GetEsbTensor(), scale.GetEsbTensor());
  return out;
}
inline Tensor AdjustSaturationV2(const Tensor &images, const Tensor &scale, const char *data_format="CHW") {
  auto out = EsAdjustSaturationV2(images.GetEsbTensor(), scale.GetEsbTensor(), data_format);
  return out;
}
inline Tensor AffineGrid(const Tensor &theta, const Tensor &output_size, bool align_corners=false) {
  auto out = EsAffineGrid(theta.GetEsbTensor(), output_size.GetEsbTensor(), align_corners);
  return out;
}
inline Tensor Aipp(const Tensor &images, const Tensor &params=nullptr, const char *aipp_config_path="./aipp.cfg") {
  auto out = EsAipp(images.GetEsbTensor(), params.GetEsbTensor(), aipp_config_path);
  return out;
}
struct AllCandidateSamplerOutput {
  Tensor sampled_candidates;
  Tensor true_expected_count;
  Tensor sampled_expected_count;
};
inline AllCandidateSamplerOutput AllCandidateSampler(const Tensor &true_classes, int64_t num_true, int64_t num_sampled, bool unique, int64_t seed=0, int64_t seed2=0) {
  auto out = EsAllCandidateSampler(true_classes.GetEsbTensor(), num_true, num_sampled, unique, seed, seed2);
  return {out.sampled_candidates, out.true_expected_count, out.sampled_expected_count};
}
struct AllGatherMatmulOutput {
  Tensor y;
  Tensor gather_out;
};
inline AllGatherMatmulOutput AllGatherMatmul(const Tensor &x1, const Tensor &x2, const Tensor &bias, const char *group, bool is_trans_a=false, bool is_trans_b=false, int64_t gather_index=0, int64_t comm_turn=0, int64_t rank_size=0, bool is_gather_out=true) {
  auto out = EsAllGatherMatmul(x1.GetEsbTensor(), x2.GetEsbTensor(), bias.GetEsbTensor(), group, is_trans_a, is_trans_b, gather_index, comm_turn, rank_size, is_gather_out);
  return {out.y, out.gather_out};
}
struct AlltoAllAllGatherBatchMatMulOutput {
  Tensor y1;
  Tensor y2;
  Tensor y3;
};
inline AlltoAllAllGatherBatchMatMulOutput AlltoAllAllGatherBatchMatMul(const Tensor &x, const Tensor &weight, const Tensor &bias, const char *group_ep, const char *group_tp, int64_t ep_world_size, int64_t tp_world_size, int64_t x_shard_type=0, int64_t act_type=0, bool transpose_weight=false, bool output_y2_flag=false, bool output_y3_flag=false) {
  auto out = EsAlltoAllAllGatherBatchMatMul(x.GetEsbTensor(), weight.GetEsbTensor(), bias.GetEsbTensor(), group_ep, group_tp, ep_world_size, tp_world_size, x_shard_type, act_type, transpose_weight, output_y2_flag, output_y3_flag);
  return {out.y1, out.y2, out.y3};
}
struct AmpUpdateScaleOutput {
  Tensor updated_scale;
  Tensor updated_growth_tracker;
};
inline AmpUpdateScaleOutput AmpUpdateScale(const Tensor &current_scale, const Tensor &growth_tracker, const Tensor &found_inf, float growth_factor, float backoff_factor, int64_t growth_interval) {
  auto out = EsAmpUpdateScale(current_scale.GetEsbTensor(), growth_tracker.GetEsbTensor(), found_inf.GetEsbTensor(), growth_factor, backoff_factor, growth_interval);
  return {out.updated_scale, out.updated_growth_tracker};
}
inline Tensor AnchorResponseFlags(const Tensor &gt_bboxes, const std::vector<int64_t> &featmap_size, const std::vector<int64_t> &strides, int64_t num_base_anchors) {
  auto out = EsAnchorResponseFlags(gt_bboxes.GetEsbTensor(), featmap_size.data(), static_cast<int64_t>(featmap_size.size()), strides.data(), static_cast<int64_t>(strides.size()), num_base_anchors);
  return out;
}
inline Tensor Angle(const Tensor &input, ge::DataType Tout=ge::DT_FLOAT) {
  auto out = EsAngle(input.GetEsbTensor(), Tout);
  return out;
}
inline Tensor AngleV2(const Tensor &x) {
  auto out = EsAngleV2(x.GetEsbTensor());
  return out;
}
struct AnonymousSeedGeneratorOutput {
  Tensor handle;
  Tensor deleter;
};
inline AnonymousSeedGeneratorOutput AnonymousSeedGenerator(const Tensor &seed, const Tensor &seed2, const Tensor &reshuffle) {
  auto out = EsAnonymousSeedGenerator(seed.GetEsbTensor(), seed2.GetEsbTensor(), reshuffle.GetEsbTensor());
  return {out.handle, out.deleter};
}
inline Tensor ApplyAdaMax(const Tensor &var, const Tensor &m, const Tensor &v, const Tensor &beta1_power, const Tensor &lr, const Tensor &beta1, const Tensor &beta2, const Tensor &epsilon, const Tensor &grad, bool use_locking=false) {
  auto out = EsApplyAdaMax(var.GetEsbTensor(), m.GetEsbTensor(), v.GetEsbTensor(), beta1_power.GetEsbTensor(), lr.GetEsbTensor(), beta1.GetEsbTensor(), beta2.GetEsbTensor(), epsilon.GetEsbTensor(), grad.GetEsbTensor(), use_locking);
  return out;
}
struct ApplyAdaMaxDOutput {
  Tensor var;
  Tensor m;
  Tensor v;
};
inline ApplyAdaMaxDOutput ApplyAdaMaxD(const Tensor &var, const Tensor &m, const Tensor &v, const Tensor &beta1_power, const Tensor &lr, const Tensor &beta1, const Tensor &beta2, const Tensor &epsilon, const Tensor &grad, bool use_locking=false) {
  auto out = EsApplyAdaMaxD(var.GetEsbTensor(), m.GetEsbTensor(), v.GetEsbTensor(), beta1_power.GetEsbTensor(), lr.GetEsbTensor(), beta1.GetEsbTensor(), beta2.GetEsbTensor(), epsilon.GetEsbTensor(), grad.GetEsbTensor(), use_locking);
  return {out.var, out.m, out.v};
}
inline Tensor ApplyAdadelta(const Tensor &var, const Tensor &accum, const Tensor &accum_update, const Tensor &lr, const Tensor &rho, const Tensor &epsilon, const Tensor &grad, bool use_locking=false) {
  auto out = EsApplyAdadelta(var.GetEsbTensor(), accum.GetEsbTensor(), accum_update.GetEsbTensor(), lr.GetEsbTensor(), rho.GetEsbTensor(), epsilon.GetEsbTensor(), grad.GetEsbTensor(), use_locking);
  return out;
}
struct ApplyAdadeltaDOutput {
  Tensor var;
  Tensor accum;
  Tensor accum_update;
};
inline ApplyAdadeltaDOutput ApplyAdadeltaD(const Tensor &var, const Tensor &accum, const Tensor &accum_update, const Tensor &lr, const Tensor &rho, const Tensor &epsilon, const Tensor &grad, bool use_locking=false) {
  auto out = EsApplyAdadeltaD(var.GetEsbTensor(), accum.GetEsbTensor(), accum_update.GetEsbTensor(), lr.GetEsbTensor(), rho.GetEsbTensor(), epsilon.GetEsbTensor(), grad.GetEsbTensor(), use_locking);
  return {out.var, out.accum, out.accum_update};
}
inline Tensor ApplyAdagrad(const Tensor &var, const Tensor &accum, const Tensor &lr, const Tensor &grad, bool update_slots=true, bool use_locking=false) {
  auto out = EsApplyAdagrad(var.GetEsbTensor(), accum.GetEsbTensor(), lr.GetEsbTensor(), grad.GetEsbTensor(), update_slots, use_locking);
  return out;
}
struct ApplyAdagradDOutput {
  Tensor var;
  Tensor accum;
};
inline ApplyAdagradDOutput ApplyAdagradD(const Tensor &var, const Tensor &accum, const Tensor &lr, const Tensor &grad, bool update_slots=true, bool use_locking=false) {
  auto out = EsApplyAdagradD(var.GetEsbTensor(), accum.GetEsbTensor(), lr.GetEsbTensor(), grad.GetEsbTensor(), update_slots, use_locking);
  return {out.var, out.accum};
}
inline Tensor ApplyAdagradDA(const Tensor &var, const Tensor &gradient_accumulator, const Tensor &gradient_squared_accumulator, const Tensor &grad, const Tensor &lr, const Tensor &l1, const Tensor &l2, const Tensor &global_step, bool use_locking=false) {
  auto out = EsApplyAdagradDA(var.GetEsbTensor(), gradient_accumulator.GetEsbTensor(), gradient_squared_accumulator.GetEsbTensor(), grad.GetEsbTensor(), lr.GetEsbTensor(), l1.GetEsbTensor(), l2.GetEsbTensor(), global_step.GetEsbTensor(), use_locking);
  return out;
}
struct ApplyAdagradDADOutput {
  Tensor var;
  Tensor gradient_accumulator;
  Tensor gradient_squared_accumulator;
};
inline ApplyAdagradDADOutput ApplyAdagradDAD(const Tensor &var, const Tensor &gradient_accumulator, const Tensor &gradient_squared_accumulator, const Tensor &grad, const Tensor &lr, const Tensor &l1, const Tensor &l2, const Tensor &global_step, bool use_locking=false) {
  auto out = EsApplyAdagradDAD(var.GetEsbTensor(), gradient_accumulator.GetEsbTensor(), gradient_squared_accumulator.GetEsbTensor(), grad.GetEsbTensor(), lr.GetEsbTensor(), l1.GetEsbTensor(), l2.GetEsbTensor(), global_step.GetEsbTensor(), use_locking);
  return {out.var, out.gradient_accumulator, out.gradient_squared_accumulator};
}
inline Tensor ApplyAdagradV2(const Tensor &var, const Tensor &accum, const Tensor &lr, const Tensor &epsilon, const Tensor &grad, bool update_slots=true, bool use_locking=false) {
  auto out = EsApplyAdagradV2(var.GetEsbTensor(), accum.GetEsbTensor(), lr.GetEsbTensor(), epsilon.GetEsbTensor(), grad.GetEsbTensor(), update_slots, use_locking);
  return out;
}
struct ApplyAdagradV2DOutput {
  Tensor var;
  Tensor accum;
};
inline ApplyAdagradV2DOutput ApplyAdagradV2D(const Tensor &var, const Tensor &accum, const Tensor &lr, const Tensor &grad, float epsilon, bool update_slots=true, bool use_locking=false) {
  auto out = EsApplyAdagradV2D(var.GetEsbTensor(), accum.GetEsbTensor(), lr.GetEsbTensor(), grad.GetEsbTensor(), epsilon, update_slots, use_locking);
  return {out.var, out.accum};
}
inline Tensor ApplyAdam(const Tensor &var, const Tensor &m, const Tensor &v, const Tensor &beta1_power, const Tensor &beta2_power, const Tensor &lr, const Tensor &beta1, const Tensor &beta2, const Tensor &epsilon, const Tensor &grad, bool use_locking=false, bool use_nesterov=false) {
  auto out = EsApplyAdam(var.GetEsbTensor(), m.GetEsbTensor(), v.GetEsbTensor(), beta1_power.GetEsbTensor(), beta2_power.GetEsbTensor(), lr.GetEsbTensor(), beta1.GetEsbTensor(), beta2.GetEsbTensor(), epsilon.GetEsbTensor(), grad.GetEsbTensor(), use_locking, use_nesterov);
  return out;
}
struct ApplyAdamDOutput {
  Tensor var;
  Tensor m;
  Tensor v;
};
inline ApplyAdamDOutput ApplyAdamD(const Tensor &var, const Tensor &m, const Tensor &v, const Tensor &beta1_power, const Tensor &beta2_power, const Tensor &lr, const Tensor &beta1, const Tensor &beta2, const Tensor &epsilon, const Tensor &grad, bool use_locking=false, bool use_nesterov=false) {
  auto out = EsApplyAdamD(var.GetEsbTensor(), m.GetEsbTensor(), v.GetEsbTensor(), beta1_power.GetEsbTensor(), beta2_power.GetEsbTensor(), lr.GetEsbTensor(), beta1.GetEsbTensor(), beta2.GetEsbTensor(), epsilon.GetEsbTensor(), grad.GetEsbTensor(), use_locking, use_nesterov);
  return {out.var, out.m, out.v};
}
struct ApplyAdamV2Output {
  Tensor var;
  Tensor m;
  Tensor v;
};
inline ApplyAdamV2Output ApplyAdamV2(const Tensor &var, const Tensor &m, const Tensor &v, const Tensor &lr, const Tensor &beta1, const Tensor &beta2, const Tensor &epsilon, const Tensor &grad, const Tensor &max_grad_norm, const Tensor &global_grad_norm, const Tensor &weight_decay, const Tensor &step_size=nullptr, const char *adam_mode="adam") {
  auto out = EsApplyAdamV2(var.GetEsbTensor(), m.GetEsbTensor(), v.GetEsbTensor(), lr.GetEsbTensor(), beta1.GetEsbTensor(), beta2.GetEsbTensor(), epsilon.GetEsbTensor(), grad.GetEsbTensor(), max_grad_norm.GetEsbTensor(), global_grad_norm.GetEsbTensor(), weight_decay.GetEsbTensor(), step_size.GetEsbTensor(), adam_mode);
  return {out.var, out.m, out.v};
}
struct ApplyAdamWOutput {
  Tensor var;
  Tensor m;
  Tensor v;
};
inline ApplyAdamWOutput ApplyAdamW(const Tensor &var, const Tensor &m, const Tensor &v, const Tensor &beta1_power, const Tensor &beta2_power, const Tensor &lr, const Tensor &weight_decay, const Tensor &beta1, const Tensor &beta2, const Tensor &epsilon, const Tensor &grad, const Tensor &max_grad_norm=nullptr, bool amsgrad=false, bool maximize=false) {
  auto out = EsApplyAdamW(var.GetEsbTensor(), m.GetEsbTensor(), v.GetEsbTensor(), beta1_power.GetEsbTensor(), beta2_power.GetEsbTensor(), lr.GetEsbTensor(), weight_decay.GetEsbTensor(), beta1.GetEsbTensor(), beta2.GetEsbTensor(), epsilon.GetEsbTensor(), grad.GetEsbTensor(), max_grad_norm.GetEsbTensor(), amsgrad, maximize);
  return {out.var, out.m, out.v};
}
inline Tensor ApplyAdamWV2(const Tensor &var, const Tensor &m, const Tensor &v, const Tensor &grad, const Tensor &step, const Tensor &max_grad_norm=nullptr, float lr=0.100000, float beta1=0.100000, float beta2=0.100000, float weight_decay=0.100000, float eps=0.100000, bool amsgrad=false, bool maximize=false) {
  auto out = EsApplyAdamWV2(var.GetEsbTensor(), m.GetEsbTensor(), v.GetEsbTensor(), grad.GetEsbTensor(), step.GetEsbTensor(), max_grad_norm.GetEsbTensor(), lr, beta1, beta2, weight_decay, eps, amsgrad, maximize);
  return out;
}
inline Tensor ApplyAdamWithAmsgrad(const Tensor &var, const Tensor &m, const Tensor &v, const Tensor &vhat, const Tensor &beta1_power, const Tensor &beta2_power, const Tensor &lr, const Tensor &beta1, const Tensor &beta2, const Tensor &epsilon, const Tensor &grad, bool use_locking=false) {
  auto out = EsApplyAdamWithAmsgrad(var.GetEsbTensor(), m.GetEsbTensor(), v.GetEsbTensor(), vhat.GetEsbTensor(), beta1_power.GetEsbTensor(), beta2_power.GetEsbTensor(), lr.GetEsbTensor(), beta1.GetEsbTensor(), beta2.GetEsbTensor(), epsilon.GetEsbTensor(), grad.GetEsbTensor(), use_locking);
  return out;
}
struct ApplyAdamWithAmsgradDOutput {
  Tensor var;
  Tensor m;
  Tensor v;
  Tensor vhat;
};
inline ApplyAdamWithAmsgradDOutput ApplyAdamWithAmsgradD(const Tensor &var, const Tensor &m, const Tensor &v, const Tensor &vhat, const Tensor &beta1_power, const Tensor &beta2_power, const Tensor &lr, const Tensor &grad, float beta1, float beta2, float epsilon, bool use_locking=false) {
  auto out = EsApplyAdamWithAmsgradD(var.GetEsbTensor(), m.GetEsbTensor(), v.GetEsbTensor(), vhat.GetEsbTensor(), beta1_power.GetEsbTensor(), beta2_power.GetEsbTensor(), lr.GetEsbTensor(), grad.GetEsbTensor(), beta1, beta2, epsilon, use_locking);
  return {out.var, out.m, out.v, out.vhat};
}
struct ApplyAdamWithAmsgradV2Output {
  Tensor var;
  Tensor m;
  Tensor v;
  Tensor vhat;
};
inline ApplyAdamWithAmsgradV2Output ApplyAdamWithAmsgradV2(const Tensor &var, const Tensor &m, const Tensor &v, const Tensor &vhat, const Tensor &beta1_power, const Tensor &beta2_power, const Tensor &lr, const Tensor &beta1, const Tensor &beta2, const Tensor &epsilon, const Tensor &grad, bool use_locking=false) {
  auto out = EsApplyAdamWithAmsgradV2(var.GetEsbTensor(), m.GetEsbTensor(), v.GetEsbTensor(), vhat.GetEsbTensor(), beta1_power.GetEsbTensor(), beta2_power.GetEsbTensor(), lr.GetEsbTensor(), beta1.GetEsbTensor(), beta2.GetEsbTensor(), epsilon.GetEsbTensor(), grad.GetEsbTensor(), use_locking);
  return {out.var, out.m, out.v, out.vhat};
}
inline Tensor ApplyAddSign(const Tensor &var, const Tensor &m, const Tensor &lr, const Tensor &alpha, const Tensor &sign_decay, const Tensor &beta, const Tensor &grad, bool use_locking=false) {
  auto out = EsApplyAddSign(var.GetEsbTensor(), m.GetEsbTensor(), lr.GetEsbTensor(), alpha.GetEsbTensor(), sign_decay.GetEsbTensor(), beta.GetEsbTensor(), grad.GetEsbTensor(), use_locking);
  return out;
}
struct ApplyAddSignDOutput {
  Tensor var;
  Tensor m;
};
inline ApplyAddSignDOutput ApplyAddSignD(const Tensor &var, const Tensor &m, const Tensor &lr, const Tensor &alpha, const Tensor &sign_decay, const Tensor &beta, const Tensor &grad, bool use_locking=false) {
  auto out = EsApplyAddSignD(var.GetEsbTensor(), m.GetEsbTensor(), lr.GetEsbTensor(), alpha.GetEsbTensor(), sign_decay.GetEsbTensor(), beta.GetEsbTensor(), grad.GetEsbTensor(), use_locking);
  return {out.var, out.m};
}
inline Tensor ApplyCenteredRMSProp(const Tensor &var, const Tensor &mg, const Tensor &ms, const Tensor &mom, const Tensor &lr, const Tensor &rho, const Tensor &momentum, const Tensor &epsilon, const Tensor &grad, bool use_locking=false) {
  auto out = EsApplyCenteredRMSProp(var.GetEsbTensor(), mg.GetEsbTensor(), ms.GetEsbTensor(), mom.GetEsbTensor(), lr.GetEsbTensor(), rho.GetEsbTensor(), momentum.GetEsbTensor(), epsilon.GetEsbTensor(), grad.GetEsbTensor(), use_locking);
  return out;
}
struct ApplyCenteredRMSPropDOutput {
  Tensor var;
  Tensor mg;
  Tensor ms;
  Tensor mom;
};
inline ApplyCenteredRMSPropDOutput ApplyCenteredRMSPropD(const Tensor &var, const Tensor &mg, const Tensor &ms, const Tensor &mom, const Tensor &lr, const Tensor &rho, const Tensor &momentum, const Tensor &epsilon, const Tensor &grad, bool use_locking=false) {
  auto out = EsApplyCenteredRMSPropD(var.GetEsbTensor(), mg.GetEsbTensor(), ms.GetEsbTensor(), mom.GetEsbTensor(), lr.GetEsbTensor(), rho.GetEsbTensor(), momentum.GetEsbTensor(), epsilon.GetEsbTensor(), grad.GetEsbTensor(), use_locking);
  return {out.var, out.mg, out.ms, out.mom};
}
inline Tensor ApplyFtrl(const Tensor &var, const Tensor &accum, const Tensor &linear, const Tensor &grad, const Tensor &lr, const Tensor &l1, const Tensor &l2, const Tensor &lr_power, bool use_locking=false) {
  auto out = EsApplyFtrl(var.GetEsbTensor(), accum.GetEsbTensor(), linear.GetEsbTensor(), grad.GetEsbTensor(), lr.GetEsbTensor(), l1.GetEsbTensor(), l2.GetEsbTensor(), lr_power.GetEsbTensor(), use_locking);
  return out;
}
struct ApplyFtrlDOutput {
  Tensor var;
  Tensor accum;
  Tensor linear;
};
inline ApplyFtrlDOutput ApplyFtrlD(const Tensor &var, const Tensor &accum, const Tensor &linear, const Tensor &grad, const Tensor &lr, const Tensor &l1, const Tensor &l2, const Tensor &lr_power, bool use_locking=false) {
  auto out = EsApplyFtrlD(var.GetEsbTensor(), accum.GetEsbTensor(), linear.GetEsbTensor(), grad.GetEsbTensor(), lr.GetEsbTensor(), l1.GetEsbTensor(), l2.GetEsbTensor(), lr_power.GetEsbTensor(), use_locking);
  return {out.var, out.accum, out.linear};
}
inline Tensor ApplyFtrlV2(const Tensor &var, const Tensor &accum, const Tensor &linear, const Tensor &grad, const Tensor &lr, const Tensor &l1, const Tensor &l2, const Tensor &l2_shrinkage, const Tensor &lr_power, bool use_locking=false) {
  auto out = EsApplyFtrlV2(var.GetEsbTensor(), accum.GetEsbTensor(), linear.GetEsbTensor(), grad.GetEsbTensor(), lr.GetEsbTensor(), l1.GetEsbTensor(), l2.GetEsbTensor(), l2_shrinkage.GetEsbTensor(), lr_power.GetEsbTensor(), use_locking);
  return out;
}
struct ApplyFtrlV2DOutput {
  Tensor var;
  Tensor accum;
  Tensor linear;
};
inline ApplyFtrlV2DOutput ApplyFtrlV2D(const Tensor &var, const Tensor &accum, const Tensor &linear, const Tensor &grad, const Tensor &lr, const Tensor &l1, const Tensor &l2, const Tensor &l2_shrinkage, const Tensor &lr_power, bool use_locking=false) {
  auto out = EsApplyFtrlV2D(var.GetEsbTensor(), accum.GetEsbTensor(), linear.GetEsbTensor(), grad.GetEsbTensor(), lr.GetEsbTensor(), l1.GetEsbTensor(), l2.GetEsbTensor(), l2_shrinkage.GetEsbTensor(), lr_power.GetEsbTensor(), use_locking);
  return {out.var, out.accum, out.linear};
}
struct ApplyFusedEmaAdamOutput {
  Tensor var;
  Tensor m;
  Tensor v;
  Tensor s;
};
inline ApplyFusedEmaAdamOutput ApplyFusedEmaAdam(const Tensor &grad, const Tensor &var, const Tensor &m, const Tensor &v, const Tensor &s, const Tensor &step, float lr=0.001000, float ema_decay=0.999900, float beta1=0.900000, float beta2=0.999000, float eps=0.000000, int64_t mode=1, bool bias_correction=true, float weight_decay=0.000000) {
  auto out = EsApplyFusedEmaAdam(grad.GetEsbTensor(), var.GetEsbTensor(), m.GetEsbTensor(), v.GetEsbTensor(), s.GetEsbTensor(), step.GetEsbTensor(), lr, ema_decay, beta1, beta2, eps, mode, bias_correction, weight_decay);
  return {out.var, out.m, out.v, out.s};
}
inline Tensor ApplyGradientDescent(const Tensor &var, const Tensor &alpha, const Tensor &delta, bool use_locking=false) {
  auto out = EsApplyGradientDescent(var.GetEsbTensor(), alpha.GetEsbTensor(), delta.GetEsbTensor(), use_locking);
  return out;
}
inline Tensor ApplyKerasMomentum(const Tensor &var, const Tensor &accum, const Tensor &lr, const Tensor &grad, const Tensor &momentum, bool use_locking=false, bool use_nesterov=false) {
  auto out = EsApplyKerasMomentum(var.GetEsbTensor(), accum.GetEsbTensor(), lr.GetEsbTensor(), grad.GetEsbTensor(), momentum.GetEsbTensor(), use_locking, use_nesterov);
  return out;
}
struct ApplyKerasMomentumDOutput {
  Tensor var;
  Tensor accum;
};
inline ApplyKerasMomentumDOutput ApplyKerasMomentumD(const Tensor &var, const Tensor &accum, const Tensor &lr, const Tensor &grad, const Tensor &momentum, bool use_locking=false, bool use_nesterov=false) {
  auto out = EsApplyKerasMomentumD(var.GetEsbTensor(), accum.GetEsbTensor(), lr.GetEsbTensor(), grad.GetEsbTensor(), momentum.GetEsbTensor(), use_locking, use_nesterov);
  return {out.var, out.accum};
}
inline Tensor ApplyMomentum(const Tensor &var, const Tensor &accum, const Tensor &lr, const Tensor &grad, const Tensor &momentum, bool use_nesterov=false, bool use_locking=false) {
  auto out = EsApplyMomentum(var.GetEsbTensor(), accum.GetEsbTensor(), lr.GetEsbTensor(), grad.GetEsbTensor(), momentum.GetEsbTensor(), use_nesterov, use_locking);
  return out;
}
struct ApplyMomentumDOutput {
  Tensor var;
  Tensor accum;
};
inline ApplyMomentumDOutput ApplyMomentumD(const Tensor &var, const Tensor &accum, const Tensor &lr, const Tensor &grad, const Tensor &momentum, bool use_nesterov=false, bool use_locking=false) {
  auto out = EsApplyMomentumD(var.GetEsbTensor(), accum.GetEsbTensor(), lr.GetEsbTensor(), grad.GetEsbTensor(), momentum.GetEsbTensor(), use_nesterov, use_locking);
  return {out.var, out.accum};
}
inline Tensor ApplyPowerSign(const Tensor &var, const Tensor &m, const Tensor &lr, const Tensor &logbase, const Tensor &sign_decay, const Tensor &beta, const Tensor &grad, bool use_locking=false) {
  auto out = EsApplyPowerSign(var.GetEsbTensor(), m.GetEsbTensor(), lr.GetEsbTensor(), logbase.GetEsbTensor(), sign_decay.GetEsbTensor(), beta.GetEsbTensor(), grad.GetEsbTensor(), use_locking);
  return out;
}
struct ApplyPowerSignDOutput {
  Tensor var;
  Tensor m;
};
inline ApplyPowerSignDOutput ApplyPowerSignD(const Tensor &var, const Tensor &m, const Tensor &lr, const Tensor &logbase, const Tensor &sign_decay, const Tensor &beta, const Tensor &grad, bool use_locking=false) {
  auto out = EsApplyPowerSignD(var.GetEsbTensor(), m.GetEsbTensor(), lr.GetEsbTensor(), logbase.GetEsbTensor(), sign_decay.GetEsbTensor(), beta.GetEsbTensor(), grad.GetEsbTensor(), use_locking);
  return {out.var, out.m};
}
inline Tensor ApplyProximalAdagrad(const Tensor &var, const Tensor &accum, const Tensor &lr, const Tensor &l1, const Tensor &l2, const Tensor &grad, bool use_locking=false) {
  auto out = EsApplyProximalAdagrad(var.GetEsbTensor(), accum.GetEsbTensor(), lr.GetEsbTensor(), l1.GetEsbTensor(), l2.GetEsbTensor(), grad.GetEsbTensor(), use_locking);
  return out;
}
struct ApplyProximalAdagradDOutput {
  Tensor var;
  Tensor accum;
};
inline ApplyProximalAdagradDOutput ApplyProximalAdagradD(const Tensor &var, const Tensor &accum, const Tensor &lr, const Tensor &l1, const Tensor &l2, const Tensor &grad, bool use_locking=false) {
  auto out = EsApplyProximalAdagradD(var.GetEsbTensor(), accum.GetEsbTensor(), lr.GetEsbTensor(), l1.GetEsbTensor(), l2.GetEsbTensor(), grad.GetEsbTensor(), use_locking);
  return {out.var, out.accum};
}
inline Tensor ApplyProximalGradientDescent(const Tensor &var, const Tensor &alpha, const Tensor &l1, const Tensor &l2, const Tensor &delta, bool use_locking=false) {
  auto out = EsApplyProximalGradientDescent(var.GetEsbTensor(), alpha.GetEsbTensor(), l1.GetEsbTensor(), l2.GetEsbTensor(), delta.GetEsbTensor(), use_locking);
  return out;
}
inline Tensor ApplyRMSProp(const Tensor &var, const Tensor &ms, const Tensor &mom, const Tensor &lr, const Tensor &rho, const Tensor &momentum, const Tensor &epsilon, const Tensor &grad, bool use_locking=false) {
  auto out = EsApplyRMSProp(var.GetEsbTensor(), ms.GetEsbTensor(), mom.GetEsbTensor(), lr.GetEsbTensor(), rho.GetEsbTensor(), momentum.GetEsbTensor(), epsilon.GetEsbTensor(), grad.GetEsbTensor(), use_locking);
  return out;
}
struct ApplyRMSPropDOutput {
  Tensor var;
  Tensor ms;
  Tensor mom;
};
inline ApplyRMSPropDOutput ApplyRMSPropD(const Tensor &var, const Tensor &ms, const Tensor &mom, const Tensor &lr, const Tensor &grad, float rho, float momentum, float epsilon, bool use_locking=false) {
  auto out = EsApplyRMSPropD(var.GetEsbTensor(), ms.GetEsbTensor(), mom.GetEsbTensor(), lr.GetEsbTensor(), grad.GetEsbTensor(), rho, momentum, epsilon, use_locking);
  return {out.var, out.ms, out.mom};
}
struct ApplyRotaryPosEmbOutput {
  Tensor query;
  Tensor key;
};
inline ApplyRotaryPosEmbOutput ApplyRotaryPosEmb(const Tensor &query, const Tensor &key, const Tensor &cos, const Tensor &sin, int64_t layout=1) {
  auto out = EsApplyRotaryPosEmb(query.GetEsbTensor(), key.GetEsbTensor(), cos.GetEsbTensor(), sin.GetEsbTensor(), layout);
  return {out.query, out.key};
}
inline Tensor ApproximateEqual(const Tensor &x1, const Tensor &x2, float tolerance=0.000010) {
  auto out = EsApproximateEqual(x1.GetEsbTensor(), x2.GetEsbTensor(), tolerance);
  return out;
}
inline Tensor ArgMaxD(const Tensor &x, int64_t dimension, ge::DataType dtype=ge::DT_INT64) {
  auto out = EsArgMaxD(x.GetEsbTensor(), dimension, dtype);
  return out;
}
inline Tensor ArgMaxGrad(const Tensor &var, const Tensor &indices, const Tensor &updates, int64_t dimension) {
  auto out = EsArgMaxGrad(var.GetEsbTensor(), indices.GetEsbTensor(), updates.GetEsbTensor(), dimension);
  return out;
}
inline Tensor ArgMaxGradD(const Tensor &var, const Tensor &indices, const Tensor &updates, const Tensor &assist, int64_t dimension) {
  auto out = EsArgMaxGradD(var.GetEsbTensor(), indices.GetEsbTensor(), updates.GetEsbTensor(), assist.GetEsbTensor(), dimension);
  return out;
}
inline Tensor ArgMaxV2(const Tensor &x, const Tensor &dimension, ge::DataType dtype=ge::DT_INT64) {
  auto out = EsArgMaxV2(x.GetEsbTensor(), dimension.GetEsbTensor(), dtype);
  return out;
}
struct ArgMaxWithKOutput {
  Tensor indices;
  Tensor values;
};
inline ArgMaxWithKOutput ArgMaxWithK(const Tensor &x, int64_t axis=10000, bool out_max_val=false, int64_t topk=1) {
  auto out = EsArgMaxWithK(x.GetEsbTensor(), axis, out_max_val, topk);
  return {out.indices, out.values};
}
struct ArgMaxWithValueOutput {
  Tensor indice;
  Tensor values;
};
inline ArgMaxWithValueOutput ArgMaxWithValue(const Tensor &x, int64_t dimension, bool keep_dims=false) {
  auto out = EsArgMaxWithValue(x.GetEsbTensor(), dimension, keep_dims);
  return {out.indice, out.values};
}
inline Tensor ArgMin(const Tensor &x, const Tensor &dimension, ge::DataType dtype=ge::DT_INT64) {
  auto out = EsArgMin(x.GetEsbTensor(), dimension.GetEsbTensor(), dtype);
  return out;
}
inline Tensor ArgMinD(const Tensor &x, int64_t dimension, ge::DataType dtype=ge::DT_INT64) {
  auto out = EsArgMinD(x.GetEsbTensor(), dimension, dtype);
  return out;
}
struct ArgMinWithValueOutput {
  Tensor indice;
  Tensor values;
};
inline ArgMinWithValueOutput ArgMinWithValue(const Tensor &x, int64_t dimension, bool keep_dims=false) {
  auto out = EsArgMinWithValue(x.GetEsbTensor(), dimension, keep_dims);
  return {out.indice, out.values};
}
inline Tensor AsStrided(const Tensor &x, const Tensor &size, const Tensor &stride, const Tensor &storage_offset) {
  auto out = EsAsStrided(x.GetEsbTensor(), size.GetEsbTensor(), stride.GetEsbTensor(), storage_offset.GetEsbTensor());
  return out;
}
inline Tensor AsString(const Tensor &x, int64_t precision=-1, bool scientific=false, bool shortest=false, int64_t width=-1, const char *fill="") {
  auto out = EsAsString(x.GetEsbTensor(), precision, scientific, shortest, width, fill);
  return out;
}
inline Tensor AscendAntiQuant(const Tensor &x, float scale, float offset, int64_t dtype=0, bool sqrt_mode=false) {
  auto out = EsAscendAntiQuant(x.GetEsbTensor(), scale, offset, dtype, sqrt_mode);
  return out;
}
inline Tensor AscendAntiQuantV2(const Tensor &x, const Tensor &scale, const Tensor &offset=nullptr, int64_t dst_type=1, bool sqrt_mode=false) {
  auto out = EsAscendAntiQuantV2(x.GetEsbTensor(), scale.GetEsbTensor(), offset.GetEsbTensor(), dst_type, sqrt_mode);
  return out;
}
inline Tensor AscendDequant(const Tensor &x, const Tensor &deq_scale, bool sqrt_mode=false, bool relu_flag=false, int64_t dtype=0) {
  auto out = EsAscendDequant(x.GetEsbTensor(), deq_scale.GetEsbTensor(), sqrt_mode, relu_flag, dtype);
  return out;
}
inline Tensor AscendDequantS16(const Tensor &x0, const Tensor &deq_scale, const Tensor &x1=nullptr, bool relu_flag=false) {
  auto out = EsAscendDequantS16(x0.GetEsbTensor(), deq_scale.GetEsbTensor(), x1.GetEsbTensor(), relu_flag);
  return out;
}
inline Tensor AscendPadding(const Tensor &x, int64_t pad_dim_size=8) {
  auto out = EsAscendPadding(x.GetEsbTensor(), pad_dim_size);
  return out;
}
inline Tensor AscendQuant(const Tensor &x, float scale, float offset, bool sqrt_mode=false, const char *round_mode="Round", int64_t dst_type=2) {
  auto out = EsAscendQuant(x.GetEsbTensor(), scale, offset, sqrt_mode, round_mode, dst_type);
  return out;
}
inline Tensor AscendQuantV2(const Tensor &x, const Tensor &scale, const Tensor &offset=nullptr, bool sqrt_mode=false, const char *round_mode="round", int64_t dst_type=2, int64_t axis=-1) {
  auto out = EsAscendQuantV2(x.GetEsbTensor(), scale.GetEsbTensor(), offset.GetEsbTensor(), sqrt_mode, round_mode, dst_type, axis);
  return out;
}
inline Tensor AscendRequant(const Tensor &x, const Tensor &req_scale, bool relu_flag=false) {
  auto out = EsAscendRequant(x.GetEsbTensor(), req_scale.GetEsbTensor(), relu_flag);
  return out;
}
struct AscendRequantS16Output {
  Tensor y0;
  Tensor y1;
};
inline AscendRequantS16Output AscendRequantS16(const Tensor &x0, const Tensor &req_scale, const Tensor &x1=nullptr, bool dual_output=false, bool relu_flag=false) {
  auto out = EsAscendRequantS16(x0.GetEsbTensor(), req_scale.GetEsbTensor(), x1.GetEsbTensor(), dual_output, relu_flag);
  return {out.y0, out.y1};
}
inline Tensor AscendWeightQuant(const Tensor &x, const Tensor &offset, int64_t dst_type=2) {
  auto out = EsAscendWeightQuant(x.GetEsbTensor(), offset.GetEsbTensor(), dst_type);
  return out;
}
inline Tensor Asin(const Tensor &x) {
  auto out = EsAsin(x.GetEsbTensor());
  return out;
}
inline Tensor AsinGrad(const Tensor &y, const Tensor &dy) {
  auto out = EsAsinGrad(y.GetEsbTensor(), dy.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor AsinGrad(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return AsinGrad(tensor, b_esb_tensor);
}
inline Tensor Asinh(const Tensor &x) {
  auto out = EsAsinh(x.GetEsbTensor());
  return out;
}
inline Tensor AsinhGrad(const Tensor &y, const Tensor &dy) {
  auto out = EsAsinhGrad(y.GetEsbTensor(), dy.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor AsinhGrad(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return AsinhGrad(tensor, b_esb_tensor);
}
inline Tensor Assert(const Tensor &input_condition, const std::vector<Tensor> &input_data, int64_t summarize=3) {
  auto esb_input_data = TensorsToEsbTensors(input_data);
  auto out = EsAssert(input_condition.GetEsbTensor(), esb_input_data.data(), static_cast<int64_t>(esb_input_data.size()), summarize);
  return out;
}
inline Tensor Assign(const Tensor &ref, const Tensor &value, bool validate_shape=true, bool use_locking=false) {
  auto out = EsAssign(ref.GetEsbTensor(), value.GetEsbTensor(), validate_shape, use_locking);
  return out;
}
inline Tensor AssignAdd(const Tensor &ref, const Tensor &value, bool use_locking=false) {
  auto out = EsAssignAdd(ref.GetEsbTensor(), value.GetEsbTensor(), use_locking);
  return out;
}
inline Tensor AssignAddVariableOp(const Tensor &resource, const Tensor &value, ge::DataType dtype) {
  auto out = EsAssignAddVariableOp(resource.GetEsbTensor(), value.GetEsbTensor(), dtype);
  return out;
}
inline Tensor AssignSub(const Tensor &var, const Tensor &value, bool use_locking=false) {
  auto out = EsAssignSub(var.GetEsbTensor(), value.GetEsbTensor(), use_locking);
  return out;
}
inline Tensor AssignSubVariableOp(const Tensor &resource, const Tensor &value, ge::DataType dtype) {
  auto out = EsAssignSubVariableOp(resource.GetEsbTensor(), value.GetEsbTensor(), dtype);
  return out;
}
inline Tensor AssignVariableOp(const Tensor &resource, const Tensor &value, ge::DataType dtype) {
  auto out = EsAssignVariableOp(resource.GetEsbTensor(), value.GetEsbTensor(), dtype);
  return out;
}
inline Tensor Atan(const Tensor &x) {
  auto out = EsAtan(x.GetEsbTensor());
  return out;
}
inline Tensor Atan2(const Tensor &x1, const Tensor &x2) {
  auto out = EsAtan2(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor Atan2(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return Atan2(tensor, b_esb_tensor);
}
inline Tensor AtanGrad(const Tensor &y, const Tensor &dy) {
  auto out = EsAtanGrad(y.GetEsbTensor(), dy.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor AtanGrad(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return AtanGrad(tensor, b_esb_tensor);
}
inline Tensor Atanh(const Tensor &x) {
  auto out = EsAtanh(x.GetEsbTensor());
  return out;
}
inline Tensor AtomicAddrClean(const Graph &owner_graph, const std::vector<int64_t> &automic_add_mem_size={}) {
  auto out = EsAtomicAddrClean(owner_graph.GetEsbGraph(), automic_add_mem_size.data(), static_cast<int64_t>(automic_add_mem_size.size()));
  return out;
}
struct AttentionLnQKVOutput {
  Tensor norm;
  Tensor query_output;
  Tensor key_output;
  Tensor value_output;
  Tensor mean;
  Tensor variance;
};
inline AttentionLnQKVOutput AttentionLnQKV(const Tensor &x, const Tensor &kernel_query, const Tensor &kernel_key, const Tensor &kernel_value, const Tensor &gamma, const Tensor &beta, const Tensor &bias_query=nullptr, const Tensor &bias_key=nullptr, const Tensor &bias_value=nullptr, float epsilon=0.000000, bool trans_a=false, bool trans_b=false) {
  auto out = EsAttentionLnQKV(x.GetEsbTensor(), kernel_query.GetEsbTensor(), kernel_key.GetEsbTensor(), kernel_value.GetEsbTensor(), gamma.GetEsbTensor(), beta.GetEsbTensor(), bias_query.GetEsbTensor(), bias_key.GetEsbTensor(), bias_value.GetEsbTensor(), epsilon, trans_a, trans_b);
  return {out.norm, out.query_output, out.key_output, out.value_output, out.mean, out.variance};
}
struct AttentionQKVGradWOutput {
  Tensor dw_query;
  Tensor dw_key;
  Tensor dw_value;
  Tensor dbias_query;
  Tensor dbias_key;
  Tensor dbias_value;
};
inline AttentionQKVGradWOutput AttentionQKVGradW(const Tensor &x, const Tensor &query_dx, const Tensor &key_dw=nullptr, const Tensor &value_dw=nullptr, bool trans_a=true, bool trans_b=false, bool trans_dw=false) {
  auto out = EsAttentionQKVGradW(x.GetEsbTensor(), query_dx.GetEsbTensor(), key_dw.GetEsbTensor(), value_dw.GetEsbTensor(), trans_a, trans_b, trans_dw);
  return {out.dw_query, out.dw_key, out.dw_value, out.dbias_query, out.dbias_key, out.dbias_value};
}
inline Tensor AttentionQKVGradX(const Tensor &ln_dx, const Tensor &query_dx, const Tensor &key_dw, const Tensor &value_dw, const Tensor &kernel_query, const Tensor &kernel_key, const Tensor &kernel_value, bool trans_a=false, bool trans_b=true) {
  auto out = EsAttentionQKVGradX(ln_dx.GetEsbTensor(), query_dx.GetEsbTensor(), key_dw.GetEsbTensor(), value_dw.GetEsbTensor(), kernel_query.GetEsbTensor(), kernel_key.GetEsbTensor(), kernel_value.GetEsbTensor(), trans_a, trans_b);
  return out;
}
struct AttentionScoreOutput {
  Tensor attention_score;
  Tensor softmax_output;
};
inline AttentionScoreOutput AttentionScore(const Tensor &query, const Tensor &key, const Tensor &value, const Tensor &padding_mask, const Tensor &scale, const Tensor &drop_mask=nullptr, float keep_prob=1.000000, bool query_transpose=false, bool key_transpose=false, bool bmm_score_transpose_a=false, bool bmm_score_transpose_b=false, const std::vector<int64_t> &softmax_axes={-1}) {
  auto out = EsAttentionScore(query.GetEsbTensor(), key.GetEsbTensor(), value.GetEsbTensor(), padding_mask.GetEsbTensor(), scale.GetEsbTensor(), drop_mask.GetEsbTensor(), keep_prob, query_transpose, key_transpose, bmm_score_transpose_a, bmm_score_transpose_b, softmax_axes.data(), static_cast<int64_t>(softmax_axes.size()));
  return {out.attention_score, out.softmax_output};
}
struct AttentionScoreGradOutput {
  Tensor value_dw;
  Tensor query_dx;
  Tensor key_dw;
};
inline AttentionScoreGradOutput AttentionScoreGrad(const Tensor &attention_score, const Tensor &dx, const Tensor &query, const Tensor &key, const Tensor &value, const Tensor &scale, const Tensor &drop_mask=nullptr, float keep_prob=1.000000, bool query_transpose=false, bool key_transpose=false, bool value_transpose=false, bool dx_transpose=false, int64_t softmax_axes=-1) {
  auto out = EsAttentionScoreGrad(attention_score.GetEsbTensor(), dx.GetEsbTensor(), query.GetEsbTensor(), key.GetEsbTensor(), value.GetEsbTensor(), scale.GetEsbTensor(), drop_mask.GetEsbTensor(), keep_prob, query_transpose, key_transpose, value_transpose, dx_transpose, softmax_axes);
  return {out.value_dw, out.query_dx, out.key_dw};
}
inline Tensor AudioSpectrogram(const Tensor &x, int64_t window_size, int64_t stride, bool magnitude_squared=false) {
  auto out = EsAudioSpectrogram(x.GetEsbTensor(), window_size, stride, magnitude_squared);
  return out;
}
inline Tensor AvgPool(const Tensor &x, const std::vector<int64_t> &ksize, const std::vector<int64_t> &strides, const char *padding, const char *data_format="NHWC") {
  auto out = EsAvgPool(x.GetEsbTensor(), ksize.data(), static_cast<int64_t>(ksize.size()), strides.data(), static_cast<int64_t>(strides.size()), padding, data_format);
  return out;
}
inline Tensor AvgPool1D(const Tensor &x, int64_t ksize, int64_t strides, const std::vector<int64_t> &pads, bool ceil_mode=false, bool count_include_pad=false) {
  auto out = EsAvgPool1D(x.GetEsbTensor(), ksize, strides, pads.data(), static_cast<int64_t>(pads.size()), ceil_mode, count_include_pad);
  return out;
}
inline Tensor AvgPool1DAvgMatrix(const Tensor &x, int64_t ksize, int64_t strides, const std::vector<int64_t> &pads, bool ceil_mode=false, bool count_include_pad=false) {
  auto out = EsAvgPool1DAvgMatrix(x.GetEsbTensor(), ksize, strides, pads.data(), static_cast<int64_t>(pads.size()), ceil_mode, count_include_pad);
  return out;
}
inline Tensor AvgPool1DD(const Tensor &x, const Tensor &assist_matrix, int64_t ksize, int64_t strides, const std::vector<int64_t> &pads, bool ceil_mode=false, bool count_include_pad=false) {
  auto out = EsAvgPool1DD(x.GetEsbTensor(), assist_matrix.GetEsbTensor(), ksize, strides, pads.data(), static_cast<int64_t>(pads.size()), ceil_mode, count_include_pad);
  return out;
}
inline Tensor AvgPool3D(const Tensor &x, const std::vector<int64_t> &ksize, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, bool ceil_mode=false, bool count_include_pad=true, int64_t divisor_override=0, const char *data_format="NDHWC") {
  auto out = EsAvgPool3D(x.GetEsbTensor(), ksize.data(), static_cast<int64_t>(ksize.size()), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), ceil_mode, count_include_pad, divisor_override, data_format);
  return out;
}
inline Tensor AvgPool3DD(const Tensor &x, const Tensor &filter, const Tensor &multiplier, const std::vector<int64_t> &ksize, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, bool ceil_mode=false, bool count_include_pad=true, int64_t divisor_override=0, const char *data_format="NDHWC") {
  auto out = EsAvgPool3DD(x.GetEsbTensor(), filter.GetEsbTensor(), multiplier.GetEsbTensor(), ksize.data(), static_cast<int64_t>(ksize.size()), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), ceil_mode, count_include_pad, divisor_override, data_format);
  return out;
}
inline Tensor AvgPool3DGrad(const Tensor &orig_input_shape, const Tensor &grads, const std::vector<int64_t> &ksize, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, bool ceil_mode=false, bool count_include_pad=true, int64_t divisor_override=0, const char *data_format="NDHWC") {
  auto out = EsAvgPool3DGrad(orig_input_shape.GetEsbTensor(), grads.GetEsbTensor(), ksize.data(), static_cast<int64_t>(ksize.size()), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), ceil_mode, count_include_pad, divisor_override, data_format);
  return out;
}
inline Tensor AvgPool3DGradD(const Tensor &grads, const Tensor &filter, const Tensor &multiplier, const std::vector<int64_t> &orig_input_shape, const std::vector<int64_t> &ksize, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, bool ceil_mode=false, bool count_include_pad=true, int64_t divisor_override=0, const char *data_format="NDHWC") {
  auto out = EsAvgPool3DGradD(grads.GetEsbTensor(), filter.GetEsbTensor(), multiplier.GetEsbTensor(), orig_input_shape.data(), static_cast<int64_t>(orig_input_shape.size()), ksize.data(), static_cast<int64_t>(ksize.size()), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), ceil_mode, count_include_pad, divisor_override, data_format);
  return out;
}
inline Tensor AvgPoolGrad(const Tensor &orig_input_shape, const Tensor &input_grad, const std::vector<int64_t> &ksize, const std::vector<int64_t> &strides, const char *padding, const char *data_format="NHWC") {
  auto out = EsAvgPoolGrad(orig_input_shape.GetEsbTensor(), input_grad.GetEsbTensor(), ksize.data(), static_cast<int64_t>(ksize.size()), strides.data(), static_cast<int64_t>(strides.size()), padding, data_format);
  return out;
}
inline Tensor AvgPoolGradD(const Tensor &input_grad, const Tensor &mean_matrix, const Tensor &kernel_matrix, const std::vector<int64_t> &orig_input_shape, const std::vector<int64_t> &ksize, const std::vector<int64_t> &strides, const char *padding, const char *data_format="NHWC") {
  auto out = EsAvgPoolGradD(input_grad.GetEsbTensor(), mean_matrix.GetEsbTensor(), kernel_matrix.GetEsbTensor(), orig_input_shape.data(), static_cast<int64_t>(orig_input_shape.size()), ksize.data(), static_cast<int64_t>(ksize.size()), strides.data(), static_cast<int64_t>(strides.size()), padding, data_format);
  return out;
}
inline Tensor AvgPoolUpdate(const Tensor &x1, const Tensor &x2, const std::vector<int64_t> &ksize, const std::vector<int64_t> &strides, const char *padding_mode="CALCULATED", const std::vector<int64_t> &pads={0, 0, 0, 0}, const char *data_format="NHWC", bool ceil_mode=false, bool exclusive=true) {
  auto out = EsAvgPoolUpdate(x1.GetEsbTensor(), x2.GetEsbTensor(), ksize.data(), static_cast<int64_t>(ksize.size()), strides.data(), static_cast<int64_t>(strides.size()), padding_mode, pads.data(), static_cast<int64_t>(pads.size()), data_format, ceil_mode, exclusive);
  return out;
}
inline Tensor AvgPoolV2(const Tensor &x, const std::vector<int64_t> &ksize, const std::vector<int64_t> &strides, const char *padding_mode="CALCULATED", const std::vector<int64_t> &pads={0, 0, 0, 0}, const char *data_format="NCHW", bool global_pooling=false, bool ceil_mode=false, bool exclusive=true, int64_t divisor_override=0) {
  auto out = EsAvgPoolV2(x.GetEsbTensor(), ksize.data(), static_cast<int64_t>(ksize.size()), strides.data(), static_cast<int64_t>(strides.size()), padding_mode, pads.data(), static_cast<int64_t>(pads.size()), data_format, global_pooling, ceil_mode, exclusive, divisor_override);
  return out;
}
inline Tensor AvgPoolV2Grad(const Tensor &orig_input_shape, const Tensor &input_grad, const std::vector<int64_t> &ksize, const std::vector<int64_t> &strides, const char *padding_mode="CALCULATED", const std::vector<int64_t> &pads={0, 0, 0, 0}, const char *data_format="NCHW", bool global_pooling=false, bool ceil_mode=false, bool exclusive=true) {
  auto out = EsAvgPoolV2Grad(orig_input_shape.GetEsbTensor(), input_grad.GetEsbTensor(), ksize.data(), static_cast<int64_t>(ksize.size()), strides.data(), static_cast<int64_t>(strides.size()), padding_mode, pads.data(), static_cast<int64_t>(pads.size()), data_format, global_pooling, ceil_mode, exclusive);
  return out;
}
inline Tensor AvgPoolV2GradD(const Tensor &input_grad, const Tensor &mean_matrix, const Tensor &kernel_matrix, const std::vector<int64_t> &orig_input_shape, const std::vector<int64_t> &ksize, const std::vector<int64_t> &strides, const char *padding_mode="CALCULATED", const std::vector<int64_t> &pads={0, 0, 0, 0}, const char *data_format="NCHW", bool global_pooling=false, bool ceil_mode=false, bool exclusive=true) {
  auto out = EsAvgPoolV2GradD(input_grad.GetEsbTensor(), mean_matrix.GetEsbTensor(), kernel_matrix.GetEsbTensor(), orig_input_shape.data(), static_cast<int64_t>(orig_input_shape.size()), ksize.data(), static_cast<int64_t>(ksize.size()), strides.data(), static_cast<int64_t>(strides.size()), padding_mode, pads.data(), static_cast<int64_t>(pads.size()), data_format, global_pooling, ceil_mode, exclusive);
  return out;
}
inline Tensor Axpy(const Tensor &x1, const Tensor &x2, float alpha) {
  auto out = EsAxpy(x1.GetEsbTensor(), x2.GetEsbTensor(), alpha);
  return out;
}
inline Tensor AxpyV2(const Tensor &x1, const Tensor &x2, const Tensor &alpha) {
  auto out = EsAxpyV2(x1.GetEsbTensor(), x2.GetEsbTensor(), alpha.GetEsbTensor());
  return out;
}
struct AxpyWithSoftmaxAndDropOutDoMaskOutput {
  Tensor y1;
  Tensor y2;
};
inline AxpyWithSoftmaxAndDropOutDoMaskOutput AxpyWithSoftmaxAndDropOutDoMask(const Tensor &x1, const Tensor &x2, const Tensor &mask, float alpha, float input_keep_prob, const std::vector<int64_t> &axis={-1}) {
  auto out = EsAxpyWithSoftmaxAndDropOutDoMask(x1.GetEsbTensor(), x2.GetEsbTensor(), mask.GetEsbTensor(), alpha, input_keep_prob, axis.data(), static_cast<int64_t>(axis.size()));
  return {out.y1, out.y2};
}
struct BN3DTrainingReduceOutput {
  Tensor sum;
  Tensor square_sum;
};
inline BN3DTrainingReduceOutput BN3DTrainingReduce(const Tensor &x) {
  auto out = EsBN3DTrainingReduce(x.GetEsbTensor());
  return {out.sum, out.square_sum};
}
inline Tensor BN3DTrainingReduceGrad(const Tensor &grads, const Tensor &x, const Tensor &diff_scale, const Tensor &diff_offset, const Tensor &scale, const Tensor &batch_mean, const Tensor &batch_variance, float epsilon=0.000100) {
  auto out = EsBN3DTrainingReduceGrad(grads.GetEsbTensor(), x.GetEsbTensor(), diff_scale.GetEsbTensor(), diff_offset.GetEsbTensor(), scale.GetEsbTensor(), batch_mean.GetEsbTensor(), batch_variance.GetEsbTensor(), epsilon);
  return out;
}
struct BN3DTrainingUpdateOutput {
  Tensor y;
  Tensor mean;
  Tensor variance;
  Tensor batch_mean;
  Tensor batch_variance;
};
inline BN3DTrainingUpdateOutput BN3DTrainingUpdate(const Tensor &x, const Tensor &sum, const Tensor &square_sum, const Tensor &scale, const Tensor &offset, const Tensor &mean, const Tensor &variance, float factor, float epsilon) {
  auto out = EsBN3DTrainingUpdate(x.GetEsbTensor(), sum.GetEsbTensor(), square_sum.GetEsbTensor(), scale.GetEsbTensor(), offset.GetEsbTensor(), mean.GetEsbTensor(), variance.GetEsbTensor(), factor, epsilon);
  return {out.y, out.mean, out.variance, out.batch_mean, out.batch_variance};
}
struct BN3DTrainingUpdateGradOutput {
  Tensor diff_scale;
  Tensor diff_offset;
};
inline BN3DTrainingUpdateGradOutput BN3DTrainingUpdateGrad(const Tensor &grads, const Tensor &x, const Tensor &batch_mean, const Tensor &batch_variance, float epsilon=0.000100) {
  auto out = EsBN3DTrainingUpdateGrad(grads.GetEsbTensor(), x.GetEsbTensor(), batch_mean.GetEsbTensor(), batch_variance.GetEsbTensor(), epsilon);
  return {out.diff_scale, out.diff_offset};
}
inline Tensor BNInfer(const Tensor &x, const Tensor &scale, const Tensor &offset, const Tensor &mean, const Tensor &variance, float epsilon) {
  auto out = EsBNInfer(x.GetEsbTensor(), scale.GetEsbTensor(), offset.GetEsbTensor(), mean.GetEsbTensor(), variance.GetEsbTensor(), epsilon);
  return out;
}
inline Tensor BNInferGrad(const Tensor &grads, const Tensor &scale, const Tensor &batch_variance, float epsilon=0.000100) {
  auto out = EsBNInferGrad(grads.GetEsbTensor(), scale.GetEsbTensor(), batch_variance.GetEsbTensor(), epsilon);
  return out;
}
inline Tensor BNInference(const Tensor &x, const Tensor &mean, const Tensor &variance, const Tensor &momentum, const Tensor &scale=nullptr, const Tensor &offset=nullptr, float epsilon=0.000010, bool use_global_stats=true, int64_t mode=1) {
  auto out = EsBNInference(x.GetEsbTensor(), mean.GetEsbTensor(), variance.GetEsbTensor(), momentum.GetEsbTensor(), scale.GetEsbTensor(), offset.GetEsbTensor(), epsilon, use_global_stats, mode);
  return out;
}
inline Tensor BNInferenceD(const Tensor &x, const Tensor &mean, const Tensor &variance, const Tensor &scale=nullptr, const Tensor &b=nullptr, float momentum=0.900000, float epsilon=0.000010, bool use_global_stats=true, int64_t mode=1) {
  auto out = EsBNInferenceD(x.GetEsbTensor(), mean.GetEsbTensor(), variance.GetEsbTensor(), scale.GetEsbTensor(), b.GetEsbTensor(), momentum, epsilon, use_global_stats, mode);
  return out;
}
inline Tensor BNLL(const Tensor &x) {
  auto out = EsBNLL(x.GetEsbTensor());
  return out;
}
struct BNTrainingReduceOutput {
  Tensor sum;
  Tensor square_sum;
};
inline BNTrainingReduceOutput BNTrainingReduce(const Tensor &x) {
  auto out = EsBNTrainingReduce(x.GetEsbTensor());
  return {out.sum, out.square_sum};
}
inline Tensor BNTrainingReduceGrad(const Tensor &grads, const Tensor &x, const Tensor &diff_scale, const Tensor &diff_offset, const Tensor &scale, const Tensor &batch_mean, const Tensor &batch_variance, float epsilon=0.000100) {
  auto out = EsBNTrainingReduceGrad(grads.GetEsbTensor(), x.GetEsbTensor(), diff_scale.GetEsbTensor(), diff_offset.GetEsbTensor(), scale.GetEsbTensor(), batch_mean.GetEsbTensor(), batch_variance.GetEsbTensor(), epsilon);
  return out;
}
struct BNTrainingUpdateOutput {
  Tensor y;
  Tensor mean;
  Tensor variance;
  Tensor batch_mean;
  Tensor batch_variance;
};
inline BNTrainingUpdateOutput BNTrainingUpdate(const Tensor &x, const Tensor &sum, const Tensor &square_sum, const Tensor &scale, const Tensor &offset, const Tensor &mean, const Tensor &variance, float factor, float epsilon) {
  auto out = EsBNTrainingUpdate(x.GetEsbTensor(), sum.GetEsbTensor(), square_sum.GetEsbTensor(), scale.GetEsbTensor(), offset.GetEsbTensor(), mean.GetEsbTensor(), variance.GetEsbTensor(), factor, epsilon);
  return {out.y, out.mean, out.variance, out.batch_mean, out.batch_variance};
}
struct BNTrainingUpdateGradOutput {
  Tensor diff_scale;
  Tensor diff_offset;
};
inline BNTrainingUpdateGradOutput BNTrainingUpdateGrad(const Tensor &grads, const Tensor &x, const Tensor &batch_mean, const Tensor &batch_variance, float epsilon=0.000100) {
  auto out = EsBNTrainingUpdateGrad(grads.GetEsbTensor(), x.GetEsbTensor(), batch_mean.GetEsbTensor(), batch_variance.GetEsbTensor(), epsilon);
  return {out.diff_scale, out.diff_offset};
}
struct BNTrainingUpdateV2Output {
  Tensor y;
  Tensor batch_mean;
  Tensor batch_variance;
};
inline BNTrainingUpdateV2Output BNTrainingUpdateV2(const Tensor &x, const Tensor &sum, const Tensor &square_sum, const Tensor &scale, const Tensor &offset, float epsilon) {
  auto out = EsBNTrainingUpdateV2(x.GetEsbTensor(), sum.GetEsbTensor(), square_sum.GetEsbTensor(), scale.GetEsbTensor(), offset.GetEsbTensor(), epsilon);
  return {out.y, out.batch_mean, out.batch_variance};
}
struct BNTrainingUpdateV3Output {
  Tensor y;
  Tensor batch_mean;
  Tensor batch_variance;
  Tensor reserve_1;
  Tensor reserve_2;
};
inline BNTrainingUpdateV3Output BNTrainingUpdateV3(const Tensor &x, const Tensor &sum, const Tensor &square_sum, const Tensor &scale, const Tensor &offset, float epsilon) {
  auto out = EsBNTrainingUpdateV3(x.GetEsbTensor(), sum.GetEsbTensor(), square_sum.GetEsbTensor(), scale.GetEsbTensor(), offset.GetEsbTensor(), epsilon);
  return {out.y, out.batch_mean, out.batch_variance, out.reserve_1, out.reserve_2};
}
struct BalanceRoisOutput {
  Tensor balance_rois;
  Tensor index;
};
inline BalanceRoisOutput BalanceRois(const Tensor &rois) {
  auto out = EsBalanceRois(rois.GetEsbTensor());
  return {out.balance_rois, out.index};
}
inline Tensor BallQuery(const Tensor &xyz, const Tensor &center_xyz, float min_radius, float max_radius, int64_t sample_num) {
  auto out = EsBallQuery(xyz.GetEsbTensor(), center_xyz.GetEsbTensor(), min_radius, max_radius, sample_num);
  return out;
}
inline Tensor BandedTriangularSolve(const Tensor &bands, const Tensor &rhs, bool lower=true, bool adjoint=false) {
  auto out = EsBandedTriangularSolve(bands.GetEsbTensor(), rhs.GetEsbTensor(), lower, adjoint);
  return out;
}
inline Tensor BarrierClose(const Tensor &handle, bool cancel_pending_enqueues=false) {
  auto out = EsBarrierClose(handle.GetEsbTensor(), cancel_pending_enqueues);
  return out;
}
inline Tensor BarrierIncompleteSize(const Tensor &handle) {
  auto out = EsBarrierIncompleteSize(handle.GetEsbTensor());
  return out;
}
inline Tensor BarrierInsertMany(const Tensor &handle, const Tensor &keys, const Tensor &values, int64_t component_index) {
  auto out = EsBarrierInsertMany(handle.GetEsbTensor(), keys.GetEsbTensor(), values.GetEsbTensor(), component_index);
  return out;
}
inline Tensor BarrierReadySize(const Tensor &handle) {
  auto out = EsBarrierReadySize(handle.GetEsbTensor());
  return out;
}
struct BasicLSTMCellOutput {
  Tensor ct;
  Tensor ht;
  Tensor it;
  Tensor jt;
  Tensor ft;
  Tensor ot;
  Tensor tanhct;
};
inline BasicLSTMCellOutput BasicLSTMCell(const Tensor &x, const Tensor &h, const Tensor &c, const Tensor &w, const Tensor &b, const Tensor &mask=nullptr, float keep_prob=1.000000, float forget_bias=1.000000, bool state_is_tuple=true, const char *activation="tanh") {
  auto out = EsBasicLSTMCell(x.GetEsbTensor(), h.GetEsbTensor(), c.GetEsbTensor(), w.GetEsbTensor(), b.GetEsbTensor(), mask.GetEsbTensor(), keep_prob, forget_bias, state_is_tuple, activation);
  return {out.ct, out.ht, out.it, out.jt, out.ft, out.ot, out.tanhct};
}
struct BasicLSTMCellCStateGradOutput {
  Tensor dgate;
  Tensor dct_1;
};
inline BasicLSTMCellCStateGradOutput BasicLSTMCellCStateGrad(const Tensor &c, const Tensor &dht, const Tensor &dct, const Tensor &it, const Tensor &jt, const Tensor &ft, const Tensor &ot, const Tensor &tanhct, float forget_bias=1.000000, const char *activation="tanh") {
  auto out = EsBasicLSTMCellCStateGrad(c.GetEsbTensor(), dht.GetEsbTensor(), dct.GetEsbTensor(), it.GetEsbTensor(), jt.GetEsbTensor(), ft.GetEsbTensor(), ot.GetEsbTensor(), tanhct.GetEsbTensor(), forget_bias, activation);
  return {out.dgate, out.dct_1};
}
struct BasicLSTMCellInputGradOutput {
  Tensor dxt;
  Tensor dht;
};
inline BasicLSTMCellInputGradOutput BasicLSTMCellInputGrad(const Tensor &dgate, const Tensor &w, const Tensor &dropout_mask=nullptr, float keep_prob=1.000000) {
  auto out = EsBasicLSTMCellInputGrad(dgate.GetEsbTensor(), w.GetEsbTensor(), dropout_mask.GetEsbTensor(), keep_prob);
  return {out.dxt, out.dht};
}
struct BasicLSTMCellWeightGradOutput {
  Tensor dw;
  Tensor db;
};
inline BasicLSTMCellWeightGradOutput BasicLSTMCellWeightGrad(const Tensor &x, const Tensor &h, const Tensor &dgate) {
  auto out = EsBasicLSTMCellWeightGrad(x.GetEsbTensor(), h.GetEsbTensor(), dgate.GetEsbTensor());
  return {out.dw, out.db};
}
struct BasicRNNCellOutput {
  Tensor o_t;
  Tensor h_t;
};
inline BasicRNNCellOutput BasicRNNCell(const Tensor &x, const Tensor &cont, const Tensor &w_xh_x_static, const Tensor &h_0, const Tensor &w_xh, const Tensor &bias_h, const Tensor &w_hh, const Tensor &w_ho, const Tensor &bias_o, bool expose_hidden=false, int64_t num_output=0) {
  auto out = EsBasicRNNCell(x.GetEsbTensor(), cont.GetEsbTensor(), w_xh_x_static.GetEsbTensor(), h_0.GetEsbTensor(), w_xh.GetEsbTensor(), bias_h.GetEsbTensor(), w_hh.GetEsbTensor(), w_ho.GetEsbTensor(), bias_o.GetEsbTensor(), expose_hidden, num_output);
  return {out.o_t, out.h_t};
}
struct BatchDilatePolysOutput {
  Tensor dilated_polys_data;
  Tensor dilated_polys_offset;
  Tensor dilated_polys_size;
};
inline BatchDilatePolysOutput BatchDilatePolys(const Tensor &polys_data, const Tensor &polys_offset, const Tensor &polys_size, const Tensor &score, const Tensor &min_border, const Tensor &min_area_thr, const Tensor &score_thr, const Tensor &expands_cale) {
  auto out = EsBatchDilatePolys(polys_data.GetEsbTensor(), polys_offset.GetEsbTensor(), polys_size.GetEsbTensor(), score.GetEsbTensor(), min_border.GetEsbTensor(), min_area_thr.GetEsbTensor(), score_thr.GetEsbTensor(), expands_cale.GetEsbTensor());
  return {out.dilated_polys_data, out.dilated_polys_offset, out.dilated_polys_size};
}
inline Tensor BatchEnqueue(const Tensor &x, const Tensor &queue_id=nullptr, int64_t batch_size=8, const char *queue_name="", int64_t queue_depth=100, const char *pad_mode="REPLICATE") {
  auto out = EsBatchEnqueue(x.GetEsbTensor(), queue_id.GetEsbTensor(), batch_size, queue_name, queue_depth, pad_mode);
  return out;
}
inline Tensor BatchMatMul(const Tensor &x1, const Tensor &x2, bool adj_x1=false, bool adj_x2=false) {
  auto out = EsBatchMatMul(x1.GetEsbTensor(), x2.GetEsbTensor(), adj_x1, adj_x2);
  return out;
}
inline Tensor BatchMatMulReduceScatterAlltoAll(const Tensor &x, const Tensor &weight, const Tensor &bias, const char *group_ep, const char *group_tp, int64_t ep_world_size, int64_t tp_world_size, int64_t y_shard_type=0, bool transpose_weight=false) {
  auto out = EsBatchMatMulReduceScatterAlltoAll(x.GetEsbTensor(), weight.GetEsbTensor(), bias.GetEsbTensor(), group_ep, group_tp, ep_world_size, tp_world_size, y_shard_type, transpose_weight);
  return out;
}
inline Tensor BatchMatMulV2(const Tensor &x1, const Tensor &x2, const Tensor &bias=nullptr, const Tensor &offset_w=nullptr, bool adj_x1=false, bool adj_x2=false, int64_t offset_x=0) {
  auto out = EsBatchMatMulV2(x1.GetEsbTensor(), x2.GetEsbTensor(), bias.GetEsbTensor(), offset_w.GetEsbTensor(), adj_x1, adj_x2, offset_x);
  return out;
}
inline Tensor BatchMatMulV3(const Tensor &x1, const Tensor &x2, const Tensor &bias=nullptr, const Tensor &offset_w=nullptr, bool adj_x1=false, bool adj_x2=false, int64_t offset_x=0, bool enable_hf32=false) {
  auto out = EsBatchMatMulV3(x1.GetEsbTensor(), x2.GetEsbTensor(), bias.GetEsbTensor(), offset_w.GetEsbTensor(), adj_x1, adj_x2, offset_x, enable_hf32);
  return out;
}
inline Tensor BatchMatmulFixpipe(const Tensor &x1, const Tensor &x2, const Tensor &quant_pre, const Tensor &bias=nullptr, bool adj_x1=false, bool adj_x2=false) {
  auto out = EsBatchMatmulFixpipe(x1.GetEsbTensor(), x2.GetEsbTensor(), quant_pre.GetEsbTensor(), bias.GetEsbTensor(), adj_x1, adj_x2);
  return out;
}
struct BatchMultiClassNonMaxSuppressionOutput {
  Tensor nmsed_boxes;
  Tensor nmsed_scores;
  Tensor nmsed_classes;
  Tensor nmsed_num;
};
inline BatchMultiClassNonMaxSuppressionOutput BatchMultiClassNonMaxSuppression(const Tensor &boxes, const Tensor &scores, const Tensor &clip_window, const Tensor &num_valid_boxes, float score_threshold, float iou_threshold, int64_t max_size_per_class, int64_t max_total_size, bool change_coordinate_frame=false, bool transpose_box=false, const std::vector<int64_t> &image_size={}) {
  auto out = EsBatchMultiClassNonMaxSuppression(boxes.GetEsbTensor(), scores.GetEsbTensor(), clip_window.GetEsbTensor(), num_valid_boxes.GetEsbTensor(), score_threshold, iou_threshold, max_size_per_class, max_total_size, change_coordinate_frame, transpose_box, image_size.data(), static_cast<int64_t>(image_size.size()));
  return {out.nmsed_boxes, out.nmsed_scores, out.nmsed_classes, out.nmsed_num};
}
struct BatchNormOutput {
  Tensor y;
  Tensor batch_mean;
  Tensor batch_variance;
  Tensor reserve_space_1;
  Tensor reserve_space_2;
  Tensor reserve_space_3;
};
inline BatchNormOutput BatchNorm(const Tensor &x, const Tensor &scale, const Tensor &offset, const Tensor &mean=nullptr, const Tensor &variance=nullptr, float epsilon=0.000100, const char *data_format="NHWC", bool is_training=true, float exponential_avg_factor=1.000000) {
  auto out = EsBatchNorm(x.GetEsbTensor(), scale.GetEsbTensor(), offset.GetEsbTensor(), mean.GetEsbTensor(), variance.GetEsbTensor(), epsilon, data_format, is_training, exponential_avg_factor);
  return {out.y, out.batch_mean, out.batch_variance, out.reserve_space_1, out.reserve_space_2, out.reserve_space_3};
}
struct BatchNorm3DOutput {
  Tensor y;
  Tensor batch_mean;
  Tensor batch_variance;
  Tensor reserve_space_1;
  Tensor reserve_space_2;
};
inline BatchNorm3DOutput BatchNorm3D(const Tensor &x, const Tensor &scale, const Tensor &offset, const Tensor &mean=nullptr, const Tensor &variance=nullptr, float epsilon=0.000100, const char *data_format="NCDHW", bool is_training=true) {
  auto out = EsBatchNorm3D(x.GetEsbTensor(), scale.GetEsbTensor(), offset.GetEsbTensor(), mean.GetEsbTensor(), variance.GetEsbTensor(), epsilon, data_format, is_training);
  return {out.y, out.batch_mean, out.batch_variance, out.reserve_space_1, out.reserve_space_2};
}
struct BatchNorm3DGradOutput {
  Tensor x_backprop;
  Tensor scale_backprop;
  Tensor offset_backprop;
  Tensor reserve_space_4;
  Tensor reserve_space_5;
};
inline BatchNorm3DGradOutput BatchNorm3DGrad(const Tensor &y_backprop, const Tensor &x, const Tensor &scale, const Tensor &reserve_space_1, const Tensor &reserve_space_2, float epsilon=0.000100, const char *data_format="NCDHW", bool is_training=true) {
  auto out = EsBatchNorm3DGrad(y_backprop.GetEsbTensor(), x.GetEsbTensor(), scale.GetEsbTensor(), reserve_space_1.GetEsbTensor(), reserve_space_2.GetEsbTensor(), epsilon, data_format, is_training);
  return {out.x_backprop, out.scale_backprop, out.offset_backprop, out.reserve_space_4, out.reserve_space_5};
}
struct BatchNormExt2Output {
  Tensor output_y;
  Tensor output_mean;
  Tensor output_variance;
  Tensor output_reserve_space_1;
  Tensor output_reserve_space_2;
};
inline BatchNormExt2Output BatchNormExt2(const Tensor &input_x, const Tensor &input_scale, const Tensor &input_offset, const Tensor &input_mean=nullptr, const Tensor &input_variance=nullptr, float epsilon=0.000100, const char *data_format="NHWC", bool is_training=true) {
  auto out = EsBatchNormExt2(input_x.GetEsbTensor(), input_scale.GetEsbTensor(), input_offset.GetEsbTensor(), input_mean.GetEsbTensor(), input_variance.GetEsbTensor(), epsilon, data_format, is_training);
  return {out.output_y, out.output_mean, out.output_variance, out.output_reserve_space_1, out.output_reserve_space_2};
}
struct BatchNormGradOutput {
  Tensor x_backprop;
  Tensor scale_backprop;
  Tensor offset_backprop;
  Tensor reserve_space_4;
  Tensor reserve_space_5;
};
inline BatchNormGradOutput BatchNormGrad(const Tensor &y_backprop, const Tensor &x, const Tensor &scale, const Tensor &reserve_space_1, const Tensor &reserve_space_2, const Tensor &reserve_space_3=nullptr, float epsilon=0.000100, const char *data_format="NHWC", bool is_training=true) {
  auto out = EsBatchNormGrad(y_backprop.GetEsbTensor(), x.GetEsbTensor(), scale.GetEsbTensor(), reserve_space_1.GetEsbTensor(), reserve_space_2.GetEsbTensor(), reserve_space_3.GetEsbTensor(), epsilon, data_format, is_training);
  return {out.x_backprop, out.scale_backprop, out.offset_backprop, out.reserve_space_4, out.reserve_space_5};
}
struct BatchNormGradExt2Output {
  Tensor x_backprop;
  Tensor scale_backprop;
  Tensor offset_backprop;
  Tensor reserve_space_3;
  Tensor reserve_space_4;
};
inline BatchNormGradExt2Output BatchNormGradExt2(const Tensor &y_backprop, const Tensor &x, const Tensor &scale, const Tensor &reserve_space_1, const Tensor &reserve_space_2, float epsilon=0.000100, const char *data_format="NHWC", bool is_training=true) {
  auto out = EsBatchNormGradExt2(y_backprop.GetEsbTensor(), x.GetEsbTensor(), scale.GetEsbTensor(), reserve_space_1.GetEsbTensor(), reserve_space_2.GetEsbTensor(), epsilon, data_format, is_training);
  return {out.x_backprop, out.scale_backprop, out.offset_backprop, out.reserve_space_3, out.reserve_space_4};
}
struct BatchNormV3Output {
  Tensor y;
  Tensor running_mean;
  Tensor running_var;
  Tensor save_mean;
  Tensor save_rstd;
};
inline BatchNormV3Output BatchNormV3(const Tensor &x, const Tensor &weight, const Tensor &bias, const Tensor &running_mean, const Tensor &running_var, float epsilon=0.000010, float momentum=0.100000, bool is_training=true) {
  auto out = EsBatchNormV3(x.GetEsbTensor(), weight.GetEsbTensor(), bias.GetEsbTensor(), running_mean.GetEsbTensor(), running_var.GetEsbTensor(), epsilon, momentum, is_training);
  return {out.y, out.running_mean, out.running_var, out.save_mean, out.save_rstd};
}
inline Tensor BatchToSpace(const Tensor &x, const Tensor &crops, int64_t block_size) {
  auto out = EsBatchToSpace(x.GetEsbTensor(), crops.GetEsbTensor(), block_size);
  return out;
}
inline Tensor BatchToSpaceD(const Tensor &x, int64_t block_size, const std::vector<int64_t> &crops) {
  auto out = EsBatchToSpaceD(x.GetEsbTensor(), block_size, crops.data(), static_cast<int64_t>(crops.size()));
  return out;
}
inline Tensor BatchToSpaceND(const Tensor &x, const Tensor &block_shape, const Tensor &crops) {
  auto out = EsBatchToSpaceND(x.GetEsbTensor(), block_shape.GetEsbTensor(), crops.GetEsbTensor());
  return out;
}
inline Tensor BatchToSpaceNDD(const Tensor &x, const std::vector<int64_t> &block_shape, const std::vector<int64_t> &crops) {
  auto out = EsBatchToSpaceNDD(x.GetEsbTensor(), block_shape.data(), static_cast<int64_t>(block_shape.size()), crops.data(), static_cast<int64_t>(crops.size()));
  return out;
}
inline Tensor BesselI0e(const Tensor &x) {
  auto out = EsBesselI0e(x.GetEsbTensor());
  return out;
}
inline Tensor BesselI1e(const Tensor &x) {
  auto out = EsBesselI1e(x.GetEsbTensor());
  return out;
}
inline Tensor Betainc(const Tensor &a, const Tensor &b, const Tensor &x) {
  auto out = EsBetainc(a.GetEsbTensor(), b.GetEsbTensor(), x.GetEsbTensor());
  return out;
}
inline Tensor Bias(const Tensor &x, const Tensor &bias, int64_t axis=1, int64_t num_axes=1, bool bias_from_blob=true) {
  auto out = EsBias(x.GetEsbTensor(), bias.GetEsbTensor(), axis, num_axes, bias_from_blob);
  return out;
}
inline Tensor BiasAdd(const Tensor &x, const Tensor &bias, const char *data_format="NHWC") {
  auto out = EsBiasAdd(x.GetEsbTensor(), bias.GetEsbTensor(), data_format);
  return out;
}
inline Tensor BiasAddGrad(const Tensor &x, const char *data_format="NHWC") {
  auto out = EsBiasAddGrad(x.GetEsbTensor(), data_format);
  return out;
}
inline Tensor BinaryCrossEntropy(const Tensor &x, const Tensor &y, const Tensor &weight=nullptr, const char *reduction="mean") {
  auto out = EsBinaryCrossEntropy(x.GetEsbTensor(), y.GetEsbTensor(), weight.GetEsbTensor(), reduction);
  return out;
}
inline Tensor BinaryCrossEntropyGrad(const Tensor &x, const Tensor &y, const Tensor &grad_output, const Tensor &weight=nullptr, const char *reduction="mean") {
  auto out = EsBinaryCrossEntropyGrad(x.GetEsbTensor(), y.GetEsbTensor(), grad_output.GetEsbTensor(), weight.GetEsbTensor(), reduction);
  return out;
}
inline Tensor Bincount(const Tensor &array, const Tensor &size, const Tensor &weights) {
  auto out = EsBincount(array.GetEsbTensor(), size.GetEsbTensor(), weights.GetEsbTensor());
  return out;
}
inline Tensor Bitcast(const Tensor &x, ge::DataType type) {
  auto out = EsBitcast(x.GetEsbTensor(), type);
  return out;
}
inline Tensor BitwiseAnd(const Tensor &x1, const Tensor &x2) {
  auto out = EsBitwiseAnd(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor BitwiseAnd(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return BitwiseAnd(tensor, b_esb_tensor);
}
inline Tensor BitwiseOr(const Tensor &x1, const Tensor &x2) {
  auto out = EsBitwiseOr(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor BitwiseOr(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return BitwiseOr(tensor, b_esb_tensor);
}
inline Tensor BitwiseXor(const Tensor &x1, const Tensor &x2) {
  auto out = EsBitwiseXor(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor BitwiseXor(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return BitwiseXor(tensor, b_esb_tensor);
}
struct BlendFaceBgPartOneOutput {
  Tensor acc_face;
  Tensor acc_mask;
  Tensor max_mask;
};
inline BlendFaceBgPartOneOutput BlendFaceBgPartOne(const Tensor &face_img, const Tensor &face_rect, const Tensor &face_mask, const Tensor &acc_face, const Tensor &acc_mask, const Tensor &max_mask) {
  auto out = EsBlendFaceBgPartOne(face_img.GetEsbTensor(), face_rect.GetEsbTensor(), face_mask.GetEsbTensor(), acc_face.GetEsbTensor(), acc_mask.GetEsbTensor(), max_mask.GetEsbTensor());
  return {out.acc_face, out.acc_mask, out.max_mask};
}
inline Tensor BlendFaceBgPartTwo(const Tensor &acc_face, const Tensor &acc_mask, const Tensor &max_mask, const Tensor &bg_img, float epsilon=0.000000) {
  auto out = EsBlendFaceBgPartTwo(acc_face.GetEsbTensor(), acc_mask.GetEsbTensor(), max_mask.GetEsbTensor(), bg_img.GetEsbTensor(), epsilon);
  return out;
}
inline Tensor BlendImagesCustom(const Tensor &rgb, const Tensor &alpha, const Tensor &frame) {
  auto out = EsBlendImagesCustom(rgb.GetEsbTensor(), alpha.GetEsbTensor(), frame.GetEsbTensor());
  return out;
}
inline Tensor BoundingBoxDecode(const Tensor &rois, const Tensor &deltas, const std::vector<int64_t> &max_shape, const std::vector<float> &means={0.000000, 0.000000, 0.000000, 0.000000}, const std::vector<float> &stds={1.000000, 1.000000, 1.000000, 1.000000}, float wh_ratio_clip=0.016000) {
  auto out = EsBoundingBoxDecode(rois.GetEsbTensor(), deltas.GetEsbTensor(), max_shape.data(), static_cast<int64_t>(max_shape.size()), means.data(), static_cast<int64_t>(means.size()), stds.data(), static_cast<int64_t>(stds.size()), wh_ratio_clip);
  return out;
}
inline Tensor BoundingBoxEncode(const Tensor &anchor_box, const Tensor &ground_truth_box, const std::vector<float> &means={0.000000, 0.000000, 0.000000, 0.000000}, const std::vector<float> &stds={1.000000, 1.000000, 1.000000, 1.000000}) {
  auto out = EsBoundingBoxEncode(anchor_box.GetEsbTensor(), ground_truth_box.GetEsbTensor(), means.data(), static_cast<int64_t>(means.size()), stds.data(), static_cast<int64_t>(stds.size()));
  return out;
}
inline Tensor BroadcastArgs(const Tensor &x1, const Tensor &x2) {
  auto out = EsBroadcastArgs(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
struct BroadcastGradientArgsOutput {
  Tensor y1;
  Tensor y2;
};
inline BroadcastGradientArgsOutput BroadcastGradientArgs(const Tensor &x1, const Tensor &x2) {
  auto out = EsBroadcastGradientArgs(x1.GetEsbTensor(), x2.GetEsbTensor());
  return {out.y1, out.y2};
}
inline Tensor BroadcastTo(const Tensor &x, const Tensor &shape) {
  auto out = EsBroadcastTo(x.GetEsbTensor(), shape.GetEsbTensor());
  return out;
}
inline Tensor BroadcastToD(const Tensor &x, const std::vector<int64_t> &shape) {
  auto out = EsBroadcastToD(x.GetEsbTensor(), shape.data(), static_cast<int64_t>(shape.size()));
  return out;
}
inline Tensor Bucketize(const Tensor &x, const std::vector<float> &boundaries, ge::DataType dtype=ge::DT_INT32, bool right=true) {
  auto out = EsBucketize(x.GetEsbTensor(), boundaries.data(), static_cast<int64_t>(boundaries.size()), dtype, right);
  return out;
}
struct CIoUOutput {
  Tensor overlap;
  Tensor atan_sub;
};
inline CIoUOutput CIoU(const Tensor &bboxes, const Tensor &gtboxes, bool trans=false, bool is_cross=true, const char *mode="iou", bool atan_sub_flag=false) {
  auto out = EsCIoU(bboxes.GetEsbTensor(), gtboxes.GetEsbTensor(), trans, is_cross, mode, atan_sub_flag);
  return {out.overlap, out.atan_sub};
}
struct CIoUGradOutput {
  Tensor dbboxes;
  Tensor dgtboxes;
};
inline CIoUGradOutput CIoUGrad(const Tensor &dy, const Tensor &bboxes, const Tensor &gtboxes, const Tensor &atan_sub, bool trans=false, bool is_cross=true, const char *mode="iou") {
  auto out = EsCIoUGrad(dy.GetEsbTensor(), bboxes.GetEsbTensor(), gtboxes.GetEsbTensor(), atan_sub.GetEsbTensor(), trans, is_cross, mode);
  return {out.dbboxes, out.dgtboxes};
}
struct CTCGreedyDecoderOutput {
  Tensor decoded_indices;
  Tensor decoded_values;
  Tensor decoded_shape;
  Tensor log_probability;
};
inline CTCGreedyDecoderOutput CTCGreedyDecoder(const Tensor &inputs, const Tensor &sequence_length, bool merge_repeated=false) {
  auto out = EsCTCGreedyDecoder(inputs.GetEsbTensor(), sequence_length.GetEsbTensor(), merge_repeated);
  return {out.decoded_indices, out.decoded_values, out.decoded_shape, out.log_probability};
}
struct CTCLossOutput {
  Tensor loss;
  Tensor gradient;
};
inline CTCLossOutput CTCLoss(const Tensor &inputs, const Tensor &labels_indices, const Tensor &labels_values, const Tensor &sequence_length, bool preprocess_collapse_repeated=false, bool ctc_merge_repeated=true, bool ignore_longer_outputs_than_inputs=false) {
  auto out = EsCTCLoss(inputs.GetEsbTensor(), labels_indices.GetEsbTensor(), labels_values.GetEsbTensor(), sequence_length.GetEsbTensor(), preprocess_collapse_repeated, ctc_merge_repeated, ignore_longer_outputs_than_inputs);
  return {out.loss, out.gradient};
}
struct CTCLossV2Output {
  Tensor neg_log_likelihood;
  Tensor log_alpha;
};
inline CTCLossV2Output CTCLossV2(const Tensor &log_probs, const Tensor &targets, const Tensor &input_lengths, const Tensor &target_lengths, int64_t blank=0, const char *reduction="mean", bool zero_infinity=false) {
  auto out = EsCTCLossV2(log_probs.GetEsbTensor(), targets.GetEsbTensor(), input_lengths.GetEsbTensor(), target_lengths.GetEsbTensor(), blank, reduction, zero_infinity);
  return {out.neg_log_likelihood, out.log_alpha};
}
inline Tensor CTCLossV2Grad(const Tensor &grad_out, const Tensor &log_probs, const Tensor &targets, const Tensor &input_lengths, const Tensor &target_lengths, const Tensor &neg_log_likelihood, const Tensor &log_alpha, int64_t blank=0, const char *reduction="mean", bool zero_infinity=false) {
  auto out = EsCTCLossV2Grad(grad_out.GetEsbTensor(), log_probs.GetEsbTensor(), targets.GetEsbTensor(), input_lengths.GetEsbTensor(), target_lengths.GetEsbTensor(), neg_log_likelihood.GetEsbTensor(), log_alpha.GetEsbTensor(), blank, reduction, zero_infinity);
  return out;
}
struct CacheAddOutput {
  Tensor swap_in_id;
  Tensor swap_in_idx;
  Tensor swap_out_id;
  Tensor swap_out_idx;
};
inline CacheAddOutput CacheAdd(const Tensor &cache, const Tensor &ids) {
  auto out = EsCacheAdd(cache.GetEsbTensor(), ids.GetEsbTensor());
  return {out.swap_in_id, out.swap_in_idx, out.swap_out_id, out.swap_out_idx};
}
inline Tensor CacheAllIndexToLocal(const Tensor &cache, ge::DataType dtype) {
  auto out = EsCacheAllIndexToLocal(cache.GetEsbTensor(), dtype);
  return out;
}
inline Tensor CacheRemoteIndexToLocal(const Tensor &cache, const Tensor &ids) {
  auto out = EsCacheRemoteIndexToLocal(cache.GetEsbTensor(), ids.GetEsbTensor());
  return out;
}
inline Tensor CacheUpdate(const Tensor &x) {
  auto out = EsCacheUpdate(x.GetEsbTensor());
  return out;
}
struct CalcBucketsLimitAndOffsetOutput {
  Tensor buckets_limit;
  Tensor buckets_offset;
};
inline CalcBucketsLimitAndOffsetOutput CalcBucketsLimitAndOffset(const Tensor &bucket_list, const Tensor &ivf_counts, const Tensor &ivf_offset, int64_t total_limit) {
  auto out = EsCalcBucketsLimitAndOffset(bucket_list.GetEsbTensor(), ivf_counts.GetEsbTensor(), ivf_offset.GetEsbTensor(), total_limit);
  return {out.buckets_limit, out.buckets_offset};
}
inline Tensor CaseCondition(const Tensor &x, const char *algorithm="LU") {
  auto out = EsCaseCondition(x.GetEsbTensor(), algorithm);
  return out;
}
inline Tensor Cast(const Tensor &x, int64_t dst_type) {
  auto out = EsCast(x.GetEsbTensor(), dst_type);
  return out;
}
inline Tensor CastLike(const Tensor &x, const Tensor &target) {
  auto out = EsCastLike(x.GetEsbTensor(), target.GetEsbTensor());
  return out;
}
inline Tensor Cdist(const Tensor &x1, const Tensor &x2, float p=2.000000) {
  auto out = EsCdist(x1.GetEsbTensor(), x2.GetEsbTensor(), p);
  return out;
}
inline Tensor CdistGrad(const Tensor &grad, const Tensor &x1, const Tensor &x2, const Tensor &cdist, float p=2.000000) {
  auto out = EsCdistGrad(grad.GetEsbTensor(), x1.GetEsbTensor(), x2.GetEsbTensor(), cdist.GetEsbTensor(), p);
  return out;
}
inline Tensor Ceil(const Tensor &x) {
  auto out = EsCeil(x.GetEsbTensor());
  return out;
}
inline Tensor Celu(const Tensor &x, float alpha1=1.000000, float alpha2=1.000000, float alpha3=1.000000) {
  auto out = EsCelu(x.GetEsbTensor(), alpha1, alpha2, alpha3);
  return out;
}
inline Tensor CeluV2(const Tensor &x, float alpha=1.000000) {
  auto out = EsCeluV2(x.GetEsbTensor(), alpha);
  return out;
}
inline Tensor Centralization(const Tensor &x, const std::vector<int64_t> &axes={-1}) {
  auto out = EsCentralization(x.GetEsbTensor(), axes.data(), static_cast<int64_t>(axes.size()));
  return out;
}
struct ChamferDistanceOutput {
  Tensor dist1;
  Tensor dist2;
  Tensor idx1;
  Tensor idx2;
};
inline ChamferDistanceOutput ChamferDistance(const Tensor &xyz1, const Tensor &xyz2) {
  auto out = EsChamferDistance(xyz1.GetEsbTensor(), xyz2.GetEsbTensor());
  return {out.dist1, out.dist2, out.idx1, out.idx2};
}
struct ChamferDistanceGradOutput {
  Tensor grad_xyz1;
  Tensor grad_xyz2;
};
inline ChamferDistanceGradOutput ChamferDistanceGrad(const Tensor &xyz1, const Tensor &xyz2, const Tensor &idx1, const Tensor &idx2, const Tensor &grad_dist1, const Tensor &grad_dist2) {
  auto out = EsChamferDistanceGrad(xyz1.GetEsbTensor(), xyz2.GetEsbTensor(), idx1.GetEsbTensor(), idx2.GetEsbTensor(), grad_dist1.GetEsbTensor(), grad_dist2.GetEsbTensor());
  return {out.grad_xyz1, out.grad_xyz2};
}
inline Tensor CheckNumerics(const Tensor &x, const char *message) {
  auto out = EsCheckNumerics(x.GetEsbTensor(), message);
  return out;
}
inline Tensor CheckValid(const Tensor &bbox_tensor, const Tensor &img_metas) {
  auto out = EsCheckValid(bbox_tensor.GetEsbTensor(), img_metas.GetEsbTensor());
  return out;
}
inline Tensor Cholesky(const Tensor &x) {
  auto out = EsCholesky(x.GetEsbTensor());
  return out;
}
inline Tensor CholeskyGrad(const Tensor &x, const Tensor &grad) {
  auto out = EsCholeskyGrad(x.GetEsbTensor(), grad.GetEsbTensor());
  return out;
}
inline Tensor ClipBoxes(const Tensor &boxes_input, const Tensor &img_size) {
  auto out = EsClipBoxes(boxes_input.GetEsbTensor(), img_size.GetEsbTensor());
  return out;
}
inline Tensor ClipBoxesD(const Tensor &boxes_input, const std::vector<int64_t> &img_size) {
  auto out = EsClipBoxesD(boxes_input.GetEsbTensor(), img_size.data(), static_cast<int64_t>(img_size.size()));
  return out;
}
inline Tensor ClipByNormNoDivSum(const Tensor &x, const Tensor &greater_zeros, const Tensor &select_ones, const Tensor &maximum_ones) {
  auto out = EsClipByNormNoDivSum(x.GetEsbTensor(), greater_zeros.GetEsbTensor(), select_ones.GetEsbTensor(), maximum_ones.GetEsbTensor());
  return out;
}
inline Tensor ClipByValue(const Tensor &x, const Tensor &clip_value_min, const Tensor &clip_value_max) {
  auto out = EsClipByValue(x.GetEsbTensor(), clip_value_min.GetEsbTensor(), clip_value_max.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor ClipByValue(const Tensor &x, T &&clip_value_min, T &&clip_value_max) {
  auto clip_value_min_esb_tensor = EnsureTensor(std::forward<T>(clip_value_min), x);
  auto clip_value_max_esb_tensor = EnsureTensor(std::forward<T>(clip_value_max), x);
  return ClipByValue(x, clip_value_min_esb_tensor, clip_value_max_esb_tensor);
}
inline Tensor ClipByValueV2(const Tensor &x, const Tensor &clip_value_min, const Tensor &clip_value_max) {
  auto out = EsClipByValueV2(x.GetEsbTensor(), clip_value_min.GetEsbTensor(), clip_value_max.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor ClipByValueV2(const Tensor &x, T &&clip_value_min, T &&clip_value_max) {
  auto clip_value_min_esb_tensor = EnsureTensor(std::forward<T>(clip_value_min), x);
  auto clip_value_max_esb_tensor = EnsureTensor(std::forward<T>(clip_value_max), x);
  return ClipByValueV2(x, clip_value_min_esb_tensor, clip_value_max_esb_tensor);
}
inline Tensor Cmo(const Tensor &src, int64_t max_size, int64_t type=6, int64_t offset=0) {
  auto out = EsCmo(src.GetEsbTensor(), max_size, type, offset);
  return out;
}
inline Tensor Col2ImV2(const Tensor &x, const Tensor &output_size, const Tensor &kernel_size, const std::vector<int64_t> &dilation, const std::vector<int64_t> &padding, const std::vector<int64_t> &stride) {
  auto out = EsCol2ImV2(x.GetEsbTensor(), output_size.GetEsbTensor(), kernel_size.GetEsbTensor(), dilation.data(), static_cast<int64_t>(dilation.size()), padding.data(), static_cast<int64_t>(padding.size()), stride.data(), static_cast<int64_t>(stride.size()));
  return out;
}
inline Tensor Col2im(const Tensor &x, const Tensor &output_size, const std::vector<int64_t> &kernel_size, const std::vector<int64_t> &dilation, const std::vector<int64_t> &padding, const std::vector<int64_t> &stride) {
  auto out = EsCol2im(x.GetEsbTensor(), output_size.GetEsbTensor(), kernel_size.data(), static_cast<int64_t>(kernel_size.size()), dilation.data(), static_cast<int64_t>(dilation.size()), padding.data(), static_cast<int64_t>(padding.size()), stride.data(), static_cast<int64_t>(stride.size()));
  return out;
}
inline Tensor Combinations(const Tensor &x, int64_t r=2, bool with_replacement=false) {
  auto out = EsCombinations(x.GetEsbTensor(), r, with_replacement);
  return out;
}
struct CombinedNonMaxSuppressionOutput {
  Tensor nmsed_boxes;
  Tensor nmsed_scores;
  Tensor nmsed_classes;
  Tensor valid_detections;
};
inline CombinedNonMaxSuppressionOutput CombinedNonMaxSuppression(const Tensor &boxes, const Tensor &scores, const Tensor &max_output_size_per_class, const Tensor &max_total_size, const Tensor &iou_threshold, const Tensor &score_threshold, bool pad_per_class=false, bool clip_boxes=true) {
  auto out = EsCombinedNonMaxSuppression(boxes.GetEsbTensor(), scores.GetEsbTensor(), max_output_size_per_class.GetEsbTensor(), max_total_size.GetEsbTensor(), iou_threshold.GetEsbTensor(), score_threshold.GetEsbTensor(), pad_per_class, clip_boxes);
  return {out.nmsed_boxes, out.nmsed_scores, out.nmsed_classes, out.valid_detections};
}
inline Tensor CompareAndBitpack(const Tensor &x, const Tensor &threshold) {
  auto out = EsCompareAndBitpack(x.GetEsbTensor(), threshold.GetEsbTensor());
  return out;
}
inline Tensor Complex(const Tensor &real, const Tensor &imag, int64_t Tout=16) {
  auto out = EsComplex(real.GetEsbTensor(), imag.GetEsbTensor(), Tout);
  return out;
}
inline Tensor ComplexAbs(const Tensor &x, ge::DataType Tout=ge::DT_FLOAT) {
  auto out = EsComplexAbs(x.GetEsbTensor(), Tout);
  return out;
}
struct CompressOutput {
  Tensor weight_compress;
  Tensor compress_index;
};
inline CompressOutput Compress(const Tensor &weight, const std::vector<int64_t> &compress_parameters) {
  auto out = EsCompress(weight.GetEsbTensor(), compress_parameters.data(), static_cast<int64_t>(compress_parameters.size()));
  return {out.weight_compress, out.compress_index};
}
struct CompressFcOpOutput {
  Tensor weight_compress;
  Tensor compress_index;
  Tensor compress_info;
};
inline CompressFcOpOutput CompressFcOp(const Tensor &weight, const std::vector<int64_t> &compress_parameters) {
  auto out = EsCompressFcOp(weight.GetEsbTensor(), compress_parameters.data(), static_cast<int64_t>(compress_parameters.size()));
  return {out.weight_compress, out.compress_index, out.compress_info};
}
struct ComputeAccidentalHitsOutput {
  Tensor indices;
  Tensor ids;
  Tensor weights;
};
inline ComputeAccidentalHitsOutput ComputeAccidentalHits(const Tensor &true_classes, const Tensor &sampled_candidates, int64_t num_true, int64_t seed=0, int64_t seed2=0) {
  auto out = EsComputeAccidentalHits(true_classes.GetEsbTensor(), sampled_candidates.GetEsbTensor(), num_true, seed, seed2);
  return {out.indices, out.ids, out.weights};
}
inline Tensor Concat(const Tensor &concat_dim, const std::vector<Tensor> &x, int64_t N=1) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsConcat(concat_dim.GetEsbTensor(), esb_x.data(), static_cast<int64_t>(esb_x.size()), N);
  return out;
}
inline Tensor ConcatD(const std::vector<Tensor> &x, int64_t concat_dim, int64_t N=1) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsConcatD(esb_x.data(), static_cast<int64_t>(esb_x.size()), concat_dim, N);
  return out;
}
inline Tensor ConcatFromSequence(const Tensor &handle, int64_t axis, int64_t new_axis=0) {
  auto out = EsConcatFromSequence(handle.GetEsbTensor(), axis, new_axis);
  return out;
}
inline Tensor ConcatV2(const std::vector<Tensor> &x, const Tensor &concat_dim, int64_t N=1) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsConcatV2(esb_x.data(), static_cast<int64_t>(esb_x.size()), concat_dim.GetEsbTensor(), N);
  return out;
}
inline Tensor ConcatV2D(const std::vector<Tensor> &x, int64_t concat_dim, int64_t N=1) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsConcatV2D(esb_x.data(), static_cast<int64_t>(esb_x.size()), concat_dim, N);
  return out;
}
struct CondTakeOutput {
  Tensor out_data;
  Tensor out_index;
  Tensor valid_num;
};
inline CondTakeOutput CondTake(const Tensor &data, const Tensor &mask, const char *mode, float val, float eps=0.000001) {
  auto out = EsCondTake(data.GetEsbTensor(), mask.GetEsbTensor(), mode, val, eps);
  return {out.out_data, out.out_index, out.valid_num};
}
inline Tensor ConditionCalc(const std::vector<Tensor> &x, const char *cond_func, const std::vector<int64_t> &x_dependency) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsConditionCalc(esb_x.data(), static_cast<int64_t>(esb_x.size()), cond_func, x_dependency.data(), static_cast<int64_t>(x_dependency.size()));
  return out;
}
inline Tensor ConditionalAccumulator(const Graph &owner_graph, ge::DataType dtype, const std::vector<int64_t> &shape, const char *container="", const char *shared_name="", const char *reduction_type="MEAN") {
  auto out = EsConditionalAccumulator(owner_graph.GetEsbGraph(), dtype, shape.data(), static_cast<int64_t>(shape.size()), container, shared_name, reduction_type);
  return out;
}
inline Tensor ConfusionMatrix(const Tensor &labels, const Tensor &predictions, const Tensor &weights, int64_t num_classes, const char *dtype) {
  auto out = EsConfusionMatrix(labels.GetEsbTensor(), predictions.GetEsbTensor(), weights.GetEsbTensor(), num_classes, dtype);
  return out;
}
struct ConfusionMulGradOutput {
  Tensor output0;
  Tensor output1;
};
inline ConfusionMulGradOutput ConfusionMulGrad(const Tensor &input0, const Tensor &input1, const Tensor &input2, const std::vector<int64_t> &axes={}, bool keep_dims=false) {
  auto out = EsConfusionMulGrad(input0.GetEsbTensor(), input1.GetEsbTensor(), input2.GetEsbTensor(), axes.data(), static_cast<int64_t>(axes.size()), keep_dims);
  return {out.output0, out.output1};
}
inline Tensor ConfusionSoftmaxGrad(const Tensor &grad, const Tensor &x) {
  auto out = EsConfusionSoftmaxGrad(grad.GetEsbTensor(), x.GetEsbTensor());
  return out;
}
inline Tensor ConfusionTranspose(const Tensor &x, const Tensor &shape, const std::vector<int64_t> &perm, bool transpose_first) {
  auto out = EsConfusionTranspose(x.GetEsbTensor(), shape.GetEsbTensor(), perm.data(), static_cast<int64_t>(perm.size()), transpose_first);
  return out;
}
inline Tensor ConfusionTransposeD(const Tensor &x, const std::vector<int64_t> &perm, const std::vector<int64_t> &shape, bool transpose_first) {
  auto out = EsConfusionTransposeD(x.GetEsbTensor(), perm.data(), static_cast<int64_t>(perm.size()), shape.data(), static_cast<int64_t>(shape.size()), transpose_first);
  return out;
}
inline Tensor Conj(const Tensor &input) {
  auto out = EsConj(input.GetEsbTensor());
  return out;
}
inline Tensor ConjugateTranspose(const Tensor &x, const Tensor &perm) {
  auto out = EsConjugateTranspose(x.GetEsbTensor(), perm.GetEsbTensor());
  return out;
}
inline Tensor ContinuationIndicator(const Graph &owner_graph, int64_t time_step, int64_t batch_size) {
  auto out = EsContinuationIndicator(owner_graph.GetEsbGraph(), time_step, batch_size);
  return out;
}
inline Tensor ControlTrigger(const Graph &owner_graph) {
  auto out = EsControlTrigger(owner_graph.GetEsbGraph());
  return out;
}
inline Tensor Conv2D(const Tensor &x, const Tensor &filter, const Tensor &bias, const Tensor &offset_w, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const std::vector<int64_t> &dilations={1, 1, 1, 1}, int64_t groups=1, const char *data_format="NHWC", int64_t offset_x=0) {
  auto out = EsConv2D(x.GetEsbTensor(), filter.GetEsbTensor(), bias.GetEsbTensor(), offset_w.GetEsbTensor(), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dilations.data(), static_cast<int64_t>(dilations.size()), groups, data_format, offset_x);
  return out;
}
inline Tensor Conv2DBackpropFilter(const Tensor &x, const Tensor &filter_size, const Tensor &out_backprop, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const std::vector<int64_t> &dilations={1, 1, 1, 1}, int64_t groups=1, const char *data_format="NHWC") {
  auto out = EsConv2DBackpropFilter(x.GetEsbTensor(), filter_size.GetEsbTensor(), out_backprop.GetEsbTensor(), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dilations.data(), static_cast<int64_t>(dilations.size()), groups, data_format);
  return out;
}
inline Tensor Conv2DBackpropFilterD(const Tensor &x, const Tensor &out_backprop, const std::vector<int64_t> &filter_size, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const std::vector<int64_t> &dilations={1, 1, 1, 1}, int64_t groups=1, const char *data_format="NHWC") {
  auto out = EsConv2DBackpropFilterD(x.GetEsbTensor(), out_backprop.GetEsbTensor(), filter_size.data(), static_cast<int64_t>(filter_size.size()), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dilations.data(), static_cast<int64_t>(dilations.size()), groups, data_format);
  return out;
}
inline Tensor Conv2DBackpropFilterV2(const Tensor &x, const Tensor &filter_size, const Tensor &out_backprop, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const std::vector<int64_t> &dilations={1, 1, 1, 1}, int64_t groups=1, const char *data_format="NHWC") {
  auto out = EsConv2DBackpropFilterV2(x.GetEsbTensor(), filter_size.GetEsbTensor(), out_backprop.GetEsbTensor(), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dilations.data(), static_cast<int64_t>(dilations.size()), groups, data_format);
  return out;
}
inline Tensor Conv2DBackpropFilterV3(const Tensor &x, const Tensor &filter_size, const Tensor &out_backprop, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const std::vector<int64_t> &dilations={1, 1, 1, 1}, int64_t groups=1, const char *data_format="NHWC") {
  auto out = EsConv2DBackpropFilterV3(x.GetEsbTensor(), filter_size.GetEsbTensor(), out_backprop.GetEsbTensor(), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dilations.data(), static_cast<int64_t>(dilations.size()), groups, data_format);
  return out;
}
inline Tensor Conv2DBackpropInput(const Tensor &input_size, const Tensor &filter, const Tensor &out_backprop, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const std::vector<int64_t> &dilations={1, 1, 1, 1}, int64_t groups=1, const char *data_format="NHWC") {
  auto out = EsConv2DBackpropInput(input_size.GetEsbTensor(), filter.GetEsbTensor(), out_backprop.GetEsbTensor(), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dilations.data(), static_cast<int64_t>(dilations.size()), groups, data_format);
  return out;
}
inline Tensor Conv2DBackpropInputD(const Tensor &filter, const Tensor &out_backprop, const std::vector<int64_t> &input_size, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const std::vector<int64_t> &dilations={1, 1, 1, 1}, int64_t groups=1, const char *data_format="NHWC") {
  auto out = EsConv2DBackpropInputD(filter.GetEsbTensor(), out_backprop.GetEsbTensor(), input_size.data(), static_cast<int64_t>(input_size.size()), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dilations.data(), static_cast<int64_t>(dilations.size()), groups, data_format);
  return out;
}
inline Tensor Conv2DBackpropInputV2(const Tensor &input_size, const Tensor &filter, const Tensor &out_backprop, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const std::vector<int64_t> &dilations={1, 1, 1, 1}, int64_t groups=1, const char *data_format="NHWC") {
  auto out = EsConv2DBackpropInputV2(input_size.GetEsbTensor(), filter.GetEsbTensor(), out_backprop.GetEsbTensor(), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dilations.data(), static_cast<int64_t>(dilations.size()), groups, data_format);
  return out;
}
inline Tensor Conv2DCompress(const Tensor &x, const Tensor &filter_compress, const Tensor &compress_index, const Tensor &bias, const Tensor &offset_w, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const std::vector<int64_t> &dilations={1, 1, 1, 1}, int64_t groups=1, const char *data_format="NHWC", int64_t offset_x=0, const char *alg="weight_unzip") {
  auto out = EsConv2DCompress(x.GetEsbTensor(), filter_compress.GetEsbTensor(), compress_index.GetEsbTensor(), bias.GetEsbTensor(), offset_w.GetEsbTensor(), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dilations.data(), static_cast<int64_t>(dilations.size()), groups, data_format, offset_x, alg);
  return out;
}
inline Tensor Conv2DTranspose(const Tensor &input_size, const Tensor &x, const Tensor &filter, const Tensor &bias, const Tensor &offset_w, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const std::vector<int64_t> &dilations={1, 1, 1, 1}, int64_t groups=1, const char *data_format="NHWC", const std::vector<int64_t> &output_padding={0, 0, 0, 0}, int64_t offset_x=0) {
  auto out = EsConv2DTranspose(input_size.GetEsbTensor(), x.GetEsbTensor(), filter.GetEsbTensor(), bias.GetEsbTensor(), offset_w.GetEsbTensor(), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dilations.data(), static_cast<int64_t>(dilations.size()), groups, data_format, output_padding.data(), static_cast<int64_t>(output_padding.size()), offset_x);
  return out;
}
inline Tensor Conv2DTransposeD(const Tensor &x, const Tensor &filter, const Tensor &bias, const Tensor &offset_w, const std::vector<int64_t> &input_size, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const std::vector<int64_t> &dilations={1, 1, 1, 1}, int64_t groups=1, const char *data_format="NHWC", const std::vector<int64_t> &output_padding={0, 0, 0, 0}, int64_t offset_x=0) {
  auto out = EsConv2DTransposeD(x.GetEsbTensor(), filter.GetEsbTensor(), bias.GetEsbTensor(), offset_w.GetEsbTensor(), input_size.data(), static_cast<int64_t>(input_size.size()), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dilations.data(), static_cast<int64_t>(dilations.size()), groups, data_format, output_padding.data(), static_cast<int64_t>(output_padding.size()), offset_x);
  return out;
}
inline Tensor Conv2DTransposeDCompress(const Tensor &x, const Tensor &filter_compress, const Tensor &compress_index, const Tensor &bias, const Tensor &offset_w, const std::vector<int64_t> &input_size, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const std::vector<int64_t> &dilations={1, 1, 1, 1}, int64_t groups=1, const char *data_format="NHWC", const std::vector<int64_t> &output_padding={0, 0, 0, 0}, int64_t offset_x=0, const char *alg="weight_sparse_4_2") {
  auto out = EsConv2DTransposeDCompress(x.GetEsbTensor(), filter_compress.GetEsbTensor(), compress_index.GetEsbTensor(), bias.GetEsbTensor(), offset_w.GetEsbTensor(), input_size.data(), static_cast<int64_t>(input_size.size()), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dilations.data(), static_cast<int64_t>(dilations.size()), groups, data_format, output_padding.data(), static_cast<int64_t>(output_padding.size()), offset_x, alg);
  return out;
}
inline Tensor Conv2DTransposeV2(const Tensor &input_size, const Tensor &x, const Tensor &filter, const Tensor &bias, const Tensor &offset_w, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const std::vector<int64_t> &dilations={1, 1, 1, 1}, int64_t groups=1, const char *data_format="NHWC", const std::vector<int64_t> &output_padding={0, 0, 0, 0}, int64_t offset_x=0) {
  auto out = EsConv2DTransposeV2(input_size.GetEsbTensor(), x.GetEsbTensor(), filter.GetEsbTensor(), bias.GetEsbTensor(), offset_w.GetEsbTensor(), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dilations.data(), static_cast<int64_t>(dilations.size()), groups, data_format, output_padding.data(), static_cast<int64_t>(output_padding.size()), offset_x);
  return out;
}
inline Tensor Conv3D(const Tensor &x, const Tensor &filter, const Tensor &bias, const Tensor &offset_w, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const std::vector<int64_t> &dilations={1, 1, 1, 1, 1}, int64_t groups=1, const char *data_format="NDHWC", int64_t offset_x=0) {
  auto out = EsConv3D(x.GetEsbTensor(), filter.GetEsbTensor(), bias.GetEsbTensor(), offset_w.GetEsbTensor(), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dilations.data(), static_cast<int64_t>(dilations.size()), groups, data_format, offset_x);
  return out;
}
inline Tensor Conv3DBackpropFilter(const Tensor &x, const Tensor &filter_size, const Tensor &out_backprop, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const std::vector<int64_t> &dilations={1, 1, 1, 1, 1}, int64_t groups=1, const char *data_format="NDHWC") {
  auto out = EsConv3DBackpropFilter(x.GetEsbTensor(), filter_size.GetEsbTensor(), out_backprop.GetEsbTensor(), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dilations.data(), static_cast<int64_t>(dilations.size()), groups, data_format);
  return out;
}
inline Tensor Conv3DBackpropFilterD(const Tensor &x, const Tensor &out_backprop, const std::vector<int64_t> &filter_size, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const std::vector<int64_t> &dilations={1, 1, 1, 1, 1}, int64_t groups=1, const char *data_format="NDHWC") {
  auto out = EsConv3DBackpropFilterD(x.GetEsbTensor(), out_backprop.GetEsbTensor(), filter_size.data(), static_cast<int64_t>(filter_size.size()), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dilations.data(), static_cast<int64_t>(dilations.size()), groups, data_format);
  return out;
}
inline Tensor Conv3DBackpropFilterV2(const Tensor &x, const Tensor &filter_size, const Tensor &out_backprop, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const std::vector<int64_t> &dilations={1, 1, 1, 1, 1}, int64_t groups=1, const char *data_format="NDHWC") {
  auto out = EsConv3DBackpropFilterV2(x.GetEsbTensor(), filter_size.GetEsbTensor(), out_backprop.GetEsbTensor(), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dilations.data(), static_cast<int64_t>(dilations.size()), groups, data_format);
  return out;
}
inline Tensor Conv3DBackpropInput(const Tensor &input_size, const Tensor &filter, const Tensor &out_backprop, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const std::vector<int64_t> &dilations={1, 1, 1, 1, 1}, int64_t groups=1, const char *data_format="NDHWC") {
  auto out = EsConv3DBackpropInput(input_size.GetEsbTensor(), filter.GetEsbTensor(), out_backprop.GetEsbTensor(), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dilations.data(), static_cast<int64_t>(dilations.size()), groups, data_format);
  return out;
}
inline Tensor Conv3DBackpropInputD(const Tensor &filter, const Tensor &out_backprop, const std::vector<int64_t> &input_size, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const std::vector<int64_t> &dilations={1, 1, 1, 1, 1}, int64_t groups=1, const char *data_format="NDHWC") {
  auto out = EsConv3DBackpropInputD(filter.GetEsbTensor(), out_backprop.GetEsbTensor(), input_size.data(), static_cast<int64_t>(input_size.size()), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dilations.data(), static_cast<int64_t>(dilations.size()), groups, data_format);
  return out;
}
inline Tensor Conv3DBackpropInputV2(const Tensor &input_size, const Tensor &filter, const Tensor &out_backprop, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const std::vector<int64_t> &dilations={1, 1, 1, 1, 1}, int64_t groups=1, const char *data_format="NDHWC") {
  auto out = EsConv3DBackpropInputV2(input_size.GetEsbTensor(), filter.GetEsbTensor(), out_backprop.GetEsbTensor(), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dilations.data(), static_cast<int64_t>(dilations.size()), groups, data_format);
  return out;
}
inline Tensor Conv3DTranspose(const Tensor &input_size, const Tensor &x, const Tensor &filter, const Tensor &bias, const Tensor &offset_w, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const std::vector<int64_t> &dilations={1, 1, 1, 1, 1}, int64_t groups=1, const char *data_format="NDHWC", const std::vector<int64_t> &output_padding={0, 0, 0, 0, 0}, int64_t offset_x=0) {
  auto out = EsConv3DTranspose(input_size.GetEsbTensor(), x.GetEsbTensor(), filter.GetEsbTensor(), bias.GetEsbTensor(), offset_w.GetEsbTensor(), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dilations.data(), static_cast<int64_t>(dilations.size()), groups, data_format, output_padding.data(), static_cast<int64_t>(output_padding.size()), offset_x);
  return out;
}
inline Tensor Conv3DTransposeD(const Tensor &x, const Tensor &filter, const Tensor &bias, const Tensor &offset_w, const std::vector<int64_t> &input_size, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const std::vector<int64_t> &dilations={1, 1, 1, 1, 1}, int64_t groups=1, const char *data_format="NDHWC", const std::vector<int64_t> &output_padding={0, 0, 0, 0, 0}, int64_t offset_x=0) {
  auto out = EsConv3DTransposeD(x.GetEsbTensor(), filter.GetEsbTensor(), bias.GetEsbTensor(), offset_w.GetEsbTensor(), input_size.data(), static_cast<int64_t>(input_size.size()), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dilations.data(), static_cast<int64_t>(dilations.size()), groups, data_format, output_padding.data(), static_cast<int64_t>(output_padding.size()), offset_x);
  return out;
}
inline Tensor Conv3DTransposeV2(const Tensor &input_size, const Tensor &x, const Tensor &filter, const Tensor &bias, const Tensor &offset_w, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const std::vector<int64_t> &dilations={1, 1, 1, 1, 1}, int64_t groups=1, const char *data_format="NDHWC", const std::vector<int64_t> &output_padding={0, 0, 0, 0, 0}, int64_t offset_x=0) {
  auto out = EsConv3DTransposeV2(input_size.GetEsbTensor(), x.GetEsbTensor(), filter.GetEsbTensor(), bias.GetEsbTensor(), offset_w.GetEsbTensor(), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dilations.data(), static_cast<int64_t>(dilations.size()), groups, data_format, output_padding.data(), static_cast<int64_t>(output_padding.size()), offset_x);
  return out;
}
inline Tensor Conv3DV2(const Tensor &x, const Tensor &filter, const Tensor &bias, const Tensor &offset_w, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const std::vector<int64_t> &dilations={1, 1, 1, 1, 1}, int64_t groups=1, const char *data_format="NCDHW", int64_t offset_x=0) {
  auto out = EsConv3DV2(x.GetEsbTensor(), filter.GetEsbTensor(), bias.GetEsbTensor(), offset_w.GetEsbTensor(), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dilations.data(), static_cast<int64_t>(dilations.size()), groups, data_format, offset_x);
  return out;
}
struct Coordinates1DTo2DOutput {
  Tensor row;
  Tensor col;
  Tensor n;
};
inline Coordinates1DTo2DOutput Coordinates1DTo2D(const Tensor &x, const Tensor &shape) {
  auto out = EsCoordinates1DTo2D(x.GetEsbTensor(), shape.GetEsbTensor());
  return {out.row, out.col, out.n};
}
inline Tensor CorrectBBox(const Tensor &x, const Tensor &grid, const Tensor &anchor_grid, int64_t stride, const char *yolo_version) {
  auto out = EsCorrectBBox(x.GetEsbTensor(), grid.GetEsbTensor(), anchor_grid.GetEsbTensor(), stride, yolo_version);
  return out;
}
inline Tensor Correlation(const Tensor &filter, const Tensor &x, int64_t groups=1) {
  auto out = EsCorrelation(filter.GetEsbTensor(), x.GetEsbTensor(), groups);
  return out;
}
inline Tensor Cos(const Tensor &x) {
  auto out = EsCos(x.GetEsbTensor());
  return out;
}
inline Tensor Cosh(const Tensor &x) {
  auto out = EsCosh(x.GetEsbTensor());
  return out;
}
inline Tensor CosineEmbeddingLoss(const Tensor &x1, const Tensor &x2, const Tensor &target, float margin=0.000000, const char *reduction="mean") {
  auto out = EsCosineEmbeddingLoss(x1.GetEsbTensor(), x2.GetEsbTensor(), target.GetEsbTensor(), margin, reduction);
  return out;
}
inline Tensor CosineSimilarity(const Tensor &input_x1, const Tensor &input_x2, int64_t dim=1, float eps=0.000000) {
  auto out = EsCosineSimilarity(input_x1.GetEsbTensor(), input_x2.GetEsbTensor(), dim, eps);
  return out;
}
inline Tensor CountUpTo(const Tensor &ref, int64_t limit=0) {
  auto out = EsCountUpTo(ref.GetEsbTensor(), limit);
  return out;
}
inline Tensor Crop(const Tensor &x, const Tensor &size, const std::vector<int64_t> &offsets, int64_t axis=2) {
  auto out = EsCrop(x.GetEsbTensor(), size.GetEsbTensor(), offsets.data(), static_cast<int64_t>(offsets.size()), axis);
  return out;
}
inline Tensor CropAndResize(const Tensor &x, const Tensor &boxes, const Tensor &box_index, const Tensor &crop_size, float extrapolation_value=0.000000, const char *method="bilinear") {
  auto out = EsCropAndResize(x.GetEsbTensor(), boxes.GetEsbTensor(), box_index.GetEsbTensor(), crop_size.GetEsbTensor(), extrapolation_value, method);
  return out;
}
inline Tensor CropAndResizeD(const Tensor &x, const Tensor &boxes, const Tensor &box_index, const std::vector<int64_t> &crop_size, float extrapolation_value=0.000000, const char *method="bilinear") {
  auto out = EsCropAndResizeD(x.GetEsbTensor(), boxes.GetEsbTensor(), box_index.GetEsbTensor(), crop_size.data(), static_cast<int64_t>(crop_size.size()), extrapolation_value, method);
  return out;
}
inline Tensor CropAndResizeGradBoxes(const Tensor &grads, const Tensor &images, const Tensor &boxes, const Tensor &box_index, const char *method="bilinear") {
  auto out = EsCropAndResizeGradBoxes(grads.GetEsbTensor(), images.GetEsbTensor(), boxes.GetEsbTensor(), box_index.GetEsbTensor(), method);
  return out;
}
inline Tensor CropAndResizeGradImage(const Tensor &grads, const Tensor &boxes, const Tensor &box_index, const Tensor &image_size, ge::DataType T, const char *method="bilinear") {
  auto out = EsCropAndResizeGradImage(grads.GetEsbTensor(), boxes.GetEsbTensor(), box_index.GetEsbTensor(), image_size.GetEsbTensor(), T, method);
  return out;
}
inline Tensor CropAndResizeV2(const Tensor &x, const Tensor &boxes, const Tensor &box_index, const Tensor &crop_size, float extrapolation_value=0.000000, const char *method="bilinear", ge::DataType dtype=ge::DT_FLOAT) {
  auto out = EsCropAndResizeV2(x.GetEsbTensor(), boxes.GetEsbTensor(), box_index.GetEsbTensor(), crop_size.GetEsbTensor(), extrapolation_value, method, dtype);
  return out;
}
inline Tensor Cross(const Tensor &x1, const Tensor &x2, int64_t dim=-65530) {
  auto out = EsCross(x1.GetEsbTensor(), x2.GetEsbTensor(), dim);
  return out;
}
struct CummaxOutput {
  Tensor y;
  Tensor indices;
};
inline CummaxOutput Cummax(const Tensor &x, int64_t dim) {
  auto out = EsCummax(x.GetEsbTensor(), dim);
  return {out.y, out.indices};
}
struct CumminOutput {
  Tensor y;
  Tensor indices;
};
inline CumminOutput Cummin(const Tensor &x, int64_t axis) {
  auto out = EsCummin(x.GetEsbTensor(), axis);
  return {out.y, out.indices};
}
inline Tensor Cumprod(const Tensor &x, const Tensor &axis, bool exclusive=false, bool reverse=false) {
  auto out = EsCumprod(x.GetEsbTensor(), axis.GetEsbTensor(), exclusive, reverse);
  return out;
}
inline Tensor CumprodD(const Tensor &x, int64_t axis, bool exclusive=false, bool reverse=false) {
  auto out = EsCumprodD(x.GetEsbTensor(), axis, exclusive, reverse);
  return out;
}
inline Tensor Cumsum(const Tensor &x, const Tensor &axis, bool exclusive=false, bool reverse=false) {
  auto out = EsCumsum(x.GetEsbTensor(), axis.GetEsbTensor(), exclusive, reverse);
  return out;
}
inline Tensor CumsumD(const Tensor &x, int64_t axis, bool exclusive=false, bool reverse=false) {
  auto out = EsCumsumD(x.GetEsbTensor(), axis, exclusive, reverse);
  return out;
}
inline Tensor CumulativeLogsumexp(const Tensor &x, const Tensor &axis, bool exclusive=false, bool reverse=false) {
  auto out = EsCumulativeLogsumexp(x.GetEsbTensor(), axis.GetEsbTensor(), exclusive, reverse);
  return out;
}
inline Tensor CumulativeLogsumexpD(const Tensor &x, int64_t axis, bool exclusive=false, bool reverse=false) {
  auto out = EsCumulativeLogsumexpD(x.GetEsbTensor(), axis, exclusive, reverse);
  return out;
}
inline Tensor DIoU(const Tensor &bboxes, const Tensor &gtboxes, bool trans=false, bool is_cross=true, const char *mode="iou") {
  auto out = EsDIoU(bboxes.GetEsbTensor(), gtboxes.GetEsbTensor(), trans, is_cross, mode);
  return out;
}
struct DIoUGradOutput {
  Tensor dbboxes;
  Tensor dgtboxes;
};
inline DIoUGradOutput DIoUGrad(const Tensor &dy, const Tensor &bboxes, const Tensor &gtboxes, bool trans=false, bool is_cross=true, const char *mode="iou") {
  auto out = EsDIoUGrad(dy.GetEsbTensor(), bboxes.GetEsbTensor(), gtboxes.GetEsbTensor(), trans, is_cross, mode);
  return {out.dbboxes, out.dgtboxes};
}
inline Tensor DSAGenBitMask(const Tensor &count, const Tensor &seed, const Tensor &dropout, const char *random_algorithm="Philox", const char *output_dtype="uint8") {
  auto out = EsDSAGenBitMask(count.GetEsbTensor(), seed.GetEsbTensor(), dropout.GetEsbTensor(), random_algorithm, output_dtype);
  return out;
}
inline Tensor DSARandomNormal(const Tensor &count, const Tensor &seed, const Tensor &mean, const Tensor &stdev, const char *random_algorithm="Philox") {
  auto out = EsDSARandomNormal(count.GetEsbTensor(), seed.GetEsbTensor(), mean.GetEsbTensor(), stdev.GetEsbTensor(), random_algorithm);
  return out;
}
inline Tensor DSARandomTruncatedNormal(const Tensor &count, const Tensor &seed, const Tensor &mean, const Tensor &stdev, const char *random_algorithm="Philox") {
  auto out = EsDSARandomTruncatedNormal(count.GetEsbTensor(), seed.GetEsbTensor(), mean.GetEsbTensor(), stdev.GetEsbTensor(), random_algorithm);
  return out;
}
inline Tensor DSARandomUniform(const Tensor &count, const Tensor &seed, const Tensor &low, const Tensor &high, const char *random_algorithm="Philox") {
  auto out = EsDSARandomUniform(count.GetEsbTensor(), seed.GetEsbTensor(), low.GetEsbTensor(), high.GetEsbTensor(), random_algorithm);
  return out;
}
inline Tensor DSAStatelessGenBitMask(const Tensor &count, const Tensor &seed, const Tensor &dropout, const Tensor &offset, const char *random_algorithm="Philox", const char *output_dtype="uint8") {
  auto out = EsDSAStatelessGenBitMask(count.GetEsbTensor(), seed.GetEsbTensor(), dropout.GetEsbTensor(), offset.GetEsbTensor(), random_algorithm, output_dtype);
  return out;
}
inline Tensor DSAStatelessRandomNormal(const Tensor &count, const Tensor &seed, const Tensor &mean, const Tensor &stdev, const Tensor &counter, const char *random_algorithm="Philox") {
  auto out = EsDSAStatelessRandomNormal(count.GetEsbTensor(), seed.GetEsbTensor(), mean.GetEsbTensor(), stdev.GetEsbTensor(), counter.GetEsbTensor(), random_algorithm);
  return out;
}
inline Tensor DSAStatelessRandomTruncatedNormal(const Tensor &count, const Tensor &seed, const Tensor &mean, const Tensor &stdev, const Tensor &counter, const char *random_algorithm="Philox") {
  auto out = EsDSAStatelessRandomTruncatedNormal(count.GetEsbTensor(), seed.GetEsbTensor(), mean.GetEsbTensor(), stdev.GetEsbTensor(), counter.GetEsbTensor(), random_algorithm);
  return out;
}
inline Tensor DSAStatelessRandomUniform(const Tensor &count, const Tensor &seed, const Tensor &low, const Tensor &high, const Tensor &counter, const char *random_algorithm="Philox") {
  auto out = EsDSAStatelessRandomUniform(count.GetEsbTensor(), seed.GetEsbTensor(), low.GetEsbTensor(), high.GetEsbTensor(), counter.GetEsbTensor(), random_algorithm);
  return out;
}
inline Tensor DataCompare(const Tensor &x1, const Tensor &x2, float atol=0.000010, float rtol=0.001000) {
  auto out = EsDataCompare(x1.GetEsbTensor(), x2.GetEsbTensor(), atol, rtol);
  return out;
}
inline Tensor DataFormatDimMap(const Tensor &x, const char *src_format="NHWC", const char *dst_format="NCHW") {
  auto out = EsDataFormatDimMap(x.GetEsbTensor(), src_format, dst_format);
  return out;
}
inline Tensor DataFormatVecPermute(const Tensor &x, const char *src_format="NHWC", const char *dst_format="NCHW") {
  auto out = EsDataFormatVecPermute(x.GetEsbTensor(), src_format, dst_format);
  return out;
}
inline Tensor Dawsn(const Tensor &x) {
  auto out = EsDawsn(x.GetEsbTensor());
  return out;
}
inline Tensor DecodeAndCropJpeg(const Tensor &contents, const Tensor &crop_window, int64_t channels=0, int64_t ratio=1, bool fancy_upscaling=true, bool try_recover_truncated=false, float acceptable_fraction=1.000000, const char *dct_method="", const char *dst_img_format="HWC") {
  auto out = EsDecodeAndCropJpeg(contents.GetEsbTensor(), crop_window.GetEsbTensor(), channels, ratio, fancy_upscaling, try_recover_truncated, acceptable_fraction, dct_method, dst_img_format);
  return out;
}
inline Tensor DecodeBase64(const Tensor &x) {
  auto out = EsDecodeBase64(x.GetEsbTensor());
  return out;
}
inline Tensor DecodeBbox(const Tensor &box_predictions, const Tensor &anchors, float decode_clip) {
  auto out = EsDecodeBbox(box_predictions.GetEsbTensor(), anchors.GetEsbTensor(), decode_clip);
  return out;
}
inline Tensor DecodeBboxV2(const Tensor &boxes, const Tensor &anchors, const std::vector<float> &scales={1.000000, 1.000000, 1.000000, 1.000000}, float decode_clip=0.000000, bool reversed_box=false) {
  auto out = EsDecodeBboxV2(boxes.GetEsbTensor(), anchors.GetEsbTensor(), scales.data(), static_cast<int64_t>(scales.size()), decode_clip, reversed_box);
  return out;
}
inline Tensor DecodeBmp(const Tensor &contents, int64_t channels=0) {
  auto out = EsDecodeBmp(contents.GetEsbTensor(), channels);
  return out;
}
inline Tensor DecodeBoundariesTarget(const Tensor &boundary_predictions, const Tensor &anchors) {
  auto out = EsDecodeBoundariesTarget(boundary_predictions.GetEsbTensor(), anchors.GetEsbTensor());
  return out;
}
inline Tensor DecodeCornerpointsTargetBG(const Tensor &keypoints_prediction, const Tensor &anchors) {
  auto out = EsDecodeCornerpointsTargetBG(keypoints_prediction.GetEsbTensor(), anchors.GetEsbTensor());
  return out;
}
inline Tensor DecodeCornerpointsTargetWrtCenterV1(const Tensor &keypoints_prediction, const Tensor &anchors) {
  auto out = EsDecodeCornerpointsTargetWrtCenterV1(keypoints_prediction.GetEsbTensor(), anchors.GetEsbTensor());
  return out;
}
inline Tensor DecodeGif(const Tensor &contents) {
  auto out = EsDecodeGif(contents.GetEsbTensor());
  return out;
}
inline Tensor DecodeImage(const Tensor &contents, int64_t channels=0, ge::DataType dtype=ge::DT_UINT8, bool expand_animations=true) {
  auto out = EsDecodeImage(contents.GetEsbTensor(), channels, dtype, expand_animations);
  return out;
}
inline Tensor DecodeJpeg(const Tensor &contents, int64_t channels=0, int64_t ratio=1, bool fancy_upscaling=true, bool try_recover_truncated=false, float acceptable_fraction=1.000000, const char *dct_method="", const char *dst_img_format="HWC") {
  auto out = EsDecodeJpeg(contents.GetEsbTensor(), channels, ratio, fancy_upscaling, try_recover_truncated, acceptable_fraction, dct_method, dst_img_format);
  return out;
}
inline Tensor DecodeJpegPre(const Tensor &contents, const std::vector<int64_t> &w_range, const std::vector<int64_t> &h_range) {
  auto out = EsDecodeJpegPre(contents.GetEsbTensor(), w_range.data(), static_cast<int64_t>(w_range.size()), h_range.data(), static_cast<int64_t>(h_range.size()));
  return out;
}
inline Tensor DecodePng(const Tensor &contents, ge::DataType dtype=ge::DT_UINT8, int64_t channels=0) {
  auto out = EsDecodePng(contents.GetEsbTensor(), dtype, channels);
  return out;
}
inline Tensor DecodeRaw(const Tensor &bytes, ge::DataType out_type=ge::DT_FLOAT, bool little_endian=true) {
  auto out = EsDecodeRaw(bytes.GetEsbTensor(), out_type, little_endian);
  return out;
}
struct DecodeWavOutput {
  Tensor audio;
  Tensor sample_rate;
};
inline DecodeWavOutput DecodeWav(const Tensor &contents, int64_t desired_channels=-1, int64_t desired_samples=-1) {
  auto out = EsDecodeWav(contents.GetEsbTensor(), desired_channels, desired_samples);
  return {out.audio, out.sample_rate};
}
inline Tensor DecodeWheelsTarget(const Tensor &boundary_predictions, const Tensor &anchors) {
  auto out = EsDecodeWheelsTarget(boundary_predictions.GetEsbTensor(), anchors.GetEsbTensor());
  return out;
}
inline Tensor Deconvolution(const Tensor &x, const Tensor &filter, const Tensor &bias=nullptr, const Tensor &offset_w=nullptr, const std::vector<int64_t> &strides={1, 1}, const std::vector<int64_t> &pads={0, 0, 0, 0}, const std::vector<int64_t> &dilations={1, 1, 1, 1}, int64_t groups=1, const char *data_format="NCHW", int64_t offset_x=0) {
  auto out = EsDeconvolution(x.GetEsbTensor(), filter.GetEsbTensor(), bias.GetEsbTensor(), offset_w.GetEsbTensor(), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dilations.data(), static_cast<int64_t>(dilations.size()), groups, data_format, offset_x);
  return out;
}
struct DeepNormOutput {
  Tensor mean;
  Tensor rstd;
  Tensor y;
};
inline DeepNormOutput DeepNorm(const Tensor &x, const Tensor &gx, const Tensor &beta, const Tensor &gamma, float alpha=0.300000, float epsilon=0.000001) {
  auto out = EsDeepNorm(x.GetEsbTensor(), gx.GetEsbTensor(), beta.GetEsbTensor(), gamma.GetEsbTensor(), alpha, epsilon);
  return {out.mean, out.rstd, out.y};
}
struct DeepNormGradOutput {
  Tensor dx;
  Tensor dgx;
  Tensor dbeta;
  Tensor dgamma;
};
inline DeepNormGradOutput DeepNormGrad(const Tensor &dy, const Tensor &x, const Tensor &gx, const Tensor &gamma, const Tensor &mean, const Tensor &rstd, float alpha=0.300000) {
  auto out = EsDeepNormGrad(dy.GetEsbTensor(), x.GetEsbTensor(), gx.GetEsbTensor(), gamma.GetEsbTensor(), mean.GetEsbTensor(), rstd.GetEsbTensor(), alpha);
  return {out.dx, out.dgx, out.dbeta, out.dgamma};
}
inline Tensor DeformableConv2D(const Tensor &x, const Tensor &filter, const Tensor &offsets, const Tensor &bias, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const std::vector<int64_t> &dilations={1, 1, 1, 1}, int64_t groups=1, const char *data_format="NHWC", int64_t deformable_groups=1, bool modulated=true) {
  auto out = EsDeformableConv2D(x.GetEsbTensor(), filter.GetEsbTensor(), offsets.GetEsbTensor(), bias.GetEsbTensor(), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dilations.data(), static_cast<int64_t>(dilations.size()), groups, data_format, deformable_groups, modulated);
  return out;
}
inline Tensor DeformableOffsets(const Tensor &x, const Tensor &offsets, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const std::vector<int64_t> &ksize, const std::vector<int64_t> &dilations={1, 1, 1, 1}, const char *data_format="NCHW", int64_t deformable_groups=1, bool modulated=true) {
  auto out = EsDeformableOffsets(x.GetEsbTensor(), offsets.GetEsbTensor(), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), ksize.data(), static_cast<int64_t>(ksize.size()), dilations.data(), static_cast<int64_t>(dilations.size()), data_format, deformable_groups, modulated);
  return out;
}
struct DeformableOffsetsGradOutput {
  Tensor grad_x;
  Tensor grad_offsets;
};
inline DeformableOffsetsGradOutput DeformableOffsetsGrad(const Tensor &grad, const Tensor &x, const Tensor &offsets, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const std::vector<int64_t> &ksize, const std::vector<int64_t> &dilations={1, 1, 1, 1}, const char *data_format="NCHW", int64_t deformable_groups=1, bool modulated=true) {
  auto out = EsDeformableOffsetsGrad(grad.GetEsbTensor(), x.GetEsbTensor(), offsets.GetEsbTensor(), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), ksize.data(), static_cast<int64_t>(ksize.size()), dilations.data(), static_cast<int64_t>(dilations.size()), data_format, deformable_groups, modulated);
  return {out.grad_x, out.grad_offsets};
}
inline Tensor DeformableRoiPool(const Tensor &x, const Tensor &rois, const Tensor &offset, const std::vector<int64_t> &output_size, float spatial_scale=1.000000, int64_t sampling_ratio=0, float gamma=0.100000) {
  auto out = EsDeformableRoiPool(x.GetEsbTensor(), rois.GetEsbTensor(), offset.GetEsbTensor(), output_size.data(), static_cast<int64_t>(output_size.size()), spatial_scale, sampling_ratio, gamma);
  return out;
}
struct DeformableRoiPoolGradOutput {
  Tensor grad_x;
  Tensor grad_offset;
};
inline DeformableRoiPoolGradOutput DeformableRoiPoolGrad(const Tensor &grad, const Tensor &x, const Tensor &rois, const Tensor &offset, const std::vector<int64_t> &output_size, float spatial_scale=1.000000, int64_t sampling_ratio=0, float gamma=0.100000) {
  auto out = EsDeformableRoiPoolGrad(grad.GetEsbTensor(), x.GetEsbTensor(), rois.GetEsbTensor(), offset.GetEsbTensor(), output_size.data(), static_cast<int64_t>(output_size.size()), spatial_scale, sampling_ratio, gamma);
  return {out.grad_x, out.grad_offset};
}
inline Tensor DeinitEmbeddingHashmapV2(const Tensor &table_id) {
  auto out = EsDeinitEmbeddingHashmapV2(table_id.GetEsbTensor());
  return out;
}
inline Tensor DeleteSeedGenerator(const Tensor &handle, const Tensor &deleter) {
  auto out = EsDeleteSeedGenerator(handle.GetEsbTensor(), deleter.GetEsbTensor());
  return out;
}
inline Tensor DenseBincount(const Tensor &input, const Tensor &size, const Tensor &weights, bool binary_output=false) {
  auto out = EsDenseBincount(input.GetEsbTensor(), size.GetEsbTensor(), weights.GetEsbTensor(), binary_output);
  return out;
}
struct DenseCountSparseOutputOutput {
  Tensor output_indices;
  Tensor output_values;
  Tensor output_dense_shape;
};
inline DenseCountSparseOutputOutput DenseCountSparseOutput(const Tensor &values, const Tensor &weights, bool binary_output, int64_t minlength=-1, int64_t maxlength=-1) {
  auto out = EsDenseCountSparseOutput(values.GetEsbTensor(), weights.GetEsbTensor(), binary_output, minlength, maxlength);
  return {out.output_indices, out.output_values, out.output_dense_shape};
}
inline Tensor DenseImageWarp(const Tensor &image, const Tensor &flow) {
  auto out = EsDenseImageWarp(image.GetEsbTensor(), flow.GetEsbTensor());
  return out;
}
struct DenseImageWarpGradOutput {
  Tensor grad_image;
  Tensor grad_flow;
};
inline DenseImageWarpGradOutput DenseImageWarpGrad(const Tensor &grad, const Tensor &image, const Tensor &flow) {
  auto out = EsDenseImageWarpGrad(grad.GetEsbTensor(), image.GetEsbTensor(), flow.GetEsbTensor());
  return {out.grad_image, out.grad_flow};
}
struct DenseToDenseSetOperationOutput {
  Tensor y_indices;
  Tensor y_values;
  Tensor y_shape;
};
inline DenseToDenseSetOperationOutput DenseToDenseSetOperation(const Tensor &x1, const Tensor &x2, const char *set_operation="", bool validate_indices=true) {
  auto out = EsDenseToDenseSetOperation(x1.GetEsbTensor(), x2.GetEsbTensor(), set_operation, validate_indices);
  return {out.y_indices, out.y_values, out.y_shape};
}
struct DenseToSparseSetOperationOutput {
  Tensor y_indices;
  Tensor y_values;
  Tensor y_shape;
};
inline DenseToSparseSetOperationOutput DenseToSparseSetOperation(const Tensor &x1, const Tensor &x2_indices, const Tensor &x2_values, const Tensor &x2_shape, const char *set_operation="", bool validate_indices=true) {
  auto out = EsDenseToSparseSetOperation(x1.GetEsbTensor(), x2_indices.GetEsbTensor(), x2_values.GetEsbTensor(), x2_shape.GetEsbTensor(), set_operation, validate_indices);
  return {out.y_indices, out.y_values, out.y_shape};
}
inline Tensor DepthToSpace(const Tensor &x, int64_t block_size, const char *mode="DCR", const char *data_format="NHWC") {
  auto out = EsDepthToSpace(x.GetEsbTensor(), block_size, mode, data_format);
  return out;
}
inline Tensor DepthwiseConv2D(const Tensor &x, const Tensor &filter, const Tensor &bias, const Tensor &offset_w, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const std::vector<int64_t> &dilations={1, 1, 1, 1}, const char *data_format="NHWC", int64_t offset_x=0) {
  auto out = EsDepthwiseConv2D(x.GetEsbTensor(), filter.GetEsbTensor(), bias.GetEsbTensor(), offset_w.GetEsbTensor(), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dilations.data(), static_cast<int64_t>(dilations.size()), data_format, offset_x);
  return out;
}
inline Tensor DepthwiseConv2DBackpropFilter(const Tensor &input, const Tensor &filter_size, const Tensor &out_backprop, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const std::vector<int64_t> &dilations={1, 1, 1, 1}, const char *data_format="NHWC") {
  auto out = EsDepthwiseConv2DBackpropFilter(input.GetEsbTensor(), filter_size.GetEsbTensor(), out_backprop.GetEsbTensor(), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dilations.data(), static_cast<int64_t>(dilations.size()), data_format);
  return out;
}
inline Tensor DepthwiseConv2DBackpropFilterD(const Tensor &input, const Tensor &out_backprop, const std::vector<int64_t> &filter_size, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const std::vector<int64_t> &dilations={1, 1, 1, 1}, const char *data_format="NHWC") {
  auto out = EsDepthwiseConv2DBackpropFilterD(input.GetEsbTensor(), out_backprop.GetEsbTensor(), filter_size.data(), static_cast<int64_t>(filter_size.size()), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dilations.data(), static_cast<int64_t>(dilations.size()), data_format);
  return out;
}
inline Tensor DepthwiseConv2DBackpropInput(const Tensor &input_size, const Tensor &filter, const Tensor &out_backprop, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const std::vector<int64_t> &dilations={1, 1, 1, 1}, const char *data_format="NHWC") {
  auto out = EsDepthwiseConv2DBackpropInput(input_size.GetEsbTensor(), filter.GetEsbTensor(), out_backprop.GetEsbTensor(), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dilations.data(), static_cast<int64_t>(dilations.size()), data_format);
  return out;
}
inline Tensor DepthwiseConv2DBackpropInputD(const Tensor &filter, const Tensor &out_backprop, const std::vector<int64_t> &input_size, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const std::vector<int64_t> &dilations={1, 1, 1, 1}, const char *data_format="NHWC") {
  auto out = EsDepthwiseConv2DBackpropInputD(filter.GetEsbTensor(), out_backprop.GetEsbTensor(), input_size.data(), static_cast<int64_t>(input_size.size()), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dilations.data(), static_cast<int64_t>(dilations.size()), data_format);
  return out;
}
inline Tensor DepthwiseWeight4DTo6D(const Tensor &x) {
  auto out = EsDepthwiseWeight4DTo6D(x.GetEsbTensor());
  return out;
}
inline Tensor DepthwiseWeight6DTo4D(const Tensor &x, int64_t channel_size=16) {
  auto out = EsDepthwiseWeight6DTo4D(x.GetEsbTensor(), channel_size);
  return out;
}
inline Tensor Dequantize(const Tensor &x, const Tensor &min_range, const Tensor &max_range, const char *mode="MIN_COMBINED") {
  auto out = EsDequantize(x.GetEsbTensor(), min_range.GetEsbTensor(), max_range.GetEsbTensor(), mode);
  return out;
}
inline Tensor Dequeue(const Tensor &queue_id, ge::DataType output_type, const std::vector<int64_t> &output_shape, const char *queue_name="") {
  auto out = EsDequeue(queue_id.GetEsbTensor(), output_type, output_shape.data(), static_cast<int64_t>(output_shape.size()), queue_name);
  return out;
}
struct DeserializeManySparseOutput {
  Tensor indices;
  Tensor values;
  Tensor shape;
};
inline DeserializeManySparseOutput DeserializeManySparse(const Tensor &serialized_sparse, ge::DataType dtype) {
  auto out = EsDeserializeManySparse(serialized_sparse.GetEsbTensor(), dtype);
  return {out.indices, out.values, out.shape};
}
struct DeserializeSparseOutput {
  Tensor indices;
  Tensor values;
  Tensor shape;
};
inline DeserializeSparseOutput DeserializeSparse(const Tensor &serialized_sparse, ge::DataType dtype) {
  auto out = EsDeserializeSparse(serialized_sparse.GetEsbTensor(), dtype);
  return {out.indices, out.values, out.shape};
}
inline Tensor DestroyTemporaryVariable(const Tensor &x, const char *var_name="") {
  auto out = EsDestroyTemporaryVariable(x.GetEsbTensor(), var_name);
  return out;
}
struct DetectFlashAttentionScoreOutput {
  Tensor softmax_max;
  Tensor softmax_sum;
  Tensor softmax_out;
  Tensor attention_out;
};
inline DetectFlashAttentionScoreOutput DetectFlashAttentionScore(const Tensor &query, const Tensor &key, const Tensor &value, const Tensor &real_shift, const Tensor &drop_mask, const Tensor &padding_mask, const Tensor &atten_mask, const Tensor &prefix, const Tensor &actual_seq_qlen, const Tensor &actual_seq_kvlen, const Tensor &q_start_idx, const Tensor &kv_start_idx, int64_t head_num, const char *input_layout, float scale_value=1.000000, float keep_prob=1.000000, int64_t pre_tockens=2147483647, int64_t next_tockens=2147483647, int64_t inner_precise=0, int64_t sparse_mode=0, int64_t pse_type=1) {
  auto out = EsDetectFlashAttentionScore(query.GetEsbTensor(), key.GetEsbTensor(), value.GetEsbTensor(), real_shift.GetEsbTensor(), drop_mask.GetEsbTensor(), padding_mask.GetEsbTensor(), atten_mask.GetEsbTensor(), prefix.GetEsbTensor(), actual_seq_qlen.GetEsbTensor(), actual_seq_kvlen.GetEsbTensor(), q_start_idx.GetEsbTensor(), kv_start_idx.GetEsbTensor(), head_num, input_layout, scale_value, keep_prob, pre_tockens, next_tockens, inner_precise, sparse_mode, pse_type);
  return {out.softmax_max, out.softmax_sum, out.softmax_out, out.attention_out};
}
struct DetectFlashAttentionScoreGradOutput {
  Tensor dq;
  Tensor dk;
  Tensor dv;
  Tensor dpse;
};
inline DetectFlashAttentionScoreGradOutput DetectFlashAttentionScoreGrad(const Tensor &query, const Tensor &key, const Tensor &value, const Tensor &dy, const Tensor &pse_shift, const Tensor &drop_mask, const Tensor &padding_mask, const Tensor &atten_mask, const Tensor &softmax_max, const Tensor &softmax_sum, const Tensor &softmax_in, const Tensor &attention_in, const Tensor &prefix, const Tensor &actual_seq_qlen, const Tensor &actual_seq_kvlen, const Tensor &q_start_idx, const Tensor &kv_start_idx, int64_t head_num, const char *input_layout, float scale_value=1.000000, float keep_prob=1.000000, int64_t pre_tockens=2147483647, int64_t next_tockens=2147483647, int64_t inner_precise=0, int64_t sparse_mode=0, int64_t pse_type=1) {
  auto out = EsDetectFlashAttentionScoreGrad(query.GetEsbTensor(), key.GetEsbTensor(), value.GetEsbTensor(), dy.GetEsbTensor(), pse_shift.GetEsbTensor(), drop_mask.GetEsbTensor(), padding_mask.GetEsbTensor(), atten_mask.GetEsbTensor(), softmax_max.GetEsbTensor(), softmax_sum.GetEsbTensor(), softmax_in.GetEsbTensor(), attention_in.GetEsbTensor(), prefix.GetEsbTensor(), actual_seq_qlen.GetEsbTensor(), actual_seq_kvlen.GetEsbTensor(), q_start_idx.GetEsbTensor(), kv_start_idx.GetEsbTensor(), head_num, input_layout, scale_value, keep_prob, pre_tockens, next_tockens, inner_precise, sparse_mode, pse_type);
  return {out.dq, out.dk, out.dv, out.dpse};
}
inline Tensor Diag(const Tensor &x) {
  auto out = EsDiag(x.GetEsbTensor());
  return out;
}
inline Tensor DiagD(const Tensor &x, const Tensor &assist) {
  auto out = EsDiagD(x.GetEsbTensor(), assist.GetEsbTensor());
  return out;
}
inline Tensor DiagFlat(const Tensor &x, int64_t diagonal=0) {
  auto out = EsDiagFlat(x.GetEsbTensor(), diagonal);
  return out;
}
inline Tensor DiagPart(const Tensor &x) {
  auto out = EsDiagPart(x.GetEsbTensor());
  return out;
}
inline Tensor DiagPartD(const Tensor &x, const Tensor &assist) {
  auto out = EsDiagPartD(x.GetEsbTensor(), assist.GetEsbTensor());
  return out;
}
inline Tensor DiagV2(const Tensor &x, int64_t diagonal=0) {
  auto out = EsDiagV2(x.GetEsbTensor(), diagonal);
  return out;
}
inline Tensor Digamma(const Tensor &x) {
  auto out = EsDigamma(x.GetEsbTensor());
  return out;
}
inline Tensor Dilation(const Tensor &x, const std::vector<int64_t> &dilations, const std::vector<int64_t> &pads={}, float padding_value=0.000000) {
  auto out = EsDilation(x.GetEsbTensor(), dilations.data(), static_cast<int64_t>(dilations.size()), pads.data(), static_cast<int64_t>(pads.size()), padding_value);
  return out;
}
inline Tensor Dilation2D(const Tensor &x, const Tensor &filter, const std::vector<int64_t> &strides, const std::vector<int64_t> &rates, const char *padding_mode="SAME", const std::vector<int64_t> &pads={0, 0, 0, 0}, bool ceil_mode=false, const char *data_format="NHWC") {
  auto out = EsDilation2D(x.GetEsbTensor(), filter.GetEsbTensor(), strides.data(), static_cast<int64_t>(strides.size()), rates.data(), static_cast<int64_t>(rates.size()), padding_mode, pads.data(), static_cast<int64_t>(pads.size()), ceil_mode, data_format);
  return out;
}
inline Tensor Dilation2DBackpropFilter(const Tensor &x, const Tensor &filter, const Tensor &out_backprop, const std::vector<int64_t> &strides, const std::vector<int64_t> &rates, const char *padding_mode="SAME", const std::vector<int64_t> &pads={0, 0, 0, 0}, bool ceil_mode=false, const char *data_format="NHWC") {
  auto out = EsDilation2DBackpropFilter(x.GetEsbTensor(), filter.GetEsbTensor(), out_backprop.GetEsbTensor(), strides.data(), static_cast<int64_t>(strides.size()), rates.data(), static_cast<int64_t>(rates.size()), padding_mode, pads.data(), static_cast<int64_t>(pads.size()), ceil_mode, data_format);
  return out;
}
inline Tensor Dilation2DBackpropInput(const Tensor &x, const Tensor &filter, const Tensor &out_backprop, const std::vector<int64_t> &strides, const std::vector<int64_t> &rates, const char *padding_mode="SAME", const std::vector<int64_t> &pads={0, 0, 0, 0}, bool ceil_mode=false, const char *data_format="NHWC") {
  auto out = EsDilation2DBackpropInput(x.GetEsbTensor(), filter.GetEsbTensor(), out_backprop.GetEsbTensor(), strides.data(), static_cast<int64_t>(strides.size()), rates.data(), static_cast<int64_t>(rates.size()), padding_mode, pads.data(), static_cast<int64_t>(pads.size()), ceil_mode, data_format);
  return out;
}
inline Tensor Div(const Tensor &x1, const Tensor &x2) {
  auto out = EsDiv(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor Div(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return Div(tensor, b_esb_tensor);
}
inline Tensor DivNoNan(const Tensor &x1, const Tensor &x2) {
  auto out = EsDivNoNan(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor DivNoNan(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return DivNoNan(tensor, b_esb_tensor);
}
inline Tensor Dot(const Tensor &input_x, const Tensor &input_y) {
  auto out = EsDot(input_x.GetEsbTensor(), input_y.GetEsbTensor());
  return out;
}
inline Tensor DrawBoundingBoxes(const Tensor &images, const Tensor &boxes) {
  auto out = EsDrawBoundingBoxes(images.GetEsbTensor(), boxes.GetEsbTensor());
  return out;
}
inline Tensor DrawBoundingBoxesV2(const Tensor &images, const Tensor &boxes, const Tensor &colors) {
  auto out = EsDrawBoundingBoxesV2(images.GetEsbTensor(), boxes.GetEsbTensor(), colors.GetEsbTensor());
  return out;
}
inline Tensor DropOutDoMask(const Tensor &x, const Tensor &mask, const Tensor &keep_prob) {
  auto out = EsDropOutDoMask(x.GetEsbTensor(), mask.GetEsbTensor(), keep_prob.GetEsbTensor());
  return out;
}
inline Tensor DropOutDoMaskV3(const Tensor &x, const Tensor &mask, const Tensor &keep_prob) {
  auto out = EsDropOutDoMaskV3(x.GetEsbTensor(), mask.GetEsbTensor(), keep_prob.GetEsbTensor());
  return out;
}
inline Tensor DropOutDoMaskV3D(const Tensor &x, const Tensor &mask, float keep_prob) {
  auto out = EsDropOutDoMaskV3D(x.GetEsbTensor(), mask.GetEsbTensor(), keep_prob);
  return out;
}
inline Tensor DropOutGenMask(const Tensor &shape, const Tensor &prob, int64_t seed=0, int64_t seed2=0) {
  auto out = EsDropOutGenMask(shape.GetEsbTensor(), prob.GetEsbTensor(), seed, seed2);
  return out;
}
inline Tensor DropOutGenMaskV3(const Tensor &shape, const Tensor &prob, int64_t seed=0, int64_t seed2=0) {
  auto out = EsDropOutGenMaskV3(shape.GetEsbTensor(), prob.GetEsbTensor(), seed, seed2);
  return out;
}
inline Tensor DropOutGenMaskV4(const Tensor &shape, const Tensor &prob, int64_t seed=0, int64_t seed2=0, ge::DataType dtype=ge::DT_BOOL) {
  auto out = EsDropOutGenMaskV4(shape.GetEsbTensor(), prob.GetEsbTensor(), seed, seed2, dtype);
  return out;
}
inline Tensor Dropout(const Tensor &x, float dropout_ratio=0.500000, bool scale_train=true, float alpha=1.000000, float beta=0.000000) {
  auto out = EsDropout(x.GetEsbTensor(), dropout_ratio, scale_train, alpha, beta);
  return out;
}
struct DropoutV2Output {
  Tensor y;
  Tensor mask;
  Tensor seed;
};
inline DropoutV2Output DropoutV2(const Tensor &x, const Tensor &seed, float p) {
  auto out = EsDropoutV2(x.GetEsbTensor(), seed.GetEsbTensor(), p);
  return {out.y, out.mask, out.seed};
}
inline Tensor DropoutWithMulsAndSoftmaxGrad(const Tensor &y_grad, const Tensor &mask, const Tensor &softmax_output, float input_keep_prob, float alpha, const std::vector<int64_t> &axes={-1}) {
  auto out = EsDropoutWithMulsAndSoftmaxGrad(y_grad.GetEsbTensor(), mask.GetEsbTensor(), softmax_output.GetEsbTensor(), input_keep_prob, alpha, axes.data(), static_cast<int64_t>(axes.size()));
  return out;
}
struct DuaQuantizeAddLayerNormOutput {
  Tensor y1;
  Tensor y2;
  Tensor x;
};
inline DuaQuantizeAddLayerNormOutput DuaQuantizeAddLayerNorm(const Tensor &x1, const Tensor &x2, const Tensor &gamma, const Tensor &beta, const Tensor &bias, const Tensor &scales1, const Tensor &scales2, const Tensor &zero_points1, const Tensor &zero_points2, int64_t dtype, int64_t axis=-1, float epsilon=0.000010, bool additional_output=false) {
  auto out = EsDuaQuantizeAddLayerNorm(x1.GetEsbTensor(), x2.GetEsbTensor(), gamma.GetEsbTensor(), beta.GetEsbTensor(), bias.GetEsbTensor(), scales1.GetEsbTensor(), scales2.GetEsbTensor(), zero_points1.GetEsbTensor(), zero_points2.GetEsbTensor(), dtype, axis, epsilon, additional_output);
  return {out.y1, out.y2, out.x};
}
inline Tensor DummySeedGenerator(const Graph &owner_graph) {
  auto out = EsDummySeedGenerator(owner_graph.GetEsbGraph());
  return out;
}
inline Tensor DynSeqOuter(const Tensor &x1, const Tensor &x2, const Tensor &seq_len1, const Tensor &seq_len2) {
  auto out = EsDynSeqOuter(x1.GetEsbTensor(), x2.GetEsbTensor(), seq_len1.GetEsbTensor(), seq_len2.GetEsbTensor());
  return out;
}
struct DynamicAUGRUOutput {
  Tensor y;
  Tensor output_h;
  Tensor update;
  Tensor update_att;
  Tensor reset;
  Tensor out_new;
  Tensor hidden_new;
};
inline DynamicAUGRUOutput DynamicAUGRU(const Tensor &x, const Tensor &weight_input, const Tensor &weight_hidden, const Tensor &weight_att, const Tensor &bias_input=nullptr, const Tensor &bias_hidden=nullptr, const Tensor &seq_length=nullptr, const Tensor &init_h=nullptr, const char *direction="UNIDIRECTIONAL", int64_t cell_depth=1, float keep_prob=1.000000, float cell_clip=-1.000000, int64_t num_proj=0, bool time_major=true, const char *activation="tanh", const char *gate_order="zrh", bool reset_after=true, bool is_training=true) {
  auto out = EsDynamicAUGRU(x.GetEsbTensor(), weight_input.GetEsbTensor(), weight_hidden.GetEsbTensor(), weight_att.GetEsbTensor(), bias_input.GetEsbTensor(), bias_hidden.GetEsbTensor(), seq_length.GetEsbTensor(), init_h.GetEsbTensor(), direction, cell_depth, keep_prob, cell_clip, num_proj, time_major, activation, gate_order, reset_after, is_training);
  return {out.y, out.output_h, out.update, out.update_att, out.reset, out.out_new, out.hidden_new};
}
struct DynamicAUGRUGradOutput {
  Tensor dw_input;
  Tensor dw_hidden;
  Tensor db_input;
  Tensor db_hidden;
  Tensor dx;
  Tensor dh_prev;
  Tensor dw_att;
};
inline DynamicAUGRUGradOutput DynamicAUGRUGrad(const Tensor &x, const Tensor &weight_input, const Tensor &weight_hidden, const Tensor &weight_att, const Tensor &y, const Tensor &init_h, const Tensor &h, const Tensor &dy, const Tensor &dh, const Tensor &update, const Tensor &update_att, const Tensor &reset, const Tensor &in_new, const Tensor &hidden_new, const Tensor &seq_length=nullptr, const Tensor &mask=nullptr, const char *direction="UNIDIRECTIONAL", int64_t cell_depth=1, float keep_prob=-1.000000, float cell_clip=-1.000000, int64_t num_proj=0, bool time_major=true, const char *gate_order="zrh", bool reset_after=true) {
  auto out = EsDynamicAUGRUGrad(x.GetEsbTensor(), weight_input.GetEsbTensor(), weight_hidden.GetEsbTensor(), weight_att.GetEsbTensor(), y.GetEsbTensor(), init_h.GetEsbTensor(), h.GetEsbTensor(), dy.GetEsbTensor(), dh.GetEsbTensor(), update.GetEsbTensor(), update_att.GetEsbTensor(), reset.GetEsbTensor(), in_new.GetEsbTensor(), hidden_new.GetEsbTensor(), seq_length.GetEsbTensor(), mask.GetEsbTensor(), direction, cell_depth, keep_prob, cell_clip, num_proj, time_major, gate_order, reset_after);
  return {out.dw_input, out.dw_hidden, out.db_input, out.db_hidden, out.dx, out.dh_prev, out.dw_att};
}
inline Tensor DynamicAtomicAddrClean(const Graph &owner_graph, const std::vector<int64_t> &automic_add_mem_size={}) {
  auto out = EsDynamicAtomicAddrClean(owner_graph.GetEsbGraph(), automic_add_mem_size.data(), static_cast<int64_t>(automic_add_mem_size.size()));
  return out;
}
struct DynamicGRUOutput {
  Tensor y;
  Tensor output_h;
  Tensor r;
  Tensor i;
  Tensor n;
};
inline DynamicGRUOutput DynamicGRU(const Tensor &x, const Tensor &w, const Tensor &b, const Tensor &cw, const Tensor &cb, const Tensor &seq_length=nullptr, const Tensor &init_h=nullptr, const char *direction="UNIDIRECTIONAL", int64_t cell_depth=1, float keep_prob=1.000000, float cell_clip=-1.000000, int64_t num_proj=0, bool time_major=true, const char *activation="tanh", bool is_training=true) {
  auto out = EsDynamicGRU(x.GetEsbTensor(), w.GetEsbTensor(), b.GetEsbTensor(), cw.GetEsbTensor(), cb.GetEsbTensor(), seq_length.GetEsbTensor(), init_h.GetEsbTensor(), direction, cell_depth, keep_prob, cell_clip, num_proj, time_major, activation, is_training);
  return {out.y, out.output_h, out.r, out.i, out.n};
}
struct DynamicGRUCellGradOutput {
  Tensor dh_prev;
  Tensor dgate_h;
  Tensor dnt_x;
};
inline DynamicGRUCellGradOutput DynamicGRUCellGrad(const Tensor &dh_pre_t, const Tensor &h, const Tensor &dy, const Tensor &dh, const Tensor &update, const Tensor &reset, const Tensor &in_new, const Tensor &hidden_new, const Tensor &init_h, const Tensor &t_state, const Tensor &seq_length=nullptr, const char *gate_order="zrh") {
  auto out = EsDynamicGRUCellGrad(dh_pre_t.GetEsbTensor(), h.GetEsbTensor(), dy.GetEsbTensor(), dh.GetEsbTensor(), update.GetEsbTensor(), reset.GetEsbTensor(), in_new.GetEsbTensor(), hidden_new.GetEsbTensor(), init_h.GetEsbTensor(), t_state.GetEsbTensor(), seq_length.GetEsbTensor(), gate_order);
  return {out.dh_prev, out.dgate_h, out.dnt_x};
}
struct DynamicGRUV2Output {
  Tensor y;
  Tensor output_h;
  Tensor update;
  Tensor reset;
  Tensor out_new;
  Tensor hidden_new;
};
inline DynamicGRUV2Output DynamicGRUV2(const Tensor &x, const Tensor &weight_input, const Tensor &weight_hidden, const Tensor &bias_input=nullptr, const Tensor &bias_hidden=nullptr, const Tensor &seq_length=nullptr, const Tensor &init_h=nullptr, const char *direction="UNIDIRECTIONAL", int64_t cell_depth=1, float keep_prob=1.000000, float cell_clip=-1.000000, int64_t num_proj=0, bool time_major=true, const char *activation="tanh", const char *gate_order="zrh", bool reset_after=true, bool is_training=true) {
  auto out = EsDynamicGRUV2(x.GetEsbTensor(), weight_input.GetEsbTensor(), weight_hidden.GetEsbTensor(), bias_input.GetEsbTensor(), bias_hidden.GetEsbTensor(), seq_length.GetEsbTensor(), init_h.GetEsbTensor(), direction, cell_depth, keep_prob, cell_clip, num_proj, time_major, activation, gate_order, reset_after, is_training);
  return {out.y, out.output_h, out.update, out.reset, out.out_new, out.hidden_new};
}
struct DynamicGRUV2GradOutput {
  Tensor dw_input;
  Tensor dw_hidden;
  Tensor db_input;
  Tensor db_hidden;
  Tensor dx;
  Tensor dh_prev;
};
inline DynamicGRUV2GradOutput DynamicGRUV2Grad(const Tensor &x, const Tensor &weight_input, const Tensor &weight_hidden, const Tensor &y, const Tensor &init_h, const Tensor &h, const Tensor &dy, const Tensor &dh, const Tensor &update, const Tensor &reset, const Tensor &in_new, const Tensor &hidden_new, const Tensor &seq_length=nullptr, const Tensor &mask=nullptr, const char *direction="UNIDIRECTIONAL", int64_t cell_depth=0, float keep_prob=-1.000000, float cell_clip=-1.000000, int64_t num_proj=0, bool time_major=true, const char *gate_order="zrh", bool reset_after=true) {
  auto out = EsDynamicGRUV2Grad(x.GetEsbTensor(), weight_input.GetEsbTensor(), weight_hidden.GetEsbTensor(), y.GetEsbTensor(), init_h.GetEsbTensor(), h.GetEsbTensor(), dy.GetEsbTensor(), dh.GetEsbTensor(), update.GetEsbTensor(), reset.GetEsbTensor(), in_new.GetEsbTensor(), hidden_new.GetEsbTensor(), seq_length.GetEsbTensor(), mask.GetEsbTensor(), direction, cell_depth, keep_prob, cell_clip, num_proj, time_major, gate_order, reset_after);
  return {out.dw_input, out.dw_hidden, out.db_input, out.db_hidden, out.dx, out.dh_prev};
}
struct DynamicGRUV2HiddenOutput {
  Tensor y;
  Tensor output_h;
  Tensor update;
  Tensor reset;
  Tensor out_new;
  Tensor hidden_new;
};
inline DynamicGRUV2HiddenOutput DynamicGRUV2Hidden(const Tensor &x_weight_input, const Tensor &weight_hidden, const Tensor &bias_hidden=nullptr, const Tensor &seq_length=nullptr, const Tensor &init_h=nullptr, const char *direction="UNIDIRECTIONAL", int64_t cell_depth=1, float keep_prob=1.000000, float cell_clip=-1.000000, int64_t num_proj=0, bool time_major=true, const char *activation="tanh", const char *gate_order="zrh", bool reset_after=true, bool is_training=true) {
  auto out = EsDynamicGRUV2Hidden(x_weight_input.GetEsbTensor(), weight_hidden.GetEsbTensor(), bias_hidden.GetEsbTensor(), seq_length.GetEsbTensor(), init_h.GetEsbTensor(), direction, cell_depth, keep_prob, cell_clip, num_proj, time_major, activation, gate_order, reset_after, is_training);
  return {out.y, out.output_h, out.update, out.reset, out.out_new, out.hidden_new};
}
inline Tensor DynamicLSTM(const Tensor &x, const Tensor &w, const Tensor &b) {
  auto out = EsDynamicLSTM(x.GetEsbTensor(), w.GetEsbTensor(), b.GetEsbTensor());
  return out;
}
struct DynamicLSTMV2Output {
  Tensor y;
  Tensor output_h;
  Tensor output_c;
  Tensor last_output_h;
  Tensor last_output_c;
};
inline DynamicLSTMV2Output DynamicLSTMV2(const Tensor &x, const Tensor &w, const Tensor &b, const Tensor &cont, const Tensor &w_xc_x_static=nullptr, const Tensor &h0=nullptr, const Tensor &c0=nullptr, const Tensor &wci=nullptr, const Tensor &wcf=nullptr, const Tensor &wco=nullptr, const Tensor &mask=nullptr, int64_t num_output=0, bool expose_hidden=false, bool need_output_last=false, float forget_bias=0.000000) {
  auto out = EsDynamicLSTMV2(x.GetEsbTensor(), w.GetEsbTensor(), b.GetEsbTensor(), cont.GetEsbTensor(), w_xc_x_static.GetEsbTensor(), h0.GetEsbTensor(), c0.GetEsbTensor(), wci.GetEsbTensor(), wcf.GetEsbTensor(), wco.GetEsbTensor(), mask.GetEsbTensor(), num_output, expose_hidden, need_output_last, forget_bias);
  return {out.y, out.output_h, out.output_c, out.last_output_h, out.last_output_c};
}
struct DynamicQuantOutput {
  Tensor y;
  Tensor scale;
};
inline DynamicQuantOutput DynamicQuant(const Tensor &x, const Tensor &smooth_scales=nullptr, const Tensor &group_index=nullptr, int64_t dst_type=2) {
  auto out = EsDynamicQuant(x.GetEsbTensor(), smooth_scales.GetEsbTensor(), group_index.GetEsbTensor(), dst_type);
  return {out.y, out.scale};
}
struct DynamicQuantUpdateScatterOutput {
  Tensor var;
  Tensor var_scale;
};
inline DynamicQuantUpdateScatterOutput DynamicQuantUpdateScatter(const Tensor &var, const Tensor &var_scale, const Tensor &indices, const Tensor &updates, const Tensor &smooth_scales, const char *reduce, int64_t axis=0) {
  auto out = EsDynamicQuantUpdateScatter(var.GetEsbTensor(), var_scale.GetEsbTensor(), indices.GetEsbTensor(), updates.GetEsbTensor(), smooth_scales.GetEsbTensor(), reduce, axis);
  return {out.var, out.var_scale};
}
struct DynamicQuantV2Output {
  Tensor y;
  Tensor scale;
  Tensor offset;
};
inline DynamicQuantV2Output DynamicQuantV2(const Tensor &x, const Tensor &smooth_scales=nullptr, const Tensor &group_index=nullptr, int64_t dst_type=2) {
  auto out = EsDynamicQuantV2(x.GetEsbTensor(), smooth_scales.GetEsbTensor(), group_index.GetEsbTensor(), dst_type);
  return {out.y, out.scale, out.offset};
}
struct DynamicRNNOutput {
  Tensor y;
  Tensor output_h;
  Tensor output_c;
  Tensor i;
  Tensor j;
  Tensor f;
  Tensor o;
  Tensor tanhc;
};
inline DynamicRNNOutput DynamicRNN(const Tensor &x, const Tensor &w, const Tensor &b, const Tensor &seq_length=nullptr, const Tensor &init_h=nullptr, const Tensor &init_c=nullptr, const Tensor &wci=nullptr, const Tensor &wcf=nullptr, const Tensor &wco=nullptr, const Tensor &mask=nullptr, const char *cell_type="LSTM", const char *direction="UNIDIRECTIONAL", int64_t cell_depth=1, bool use_peephole=false, float keep_prob=1.000000, float cell_clip=-1.000000, int64_t num_proj=0, bool time_major=true, const char *activation="tanh", float forget_bias=0.000000, const char *gate_order="ijfo", bool is_training=true) {
  auto out = EsDynamicRNN(x.GetEsbTensor(), w.GetEsbTensor(), b.GetEsbTensor(), seq_length.GetEsbTensor(), init_h.GetEsbTensor(), init_c.GetEsbTensor(), wci.GetEsbTensor(), wcf.GetEsbTensor(), wco.GetEsbTensor(), mask.GetEsbTensor(), cell_type, direction, cell_depth, use_peephole, keep_prob, cell_clip, num_proj, time_major, activation, forget_bias, gate_order, is_training);
  return {out.y, out.output_h, out.output_c, out.i, out.j, out.f, out.o, out.tanhc};
}
struct DynamicRNNV2Output {
  Tensor y;
  Tensor output_h;
  Tensor output_c;
  Tensor i;
  Tensor j;
  Tensor f;
  Tensor o;
  Tensor tanhc;
};
inline DynamicRNNV2Output DynamicRNNV2(const Tensor &x, const Tensor &weight_input, const Tensor &weight_hidden, const Tensor &b=nullptr, const Tensor &seq_length=nullptr, const Tensor &init_h=nullptr, const Tensor &init_c=nullptr, const Tensor &wci=nullptr, const Tensor &wcf=nullptr, const Tensor &wco=nullptr, const Tensor &mask=nullptr, const char *cell_type="LSTM", const char *direction="UNIDIRECTIONAL", int64_t cell_depth=1, bool use_peephole=false, float keep_prob=1.000000, float cell_clip=-1.000000, int64_t num_proj=0, bool time_major=true, const char *activation="tanh", const char *recurrent_activation="sigmoid", float forget_bias=0.000000, const char *gate_order="ijfo", bool stateful=false, const char *merge_mode="concat", bool is_training=true) {
  auto out = EsDynamicRNNV2(x.GetEsbTensor(), weight_input.GetEsbTensor(), weight_hidden.GetEsbTensor(), b.GetEsbTensor(), seq_length.GetEsbTensor(), init_h.GetEsbTensor(), init_c.GetEsbTensor(), wci.GetEsbTensor(), wcf.GetEsbTensor(), wco.GetEsbTensor(), mask.GetEsbTensor(), cell_type, direction, cell_depth, use_peephole, keep_prob, cell_clip, num_proj, time_major, activation, recurrent_activation, forget_bias, gate_order, stateful, merge_mode, is_training);
  return {out.y, out.output_h, out.output_c, out.i, out.j, out.f, out.o, out.tanhc};
}
struct DynamicRNNV3Output {
  Tensor y;
  Tensor output_h;
  Tensor output_c;
  Tensor i;
  Tensor j;
  Tensor f;
  Tensor o;
  Tensor tanhc;
};
inline DynamicRNNV3Output DynamicRNNV3(const Tensor &x, const Tensor &w, const Tensor &b, const Tensor &seq_length=nullptr, const Tensor &init_h=nullptr, const Tensor &init_c=nullptr, const Tensor &wci=nullptr, const Tensor &wcf=nullptr, const Tensor &wco=nullptr, const Tensor &mask=nullptr, const Tensor &real_mask=nullptr, const Tensor &project=nullptr, const char *cell_type="LSTM", const char *direction="UNIDIRECTIONAL", int64_t cell_depth=1, bool use_peephole=false, float keep_prob=1.000000, float cell_clip=-1.000000, int64_t num_proj=0, bool time_major=true, const char *activation="tanh", float forget_bias=0.000000, bool is_training=true) {
  auto out = EsDynamicRNNV3(x.GetEsbTensor(), w.GetEsbTensor(), b.GetEsbTensor(), seq_length.GetEsbTensor(), init_h.GetEsbTensor(), init_c.GetEsbTensor(), wci.GetEsbTensor(), wcf.GetEsbTensor(), wco.GetEsbTensor(), mask.GetEsbTensor(), real_mask.GetEsbTensor(), project.GetEsbTensor(), cell_type, direction, cell_depth, use_peephole, keep_prob, cell_clip, num_proj, time_major, activation, forget_bias, is_training);
  return {out.y, out.output_h, out.output_c, out.i, out.j, out.f, out.o, out.tanhc};
}
inline Tensor DynamicStitch(const std::vector<Tensor> &indices, const std::vector<Tensor> &x, int64_t N=1) {
  auto esb_indices = TensorsToEsbTensors(indices);
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsDynamicStitch(esb_indices.data(), static_cast<int64_t>(esb_indices.size()), esb_x.data(), static_cast<int64_t>(esb_x.size()), N);
  return out;
}
inline Tensor EditDistance(const Tensor &hypothesis_indices, const Tensor &hypothesis_values, const Tensor &hypothesis_shape, const Tensor &truth_indices, const Tensor &truth_values, const Tensor &truth_shape, bool normalize=true) {
  auto out = EsEditDistance(hypothesis_indices.GetEsbTensor(), hypothesis_values.GetEsbTensor(), hypothesis_shape.GetEsbTensor(), truth_indices.GetEsbTensor(), truth_values.GetEsbTensor(), truth_shape.GetEsbTensor(), normalize);
  return out;
}
inline Tensor Einsum(const std::vector<Tensor> &x, const char *equation, int64_t N) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsEinsum(esb_x.data(), static_cast<int64_t>(esb_x.size()), equation, N);
  return out;
}
inline Tensor Eltwise(const std::vector<Tensor> &x, int64_t N, int64_t mode=1, const std::vector<float> &coeff={}) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsEltwise(esb_x.data(), static_cast<int64_t>(esb_x.size()), N, mode, coeff.data(), static_cast<int64_t>(coeff.size()));
  return out;
}
inline Tensor Elu(const Tensor &x, float alpha=1.000000, float scale=1.000000, float input_scale=1.000000) {
  auto out = EsElu(x.GetEsbTensor(), alpha, scale, input_scale);
  return out;
}
inline Tensor EluGrad(const Tensor &grads, const Tensor &activations) {
  auto out = EsEluGrad(grads.GetEsbTensor(), activations.GetEsbTensor());
  return out;
}
inline Tensor EluGradV2(const Tensor &grads, const Tensor &activations, float alpha=1.000000, float scale=1.000000, float input_scale=1.000000, bool is_result=false) {
  auto out = EsEluGradV2(grads.GetEsbTensor(), activations.GetEsbTensor(), alpha, scale, input_scale, is_result);
  return out;
}
struct EmbeddingBagOutput {
  Tensor y;
  Tensor offset2bag;
  Tensor bag_size;
  Tensor max_indices;
};
inline EmbeddingBagOutput EmbeddingBag(const Tensor &weight, const Tensor &indices, const Tensor &offsets=nullptr, const Tensor &per_sample_weights=nullptr, const char *mode="mean", bool scale_grad_by_freq=false, bool sparse=false, bool include_last_offset=false, int64_t padding_idx=-1) {
  auto out = EsEmbeddingBag(weight.GetEsbTensor(), indices.GetEsbTensor(), offsets.GetEsbTensor(), per_sample_weights.GetEsbTensor(), mode, scale_grad_by_freq, sparse, include_last_offset, padding_idx);
  return {out.y, out.offset2bag, out.bag_size, out.max_indices};
}
inline Tensor EmbeddingDenseGrad(const Tensor &grad, const Tensor &indices, int64_t num_weights, int64_t padding_idx=-1, bool scale_grad_by_freq=false) {
  auto out = EsEmbeddingDenseGrad(grad.GetEsbTensor(), indices.GetEsbTensor(), num_weights, padding_idx, scale_grad_by_freq);
  return out;
}
inline Tensor EmbeddingDenseGradV2(const Tensor &grad, const Tensor &sort_indices, const Tensor &pos_idx, int64_t num_weights, int64_t padding_idx=-1, bool scale_grad_by_freq=false) {
  auto out = EsEmbeddingDenseGradV2(grad.GetEsbTensor(), sort_indices.GetEsbTensor(), pos_idx.GetEsbTensor(), num_weights, padding_idx, scale_grad_by_freq);
  return out;
}
inline Tensor EmbeddingHashmapExport(const Tensor &file_path, const Tensor &table_ids, const Tensor &table_names, const Tensor &global_step, const std::vector<Tensor> &keys, const std::vector<Tensor> &counters, const std::vector<Tensor> &filter_flags, const std::vector<Tensor> &values) {
  auto esb_keys = TensorsToEsbTensors(keys);
  auto esb_counters = TensorsToEsbTensors(counters);
  auto esb_filter_flags = TensorsToEsbTensors(filter_flags);
  auto esb_values = TensorsToEsbTensors(values);
  auto out = EsEmbeddingHashmapExport(file_path.GetEsbTensor(), table_ids.GetEsbTensor(), table_names.GetEsbTensor(), global_step.GetEsbTensor(), esb_keys.data(), static_cast<int64_t>(esb_keys.size()), esb_counters.data(), static_cast<int64_t>(esb_counters.size()), esb_filter_flags.data(), static_cast<int64_t>(esb_filter_flags.size()), esb_values.data(), static_cast<int64_t>(esb_values.size()));
  return out;
}
inline Tensor EmbeddingHashmapFileSize(const Tensor &file_path, const Tensor &table_ids, const Tensor &table_names, const Tensor &global_step, const std::vector<int64_t> &embedding_dims) {
  auto out = EsEmbeddingHashmapFileSize(file_path.GetEsbTensor(), table_ids.GetEsbTensor(), table_names.GetEsbTensor(), global_step.GetEsbTensor(), embedding_dims.data(), static_cast<int64_t>(embedding_dims.size()));
  return out;
}
inline Tensor EmbeddingHashmapSize(const Tensor &table_ids, bool filter_export_flag=false, const char *export_mode="all") {
  auto out = EsEmbeddingHashmapSize(table_ids.GetEsbTensor(), filter_export_flag, export_mode);
  return out;
}
struct EmbeddingLocalIndexOutput {
  Tensor local_idx;
  Tensor nums;
  Tensor recover_idx;
};
inline EmbeddingLocalIndexOutput EmbeddingLocalIndex(const Tensor &addr_table, const Tensor &index, int64_t row_memory=320, const char *mode="mod") {
  auto out = EsEmbeddingLocalIndex(addr_table.GetEsbTensor(), index.GetEsbTensor(), row_memory, mode);
  return {out.local_idx, out.nums, out.recover_idx};
}
inline Tensor EmbeddingRankId(const Tensor &addr_table, const Tensor &index, int64_t row_memory=320, const char *mode="mod") {
  auto out = EsEmbeddingRankId(addr_table.GetEsbTensor(), index.GetEsbTensor(), row_memory, mode);
  return out;
}
inline Tensor Empty(const Tensor &shape, int64_t dtype=3, bool init=false) {
  auto out = EsEmpty(shape.GetEsbTensor(), dtype, init);
  return out;
}
inline Tensor EmptyTensorList(const Tensor &element_shape, const Tensor &max_num_elements, ge::DataType element_dtype=ge::DT_INT32) {
  auto out = EsEmptyTensorList(element_shape.GetEsbTensor(), max_num_elements.GetEsbTensor(), element_dtype);
  return out;
}
inline Tensor EmptyTensorMap(const Graph &owner_graph) {
  auto out = EsEmptyTensorMap(owner_graph.GetEsbGraph());
  return out;
}
inline Tensor EncodeBase64(const Tensor &x, bool pad=false) {
  auto out = EsEncodeBase64(x.GetEsbTensor(), pad);
  return out;
}
inline Tensor EncodeJpeg(const Tensor &image, const char *format="", int64_t quality=95, bool progressive=false, bool optimize_size=false, bool chroma_downsampling=true, const char *density_unit="in", int64_t x_density=300, int64_t y_density=300, const char *xmp_metadata="") {
  auto out = EsEncodeJpeg(image.GetEsbTensor(), format, quality, progressive, optimize_size, chroma_downsampling, density_unit, x_density, y_density, xmp_metadata);
  return out;
}
inline Tensor EncodeJpegVariableQuality(const Tensor &images, const Tensor &quality) {
  auto out = EsEncodeJpegVariableQuality(images.GetEsbTensor(), quality.GetEsbTensor());
  return out;
}
inline Tensor EncodePng(const Tensor &image, int64_t compression=-1) {
  auto out = EsEncodePng(image.GetEsbTensor(), compression);
  return out;
}
inline Tensor EncodeWav(const Tensor &audio, const Tensor &sample_rate) {
  auto out = EsEncodeWav(audio.GetEsbTensor(), sample_rate.GetEsbTensor());
  return out;
}
inline Tensor End(const Tensor &x, int64_t peerIndex=0, const char *parentOpType="") {
  auto out = EsEnd(x.GetEsbTensor(), peerIndex, parentOpType);
  return out;
}
inline Tensor EndOfSequence(const Tensor &x) {
  auto out = EsEndOfSequence(x.GetEsbTensor());
  return out;
}
inline Tensor EnsureShape(const Tensor &input, const std::vector<int64_t> &shape) {
  auto out = EsEnsureShape(input.GetEsbTensor(), shape.data(), static_cast<int64_t>(shape.size()));
  return out;
}
inline Tensor Enter(const Tensor &x, const char *frame_name, bool is_constant) {
  auto out = EsEnter(x.GetEsbTensor(), frame_name, is_constant);
  return out;
}
inline Tensor Equal(const Tensor &x1, const Tensor &x2) {
  auto out = EsEqual(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor Equal(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return Equal(tensor, b_esb_tensor);
}
inline Tensor Erf(const Tensor &x) {
  auto out = EsErf(x.GetEsbTensor());
  return out;
}
inline Tensor Erfc(const Tensor &x) {
  auto out = EsErfc(x.GetEsbTensor());
  return out;
}
inline Tensor Erfinv(const Tensor &input_x) {
  auto out = EsErfinv(input_x.GetEsbTensor());
  return out;
}
inline Tensor EuclideanNorm(const Tensor &x, const Tensor &axes, bool keep_dims=false) {
  auto out = EsEuclideanNorm(x.GetEsbTensor(), axes.GetEsbTensor(), keep_dims);
  return out;
}
inline Tensor EuclideanNormD(const Tensor &x, const std::vector<int64_t> &axes={}, bool keep_dims=false) {
  auto out = EsEuclideanNormD(x.GetEsbTensor(), axes.data(), static_cast<int64_t>(axes.size()), keep_dims);
  return out;
}
inline Tensor Exit(const Tensor &x) {
  auto out = EsExit(x.GetEsbTensor());
  return out;
}
inline Tensor Exp(const Tensor &x, float base=-1.000000, float scale=1.000000, float shift=0.000000) {
  auto out = EsExp(x.GetEsbTensor(), base, scale, shift);
  return out;
}
inline Tensor Expand(const Tensor &x, const Tensor &shape) {
  auto out = EsExpand(x.GetEsbTensor(), shape.GetEsbTensor());
  return out;
}
inline Tensor ExpandD(const Tensor &x, const std::vector<int64_t> &shape) {
  auto out = EsExpandD(x.GetEsbTensor(), shape.data(), static_cast<int64_t>(shape.size()));
  return out;
}
inline Tensor ExpandDims(const Tensor &x, const Tensor &axis) {
  auto out = EsExpandDims(x.GetEsbTensor(), axis.GetEsbTensor());
  return out;
}
inline Tensor Expint(const Tensor &x) {
  auto out = EsExpint(x.GetEsbTensor());
  return out;
}
inline Tensor Expm1(const Tensor &x) {
  auto out = EsExpm1(x.GetEsbTensor());
  return out;
}
inline Tensor Exponential(const Tensor &x, float lambda=1.000000, int64_t seed=0) {
  auto out = EsExponential(x.GetEsbTensor(), lambda, seed);
  return out;
}
inline Tensor ExponentialDecayLR(const Tensor &var_handle, const Tensor &initial_learning_rate, const Tensor &decay_rate, const Tensor &decay_steps, const Tensor &global_step=nullptr, bool staircase=false) {
  auto out = EsExponentialDecayLR(var_handle.GetEsbTensor(), initial_learning_rate.GetEsbTensor(), decay_rate.GetEsbTensor(), decay_steps.GetEsbTensor(), global_step.GetEsbTensor(), staircase);
  return out;
}
inline Tensor ExtractGlimpse(const Tensor &x, const Tensor &size, const Tensor &offsets, bool centered=true, bool normalized=true, bool uniform_noise=true, const char *noise="uniform") {
  auto out = EsExtractGlimpse(x.GetEsbTensor(), size.GetEsbTensor(), offsets.GetEsbTensor(), centered, normalized, uniform_noise, noise);
  return out;
}
inline Tensor ExtractGlimpseV2(const Tensor &input, const Tensor &size, const Tensor &offsets, bool centered=true, bool normalized=true, bool uniform_noise=true, const char *noise="uniform") {
  auto out = EsExtractGlimpseV2(input.GetEsbTensor(), size.GetEsbTensor(), offsets.GetEsbTensor(), centered, normalized, uniform_noise, noise);
  return out;
}
inline Tensor ExtractImagePatches(const Tensor &x, const std::vector<int64_t> &ksizes, const std::vector<int64_t> &strides, const std::vector<int64_t> &rates, const char *padding) {
  auto out = EsExtractImagePatches(x.GetEsbTensor(), ksizes.data(), static_cast<int64_t>(ksizes.size()), strides.data(), static_cast<int64_t>(strides.size()), rates.data(), static_cast<int64_t>(rates.size()), padding);
  return out;
}
inline Tensor ExtractJpegShape(const Tensor &contents, ge::DataType output_type) {
  auto out = EsExtractJpegShape(contents.GetEsbTensor(), output_type);
  return out;
}
inline Tensor ExtractVolumePatches(const Tensor &x, const std::vector<int64_t> &ksizes, const std::vector<int64_t> &strides, const char *padding) {
  auto out = EsExtractVolumePatches(x.GetEsbTensor(), ksizes.data(), static_cast<int64_t>(ksizes.size()), strides.data(), static_cast<int64_t>(strides.size()), padding);
  return out;
}
inline Tensor Eye(const Graph &owner_graph, int64_t num_rows, int64_t num_columns=0, const std::vector<int64_t> &batch_shape={}, int64_t dtype=0) {
  auto out = EsEye(owner_graph.GetEsbGraph(), num_rows, num_columns, batch_shape.data(), static_cast<int64_t>(batch_shape.size()), dtype);
  return out;
}
inline Tensor FFN(const Tensor &x, const Tensor &weight1, const Tensor &weight2, const Tensor &expert_tokens, const Tensor &bias1, const Tensor &bias2, const Tensor &scale, const Tensor &offset, const Tensor &deq_scale1, const Tensor &deq_scale2, const Tensor &antiquant_scale1, const Tensor &antiquant_scale2, const Tensor &antiquant_offset1, const Tensor &antiquant_offset2, const char *activation, int64_t inner_precise=0, int64_t output_dtype=-1, bool tokens_index_flag=false) {
  auto out = EsFFN(x.GetEsbTensor(), weight1.GetEsbTensor(), weight2.GetEsbTensor(), expert_tokens.GetEsbTensor(), bias1.GetEsbTensor(), bias2.GetEsbTensor(), scale.GetEsbTensor(), offset.GetEsbTensor(), deq_scale1.GetEsbTensor(), deq_scale2.GetEsbTensor(), antiquant_scale1.GetEsbTensor(), antiquant_scale2.GetEsbTensor(), antiquant_offset1.GetEsbTensor(), antiquant_offset2.GetEsbTensor(), activation, inner_precise, output_dtype, tokens_index_flag);
  return out;
}
inline Tensor FFT(const Tensor &x) {
  auto out = EsFFT(x.GetEsbTensor());
  return out;
}
inline Tensor FFT2D(const Tensor &x) {
  auto out = EsFFT2D(x.GetEsbTensor());
  return out;
}
struct FSRDetectionOutputOutput {
  Tensor actual_bbox_num;
  Tensor box;
};
inline FSRDetectionOutputOutput FSRDetectionOutput(const Tensor &rois, const Tensor &bbox_delta, const Tensor &score, const Tensor &im_info, const Tensor &actual_rois_num, int64_t num_classes, float score_threshold, float iou_threshold, int64_t batch_rois=1) {
  auto out = EsFSRDetectionOutput(rois.GetEsbTensor(), bbox_delta.GetEsbTensor(), score.GetEsbTensor(), im_info.GetEsbTensor(), actual_rois_num.GetEsbTensor(), num_classes, score_threshold, iou_threshold, batch_rois);
  return {out.actual_bbox_num, out.box};
}
struct FakeQuantAffineCachemaskOutput {
  Tensor y;
  Tensor mask;
};
inline FakeQuantAffineCachemaskOutput FakeQuantAffineCachemask(const Tensor &x, const Tensor &scale, const Tensor &zero_point, int64_t axis, int64_t quant_min, int64_t quant_max) {
  auto out = EsFakeQuantAffineCachemask(x.GetEsbTensor(), scale.GetEsbTensor(), zero_point.GetEsbTensor(), axis, quant_min, quant_max);
  return {out.y, out.mask};
}
inline Tensor FakeQuantWithMinMaxArgs(const Tensor &x, float min=-6.000000, float max=6.000000, int64_t num_bits=8, bool narrow_range=false) {
  auto out = EsFakeQuantWithMinMaxArgs(x.GetEsbTensor(), min, max, num_bits, narrow_range);
  return out;
}
inline Tensor FakeQuantWithMinMaxArgsGradient(const Tensor &gradients, const Tensor &x, float min=-6.000000, float max=6.000000, int64_t num_bits=8, bool narrow_range=false) {
  auto out = EsFakeQuantWithMinMaxArgsGradient(gradients.GetEsbTensor(), x.GetEsbTensor(), min, max, num_bits, narrow_range);
  return out;
}
inline Tensor FakeQuantWithMinMaxVars(const Tensor &x, const Tensor &min, const Tensor &max, int64_t num_bits=8, bool narrow_range=false) {
  auto out = EsFakeQuantWithMinMaxVars(x.GetEsbTensor(), min.GetEsbTensor(), max.GetEsbTensor(), num_bits, narrow_range);
  return out;
}
struct FakeQuantWithMinMaxVarsGradientOutput {
  Tensor backprops_wrt_x;
  Tensor backprops_wrt_min;
  Tensor backprops_wrt_max;
};
inline FakeQuantWithMinMaxVarsGradientOutput FakeQuantWithMinMaxVarsGradient(const Tensor &gradients, const Tensor &x, const Tensor &min, const Tensor &max, int64_t num_bits=8, bool narrow_range=false) {
  auto out = EsFakeQuantWithMinMaxVarsGradient(gradients.GetEsbTensor(), x.GetEsbTensor(), min.GetEsbTensor(), max.GetEsbTensor(), num_bits, narrow_range);
  return {out.backprops_wrt_x, out.backprops_wrt_min, out.backprops_wrt_max};
}
inline Tensor FakeQuantWithMinMaxVarsPerChannel(const Tensor &x, const Tensor &min, const Tensor &max, int64_t num_bits=8, bool narrow_range=false) {
  auto out = EsFakeQuantWithMinMaxVarsPerChannel(x.GetEsbTensor(), min.GetEsbTensor(), max.GetEsbTensor(), num_bits, narrow_range);
  return out;
}
struct FakeQuantWithMinMaxVarsPerChannelGradientOutput {
  Tensor backprops_wrt_x;
  Tensor backprops_wrt_min;
  Tensor backprops_wrt_max;
};
inline FakeQuantWithMinMaxVarsPerChannelGradientOutput FakeQuantWithMinMaxVarsPerChannelGradient(const Tensor &gradients, const Tensor &x, const Tensor &min, const Tensor &max, int64_t num_bits=8, bool narrow_range=false) {
  auto out = EsFakeQuantWithMinMaxVarsPerChannelGradient(gradients.GetEsbTensor(), x.GetEsbTensor(), min.GetEsbTensor(), max.GetEsbTensor(), num_bits, narrow_range);
  return {out.backprops_wrt_x, out.backprops_wrt_min, out.backprops_wrt_max};
}
inline Tensor FakeQueue(const Tensor &resource) {
  auto out = EsFakeQueue(resource.GetEsbTensor());
  return out;
}
inline Tensor FastGelu(const Tensor &x) {
  auto out = EsFastGelu(x.GetEsbTensor());
  return out;
}
inline Tensor FastGeluGrad(const Tensor &dy, const Tensor &x) {
  auto out = EsFastGeluGrad(dy.GetEsbTensor(), x.GetEsbTensor());
  return out;
}
inline Tensor FastGeluV2(const Tensor &x) {
  auto out = EsFastGeluV2(x.GetEsbTensor());
  return out;
}
struct FastrcnnPredictionsOutput {
  Tensor sorted_rois;
  Tensor sorted_scores;
  Tensor sorted_classes;
};
inline FastrcnnPredictionsOutput FastrcnnPredictions(const Tensor &rois, const Tensor &score, float nms_threshold, float score_threshold, int64_t k) {
  auto out = EsFastrcnnPredictions(rois.GetEsbTensor(), score.GetEsbTensor(), nms_threshold, score_threshold, k);
  return {out.sorted_rois, out.sorted_scores, out.sorted_classes};
}
inline Tensor FeedsRepeat(const Tensor &feeds, const Tensor &feeds_repeat_times, int64_t output_feeds_size) {
  auto out = EsFeedsRepeat(feeds.GetEsbTensor(), feeds_repeat_times.GetEsbTensor(), output_feeds_size);
  return out;
}
inline Tensor FileConstant(const Graph &owner_graph, const std::vector<int64_t> &shape, ge::DataType dtype, const char *file_path="", const char *file_id="") {
  auto out = EsFileConstant(owner_graph.GetEsbGraph(), shape.data(), static_cast<int64_t>(shape.size()), dtype, file_path, file_id);
  return out;
}
inline Tensor Fill(const Tensor &dims, const Tensor &value) {
  auto out = EsFill(dims.GetEsbTensor(), value.GetEsbTensor());
  return out;
}
inline Tensor FillD(const Tensor &value, const std::vector<int64_t> &dims) {
  auto out = EsFillD(value.GetEsbTensor(), dims.data(), static_cast<int64_t>(dims.size()));
  return out;
}
inline Tensor FillDiagonal(const Tensor &x, float fill_value, bool wrap=false) {
  auto out = EsFillDiagonal(x.GetEsbTensor(), fill_value, wrap);
  return out;
}
inline Tensor FillV2(const Tensor &dims, float value=0.000000) {
  auto out = EsFillV2(dims.GetEsbTensor(), value);
  return out;
}
inline Tensor FillV2D(const Graph &owner_graph, const std::vector<int64_t> &dims, float value=0.000000) {
  auto out = EsFillV2D(owner_graph.GetEsbGraph(), dims.data(), static_cast<int64_t>(dims.size()), value);
  return out;
}
inline Tensor FillWindowCache(const Tensor &x, const Tensor &clean_cache, int64_t axis, int64_t cache_depth) {
  auto out = EsFillWindowCache(x.GetEsbTensor(), clean_cache.GetEsbTensor(), axis, cache_depth);
  return out;
}
inline Tensor Fills(const Tensor &x, float value) {
  auto out = EsFills(x.GetEsbTensor(), value);
  return out;
}
inline Tensor Fingerprint(const Tensor &data, const Tensor &method) {
  auto out = EsFingerprint(data.GetEsbTensor(), method.GetEsbTensor());
  return out;
}
struct FixedUnigramCandidateSamplerOutput {
  Tensor sampled_candidates;
  Tensor true_expected_count;
  Tensor sampled_expected_count;
};
inline FixedUnigramCandidateSamplerOutput FixedUnigramCandidateSampler(const Tensor &true_classes, const std::vector<float> &unigrams, int64_t num_true=0, int64_t num_sampled=0, bool unique=false, int64_t range_max=0, const char *vocab_file="", float distortion=1.000000, int64_t num_reserved_ids=0, int64_t num_shards=1, int64_t shard=0, int64_t seed=0, int64_t seed2=0) {
  auto out = EsFixedUnigramCandidateSampler(true_classes.GetEsbTensor(), unigrams.data(), static_cast<int64_t>(unigrams.size()), num_true, num_sampled, unique, range_max, vocab_file, distortion, num_reserved_ids, num_shards, shard, seed, seed2);
  return {out.sampled_candidates, out.true_expected_count, out.sampled_expected_count};
}
struct FlashAttentionScoreOutput {
  Tensor softmax_max;
  Tensor softmax_sum;
  Tensor softmax_out;
  Tensor attention_out;
};
inline FlashAttentionScoreOutput FlashAttentionScore(const Tensor &query, const Tensor &key, const Tensor &value, const Tensor &real_shift, const Tensor &drop_mask, const Tensor &padding_mask, const Tensor &atten_mask, const Tensor &prefix, const Tensor &actual_seq_qlen, const Tensor &actual_seq_kvlen, const Tensor &q_start_idx, const Tensor &kv_start_idx, int64_t head_num, const char *input_layout, float scale_value=1.000000, float keep_prob=1.000000, int64_t pre_tockens=2147483647, int64_t next_tockens=2147483647, int64_t inner_precise=0, int64_t sparse_mode=0, int64_t pse_type=1) {
  auto out = EsFlashAttentionScore(query.GetEsbTensor(), key.GetEsbTensor(), value.GetEsbTensor(), real_shift.GetEsbTensor(), drop_mask.GetEsbTensor(), padding_mask.GetEsbTensor(), atten_mask.GetEsbTensor(), prefix.GetEsbTensor(), actual_seq_qlen.GetEsbTensor(), actual_seq_kvlen.GetEsbTensor(), q_start_idx.GetEsbTensor(), kv_start_idx.GetEsbTensor(), head_num, input_layout, scale_value, keep_prob, pre_tockens, next_tockens, inner_precise, sparse_mode, pse_type);
  return {out.softmax_max, out.softmax_sum, out.softmax_out, out.attention_out};
}
struct FlashAttentionScoreGradOutput {
  Tensor dq;
  Tensor dk;
  Tensor dv;
  Tensor dpse;
};
inline FlashAttentionScoreGradOutput FlashAttentionScoreGrad(const Tensor &query, const Tensor &key, const Tensor &value, const Tensor &dy, const Tensor &pse_shift, const Tensor &drop_mask, const Tensor &padding_mask, const Tensor &atten_mask, const Tensor &softmax_max, const Tensor &softmax_sum, const Tensor &softmax_in, const Tensor &attention_in, const Tensor &prefix, const Tensor &actual_seq_qlen, const Tensor &actual_seq_kvlen, const Tensor &q_start_idx, const Tensor &kv_start_idx, int64_t head_num, const char *input_layout, float scale_value=1.000000, float keep_prob=1.000000, int64_t pre_tockens=2147483647, int64_t next_tockens=2147483647, int64_t inner_precise=0, int64_t sparse_mode=0, int64_t pse_type=1) {
  auto out = EsFlashAttentionScoreGrad(query.GetEsbTensor(), key.GetEsbTensor(), value.GetEsbTensor(), dy.GetEsbTensor(), pse_shift.GetEsbTensor(), drop_mask.GetEsbTensor(), padding_mask.GetEsbTensor(), atten_mask.GetEsbTensor(), softmax_max.GetEsbTensor(), softmax_sum.GetEsbTensor(), softmax_in.GetEsbTensor(), attention_in.GetEsbTensor(), prefix.GetEsbTensor(), actual_seq_qlen.GetEsbTensor(), actual_seq_kvlen.GetEsbTensor(), q_start_idx.GetEsbTensor(), kv_start_idx.GetEsbTensor(), head_num, input_layout, scale_value, keep_prob, pre_tockens, next_tockens, inner_precise, sparse_mode, pse_type);
  return {out.dq, out.dk, out.dv, out.dpse};
}
inline Tensor Flatten(const Tensor &x, int64_t axis=1) {
  auto out = EsFlatten(x.GetEsbTensor(), axis);
  return out;
}
inline Tensor FlattenV2(const Tensor &x, int64_t axis=1, int64_t end_axis=-1) {
  auto out = EsFlattenV2(x.GetEsbTensor(), axis, end_axis);
  return out;
}
inline Tensor Floor(const Tensor &x) {
  auto out = EsFloor(x.GetEsbTensor());
  return out;
}
inline Tensor FloorDiv(const Tensor &x1, const Tensor &x2) {
  auto out = EsFloorDiv(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor FloorDiv(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return FloorDiv(tensor, b_esb_tensor);
}
inline Tensor FloorMod(const Tensor &x1, const Tensor &x2) {
  auto out = EsFloorMod(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor FloorMod(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return FloorMod(tensor, b_esb_tensor);
}
inline Tensor ForeachACosInplace(const std::vector<Tensor> &x) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachACosInplace(esb_x.data(), static_cast<int64_t>(esb_x.size()));
  return out;
}
inline Tensor ForeachASinInplace(const std::vector<Tensor> &x) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachASinInplace(esb_x.data(), static_cast<int64_t>(esb_x.size()));
  return out;
}
inline Tensor ForeachATanInplace(const std::vector<Tensor> &x) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachATanInplace(esb_x.data(), static_cast<int64_t>(esb_x.size()));
  return out;
}
inline Tensor ForeachAbsInplace(const std::vector<Tensor> &x) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachAbsInplace(esb_x.data(), static_cast<int64_t>(esb_x.size()));
  return out;
}
inline Tensor ForeachAddListInplace(const std::vector<Tensor> &x1, const std::vector<Tensor> &x2, const Tensor &alpha=nullptr) {
  auto esb_x1 = TensorsToEsbTensors(x1);
  auto esb_x2 = TensorsToEsbTensors(x2);
  auto out = EsForeachAddListInplace(esb_x1.data(), static_cast<int64_t>(esb_x1.size()), esb_x2.data(), static_cast<int64_t>(esb_x2.size()), alpha.GetEsbTensor());
  return out;
}
inline Tensor ForeachAddScalarInplace(const std::vector<Tensor> &x, const Tensor &scalar) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachAddScalarInplace(esb_x.data(), static_cast<int64_t>(esb_x.size()), scalar.GetEsbTensor());
  return out;
}
inline Tensor ForeachAddScalarListInplace(const std::vector<Tensor> &x, const Tensor &scalars) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachAddScalarListInplace(esb_x.data(), static_cast<int64_t>(esb_x.size()), scalars.GetEsbTensor());
  return out;
}
inline Tensor ForeachAddcdivListInplace(const std::vector<Tensor> &x1, const std::vector<Tensor> &x2, const std::vector<Tensor> &x3, const Tensor &scalars) {
  auto esb_x1 = TensorsToEsbTensors(x1);
  auto esb_x2 = TensorsToEsbTensors(x2);
  auto esb_x3 = TensorsToEsbTensors(x3);
  auto out = EsForeachAddcdivListInplace(esb_x1.data(), static_cast<int64_t>(esb_x1.size()), esb_x2.data(), static_cast<int64_t>(esb_x2.size()), esb_x3.data(), static_cast<int64_t>(esb_x3.size()), scalars.GetEsbTensor());
  return out;
}
inline Tensor ForeachAddcdivScalarInplace(const std::vector<Tensor> &x1, const std::vector<Tensor> &x2, const std::vector<Tensor> &x3, const Tensor &scalars) {
  auto esb_x1 = TensorsToEsbTensors(x1);
  auto esb_x2 = TensorsToEsbTensors(x2);
  auto esb_x3 = TensorsToEsbTensors(x3);
  auto out = EsForeachAddcdivScalarInplace(esb_x1.data(), static_cast<int64_t>(esb_x1.size()), esb_x2.data(), static_cast<int64_t>(esb_x2.size()), esb_x3.data(), static_cast<int64_t>(esb_x3.size()), scalars.GetEsbTensor());
  return out;
}
inline Tensor ForeachAddcmulListInplace(const std::vector<Tensor> &x1, const std::vector<Tensor> &x2, const std::vector<Tensor> &x3, const Tensor &scalars) {
  auto esb_x1 = TensorsToEsbTensors(x1);
  auto esb_x2 = TensorsToEsbTensors(x2);
  auto esb_x3 = TensorsToEsbTensors(x3);
  auto out = EsForeachAddcmulListInplace(esb_x1.data(), static_cast<int64_t>(esb_x1.size()), esb_x2.data(), static_cast<int64_t>(esb_x2.size()), esb_x3.data(), static_cast<int64_t>(esb_x3.size()), scalars.GetEsbTensor());
  return out;
}
inline Tensor ForeachAddcmulScalarInplace(const std::vector<Tensor> &x1, const std::vector<Tensor> &x2, const std::vector<Tensor> &x3, const Tensor &scalar) {
  auto esb_x1 = TensorsToEsbTensors(x1);
  auto esb_x2 = TensorsToEsbTensors(x2);
  auto esb_x3 = TensorsToEsbTensors(x3);
  auto out = EsForeachAddcmulScalarInplace(esb_x1.data(), static_cast<int64_t>(esb_x1.size()), esb_x2.data(), static_cast<int64_t>(esb_x2.size()), esb_x3.data(), static_cast<int64_t>(esb_x3.size()), scalar.GetEsbTensor());
  return out;
}
inline Tensor ForeachCosInplace(const std::vector<Tensor> &x) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachCosInplace(esb_x.data(), static_cast<int64_t>(esb_x.size()));
  return out;
}
inline Tensor ForeachCoshInplace(const std::vector<Tensor> &x) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachCoshInplace(esb_x.data(), static_cast<int64_t>(esb_x.size()));
  return out;
}
inline Tensor ForeachDivListInplace(const std::vector<Tensor> &x1, const std::vector<Tensor> &x2) {
  auto esb_x1 = TensorsToEsbTensors(x1);
  auto esb_x2 = TensorsToEsbTensors(x2);
  auto out = EsForeachDivListInplace(esb_x1.data(), static_cast<int64_t>(esb_x1.size()), esb_x2.data(), static_cast<int64_t>(esb_x2.size()));
  return out;
}
inline Tensor ForeachDivScalarInplace(const std::vector<Tensor> &x, const Tensor &scalar) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachDivScalarInplace(esb_x.data(), static_cast<int64_t>(esb_x.size()), scalar.GetEsbTensor());
  return out;
}
inline Tensor ForeachDivScalarListInplace(const std::vector<Tensor> &x, const Tensor &scalars) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachDivScalarListInplace(esb_x.data(), static_cast<int64_t>(esb_x.size()), scalars.GetEsbTensor());
  return out;
}
inline Tensor ForeachExpInplace(const std::vector<Tensor> &x) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachExpInplace(esb_x.data(), static_cast<int64_t>(esb_x.size()));
  return out;
}
inline Tensor ForeachExpm1Inplace(const std::vector<Tensor> &x) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachExpm1Inplace(esb_x.data(), static_cast<int64_t>(esb_x.size()));
  return out;
}
inline Tensor ForeachLerpListInplace(const std::vector<Tensor> &x1, const std::vector<Tensor> &x2, const Tensor &weights) {
  auto esb_x1 = TensorsToEsbTensors(x1);
  auto esb_x2 = TensorsToEsbTensors(x2);
  auto out = EsForeachLerpListInplace(esb_x1.data(), static_cast<int64_t>(esb_x1.size()), esb_x2.data(), static_cast<int64_t>(esb_x2.size()), weights.GetEsbTensor());
  return out;
}
inline Tensor ForeachLerpScalarInplace(const std::vector<Tensor> &x1, const std::vector<Tensor> &x2, const Tensor &weight) {
  auto esb_x1 = TensorsToEsbTensors(x1);
  auto esb_x2 = TensorsToEsbTensors(x2);
  auto out = EsForeachLerpScalarInplace(esb_x1.data(), static_cast<int64_t>(esb_x1.size()), esb_x2.data(), static_cast<int64_t>(esb_x2.size()), weight.GetEsbTensor());
  return out;
}
inline Tensor ForeachLog10Inplace(const std::vector<Tensor> &x) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachLog10Inplace(esb_x.data(), static_cast<int64_t>(esb_x.size()));
  return out;
}
inline Tensor ForeachLog1pInplace(const std::vector<Tensor> &x) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachLog1pInplace(esb_x.data(), static_cast<int64_t>(esb_x.size()));
  return out;
}
inline Tensor ForeachLog2Inplace(const std::vector<Tensor> &x) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachLog2Inplace(esb_x.data(), static_cast<int64_t>(esb_x.size()));
  return out;
}
inline Tensor ForeachLogInplace(const std::vector<Tensor> &x) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachLogInplace(esb_x.data(), static_cast<int64_t>(esb_x.size()));
  return out;
}
inline Tensor ForeachMaximumListInplace(const std::vector<Tensor> &x1, const std::vector<Tensor> &x2) {
  auto esb_x1 = TensorsToEsbTensors(x1);
  auto esb_x2 = TensorsToEsbTensors(x2);
  auto out = EsForeachMaximumListInplace(esb_x1.data(), static_cast<int64_t>(esb_x1.size()), esb_x2.data(), static_cast<int64_t>(esb_x2.size()));
  return out;
}
inline Tensor ForeachMaximumScalarInplace(const std::vector<Tensor> &x, const Tensor &scalar) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachMaximumScalarInplace(esb_x.data(), static_cast<int64_t>(esb_x.size()), scalar.GetEsbTensor());
  return out;
}
inline Tensor ForeachMaximumScalarListInplace(const std::vector<Tensor> &x, const Tensor &scalars) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachMaximumScalarListInplace(esb_x.data(), static_cast<int64_t>(esb_x.size()), scalars.GetEsbTensor());
  return out;
}
inline Tensor ForeachMinimumListInplace(const std::vector<Tensor> &x1, const std::vector<Tensor> &x2) {
  auto esb_x1 = TensorsToEsbTensors(x1);
  auto esb_x2 = TensorsToEsbTensors(x2);
  auto out = EsForeachMinimumListInplace(esb_x1.data(), static_cast<int64_t>(esb_x1.size()), esb_x2.data(), static_cast<int64_t>(esb_x2.size()));
  return out;
}
inline Tensor ForeachMinimumScalarInplace(const std::vector<Tensor> &x, const Tensor &scalar) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachMinimumScalarInplace(esb_x.data(), static_cast<int64_t>(esb_x.size()), scalar.GetEsbTensor());
  return out;
}
inline Tensor ForeachMinimumScalarListInplace(const std::vector<Tensor> &x, const Tensor &scalars) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachMinimumScalarListInplace(esb_x.data(), static_cast<int64_t>(esb_x.size()), scalars.GetEsbTensor());
  return out;
}
inline Tensor ForeachMulListInplace(const std::vector<Tensor> &x1, const std::vector<Tensor> &x2) {
  auto esb_x1 = TensorsToEsbTensors(x1);
  auto esb_x2 = TensorsToEsbTensors(x2);
  auto out = EsForeachMulListInplace(esb_x1.data(), static_cast<int64_t>(esb_x1.size()), esb_x2.data(), static_cast<int64_t>(esb_x2.size()));
  return out;
}
inline Tensor ForeachMulScalarInplace(const std::vector<Tensor> &x, const Tensor &scalar) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachMulScalarInplace(esb_x.data(), static_cast<int64_t>(esb_x.size()), scalar.GetEsbTensor());
  return out;
}
inline Tensor ForeachMulScalarListInplace(const std::vector<Tensor> &x, const Tensor &scalars) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachMulScalarListInplace(esb_x.data(), static_cast<int64_t>(esb_x.size()), scalars.GetEsbTensor());
  return out;
}
inline Tensor ForeachNegInplace(const std::vector<Tensor> &x) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachNegInplace(esb_x.data(), static_cast<int64_t>(esb_x.size()));
  return out;
}
inline Tensor ForeachNonFiniteCheckAndUnscale(const std::vector<Tensor> &scaled_grads, const Tensor &found_inf, const Tensor &inv_scale) {
  auto esb_scaled_grads = TensorsToEsbTensors(scaled_grads);
  auto out = EsForeachNonFiniteCheckAndUnscale(esb_scaled_grads.data(), static_cast<int64_t>(esb_scaled_grads.size()), found_inf.GetEsbTensor(), inv_scale.GetEsbTensor());
  return out;
}
inline Tensor ForeachPowListInplace(const std::vector<Tensor> &x1, const std::vector<Tensor> &x2) {
  auto esb_x1 = TensorsToEsbTensors(x1);
  auto esb_x2 = TensorsToEsbTensors(x2);
  auto out = EsForeachPowListInplace(esb_x1.data(), static_cast<int64_t>(esb_x1.size()), esb_x2.data(), static_cast<int64_t>(esb_x2.size()));
  return out;
}
inline Tensor ForeachPowScalarInplace(const std::vector<Tensor> &x, const Tensor &scalar) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachPowScalarInplace(esb_x.data(), static_cast<int64_t>(esb_x.size()), scalar.GetEsbTensor());
  return out;
}
inline Tensor ForeachPowScalarListInplace(const std::vector<Tensor> &x, const Tensor &scalars) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachPowScalarListInplace(esb_x.data(), static_cast<int64_t>(esb_x.size()), scalars.GetEsbTensor());
  return out;
}
inline Tensor ForeachReciprocalInplace(const std::vector<Tensor> &x) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachReciprocalInplace(esb_x.data(), static_cast<int64_t>(esb_x.size()));
  return out;
}
inline Tensor ForeachRoundOffNumberInplace(const std::vector<Tensor> &x, const Tensor &roundMode) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachRoundOffNumberInplace(esb_x.data(), static_cast<int64_t>(esb_x.size()), roundMode.GetEsbTensor());
  return out;
}
inline Tensor ForeachSigmoidInplace(const std::vector<Tensor> &x) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachSigmoidInplace(esb_x.data(), static_cast<int64_t>(esb_x.size()));
  return out;
}
inline Tensor ForeachSignInplace(const std::vector<Tensor> &x) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachSignInplace(esb_x.data(), static_cast<int64_t>(esb_x.size()));
  return out;
}
inline Tensor ForeachSinInplace(const std::vector<Tensor> &x) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachSinInplace(esb_x.data(), static_cast<int64_t>(esb_x.size()));
  return out;
}
inline Tensor ForeachSinhInplace(const std::vector<Tensor> &x) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachSinhInplace(esb_x.data(), static_cast<int64_t>(esb_x.size()));
  return out;
}
inline Tensor ForeachSqrtInplace(const std::vector<Tensor> &x) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachSqrtInplace(esb_x.data(), static_cast<int64_t>(esb_x.size()));
  return out;
}
inline Tensor ForeachSubListInplace(const std::vector<Tensor> &x1, const std::vector<Tensor> &x2, const Tensor &alpha=nullptr) {
  auto esb_x1 = TensorsToEsbTensors(x1);
  auto esb_x2 = TensorsToEsbTensors(x2);
  auto out = EsForeachSubListInplace(esb_x1.data(), static_cast<int64_t>(esb_x1.size()), esb_x2.data(), static_cast<int64_t>(esb_x2.size()), alpha.GetEsbTensor());
  return out;
}
inline Tensor ForeachSubScalarInplace(const std::vector<Tensor> &x, const Tensor &scalar) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachSubScalarInplace(esb_x.data(), static_cast<int64_t>(esb_x.size()), scalar.GetEsbTensor());
  return out;
}
inline Tensor ForeachSubScalarListInplace(const std::vector<Tensor> &x, const Tensor &scalars) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachSubScalarListInplace(esb_x.data(), static_cast<int64_t>(esb_x.size()), scalars.GetEsbTensor());
  return out;
}
inline Tensor ForeachTanInplace(const std::vector<Tensor> &x) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachTanInplace(esb_x.data(), static_cast<int64_t>(esb_x.size()));
  return out;
}
inline Tensor ForeachTanhInplace(const std::vector<Tensor> &x) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachTanhInplace(esb_x.data(), static_cast<int64_t>(esb_x.size()));
  return out;
}
inline Tensor ForeachZeroInplace(const std::vector<Tensor> &x) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsForeachZeroInplace(esb_x.data(), static_cast<int64_t>(esb_x.size()));
  return out;
}
struct FractionalAvgPoolOutput {
  Tensor y;
  Tensor row_pooling_sequence;
  Tensor col_pooling_sequence;
};
inline FractionalAvgPoolOutput FractionalAvgPool(const Tensor &x, const std::vector<float> &pooling_ratio={}, bool pseudo_random=false, bool overlapping=false, bool deterministic=false, int64_t seed=0, int64_t seed2=0) {
  auto out = EsFractionalAvgPool(x.GetEsbTensor(), pooling_ratio.data(), static_cast<int64_t>(pooling_ratio.size()), pseudo_random, overlapping, deterministic, seed, seed2);
  return {out.y, out.row_pooling_sequence, out.col_pooling_sequence};
}
inline Tensor FractionalAvgPoolGrad(const Tensor &orig_input_tensor_shape, const Tensor &out_backprop, const Tensor &row_pooling_sequence, const Tensor &col_pooling_sequence, bool overlapping=false) {
  auto out = EsFractionalAvgPoolGrad(orig_input_tensor_shape.GetEsbTensor(), out_backprop.GetEsbTensor(), row_pooling_sequence.GetEsbTensor(), col_pooling_sequence.GetEsbTensor(), overlapping);
  return out;
}
struct FractionalMaxPoolOutput {
  Tensor y;
  Tensor row_pooling_sequence;
  Tensor col_pooling_sequence;
};
inline FractionalMaxPoolOutput FractionalMaxPool(const Tensor &x, const std::vector<float> &pooling_ratio={}, bool pseudo_random=false, bool overlapping=false, bool deterministic=false, int64_t seed=0, int64_t seed2=0) {
  auto out = EsFractionalMaxPool(x.GetEsbTensor(), pooling_ratio.data(), static_cast<int64_t>(pooling_ratio.size()), pseudo_random, overlapping, deterministic, seed, seed2);
  return {out.y, out.row_pooling_sequence, out.col_pooling_sequence};
}
inline Tensor FractionalMaxPoolGrad(const Tensor &orig_input, const Tensor &orig_output, const Tensor &out_backprop, const Tensor &row_pooling_sequence, const Tensor &col_pooling_sequence, bool overlapping=false) {
  auto out = EsFractionalMaxPoolGrad(orig_input.GetEsbTensor(), orig_output.GetEsbTensor(), out_backprop.GetEsbTensor(), row_pooling_sequence.GetEsbTensor(), col_pooling_sequence.GetEsbTensor(), overlapping);
  return out;
}
inline Tensor FresnelCos(const Tensor &x) {
  auto out = EsFresnelCos(x.GetEsbTensor());
  return out;
}
inline Tensor FresnelSin(const Tensor &x) {
  auto out = EsFresnelSin(x.GetEsbTensor());
  return out;
}
inline Tensor FullyConnection(const Tensor &x, const Tensor &w, const Tensor &b, const Tensor &offset_w, int64_t num_output, bool transpose=false, int64_t axis=1, int64_t offset_x=0) {
  auto out = EsFullyConnection(x.GetEsbTensor(), w.GetEsbTensor(), b.GetEsbTensor(), offset_w.GetEsbTensor(), num_output, transpose, axis, offset_x);
  return out;
}
inline Tensor FullyConnectionCompress(const Tensor &x, const Tensor &w, const Tensor &comress_index, const Tensor &b, const Tensor &offset_w, int64_t num_output, bool transpose=false, int64_t axis=1, int64_t offset_x=0) {
  auto out = EsFullyConnectionCompress(x.GetEsbTensor(), w.GetEsbTensor(), comress_index.GetEsbTensor(), b.GetEsbTensor(), offset_w.GetEsbTensor(), num_output, transpose, axis, offset_x);
  return out;
}
struct FusedBatchNormV2Output {
  Tensor y;
  Tensor batch_mean;
  Tensor batch_variance;
  Tensor reserve_space_1;
  Tensor reserve_space_2;
};
inline FusedBatchNormV2Output FusedBatchNormV2(const Tensor &x, const Tensor &scale, const Tensor &offset, const Tensor &mean=nullptr, const Tensor &variance=nullptr, float epsilon=0.000100, const char *data_format="NHWC", bool is_training=true, float exponential_avg_factor=1.000000) {
  auto out = EsFusedBatchNormV2(x.GetEsbTensor(), scale.GetEsbTensor(), offset.GetEsbTensor(), mean.GetEsbTensor(), variance.GetEsbTensor(), epsilon, data_format, is_training, exponential_avg_factor);
  return {out.y, out.batch_mean, out.batch_variance, out.reserve_space_1, out.reserve_space_2};
}
inline Tensor FusedBiasLeakyRelu(const Tensor &x, const Tensor &bias, float negative_slope=0.200000, float scale=1.414214) {
  auto out = EsFusedBiasLeakyRelu(x.GetEsbTensor(), bias.GetEsbTensor(), negative_slope, scale);
  return out;
}
inline Tensor FusedBiasLeakyReluGrad(const Tensor &y_grad, const Tensor &features, float negative_slope=0.200000, float scale=1.414214) {
  auto out = EsFusedBiasLeakyReluGrad(y_grad.GetEsbTensor(), features.GetEsbTensor(), negative_slope, scale);
  return out;
}
struct FusedInferAttentionScoreOutput {
  Tensor attention_out;
  Tensor softmax_lse;
};
inline FusedInferAttentionScoreOutput FusedInferAttentionScore(const Tensor &query, const std::vector<Tensor> &key, const std::vector<Tensor> &value, const Tensor &pse_shift, const Tensor &atten_mask, const Tensor &actual_seq_lengths, const Tensor &actual_seq_lengths_kv, const Tensor &dequant_scale1, const Tensor &quant_scale1, const Tensor &dequant_scale2, const Tensor &quant_scale2, const Tensor &quant_offset2, const Tensor &antiquant_scale, const Tensor &antiquant_offset, const Tensor &block_table, const Tensor &query_padding_size, const Tensor &kv_padding_size, const Tensor &key_antiquant_scale, const Tensor &key_antiquant_offset, const Tensor &value_antiquant_scale, const Tensor &value_antiquant_offset, const Tensor &key_shared_prefix, const Tensor &value_shared_prefix, const Tensor &actual_shared_prefix_len, int64_t num_heads, float scale=1.000000, int64_t pre_tokens=2147483647, int64_t next_tokens=2147483647, const char *input_layout="BSH", int64_t num_key_value_heads=0, int64_t sparse_mode=0, int64_t inner_precise=1, int64_t block_size=0, int64_t antiquant_mode=0, bool softmax_lse_flag=false, int64_t key_antiquant_mode=0, int64_t value_antiquant_mode=0) {
  auto esb_key = TensorsToEsbTensors(key);
  auto esb_value = TensorsToEsbTensors(value);
  auto out = EsFusedInferAttentionScore(query.GetEsbTensor(), esb_key.data(), static_cast<int64_t>(esb_key.size()), esb_value.data(), static_cast<int64_t>(esb_value.size()), pse_shift.GetEsbTensor(), atten_mask.GetEsbTensor(), actual_seq_lengths.GetEsbTensor(), actual_seq_lengths_kv.GetEsbTensor(), dequant_scale1.GetEsbTensor(), quant_scale1.GetEsbTensor(), dequant_scale2.GetEsbTensor(), quant_scale2.GetEsbTensor(), quant_offset2.GetEsbTensor(), antiquant_scale.GetEsbTensor(), antiquant_offset.GetEsbTensor(), block_table.GetEsbTensor(), query_padding_size.GetEsbTensor(), kv_padding_size.GetEsbTensor(), key_antiquant_scale.GetEsbTensor(), key_antiquant_offset.GetEsbTensor(), value_antiquant_scale.GetEsbTensor(), value_antiquant_offset.GetEsbTensor(), key_shared_prefix.GetEsbTensor(), value_shared_prefix.GetEsbTensor(), actual_shared_prefix_len.GetEsbTensor(), num_heads, scale, pre_tokens, next_tokens, input_layout, num_key_value_heads, sparse_mode, inner_precise, block_size, antiquant_mode, softmax_lse_flag, key_antiquant_mode, value_antiquant_mode);
  return {out.attention_out, out.softmax_lse};
}
inline Tensor FusedMulAdd(const Tensor &x1, const Tensor &x2, const Tensor &x3) {
  auto out = EsFusedMulAdd(x1.GetEsbTensor(), x2.GetEsbTensor(), x3.GetEsbTensor());
  return out;
}
inline Tensor FusedMulAddAdd(const Tensor &x1, const Tensor &x2, const Tensor &x3, const Tensor &x4) {
  auto out = EsFusedMulAddAdd(x1.GetEsbTensor(), x2.GetEsbTensor(), x3.GetEsbTensor(), x4.GetEsbTensor());
  return out;
}
inline Tensor FusedMulAddN(const Tensor &x1, const Tensor &x2, const Tensor &x3) {
  auto out = EsFusedMulAddN(x1.GetEsbTensor(), x2.GetEsbTensor(), x3.GetEsbTensor());
  return out;
}
struct FusedMulAddNL2lossOutput {
  Tensor y1;
  Tensor y2;
};
inline FusedMulAddNL2lossOutput FusedMulAddNL2loss(const Tensor &x1, const Tensor &x2, const Tensor &x3) {
  auto out = EsFusedMulAddNL2loss(x1.GetEsbTensor(), x2.GetEsbTensor(), x3.GetEsbTensor());
  return {out.y1, out.y2};
}
struct FusedMulApplyKerasMomentumOutput {
  Tensor var;
  Tensor accum;
};
inline FusedMulApplyKerasMomentumOutput FusedMulApplyKerasMomentum(const Tensor &var, const Tensor &accum, const Tensor &lr, const Tensor &x1, const Tensor &momentum, const Tensor &x2, bool use_locking=false, bool use_nesterov=false) {
  auto out = EsFusedMulApplyKerasMomentum(var.GetEsbTensor(), accum.GetEsbTensor(), lr.GetEsbTensor(), x1.GetEsbTensor(), momentum.GetEsbTensor(), x2.GetEsbTensor(), use_locking, use_nesterov);
  return {out.var, out.accum};
}
struct FusedMulApplyMomentumOutput {
  Tensor var;
  Tensor accum;
};
inline FusedMulApplyMomentumOutput FusedMulApplyMomentum(const Tensor &var, const Tensor &accum, const Tensor &lr, const Tensor &x1, const Tensor &momentum, const Tensor &x2, bool use_nesterov=false, bool use_locking=false) {
  auto out = EsFusedMulApplyMomentum(var.GetEsbTensor(), accum.GetEsbTensor(), lr.GetEsbTensor(), x1.GetEsbTensor(), momentum.GetEsbTensor(), x2.GetEsbTensor(), use_nesterov, use_locking);
  return {out.var, out.accum};
}
struct FusedMulApplyMomentumExternOutput {
  Tensor var;
  Tensor var_copy;
  Tensor accum;
};
inline FusedMulApplyMomentumExternOutput FusedMulApplyMomentumExtern(const Tensor &var, const Tensor &accum, const Tensor &lr, const Tensor &x1, const Tensor &momentum, const Tensor &x2, const Tensor &var_copy, bool use_nesterov=false, bool use_locking=false) {
  auto out = EsFusedMulApplyMomentumExtern(var.GetEsbTensor(), accum.GetEsbTensor(), lr.GetEsbTensor(), x1.GetEsbTensor(), momentum.GetEsbTensor(), x2.GetEsbTensor(), var_copy.GetEsbTensor(), use_nesterov, use_locking);
  return {out.var, out.var_copy, out.accum};
}
inline Tensor GEMM(const Tensor &a, const Tensor &b, const Tensor &c, const Tensor &alpha, const Tensor &beta, bool transpose_a=false, bool transpose_b=false) {
  auto out = EsGEMM(a.GetEsbTensor(), b.GetEsbTensor(), c.GetEsbTensor(), alpha.GetEsbTensor(), beta.GetEsbTensor(), transpose_a, transpose_b);
  return out;
}
inline Tensor GIoU(const Tensor &bboxes, const Tensor &gtboxes, bool trans=false, bool is_cross=true, const char *mode="iou") {
  auto out = EsGIoU(bboxes.GetEsbTensor(), gtboxes.GetEsbTensor(), trans, is_cross, mode);
  return out;
}
struct GIoUGradOutput {
  Tensor dbboxes;
  Tensor dgtboxes;
};
inline GIoUGradOutput GIoUGrad(const Tensor &dy, const Tensor &bboxes, const Tensor &gtboxes, bool trans=false, bool is_cross=true, const char *mode="iou") {
  auto out = EsGIoUGrad(dy.GetEsbTensor(), bboxes.GetEsbTensor(), gtboxes.GetEsbTensor(), trans, is_cross, mode);
  return {out.dbboxes, out.dgtboxes};
}
inline Tensor GLU(const Tensor &x, int64_t dim=-1) {
  auto out = EsGLU(x.GetEsbTensor(), dim);
  return out;
}
inline Tensor GLUGrad(const Tensor &y_grad, const Tensor &x, int64_t dim=-1) {
  auto out = EsGLUGrad(y_grad.GetEsbTensor(), x.GetEsbTensor(), dim);
  return out;
}
struct GNTrainingReduceOutput {
  Tensor sum;
  Tensor square_sum;
};
inline GNTrainingReduceOutput GNTrainingReduce(const Tensor &x, int64_t num_groups=2) {
  auto out = EsGNTrainingReduce(x.GetEsbTensor(), num_groups);
  return {out.sum, out.square_sum};
}
struct GNTrainingUpdateOutput {
  Tensor y;
  Tensor batch_mean;
  Tensor batch_variance;
};
inline GNTrainingUpdateOutput GNTrainingUpdate(const Tensor &x, const Tensor &sum, const Tensor &square_sum, const Tensor &scale=nullptr, const Tensor &offset=nullptr, const Tensor &mean=nullptr, const Tensor &variance=nullptr, int64_t num_groups=2, float epsilon=0.000100) {
  auto out = EsGNTrainingUpdate(x.GetEsbTensor(), sum.GetEsbTensor(), square_sum.GetEsbTensor(), scale.GetEsbTensor(), offset.GetEsbTensor(), mean.GetEsbTensor(), variance.GetEsbTensor(), num_groups, epsilon);
  return {out.y, out.batch_mean, out.batch_variance};
}
struct GRUV2HiddenGradCellOutput {
  Tensor dh_prev;
  Tensor dgate_h;
  Tensor dnt_x;
};
inline GRUV2HiddenGradCellOutput GRUV2HiddenGradCell(const Tensor &dh_pre_t, const Tensor &h, const Tensor &dy, const Tensor &dh, const Tensor &update, const Tensor &reset, const Tensor &in_new, const Tensor &hidden_new, const Tensor &seq_length=nullptr, int64_t t_state=0, const char *gate_order="zrh") {
  auto out = EsGRUV2HiddenGradCell(dh_pre_t.GetEsbTensor(), h.GetEsbTensor(), dy.GetEsbTensor(), dh.GetEsbTensor(), update.GetEsbTensor(), reset.GetEsbTensor(), in_new.GetEsbTensor(), hidden_new.GetEsbTensor(), seq_length.GetEsbTensor(), t_state, gate_order);
  return {out.dh_prev, out.dgate_h, out.dnt_x};
}
inline Tensor Gather(const Tensor &x, const Tensor &indices, bool validate_indices=true, int64_t batch_dims=0, bool is_preprocessed=false, bool negative_index_support=false) {
  auto out = EsGather(x.GetEsbTensor(), indices.GetEsbTensor(), validate_indices, batch_dims, is_preprocessed, negative_index_support);
  return out;
}
inline Tensor GatherElements(const Tensor &x, const Tensor &index, int64_t dim=0) {
  auto out = EsGatherElements(x.GetEsbTensor(), index.GetEsbTensor(), dim);
  return out;
}
inline Tensor GatherNd(const Tensor &x, const Tensor &indices, bool negative_index_support=false) {
  auto out = EsGatherNd(x.GetEsbTensor(), indices.GetEsbTensor(), negative_index_support);
  return out;
}
inline Tensor GatherV2(const Tensor &x, const Tensor &indices, const Tensor &axis, int64_t batch_dims=0, bool is_preprocessed=false, bool negative_index_support=false) {
  auto out = EsGatherV2(x.GetEsbTensor(), indices.GetEsbTensor(), axis.GetEsbTensor(), batch_dims, is_preprocessed, negative_index_support);
  return out;
}
inline Tensor GatherV2D(const Tensor &x, const Tensor &indices, int64_t axis) {
  auto out = EsGatherV2D(x.GetEsbTensor(), indices.GetEsbTensor(), axis);
  return out;
}
inline Tensor GaussianBlur(const Tensor &x, const std::vector<int64_t> &kernel_size, const std::vector<float> &sigma, const char *padding_mode="constant") {
  auto out = EsGaussianBlur(x.GetEsbTensor(), kernel_size.data(), static_cast<int64_t>(kernel_size.size()), sigma.data(), static_cast<int64_t>(sigma.size()), padding_mode);
  return out;
}
inline Tensor Gcd(const Tensor &x1, const Tensor &x2) {
  auto out = EsGcd(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor Gcd(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return Gcd(tensor, b_esb_tensor);
}
inline Tensor GeGluGradV2(const Tensor &dy, const Tensor &x, const Tensor &gelu, int64_t dim=-1, int64_t approximate=1, bool activate_left=false) {
  auto out = EsGeGluGradV2(dy.GetEsbTensor(), x.GetEsbTensor(), gelu.GetEsbTensor(), dim, approximate, activate_left);
  return out;
}
struct GeGluV2Output {
  Tensor y;
  Tensor gelu;
};
inline GeGluV2Output GeGluV2(const Tensor &x, int64_t dim=-1, int64_t approximate=1, bool activate_left=false) {
  auto out = EsGeGluV2(x.GetEsbTensor(), dim, approximate, activate_left);
  return {out.y, out.gelu};
}
inline Tensor Gelu(const Tensor &x) {
  auto out = EsGelu(x.GetEsbTensor());
  return out;
}
inline Tensor GeluGrad(const Tensor &dy, const Tensor &x, const Tensor &y) {
  auto out = EsGeluGrad(dy.GetEsbTensor(), x.GetEsbTensor(), y.GetEsbTensor());
  return out;
}
inline Tensor GeluGradV2(const Tensor &dy, const Tensor &x, const char *approximate="none") {
  auto out = EsGeluGradV2(dy.GetEsbTensor(), x.GetEsbTensor(), approximate);
  return out;
}
struct GeluQuantOutput {
  Tensor y;
  Tensor out_scale;
};
inline GeluQuantOutput GeluQuant(const Tensor &x, const Tensor &input_scale=nullptr, const Tensor &input_offset=nullptr, const char *approximate="none", const char *quant_mode="dynamic") {
  auto out = EsGeluQuant(x.GetEsbTensor(), input_scale.GetEsbTensor(), input_offset.GetEsbTensor(), approximate, quant_mode);
  return {out.y, out.out_scale};
}
inline Tensor GeluV2(const Tensor &x, const char *approximate="none") {
  auto out = EsGeluV2(x.GetEsbTensor(), approximate);
  return out;
}
inline Tensor GemmV2(const Tensor &a, const Tensor &b, const Tensor &alpha, const Tensor &beta, const Tensor &c, bool transpose_a=false, bool transpose_b=false) {
  auto out = EsGemmV2(a.GetEsbTensor(), b.GetEsbTensor(), alpha.GetEsbTensor(), beta.GetEsbTensor(), c.GetEsbTensor(), transpose_a, transpose_b);
  return out;
}
inline Tensor GenADC(const Tensor &query, const Tensor &code_book, const Tensor &centroids, const Tensor &bucket_list, const char *distance_type="l2sqr") {
  auto out = EsGenADC(query.GetEsbTensor(), code_book.GetEsbTensor(), centroids.GetEsbTensor(), bucket_list.GetEsbTensor(), distance_type);
  return out;
}
struct GenerateBoundingBoxProposalsOutput {
  Tensor rois;
  Tensor rois_probabilities;
};
inline GenerateBoundingBoxProposalsOutput GenerateBoundingBoxProposals(const Tensor &scores, const Tensor &bbox_deltas, const Tensor &image_info, const Tensor &anchors, const Tensor &nms_threshold, const Tensor &pre_nms_topn, const Tensor &min_size, int64_t post_nms_topn=300) {
  auto out = EsGenerateBoundingBoxProposals(scores.GetEsbTensor(), bbox_deltas.GetEsbTensor(), image_info.GetEsbTensor(), anchors.GetEsbTensor(), nms_threshold.GetEsbTensor(), pre_nms_topn.GetEsbTensor(), min_size.GetEsbTensor(), post_nms_topn);
  return {out.rois, out.rois_probabilities};
}
inline Tensor Geometric(const Tensor &x, float p, int64_t seed=0) {
  auto out = EsGeometric(x.GetEsbTensor(), p, seed);
  return out;
}
inline Tensor Ger(const Tensor &x1, const Tensor &x2) {
  auto out = EsGer(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
inline Tensor GetDynamicDims(const std::vector<Tensor> &input, const std::vector<int64_t> &shape_info, int64_t N) {
  auto esb_input = TensorsToEsbTensors(input);
  auto out = EsGetDynamicDims(esb_input.data(), static_cast<int64_t>(esb_input.size()), shape_info.data(), static_cast<int64_t>(shape_info.size()), N);
  return out;
}
inline Tensor GetShape(const std::vector<Tensor> &x) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsGetShape(esb_x.data(), static_cast<int64_t>(esb_x.size()));
  return out;
}
inline Tensor GlobalAveragePool(const Tensor &x) {
  auto out = EsGlobalAveragePool(x.GetEsbTensor());
  return out;
}
inline Tensor GlobalLpPool(const Tensor &x, float p=2.000000) {
  auto out = EsGlobalLpPool(x.GetEsbTensor(), p);
  return out;
}
inline Tensor Greater(const Tensor &x1, const Tensor &x2) {
  auto out = EsGreater(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor Greater(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return Greater(tensor, b_esb_tensor);
}
inline Tensor GreaterEqual(const Tensor &x1, const Tensor &x2) {
  auto out = EsGreaterEqual(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor GreaterEqual(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return GreaterEqual(tensor, b_esb_tensor);
}
inline Tensor GridAssignPositive(const Tensor &assigned_gt_inds, const Tensor &overlaps, const Tensor &box_responsible_flags, const Tensor &max_overlaps, const Tensor &argmax_overlaps, const Tensor &gt_max_overlaps, const Tensor &gt_argmax_overlaps, const Tensor &num_gts, float pos_iou_thr, float min_pos_iou, bool gt_max_assign_all) {
  auto out = EsGridAssignPositive(assigned_gt_inds.GetEsbTensor(), overlaps.GetEsbTensor(), box_responsible_flags.GetEsbTensor(), max_overlaps.GetEsbTensor(), argmax_overlaps.GetEsbTensor(), gt_max_overlaps.GetEsbTensor(), gt_argmax_overlaps.GetEsbTensor(), num_gts.GetEsbTensor(), pos_iou_thr, min_pos_iou, gt_max_assign_all);
  return out;
}
inline Tensor GridSample(const Tensor &x, const Tensor &grid, const char *interpolation_mode="bilinear", const char *padding_mode="zeros", bool align_corners=false, bool channel_last=false, int64_t scheduler_mode=1) {
  auto out = EsGridSample(x.GetEsbTensor(), grid.GetEsbTensor(), interpolation_mode, padding_mode, align_corners, channel_last, scheduler_mode);
  return out;
}
inline Tensor GridSampler2D(const Tensor &x, const Tensor &grid, const char *interpolation_mode="bilinear", const char *padding_mode="zeros", bool align_corners=false) {
  auto out = EsGridSampler2D(x.GetEsbTensor(), grid.GetEsbTensor(), interpolation_mode, padding_mode, align_corners);
  return out;
}
struct GridSampler2DGradOutput {
  Tensor dx;
  Tensor dgrid;
};
inline GridSampler2DGradOutput GridSampler2DGrad(const Tensor &grad, const Tensor &x, const Tensor &grid, const char *interpolation_mode="bilinear", const char *padding_mode="zeros", bool align_corners=false) {
  auto out = EsGridSampler2DGrad(grad.GetEsbTensor(), x.GetEsbTensor(), grid.GetEsbTensor(), interpolation_mode, padding_mode, align_corners);
  return {out.dx, out.dgrid};
}
inline Tensor GridSampler3D(const Tensor &x, const Tensor &grid, const char *interpolation_mode="bilinear", const char *padding_mode="zeros", const char *data_format="NCDHW", bool align_corners=false) {
  auto out = EsGridSampler3D(x.GetEsbTensor(), grid.GetEsbTensor(), interpolation_mode, padding_mode, data_format, align_corners);
  return out;
}
struct GridSampler3DGradOutput {
  Tensor dx;
  Tensor dgrid;
};
inline GridSampler3DGradOutput GridSampler3DGrad(const Tensor &grad, const Tensor &x, const Tensor &grid, const char *interpolation_mode="bilinear", const char *padding_mode="zeros", bool align_corners=false) {
  auto out = EsGridSampler3DGrad(grad.GetEsbTensor(), x.GetEsbTensor(), grid.GetEsbTensor(), interpolation_mode, padding_mode, align_corners);
  return {out.dx, out.dgrid};
}
struct GridUnnormalOutput {
  Tensor diff;
  Tensor position;
};
inline GridUnnormalOutput GridUnnormal(const Tensor &grid, const Tensor &assist, bool align_corners=false) {
  auto out = EsGridUnnormal(grid.GetEsbTensor(), assist.GetEsbTensor(), align_corners);
  return {out.diff, out.position};
}
struct GroupNormOutput {
  Tensor y;
  Tensor mean;
  Tensor variance;
};
inline GroupNormOutput GroupNorm(const Tensor &x, const Tensor &gamma, const Tensor &beta, int64_t num_groups, const char *data_format="NHWC", float eps=0.000100, bool is_training=true) {
  auto out = EsGroupNorm(x.GetEsbTensor(), gamma.GetEsbTensor(), beta.GetEsbTensor(), num_groups, data_format, eps, is_training);
  return {out.y, out.mean, out.variance};
}
struct GroupNormGradOutput {
  Tensor dx;
  Tensor dgamma;
  Tensor dbeta;
};
inline GroupNormGradOutput GroupNormGrad(const Tensor &dy, const Tensor &mean, const Tensor &rstd, const Tensor &x, const Tensor &gamma, int64_t num_groups, const char *data_format="NCHW", bool dx_is_require=true, bool dgamma_is_require=true, bool dbeta_is_require=true) {
  auto out = EsGroupNormGrad(dy.GetEsbTensor(), mean.GetEsbTensor(), rstd.GetEsbTensor(), x.GetEsbTensor(), gamma.GetEsbTensor(), num_groups, data_format, dx_is_require, dgamma_is_require, dbeta_is_require);
  return {out.dx, out.dgamma, out.dbeta};
}
inline Tensor GroupNormRelu(const Tensor &x, const Tensor &gamma, const Tensor &beta, int64_t num_groups, float eps=0.000010) {
  auto out = EsGroupNormRelu(x.GetEsbTensor(), gamma.GetEsbTensor(), beta.GetEsbTensor(), num_groups, eps);
  return out;
}
struct GroupNormSiluOutput {
  Tensor y;
  Tensor mean;
  Tensor rstd;
};
inline GroupNormSiluOutput GroupNormSilu(const Tensor &x, const Tensor &gamma, const Tensor &beta, int64_t num_groups, float eps=0.000010, bool activate_silu=true) {
  auto out = EsGroupNormSilu(x.GetEsbTensor(), gamma.GetEsbTensor(), beta.GetEsbTensor(), num_groups, eps, activate_silu);
  return {out.y, out.mean, out.rstd};
}
struct GroupNormSwishOutput {
  Tensor y;
  Tensor mean;
  Tensor rstd;
};
inline GroupNormSwishOutput GroupNormSwish(const Tensor &x, const Tensor &gamma, const Tensor &beta, int64_t num_groups, const char *data_format="NCHW", float eps=0.000010, bool activate_swish=true, float swish_scale=1.000000) {
  auto out = EsGroupNormSwish(x.GetEsbTensor(), gamma.GetEsbTensor(), beta.GetEsbTensor(), num_groups, data_format, eps, activate_swish, swish_scale);
  return {out.y, out.mean, out.rstd};
}
struct GroupNormSwishGradOutput {
  Tensor dx;
  Tensor dgamma;
  Tensor dbeta;
};
inline GroupNormSwishGradOutput GroupNormSwishGrad(const Tensor &dy, const Tensor &mean, const Tensor &rstd, const Tensor &x, const Tensor &gamma, const Tensor &beta, int64_t num_groups, const char *data_format="NCHW", float swish_scale=1.000000, bool dgamma_is_require=true, bool dbeta_is_require=true) {
  auto out = EsGroupNormSwishGrad(dy.GetEsbTensor(), mean.GetEsbTensor(), rstd.GetEsbTensor(), x.GetEsbTensor(), gamma.GetEsbTensor(), beta.GetEsbTensor(), num_groups, data_format, swish_scale, dgamma_is_require, dbeta_is_require);
  return {out.dx, out.dgamma, out.dbeta};
}
struct GroupNormV2Output {
  Tensor y;
  Tensor mean;
  Tensor rstd;
};
inline GroupNormV2Output GroupNormV2(const Tensor &x, const Tensor &gamma, const Tensor &beta, int64_t num_groups, const char *data_format="NHWC", float eps=0.000100, bool is_training=true) {
  auto out = EsGroupNormV2(x.GetEsbTensor(), gamma.GetEsbTensor(), beta.GetEsbTensor(), num_groups, data_format, eps, is_training);
  return {out.y, out.mean, out.rstd};
}
inline Tensor GroupQuant(const Tensor &x, const Tensor &scale, const Tensor &group_index, const Tensor &offset=nullptr, int64_t dst_type=2) {
  auto out = EsGroupQuant(x.GetEsbTensor(), scale.GetEsbTensor(), group_index.GetEsbTensor(), offset.GetEsbTensor(), dst_type);
  return out;
}
inline Tensor GroupedBiasAddGrad(const Tensor &grad_y, const Tensor &group_idx=nullptr, int64_t group_idx_type=0) {
  auto out = EsGroupedBiasAddGrad(grad_y.GetEsbTensor(), group_idx.GetEsbTensor(), group_idx_type);
  return out;
}
inline Tensor GuaranteeConst(const Tensor &x) {
  auto out = EsGuaranteeConst(x.GetEsbTensor());
  return out;
}
inline Tensor HSVToRGB(const Tensor &images) {
  auto out = EsHSVToRGB(images.GetEsbTensor());
  return out;
}
inline Tensor HardMax(const Tensor &x, int64_t axis=-1) {
  auto out = EsHardMax(x.GetEsbTensor(), axis);
  return out;
}
inline Tensor HardShrink(const Tensor &input_x, float lambd=0.500000) {
  auto out = EsHardShrink(input_x.GetEsbTensor(), lambd);
  return out;
}
inline Tensor HardShrinkGrad(const Tensor &gradients, const Tensor &features, float lambd=0.500000) {
  auto out = EsHardShrinkGrad(gradients.GetEsbTensor(), features.GetEsbTensor(), lambd);
  return out;
}
inline Tensor HardSigmoid(const Tensor &input_x, float alpha=0.166667, float beta=0.500000) {
  auto out = EsHardSigmoid(input_x.GetEsbTensor(), alpha, beta);
  return out;
}
inline Tensor HardSigmoidGrad(const Tensor &grads, const Tensor &input_x, float alpha=0.166667, float beta=0.500000) {
  auto out = EsHardSigmoidGrad(grads.GetEsbTensor(), input_x.GetEsbTensor(), alpha, beta);
  return out;
}
inline Tensor HardSwish(const Tensor &x) {
  auto out = EsHardSwish(x.GetEsbTensor());
  return out;
}
inline Tensor HardSwishGrad(const Tensor &grad, const Tensor &x) {
  auto out = EsHardSwishGrad(grad.GetEsbTensor(), x.GetEsbTensor());
  return out;
}
inline Tensor HardtanhGrad(const Tensor &result, const Tensor &grad, float min_val=-1.000000, float max_val=1.000000) {
  auto out = EsHardtanhGrad(result.GetEsbTensor(), grad.GetEsbTensor(), min_val, max_val);
  return out;
}
inline Tensor HashTable(const Graph &owner_graph, ge::DataType key_dtype, ge::DataType value_dtype, const char *container="", const char *shared_name="", bool use_node_name_sharing=false) {
  auto out = EsHashTable(owner_graph.GetEsbGraph(), key_dtype, value_dtype, container, shared_name, use_node_name_sharing);
  return out;
}
inline Tensor HcomAllGather(const Tensor &x, int64_t rank_size, const char *group, int64_t fusion=0, int64_t fusion_id=-1) {
  auto out = EsHcomAllGather(x.GetEsbTensor(), rank_size, group, fusion, fusion_id);
  return out;
}
inline Tensor HcomAllReduce(const Tensor &x, const char *reduction, const char *group, int64_t fusion=1, int64_t fusion_id=-1) {
  auto out = EsHcomAllReduce(x.GetEsbTensor(), reduction, group, fusion, fusion_id);
  return out;
}
inline Tensor HcomAllToAll(const Tensor &x, const char *group) {
  auto out = EsHcomAllToAll(x.GetEsbTensor(), group);
  return out;
}
inline Tensor HcomAllToAllV(const Tensor &send_data, const Tensor &send_counts, const Tensor &send_displacements, const Tensor &recv_counts, const Tensor &recv_displacements, const char *group) {
  auto out = EsHcomAllToAllV(send_data.GetEsbTensor(), send_counts.GetEsbTensor(), send_displacements.GetEsbTensor(), recv_counts.GetEsbTensor(), recv_displacements.GetEsbTensor(), group);
  return out;
}
inline Tensor HcomAllToAllVC(const Tensor &send_data, const Tensor &send_count_matrix, int64_t rank, const char *group, int64_t fusion=0, int64_t fusion_id=-1) {
  auto out = EsHcomAllToAllVC(send_data.GetEsbTensor(), send_count_matrix.GetEsbTensor(), rank, group, fusion, fusion_id);
  return out;
}
inline Tensor HcomGather(const Tensor &x, int64_t root_rank, const char *group, int64_t rank_size) {
  auto out = EsHcomGather(x.GetEsbTensor(), root_rank, group, rank_size);
  return out;
}
struct HcomGatherAllToAllVOutput {
  Tensor recv_data;
  Tensor gathered;
};
inline HcomGatherAllToAllVOutput HcomGatherAllToAllV(const Tensor &addrinfo, const Tensor &addrinfo_count_per_rank, const Tensor &recv_counts, const Tensor &recv_displacements, const char *group, ge::DataType dtype, int64_t addr_length) {
  auto out = EsHcomGatherAllToAllV(addrinfo.GetEsbTensor(), addrinfo_count_per_rank.GetEsbTensor(), recv_counts.GetEsbTensor(), recv_displacements.GetEsbTensor(), group, dtype, addr_length);
  return {out.recv_data, out.gathered};
}
inline Tensor HcomReceive(const Graph &owner_graph, const char *group, int64_t sr_tag, int64_t src_rank, const std::vector<int64_t> &shape, ge::DataType dtype) {
  auto out = EsHcomReceive(owner_graph.GetEsbGraph(), group, sr_tag, src_rank, shape.data(), static_cast<int64_t>(shape.size()), dtype);
  return out;
}
inline Tensor HcomReduce(const Tensor &x, int64_t root_rank, const char *reduction, const char *group, int64_t fusion=0, int64_t fusion_id=-1) {
  auto out = EsHcomReduce(x.GetEsbTensor(), root_rank, reduction, group, fusion, fusion_id);
  return out;
}
inline Tensor HcomReduceScatter(const Tensor &x, const char *reduction, const char *group, int64_t rank_size, int64_t fusion=0, int64_t fusion_id=-1) {
  auto out = EsHcomReduceScatter(x.GetEsbTensor(), reduction, group, rank_size, fusion, fusion_id);
  return out;
}
inline Tensor HcomRemoteRead(const Tensor &remote, ge::DataType dtype) {
  auto out = EsHcomRemoteRead(remote.GetEsbTensor(), dtype);
  return out;
}
inline Tensor HcomRemoteRefRead(const Tensor &remote, const Tensor &cache_var, const Tensor &local_offset, ge::DataType dtype) {
  auto out = EsHcomRemoteRefRead(remote.GetEsbTensor(), cache_var.GetEsbTensor(), local_offset.GetEsbTensor(), dtype);
  return out;
}
inline Tensor HcomRemoteScatterWrite(const Tensor &remote, const Tensor &local, const Tensor &local_offset=nullptr) {
  auto out = EsHcomRemoteScatterWrite(remote.GetEsbTensor(), local.GetEsbTensor(), local_offset.GetEsbTensor());
  return out;
}
inline Tensor HcomRemoteWrite(const Tensor &remote, const Tensor &local) {
  auto out = EsHcomRemoteWrite(remote.GetEsbTensor(), local.GetEsbTensor());
  return out;
}
inline Tensor HcomSend(const Tensor &x, const char *group, int64_t sr_tag, int64_t dest_rank) {
  auto out = EsHcomSend(x.GetEsbTensor(), group, sr_tag, dest_rank);
  return out;
}
inline Tensor Histogram(const Tensor &x, int64_t bins=100, float min=0.000000, float max=0.000000) {
  auto out = EsHistogram(x.GetEsbTensor(), bins, min, max);
  return out;
}
inline Tensor HistogramFixedWidth(const Tensor &x, const Tensor &range, const Tensor &nbins, int64_t dtype=3) {
  auto out = EsHistogramFixedWidth(x.GetEsbTensor(), range.GetEsbTensor(), nbins.GetEsbTensor(), dtype);
  return out;
}
inline Tensor HistogramFixedWidthD(const Tensor &x, const Tensor &range, int64_t nbins, int64_t dtype=3) {
  auto out = EsHistogramFixedWidthD(x.GetEsbTensor(), range.GetEsbTensor(), nbins, dtype);
  return out;
}
inline Tensor HistogramV2(const Tensor &x, const Tensor &min, const Tensor &max, int64_t bins=100) {
  auto out = EsHistogramV2(x.GetEsbTensor(), min.GetEsbTensor(), max.GetEsbTensor(), bins);
  return out;
}
inline Tensor HorovodAllgather(const Tensor &x, int64_t rank_size) {
  auto out = EsHorovodAllgather(x.GetEsbTensor(), rank_size);
  return out;
}
inline Tensor HorovodAllreduce(const Tensor &x, int64_t reduce_op) {
  auto out = EsHorovodAllreduce(x.GetEsbTensor(), reduce_op);
  return out;
}
inline Tensor HorovodBroadcast(const Tensor &x, int64_t root_rank) {
  auto out = EsHorovodBroadcast(x.GetEsbTensor(), root_rank);
  return out;
}
inline Tensor IFFT(const Tensor &x) {
  auto out = EsIFFT(x.GetEsbTensor());
  return out;
}
inline Tensor IFFT2D(const Tensor &x) {
  auto out = EsIFFT2D(x.GetEsbTensor());
  return out;
}
struct IFMROutput {
  Tensor scale;
  Tensor offset;
};
inline IFMROutput IFMR(const Tensor &data, const Tensor &data_min, const Tensor &data_max, const Tensor &cumsum, float min_percentile, float max_percentile, const std::vector<float> &search_range, float search_step, bool with_offset, int64_t quant_bits=8) {
  auto out = EsIFMR(data.GetEsbTensor(), data_min.GetEsbTensor(), data_max.GetEsbTensor(), cumsum.GetEsbTensor(), min_percentile, max_percentile, search_range.data(), static_cast<int64_t>(search_range.size()), search_step, with_offset, quant_bits);
  return {out.scale, out.offset};
}
inline Tensor IMGWarp(const Tensor &img, const Tensor &warp_offset) {
  auto out = EsIMGWarp(img.GetEsbTensor(), warp_offset.GetEsbTensor());
  return out;
}
inline Tensor IMGWarpOffsets(const Tensor &images, const Tensor &offsets) {
  auto out = EsIMGWarpOffsets(images.GetEsbTensor(), offsets.GetEsbTensor());
  return out;
}
inline Tensor IMGWarpResize(const Tensor &img, const Tensor &warp_index) {
  auto out = EsIMGWarpResize(img.GetEsbTensor(), warp_index.GetEsbTensor());
  return out;
}
struct INInferV2Output {
  Tensor y;
  Tensor batch_mean;
  Tensor batch_variance;
};
inline INInferV2Output INInferV2(const Tensor &x, const Tensor &gamma=nullptr, const Tensor &beta=nullptr, const Tensor &mean=nullptr, const Tensor &variance=nullptr, float epsilon=0.000010) {
  auto out = EsINInferV2(x.GetEsbTensor(), gamma.GetEsbTensor(), beta.GetEsbTensor(), mean.GetEsbTensor(), variance.GetEsbTensor(), epsilon);
  return {out.y, out.batch_mean, out.batch_variance};
}
struct INInferV2DOutput {
  Tensor y;
  Tensor batch_mean;
  Tensor batch_variance;
};
inline INInferV2DOutput INInferV2D(const Tensor &x, const Tensor &gamma=nullptr, const Tensor &beta=nullptr, const Tensor &mean=nullptr, const Tensor &variance=nullptr, const Tensor &variance_sqrt=nullptr) {
  auto out = EsINInferV2D(x.GetEsbTensor(), gamma.GetEsbTensor(), beta.GetEsbTensor(), mean.GetEsbTensor(), variance.GetEsbTensor(), variance_sqrt.GetEsbTensor());
  return {out.y, out.batch_mean, out.batch_variance};
}
inline Tensor INTrainingReduceGrad(const Tensor &dy, const Tensor &x, const Tensor &variance, const Tensor &mean, const Tensor &res_gamma, const Tensor &res_beta, const Tensor &gamma) {
  auto out = EsINTrainingReduceGrad(dy.GetEsbTensor(), x.GetEsbTensor(), variance.GetEsbTensor(), mean.GetEsbTensor(), res_gamma.GetEsbTensor(), res_beta.GetEsbTensor(), gamma.GetEsbTensor());
  return out;
}
struct INTrainingReduceV2Output {
  Tensor sum;
  Tensor square_sum;
};
inline INTrainingReduceV2Output INTrainingReduceV2(const Tensor &x) {
  auto out = EsINTrainingReduceV2(x.GetEsbTensor());
  return {out.sum, out.square_sum};
}
struct INTrainingUpdateGradOutput {
  Tensor res_gamma;
  Tensor res_beta;
};
inline INTrainingUpdateGradOutput INTrainingUpdateGrad(const Tensor &dy, const Tensor &x, const Tensor &variance, const Tensor &mean) {
  auto out = EsINTrainingUpdateGrad(dy.GetEsbTensor(), x.GetEsbTensor(), variance.GetEsbTensor(), mean.GetEsbTensor());
  return {out.res_gamma, out.res_beta};
}
struct INTrainingUpdateGradGammaBetaOutput {
  Tensor pd_gamma;
  Tensor pd_beta;
};
inline INTrainingUpdateGradGammaBetaOutput INTrainingUpdateGradGammaBeta(const Tensor &res_gamma, const Tensor &res_beta) {
  auto out = EsINTrainingUpdateGradGammaBeta(res_gamma.GetEsbTensor(), res_beta.GetEsbTensor());
  return {out.pd_gamma, out.pd_beta};
}
struct INTrainingUpdateV2Output {
  Tensor y;
  Tensor batch_mean;
  Tensor batch_variance;
};
inline INTrainingUpdateV2Output INTrainingUpdateV2(const Tensor &x, const Tensor &sum, const Tensor &square_sum, const Tensor &gamma=nullptr, const Tensor &beta=nullptr, const Tensor &mean=nullptr, const Tensor &variance=nullptr, float momentum=0.100000, float epsilon=0.000010) {
  auto out = EsINTrainingUpdateV2(x.GetEsbTensor(), sum.GetEsbTensor(), square_sum.GetEsbTensor(), gamma.GetEsbTensor(), beta.GetEsbTensor(), mean.GetEsbTensor(), variance.GetEsbTensor(), momentum, epsilon);
  return {out.y, out.batch_mean, out.batch_variance};
}
inline Tensor IRFFT(const Tensor &x, const Tensor &fft_length) {
  auto out = EsIRFFT(x.GetEsbTensor(), fft_length.GetEsbTensor());
  return out;
}
inline Tensor Identity(const Tensor &x) {
  auto out = EsIdentity(x.GetEsbTensor());
  return out;
}
inline Tensor Igamma(const Tensor &a, const Tensor &x) {
  auto out = EsIgamma(a.GetEsbTensor(), x.GetEsbTensor());
  return out;
}
inline Tensor IgammaGradA(const Tensor &a, const Tensor &x) {
  auto out = EsIgammaGradA(a.GetEsbTensor(), x.GetEsbTensor());
  return out;
}
inline Tensor Igammac(const Tensor &a, const Tensor &x) {
  auto out = EsIgammac(a.GetEsbTensor(), x.GetEsbTensor());
  return out;
}
inline Tensor Im2col(const Tensor &x, const std::vector<int64_t> &ksizes, const std::vector<int64_t> &strides={1}, const std::vector<int64_t> &dilations={1}, const char *padding_mode="CALCULATED", const std::vector<int64_t> &pads={0}) {
  auto out = EsIm2col(x.GetEsbTensor(), ksizes.data(), static_cast<int64_t>(ksizes.size()), strides.data(), static_cast<int64_t>(strides.size()), dilations.data(), static_cast<int64_t>(dilations.size()), padding_mode, pads.data(), static_cast<int64_t>(pads.size()));
  return out;
}
inline Tensor Imag(const Tensor &input, ge::DataType Tout=ge::DT_FLOAT) {
  auto out = EsImag(input.GetEsbTensor(), Tout);
  return out;
}
inline Tensor ImageProjectiveTransform(const Tensor &images, const Tensor &transforms, const Tensor &output_shape, const char *interpolation, const char *fill_mode="CONSTANT") {
  auto out = EsImageProjectiveTransform(images.GetEsbTensor(), transforms.GetEsbTensor(), output_shape.GetEsbTensor(), interpolation, fill_mode);
  return out;
}
inline Tensor ImageProjectiveTransformV2(const Tensor &images, const Tensor &transforms, const Tensor &output_shape, const Tensor &fill_value, const char *interpolation, const char *fill_mode="CONSTANT") {
  auto out = EsImageProjectiveTransformV2(images.GetEsbTensor(), transforms.GetEsbTensor(), output_shape.GetEsbTensor(), fill_value.GetEsbTensor(), interpolation, fill_mode);
  return out;
}
inline Tensor ImageUnfold(const Tensor &x, const Tensor &position, const char *padding_mode="zeros") {
  auto out = EsImageUnfold(x.GetEsbTensor(), position.GetEsbTensor(), padding_mode);
  return out;
}
inline Tensor ImgCrop(const Tensor &x, const Tensor &boxes, const Tensor &box_index, const char *data_format="CHW") {
  auto out = EsImgCrop(x.GetEsbTensor(), boxes.GetEsbTensor(), box_index.GetEsbTensor(), data_format);
  return out;
}
inline Tensor ImgRawDecodePostHandle(const Tensor &img_channel_0, const Tensor &img_channel_1, const Tensor &img_channel_2, const Tensor &img_channel_3, const Tensor &img_size, const Tensor &gamma, const char *bayer_pattern="binning") {
  auto out = EsImgRawDecodePostHandle(img_channel_0.GetEsbTensor(), img_channel_1.GetEsbTensor(), img_channel_2.GetEsbTensor(), img_channel_3.GetEsbTensor(), img_size.GetEsbTensor(), gamma.GetEsbTensor(), bayer_pattern);
  return out;
}
inline Tensor ImgRawDecodePostHandleV2(const Tensor &img_channel_0, const Tensor &img_channel_1, const Tensor &img_channel_2, const Tensor &img_channel_3, const Tensor &gamma, const Tensor &bayer_coordinate, const Tensor &bayer_params, const Tensor &bayer_ptn) {
  auto out = EsImgRawDecodePostHandleV2(img_channel_0.GetEsbTensor(), img_channel_1.GetEsbTensor(), img_channel_2.GetEsbTensor(), img_channel_3.GetEsbTensor(), gamma.GetEsbTensor(), bayer_coordinate.GetEsbTensor(), bayer_params.GetEsbTensor(), bayer_ptn.GetEsbTensor());
  return out;
}
inline Tensor ImgToTensor(const Tensor &x) {
  auto out = EsImgToTensor(x.GetEsbTensor());
  return out;
}
inline Tensor InTopK(const Tensor &x1, const Tensor &x2, const Tensor &k) {
  auto out = EsInTopK(x1.GetEsbTensor(), x2.GetEsbTensor(), k.GetEsbTensor());
  return out;
}
inline Tensor InTopKD(const Tensor &x1, const Tensor &x2, int64_t k) {
  auto out = EsInTopKD(x1.GetEsbTensor(), x2.GetEsbTensor(), k);
  return out;
}
inline Tensor InTopKV2(const Tensor &predictions, const Tensor &targets, const Tensor &k) {
  auto out = EsInTopKV2(predictions.GetEsbTensor(), targets.GetEsbTensor(), k.GetEsbTensor());
  return out;
}
inline Tensor IncreFlashAttention(const Tensor &query, const std::vector<Tensor> &key, const std::vector<Tensor> &value, const Tensor &pse_shift, const Tensor &atten_mask, const Tensor &actual_seq_lengths, const Tensor &dequant_scale1, const Tensor &quant_scale1, const Tensor &dequant_scale2, const Tensor &quant_scale2, const Tensor &quant_offset2, const Tensor &antiquant_scale, const Tensor &antiquant_offset, const Tensor &block_table, const Tensor &kv_padding_size, int64_t num_heads, float scale_value=1.000000, const char *input_layout="BSH", int64_t num_key_value_heads=0, int64_t block_size=0, int64_t inner_precise=1) {
  auto esb_key = TensorsToEsbTensors(key);
  auto esb_value = TensorsToEsbTensors(value);
  auto out = EsIncreFlashAttention(query.GetEsbTensor(), esb_key.data(), static_cast<int64_t>(esb_key.size()), esb_value.data(), static_cast<int64_t>(esb_value.size()), pse_shift.GetEsbTensor(), atten_mask.GetEsbTensor(), actual_seq_lengths.GetEsbTensor(), dequant_scale1.GetEsbTensor(), quant_scale1.GetEsbTensor(), dequant_scale2.GetEsbTensor(), quant_scale2.GetEsbTensor(), quant_offset2.GetEsbTensor(), antiquant_scale.GetEsbTensor(), antiquant_offset.GetEsbTensor(), block_table.GetEsbTensor(), kv_padding_size.GetEsbTensor(), num_heads, scale_value, input_layout, num_key_value_heads, block_size, inner_precise);
  return out;
}
inline Tensor Index(const Tensor &x, const Tensor &indexed_sizes, const Tensor &indexed_strides, const std::vector<Tensor> &indices) {
  auto esb_indices = TensorsToEsbTensors(indices);
  auto out = EsIndex(x.GetEsbTensor(), indexed_sizes.GetEsbTensor(), indexed_strides.GetEsbTensor(), esb_indices.data(), static_cast<int64_t>(esb_indices.size()));
  return out;
}
inline Tensor IndexAdd(const Tensor &var, const Tensor &indices, const Tensor &updates, int64_t axis=0) {
  auto out = EsIndexAdd(var.GetEsbTensor(), indices.GetEsbTensor(), updates.GetEsbTensor(), axis);
  return out;
}
inline Tensor IndexFillD(const Tensor &x, const Tensor &assist1, const Tensor &assist2, int64_t dim) {
  auto out = EsIndexFillD(x.GetEsbTensor(), assist1.GetEsbTensor(), assist2.GetEsbTensor(), dim);
  return out;
}
inline Tensor IndexPut(const Tensor &x1, const Tensor &x2, const std::vector<int64_t> &indices, int64_t accumulate=0) {
  auto out = EsIndexPut(x1.GetEsbTensor(), x2.GetEsbTensor(), indices.data(), static_cast<int64_t>(indices.size()), accumulate);
  return out;
}
inline Tensor IndexPutV2(const Tensor &x, const Tensor &value, const Tensor &indexed_sizes, const Tensor &indexed_strides, const std::vector<Tensor> &indices, bool accumulate=false) {
  auto esb_indices = TensorsToEsbTensors(indices);
  auto out = EsIndexPutV2(x.GetEsbTensor(), value.GetEsbTensor(), indexed_sizes.GetEsbTensor(), indexed_strides.GetEsbTensor(), esb_indices.data(), static_cast<int64_t>(esb_indices.size()), accumulate);
  return out;
}
inline Tensor IndexToAddr(const Tensor &base_addr, const Tensor &x, const std::vector<int64_t> &ori_shape, const std::vector<int64_t> &block_size, const char *ori_storage_mode="Matrix", const char *block_storage_mode="Matrix", int64_t rank_id=0, ge::DataType dtype=ge::DT_FLOAT) {
  auto out = EsIndexToAddr(base_addr.GetEsbTensor(), x.GetEsbTensor(), ori_shape.data(), static_cast<int64_t>(ori_shape.size()), block_size.data(), static_cast<int64_t>(block_size.size()), ori_storage_mode, block_storage_mode, rank_id, dtype);
  return out;
}
inline Tensor InitData(const Graph &owner_graph, const char *channel_name="") {
  auto out = EsInitData(owner_graph.GetEsbGraph(), channel_name);
  return out;
}
inline Tensor InitEmbeddingHashmapV2(const Tensor &table_id, int64_t bucket_size, int64_t load_factor, int64_t embedding_dim, ge::DataType dtype=ge::DT_FLOAT) {
  auto out = EsInitEmbeddingHashmapV2(table_id.GetEsbTensor(), bucket_size, load_factor, embedding_dim, dtype);
  return out;
}
inline Tensor InitializeTable(const Tensor &handle, const Tensor &keys, const Tensor &values) {
  auto out = EsInitializeTable(handle.GetEsbTensor(), keys.GetEsbTensor(), values.GetEsbTensor());
  return out;
}
inline Tensor InplaceAdd(const Tensor &x, const Tensor &indices, const Tensor &v) {
  auto out = EsInplaceAdd(x.GetEsbTensor(), indices.GetEsbTensor(), v.GetEsbTensor());
  return out;
}
inline Tensor InplaceAddD(const Tensor &x, const Tensor &v, const std::vector<int64_t> &indices) {
  auto out = EsInplaceAddD(x.GetEsbTensor(), v.GetEsbTensor(), indices.data(), static_cast<int64_t>(indices.size()));
  return out;
}
struct InplaceAddLayerNormOutput {
  Tensor x1;
  Tensor mean;
  Tensor rstd;
  Tensor x2;
};
inline InplaceAddLayerNormOutput InplaceAddLayerNorm(const Tensor &x1, const Tensor &x2, const Tensor &gamma, const Tensor &beta, const Tensor &bias=nullptr, float epsilon=0.000010, bool additional_output=false) {
  auto out = EsInplaceAddLayerNorm(x1.GetEsbTensor(), x2.GetEsbTensor(), gamma.GetEsbTensor(), beta.GetEsbTensor(), bias.GetEsbTensor(), epsilon, additional_output);
  return {out.x1, out.mean, out.rstd, out.x2};
}
struct InplaceAddRmsNormOutput {
  Tensor x1;
  Tensor rstd;
  Tensor x2;
};
inline InplaceAddRmsNormOutput InplaceAddRmsNorm(const Tensor &x1, const Tensor &x2, const Tensor &gamma, float epsilon=0.000001) {
  auto out = EsInplaceAddRmsNorm(x1.GetEsbTensor(), x2.GetEsbTensor(), gamma.GetEsbTensor(), epsilon);
  return {out.x1, out.rstd, out.x2};
}
inline Tensor InplaceIndexAdd(const Tensor &var, const Tensor &indices, const Tensor &updates, const Tensor &alpha, int64_t axis) {
  auto out = EsInplaceIndexAdd(var.GetEsbTensor(), indices.GetEsbTensor(), updates.GetEsbTensor(), alpha.GetEsbTensor(), axis);
  return out;
}
struct InplaceMatmulAllReduceAddRmsNormOutput {
  Tensor residual;
  Tensor norm_out;
};
inline InplaceMatmulAllReduceAddRmsNormOutput InplaceMatmulAllReduceAddRmsNorm(const Tensor &x1, const Tensor &x2, const Tensor &bias, const Tensor &residual, const Tensor &gamma, const Tensor &antiquant_scale, const Tensor &antiquant_offset, const Tensor &dequant_scale, const char *group, const char *reduce_op="sum", bool is_trans_a=false, bool is_trans_b=false, int64_t comm_turn=0, int64_t antiquant_group_size=0, float epsilon=0.000001) {
  auto out = EsInplaceMatmulAllReduceAddRmsNorm(x1.GetEsbTensor(), x2.GetEsbTensor(), bias.GetEsbTensor(), residual.GetEsbTensor(), gamma.GetEsbTensor(), antiquant_scale.GetEsbTensor(), antiquant_offset.GetEsbTensor(), dequant_scale.GetEsbTensor(), group, reduce_op, is_trans_a, is_trans_b, comm_turn, antiquant_group_size, epsilon);
  return {out.residual, out.norm_out};
}
inline Tensor InplaceSub(const Tensor &x, const Tensor &indices, const Tensor &v) {
  auto out = EsInplaceSub(x.GetEsbTensor(), indices.GetEsbTensor(), v.GetEsbTensor());
  return out;
}
inline Tensor InplaceSubD(const Tensor &x, const Tensor &v, const std::vector<int64_t> &indices) {
  auto out = EsInplaceSubD(x.GetEsbTensor(), v.GetEsbTensor(), indices.data(), static_cast<int64_t>(indices.size()));
  return out;
}
inline Tensor InplaceTopKDistance(const Tensor &topk_pq_distance, const Tensor &topk_pq_index, const Tensor &topk_pq_ivf, const Tensor &pq_distance, const Tensor &pq_index, const Tensor &pq_ivf, const char *order="asc") {
  auto out = EsInplaceTopKDistance(topk_pq_distance.GetEsbTensor(), topk_pq_index.GetEsbTensor(), topk_pq_ivf.GetEsbTensor(), pq_distance.GetEsbTensor(), pq_index.GetEsbTensor(), pq_ivf.GetEsbTensor(), order);
  return out;
}
inline Tensor InplaceUpdate(const Tensor &x, const Tensor &indices, const Tensor &v) {
  auto out = EsInplaceUpdate(x.GetEsbTensor(), indices.GetEsbTensor(), v.GetEsbTensor());
  return out;
}
inline Tensor InplaceUpdateD(const Tensor &x, const Tensor &v, const std::vector<int64_t> &indices) {
  auto out = EsInplaceUpdateD(x.GetEsbTensor(), v.GetEsbTensor(), indices.data(), static_cast<int64_t>(indices.size()));
  return out;
}
struct InstanceNormOutput {
  Tensor y;
  Tensor mean;
  Tensor variance;
};
inline InstanceNormOutput InstanceNorm(const Tensor &x, const Tensor &gamma, const Tensor &beta, const char *data_format="NDHWC", float epsilon=0.000001) {
  auto out = EsInstanceNorm(x.GetEsbTensor(), gamma.GetEsbTensor(), beta.GetEsbTensor(), data_format, epsilon);
  return {out.y, out.mean, out.variance};
}
struct InstanceNormGradOutput {
  Tensor pd_x;
  Tensor pd_gamma;
  Tensor pd_beta;
};
inline InstanceNormGradOutput InstanceNormGrad(const Tensor &dy, const Tensor &x, const Tensor &variance, const Tensor &mean, const Tensor &gamma) {
  auto out = EsInstanceNormGrad(dy.GetEsbTensor(), x.GetEsbTensor(), variance.GetEsbTensor(), mean.GetEsbTensor(), gamma.GetEsbTensor());
  return {out.pd_x, out.pd_gamma, out.pd_beta};
}
struct InstanceNormV2Output {
  Tensor y;
  Tensor batch_mean;
  Tensor batch_variance;
};
inline InstanceNormV2Output InstanceNormV2(const Tensor &x, const Tensor &gamma=nullptr, const Tensor &beta=nullptr, const Tensor &mean=nullptr, const Tensor &variance=nullptr, bool is_training=true, float momentum=0.100000, float epsilon=0.000010) {
  auto out = EsInstanceNormV2(x.GetEsbTensor(), gamma.GetEsbTensor(), beta.GetEsbTensor(), mean.GetEsbTensor(), variance.GetEsbTensor(), is_training, momentum, epsilon);
  return {out.y, out.batch_mean, out.batch_variance};
}
inline Tensor InternalDataMove(const Tensor &x, const char *src_buf, const char *dst_buf) {
  auto out = EsInternalDataMove(x.GetEsbTensor(), src_buf, dst_buf);
  return out;
}
inline Tensor Inv(const Tensor &x) {
  auto out = EsInv(x.GetEsbTensor());
  return out;
}
inline Tensor InvGrad(const Tensor &x, const Tensor &grad) {
  auto out = EsInvGrad(x.GetEsbTensor(), grad.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor InvGrad(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return InvGrad(tensor, b_esb_tensor);
}
inline Tensor Invert(const Tensor &x) {
  auto out = EsInvert(x.GetEsbTensor());
  return out;
}
inline Tensor InvertPermutation(const Tensor &x) {
  auto out = EsInvertPermutation(x.GetEsbTensor());
  return out;
}
inline Tensor Iou(const Tensor &bboxes, const Tensor &gtboxes, const char *mode="iou", float eps=1.000000, bool aligned=false) {
  auto out = EsIou(bboxes.GetEsbTensor(), gtboxes.GetEsbTensor(), mode, eps, aligned);
  return out;
}
inline Tensor Iou3D(const Tensor &bboxes, const Tensor &gtboxes) {
  auto out = EsIou3D(bboxes.GetEsbTensor(), gtboxes.GetEsbTensor());
  return out;
}
inline Tensor IsClose(const Tensor &x1, const Tensor &x2, float rtol=0.000010, float atol=0.000000, bool equal_nan=false) {
  auto out = EsIsClose(x1.GetEsbTensor(), x2.GetEsbTensor(), rtol, atol, equal_nan);
  return out;
}
inline Tensor IsFinite(const Tensor &x) {
  auto out = EsIsFinite(x.GetEsbTensor());
  return out;
}
inline Tensor IsInf(const Tensor &x) {
  auto out = EsIsInf(x.GetEsbTensor());
  return out;
}
inline Tensor IsNan(const Tensor &x) {
  auto out = EsIsNan(x.GetEsbTensor());
  return out;
}
inline Tensor IsNegInf(const Tensor &x) {
  auto out = EsIsNegInf(x.GetEsbTensor());
  return out;
}
inline Tensor IsPosInf(const Tensor &x) {
  auto out = EsIsPosInf(x.GetEsbTensor());
  return out;
}
inline Tensor IsVariableInitialized(const Tensor &x) {
  auto out = EsIsVariableInitialized(x.GetEsbTensor());
  return out;
}
struct IsotonicRegressionOutput {
  Tensor output;
  Tensor segments;
};
inline IsotonicRegressionOutput IsotonicRegression(const Tensor &input, ge::DataType output_dtype=ge::DT_FLOAT) {
  auto out = EsIsotonicRegression(input.GetEsbTensor(), output_dtype);
  return {out.output, out.segments};
}
inline Tensor KLDiv(const Tensor &x, const Tensor &target, const char *reduction) {
  auto out = EsKLDiv(x.GetEsbTensor(), target.GetEsbTensor(), reduction);
  return out;
}
inline Tensor KLDivV2(const Tensor &x, const Tensor &target, const char *reduction="mean", bool log_target=false) {
  auto out = EsKLDivV2(x.GetEsbTensor(), target.GetEsbTensor(), reduction, log_target);
  return out;
}
struct KMeansCentroidsOutput {
  Tensor segment_sum;
  Tensor segment_count;
  Tensor kmean_total_sum;
};
inline KMeansCentroidsOutput KMeansCentroids(const Tensor &x, const Tensor &y, const Tensor &sum_square_y, const Tensor &sum_square_x=nullptr, bool use_actual_distance=false) {
  auto out = EsKMeansCentroids(x.GetEsbTensor(), y.GetEsbTensor(), sum_square_y.GetEsbTensor(), sum_square_x.GetEsbTensor(), use_actual_distance);
  return {out.segment_sum, out.segment_count, out.kmean_total_sum};
}
inline Tensor KeepRatioResizeBilinear(const Tensor &images, int64_t min_dimension, int64_t max_dimension, bool align_corners=false, bool half_pixel_centers=false) {
  auto out = EsKeepRatioResizeBilinear(images.GetEsbTensor(), min_dimension, max_dimension, align_corners, half_pixel_centers);
  return out;
}
inline Tensor KlDivLossGrad(const Tensor &grad, const Tensor &input, const Tensor &target, const char *reduction="mean", bool log_target=false) {
  auto out = EsKlDivLossGrad(grad.GetEsbTensor(), input.GetEsbTensor(), target.GetEsbTensor(), reduction, log_target);
  return out;
}
inline Tensor L1LossGrad(const Tensor &grads, const Tensor &predict, const Tensor &label, const char *reduction="mean") {
  auto out = EsL1LossGrad(grads.GetEsbTensor(), predict.GetEsbTensor(), label.GetEsbTensor(), reduction);
  return out;
}
inline Tensor L2Loss(const Tensor &x) {
  auto out = EsL2Loss(x.GetEsbTensor());
  return out;
}
inline Tensor L2Normalize(const Tensor &x, const std::vector<int64_t> &axis={}, float eps=0.000100) {
  auto out = EsL2Normalize(x.GetEsbTensor(), axis.data(), static_cast<int64_t>(axis.size()), eps);
  return out;
}
inline Tensor L2NormalizeGrad(const Tensor &x, const Tensor &y, const Tensor &dy, const std::vector<int64_t> &dim={}, float eps=0.000100) {
  auto out = EsL2NormalizeGrad(x.GetEsbTensor(), y.GetEsbTensor(), dy.GetEsbTensor(), dim.data(), static_cast<int64_t>(dim.size()), eps);
  return out;
}
inline Tensor LDPCDecode(const Tensor &valid_num, const Tensor &matrix_info) {
  auto out = EsLDPCDecode(valid_num.GetEsbTensor(), matrix_info.GetEsbTensor());
  return out;
}
struct LNDropoutGradOutput {
  Tensor pd_x;
  Tensor pd_x_dropout;
  Tensor pd_gamma;
  Tensor pd_beta;
};
inline LNDropoutGradOutput LNDropoutGrad(const Tensor &dy, const Tensor &x, const Tensor &variance, const Tensor &mean, const Tensor &gamma, const Tensor &mask, float keep_prob) {
  auto out = EsLNDropoutGrad(dy.GetEsbTensor(), x.GetEsbTensor(), variance.GetEsbTensor(), mean.GetEsbTensor(), gamma.GetEsbTensor(), mask.GetEsbTensor(), keep_prob);
  return {out.pd_x, out.pd_x_dropout, out.pd_gamma, out.pd_beta};
}
inline Tensor LRN(const Tensor &x, int64_t depth_radius=5, float bias=1.000000, float alpha=1.000000, float beta=0.500000, const char *norm_region="ACROSS_CHANNELS") {
  auto out = EsLRN(x.GetEsbTensor(), depth_radius, bias, alpha, beta, norm_region);
  return out;
}
inline Tensor LRNGrad(const Tensor &grads, const Tensor &x, const Tensor &y, int64_t depth_radius=5, float bias=1.000000, float alpha=1.000000, float beta=0.500000) {
  auto out = EsLRNGrad(grads.GetEsbTensor(), x.GetEsbTensor(), y.GetEsbTensor(), depth_radius, bias, alpha, beta);
  return out;
}
struct LRUCacheV2Output {
  Tensor data;
  Tensor cache;
  Tensor tag;
  Tensor index_offset_list;
  Tensor not_in_cache_index_list;
  Tensor not_in_cache_number;
};
inline LRUCacheV2Output LRUCacheV2(const Tensor &index_list, const Tensor &data, const Tensor &cache, const Tensor &tag, const Tensor &is_last_call, int64_t pre_route_count) {
  auto out = EsLRUCacheV2(index_list.GetEsbTensor(), data.GetEsbTensor(), cache.GetEsbTensor(), tag.GetEsbTensor(), is_last_call.GetEsbTensor(), pre_route_count);
  return {out.data, out.cache, out.tag, out.index_offset_list, out.not_in_cache_index_list, out.not_in_cache_number};
}
struct LSTMOutput {
  Tensor h;
  Tensor h_t;
  Tensor c_t;
};
inline LSTMOutput LSTM(const Tensor &x, const Tensor &cont, const Tensor &w_x, const Tensor &bias, const Tensor &w_h, const Tensor &x_static=nullptr, const Tensor &h_0=nullptr, const Tensor &c_0=nullptr, const Tensor &w_x_static=nullptr, int64_t num_output=0, bool expose_hidden=false) {
  auto out = EsLSTM(x.GetEsbTensor(), cont.GetEsbTensor(), w_x.GetEsbTensor(), bias.GetEsbTensor(), w_h.GetEsbTensor(), x_static.GetEsbTensor(), h_0.GetEsbTensor(), c_0.GetEsbTensor(), w_x_static.GetEsbTensor(), num_output, expose_hidden);
  return {out.h, out.h_t, out.c_t};
}
struct LSTMInputGradOutput {
  Tensor dx;
  Tensor dh_prev;
  Tensor dc_prev;
  Tensor dgate;
};
inline LSTMInputGradOutput LSTMInputGrad(const Tensor &w, const Tensor &init_c, const Tensor &c, const Tensor &dy, const Tensor &dh, const Tensor &dc, const Tensor &i, const Tensor &j, const Tensor &f, const Tensor &o, const Tensor &tanhct=nullptr) {
  auto out = EsLSTMInputGrad(w.GetEsbTensor(), init_c.GetEsbTensor(), c.GetEsbTensor(), dy.GetEsbTensor(), dh.GetEsbTensor(), dc.GetEsbTensor(), i.GetEsbTensor(), j.GetEsbTensor(), f.GetEsbTensor(), o.GetEsbTensor(), tanhct.GetEsbTensor());
  return {out.dx, out.dh_prev, out.dc_prev, out.dgate};
}
struct LSTMPOutput {
  Tensor y;
  Tensor output_h;
  Tensor output_c;
};
inline LSTMPOutput LSTMP(const Tensor &x, const Tensor &wx, const Tensor &bias, const Tensor &wr, const Tensor &project, const Tensor &real_mask=nullptr, const Tensor &init_h=nullptr, const Tensor &init_c=nullptr, bool time_major=false) {
  auto out = EsLSTMP(x.GetEsbTensor(), wx.GetEsbTensor(), bias.GetEsbTensor(), wr.GetEsbTensor(), project.GetEsbTensor(), real_mask.GetEsbTensor(), init_h.GetEsbTensor(), init_c.GetEsbTensor(), time_major);
  return {out.y, out.output_h, out.output_c};
}
inline Tensor LUT3D(const Tensor &img, const Tensor &lut_table) {
  auto out = EsLUT3D(img.GetEsbTensor(), lut_table.GetEsbTensor());
  return out;
}
struct LambApplyOptimizerAssignOutput {
  Tensor output0;
  Tensor inputv;
  Tensor inputm;
};
inline LambApplyOptimizerAssignOutput LambApplyOptimizerAssign(const Tensor &grad, const Tensor &inputv, const Tensor &inputm, const Tensor &input3, const Tensor &mul0_x, const Tensor &mul1_x, const Tensor &mul2_x, const Tensor &mul3_x, const Tensor &add2_y, const Tensor &steps, const Tensor &do_use_weight, const Tensor &weight_decay_rate) {
  auto out = EsLambApplyOptimizerAssign(grad.GetEsbTensor(), inputv.GetEsbTensor(), inputm.GetEsbTensor(), input3.GetEsbTensor(), mul0_x.GetEsbTensor(), mul1_x.GetEsbTensor(), mul2_x.GetEsbTensor(), mul3_x.GetEsbTensor(), add2_y.GetEsbTensor(), steps.GetEsbTensor(), do_use_weight.GetEsbTensor(), weight_decay_rate.GetEsbTensor());
  return {out.output0, out.inputv, out.inputm};
}
inline Tensor LambApplyWeightAssign(const Tensor &input0, const Tensor &input1, const Tensor &input2, const Tensor &input3, const Tensor &input_param) {
  auto out = EsLambApplyWeightAssign(input0.GetEsbTensor(), input1.GetEsbTensor(), input2.GetEsbTensor(), input3.GetEsbTensor(), input_param.GetEsbTensor());
  return out;
}
struct LambNextMVOutput {
  Tensor y1;
  Tensor y2;
  Tensor y3;
  Tensor y4;
};
inline LambNextMVOutput LambNextMV(const Tensor &input_mul3, const Tensor &input_mul2, const Tensor &input_realdiv1, const Tensor &input_mul1, const Tensor &input_mul0, const Tensor &input_realdiv0, const Tensor &input_mul4, const Tensor &mul0_x, const Tensor &mul1_sub, const Tensor &mul2_x, const Tensor &mul3_sub1, const Tensor &mul4_x, const Tensor &add2_y) {
  auto out = EsLambNextMV(input_mul3.GetEsbTensor(), input_mul2.GetEsbTensor(), input_realdiv1.GetEsbTensor(), input_mul1.GetEsbTensor(), input_mul0.GetEsbTensor(), input_realdiv0.GetEsbTensor(), input_mul4.GetEsbTensor(), mul0_x.GetEsbTensor(), mul1_sub.GetEsbTensor(), mul2_x.GetEsbTensor(), mul3_sub1.GetEsbTensor(), mul4_x.GetEsbTensor(), add2_y.GetEsbTensor());
  return {out.y1, out.y2, out.y3, out.y4};
}
struct LambNextMVWithDecayOutput {
  Tensor y1;
  Tensor y2;
  Tensor y3;
  Tensor y4;
};
inline LambNextMVWithDecayOutput LambNextMVWithDecay(const Tensor &input_mul3, const Tensor &input_mul2, const Tensor &input_realdiv1, const Tensor &input_mul1, const Tensor &input_mul0, const Tensor &input_realdiv0, const Tensor &input_mul4, const Tensor &mul0_x, const Tensor &mul1_sub, const Tensor &mul2_x, const Tensor &mul3_sub1, const Tensor &mul4_x, const Tensor &add2_y) {
  auto out = EsLambNextMVWithDecay(input_mul3.GetEsbTensor(), input_mul2.GetEsbTensor(), input_realdiv1.GetEsbTensor(), input_mul1.GetEsbTensor(), input_mul0.GetEsbTensor(), input_realdiv0.GetEsbTensor(), input_mul4.GetEsbTensor(), mul0_x.GetEsbTensor(), mul1_sub.GetEsbTensor(), mul2_x.GetEsbTensor(), mul3_sub1.GetEsbTensor(), mul4_x.GetEsbTensor(), add2_y.GetEsbTensor());
  return {out.y1, out.y2, out.y3, out.y4};
}
struct LambNextRightOutput {
  Tensor y1;
  Tensor y2;
};
inline LambNextRightOutput LambNextRight(const Tensor &input_square, const Tensor &input_mul2, const Tensor &mul2_x, const Tensor &mul3_x, const Tensor &truediv1_recip, const Tensor &add2_y) {
  auto out = EsLambNextRight(input_square.GetEsbTensor(), input_mul2.GetEsbTensor(), mul2_x.GetEsbTensor(), mul3_x.GetEsbTensor(), truediv1_recip.GetEsbTensor(), add2_y.GetEsbTensor());
  return {out.y1, out.y2};
}
inline Tensor LambUpdateWithLr(const Tensor &input_greater1, const Tensor &input_greater_realdiv, const Tensor &input_realdiv, const Tensor &input_mul0, const Tensor &input_mul1, const Tensor &input_sub, const Tensor &greater_y, const Tensor &select_e, const Tensor &minimum_y) {
  auto out = EsLambUpdateWithLr(input_greater1.GetEsbTensor(), input_greater_realdiv.GetEsbTensor(), input_realdiv.GetEsbTensor(), input_mul0.GetEsbTensor(), input_mul1.GetEsbTensor(), input_sub.GetEsbTensor(), greater_y.GetEsbTensor(), select_e.GetEsbTensor(), minimum_y.GetEsbTensor());
  return out;
}
inline Tensor LambUpdateWithLrV2(const Tensor &x1, const Tensor &x2, const Tensor &x3, const Tensor &x4, const Tensor &x5, const Tensor &greater_y, const Tensor &select_e) {
  auto out = EsLambUpdateWithLrV2(x1.GetEsbTensor(), x2.GetEsbTensor(), x3.GetEsbTensor(), x4.GetEsbTensor(), x5.GetEsbTensor(), greater_y.GetEsbTensor(), select_e.GetEsbTensor());
  return out;
}
inline Tensor LarsV2(const Tensor &w, const Tensor &g, const Tensor &weight_decay, const Tensor &learning_rate, float hyperpara=0.001000, float epsilon=0.000010, bool use_clip=false) {
  auto out = EsLarsV2(w.GetEsbTensor(), g.GetEsbTensor(), weight_decay.GetEsbTensor(), learning_rate.GetEsbTensor(), hyperpara, epsilon, use_clip);
  return out;
}
inline Tensor LarsV2Update(const Tensor &w, const Tensor &g, const Tensor &w_square_sum, const Tensor &g_square_sum, const Tensor &weight_decay, const Tensor &learning_rate, float hyperpara=0.001000, float epsilon=0.000010, bool use_clip=false) {
  auto out = EsLarsV2Update(w.GetEsbTensor(), g.GetEsbTensor(), w_square_sum.GetEsbTensor(), g_square_sum.GetEsbTensor(), weight_decay.GetEsbTensor(), learning_rate.GetEsbTensor(), hyperpara, epsilon, use_clip);
  return out;
}
struct LayerNormOutput {
  Tensor y;
  Tensor mean;
  Tensor variance;
};
inline LayerNormOutput LayerNorm(const Tensor &x, const Tensor &gamma, const Tensor &beta, int64_t begin_norm_axis=0, int64_t begin_params_axis=0, float epsilon=0.000000) {
  auto out = EsLayerNorm(x.GetEsbTensor(), gamma.GetEsbTensor(), beta.GetEsbTensor(), begin_norm_axis, begin_params_axis, epsilon);
  return {out.y, out.mean, out.variance};
}
struct LayerNormBetaGammaBackpropOutput {
  Tensor pd_gamma;
  Tensor pd_beta;
};
inline LayerNormBetaGammaBackpropOutput LayerNormBetaGammaBackprop(const Tensor &dy, const Tensor &x, const Tensor &variance, const Tensor &mean, const std::vector<int64_t> &shape_gamma) {
  auto out = EsLayerNormBetaGammaBackprop(dy.GetEsbTensor(), x.GetEsbTensor(), variance.GetEsbTensor(), mean.GetEsbTensor(), shape_gamma.data(), static_cast<int64_t>(shape_gamma.size()));
  return {out.pd_gamma, out.pd_beta};
}
struct LayerNormBetaGammaBackpropV2Output {
  Tensor pd_gamma;
  Tensor pd_beta;
};
inline LayerNormBetaGammaBackpropV2Output LayerNormBetaGammaBackpropV2(const Tensor &dy, const Tensor &res_for_gamma, const std::vector<int64_t> &shape_gamma) {
  auto out = EsLayerNormBetaGammaBackpropV2(dy.GetEsbTensor(), res_for_gamma.GetEsbTensor(), shape_gamma.data(), static_cast<int64_t>(shape_gamma.size()));
  return {out.pd_gamma, out.pd_beta};
}
struct LayerNormGradOutput {
  Tensor pd_x;
  Tensor pd_gamma;
  Tensor pd_beta;
};
inline LayerNormGradOutput LayerNormGrad(const Tensor &dy, const Tensor &x, const Tensor &variance, const Tensor &mean, const Tensor &gamma) {
  auto out = EsLayerNormGrad(dy.GetEsbTensor(), x.GetEsbTensor(), variance.GetEsbTensor(), mean.GetEsbTensor(), gamma.GetEsbTensor());
  return {out.pd_x, out.pd_gamma, out.pd_beta};
}
struct LayerNormGradV3Output {
  Tensor pd_x;
  Tensor pd_gamma;
  Tensor pd_beta;
};
inline LayerNormGradV3Output LayerNormGradV3(const Tensor &dy, const Tensor &x, const Tensor &rstd, const Tensor &mean, const Tensor &gamma) {
  auto out = EsLayerNormGradV3(dy.GetEsbTensor(), x.GetEsbTensor(), rstd.GetEsbTensor(), mean.GetEsbTensor(), gamma.GetEsbTensor());
  return {out.pd_x, out.pd_gamma, out.pd_beta};
}
inline Tensor LayerNormUpdate(const Tensor &x1, const Tensor &beta, const Tensor &gamma, const Tensor &sum, const Tensor &square_sum, float epsilon=0.000010) {
  auto out = EsLayerNormUpdate(x1.GetEsbTensor(), beta.GetEsbTensor(), gamma.GetEsbTensor(), sum.GetEsbTensor(), square_sum.GetEsbTensor(), epsilon);
  return out;
}
struct LayerNormV3Output {
  Tensor y;
  Tensor mean;
  Tensor rstd;
};
inline LayerNormV3Output LayerNormV3(const Tensor &x, const Tensor &gamma, const Tensor &beta, int64_t begin_norm_axis=0, int64_t begin_params_axis=0, float epsilon=0.000010) {
  auto out = EsLayerNormV3(x.GetEsbTensor(), gamma.GetEsbTensor(), beta.GetEsbTensor(), begin_norm_axis, begin_params_axis, epsilon);
  return {out.y, out.mean, out.rstd};
}
struct LayerNormV4Output {
  Tensor y;
  Tensor mean;
  Tensor rstd;
};
inline LayerNormV4Output LayerNormV4(const Tensor &x, const Tensor &normalized_shape, const Tensor &gamma=nullptr, const Tensor &beta=nullptr, float epsilon=0.000010) {
  auto out = EsLayerNormV4(x.GetEsbTensor(), normalized_shape.GetEsbTensor(), gamma.GetEsbTensor(), beta.GetEsbTensor(), epsilon);
  return {out.y, out.mean, out.rstd};
}
inline Tensor LayerNormXBackprop(const Tensor &dy, const Tensor &x, const Tensor &variance, const Tensor &mean, const Tensor &gamma) {
  auto out = EsLayerNormXBackprop(dy.GetEsbTensor(), x.GetEsbTensor(), variance.GetEsbTensor(), mean.GetEsbTensor(), gamma.GetEsbTensor());
  return out;
}
struct LayerNormXBackpropV2Output {
  Tensor pd_x;
  Tensor res_for_gamma;
};
inline LayerNormXBackpropV2Output LayerNormXBackpropV2(const Tensor &dy, const Tensor &x, const Tensor &variance, const Tensor &mean, const Tensor &gamma) {
  auto out = EsLayerNormXBackpropV2(dy.GetEsbTensor(), x.GetEsbTensor(), variance.GetEsbTensor(), mean.GetEsbTensor(), gamma.GetEsbTensor());
  return {out.pd_x, out.res_for_gamma};
}
struct LayerNormXBackpropV3Output {
  Tensor pd_x;
  Tensor res_for_gamma;
};
inline LayerNormXBackpropV3Output LayerNormXBackpropV3(const Tensor &dy, const Tensor &x, const Tensor &rstd, const Tensor &mean, const Tensor &gamma) {
  auto out = EsLayerNormXBackpropV3(dy.GetEsbTensor(), x.GetEsbTensor(), rstd.GetEsbTensor(), mean.GetEsbTensor(), gamma.GetEsbTensor());
  return {out.pd_x, out.res_for_gamma};
}
inline Tensor LeakyRelu(const Tensor &x, float negative_slope=0.000000) {
  auto out = EsLeakyRelu(x.GetEsbTensor(), negative_slope);
  return out;
}
inline Tensor LeakyReluGrad(const Tensor &gradients, const Tensor &features, float negative_slope=0.000000) {
  auto out = EsLeakyReluGrad(gradients.GetEsbTensor(), features.GetEsbTensor(), negative_slope);
  return out;
}
struct LearnedUnigramCandidateSamplerOutput {
  Tensor sampled_candidates;
  Tensor true_expected_count;
  Tensor sampled_expected_count;
};
inline LearnedUnigramCandidateSamplerOutput LearnedUnigramCandidateSampler(const Tensor &true_classes, int64_t num_true, int64_t num_sampled, bool unique, int64_t range_max, int64_t seed=0, int64_t seed2=0) {
  auto out = EsLearnedUnigramCandidateSampler(true_classes.GetEsbTensor(), num_true, num_sampled, unique, range_max, seed, seed2);
  return {out.sampled_candidates, out.true_expected_count, out.sampled_expected_count};
}
inline Tensor LeftShift(const Tensor &x, const Tensor &y) {
  auto out = EsLeftShift(x.GetEsbTensor(), y.GetEsbTensor());
  return out;
}
inline Tensor Lerp(const Tensor &start, const Tensor &end, const Tensor &weight) {
  auto out = EsLerp(start.GetEsbTensor(), end.GetEsbTensor(), weight.GetEsbTensor());
  return out;
}
inline Tensor Less(const Tensor &x1, const Tensor &x2) {
  auto out = EsLess(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor Less(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return Less(tensor, b_esb_tensor);
}
inline Tensor LessEqual(const Tensor &x1, const Tensor &x2) {
  auto out = EsLessEqual(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor LessEqual(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return LessEqual(tensor, b_esb_tensor);
}
inline Tensor Lgamma(const Tensor &x) {
  auto out = EsLgamma(x.GetEsbTensor());
  return out;
}
inline Tensor LinSpace(const Tensor &start, const Tensor &stop, const Tensor &num) {
  auto out = EsLinSpace(start.GetEsbTensor(), stop.GetEsbTensor(), num.GetEsbTensor());
  return out;
}
inline Tensor LinSpaceD(const Tensor &assist, const Tensor &start, const Tensor &stop, const Tensor &num) {
  auto out = EsLinSpaceD(assist.GetEsbTensor(), start.GetEsbTensor(), stop.GetEsbTensor(), num.GetEsbTensor());
  return out;
}
struct ListDiffOutput {
  Tensor out;
  Tensor idx;
};
inline ListDiffOutput ListDiff(const Tensor &x, const Tensor &y, ge::DataType out_idx=ge::DT_INT32) {
  auto out = EsListDiff(x.GetEsbTensor(), y.GetEsbTensor(), out_idx);
  return {out.out, out.idx};
}
inline Tensor Log(const Tensor &x, float base=-1.000000, float scale=1.000000, float shift=0.000000) {
  auto out = EsLog(x.GetEsbTensor(), base, scale, shift);
  return out;
}
inline Tensor Log1p(const Tensor &x) {
  auto out = EsLog1p(x.GetEsbTensor());
  return out;
}
inline Tensor LogAddExp(const Tensor &x1, const Tensor &x2, float base=-1.000000, float scale=1.000000, float shift=0.000000) {
  auto out = EsLogAddExp(x1.GetEsbTensor(), x2.GetEsbTensor(), base, scale, shift);
  return out;
}
struct LogMatrixDeterminantOutput {
  Tensor sign;
  Tensor y;
};
inline LogMatrixDeterminantOutput LogMatrixDeterminant(const Tensor &x) {
  auto out = EsLogMatrixDeterminant(x.GetEsbTensor());
  return {out.sign, out.y};
}
inline Tensor LogSigmoid(const Tensor &x) {
  auto out = EsLogSigmoid(x.GetEsbTensor());
  return out;
}
inline Tensor LogSigmoidGrad(const Tensor &grads, const Tensor &features) {
  auto out = EsLogSigmoidGrad(grads.GetEsbTensor(), features.GetEsbTensor());
  return out;
}
inline Tensor LogSoftmaxGrad(const Tensor &grad, const Tensor &x, const std::vector<int64_t> &axis={-1}) {
  auto out = EsLogSoftmaxGrad(grad.GetEsbTensor(), x.GetEsbTensor(), axis.data(), static_cast<int64_t>(axis.size()));
  return out;
}
inline Tensor LogSoftmaxV2(const Tensor &logits, const std::vector<int64_t> &axes={-1}) {
  auto out = EsLogSoftmaxV2(logits.GetEsbTensor(), axes.data(), static_cast<int64_t>(axes.size()));
  return out;
}
inline Tensor LogSpaceD(const Tensor &assist, float start, float end, int64_t steps=100, float base=10.000000, int64_t dtype=1) {
  auto out = EsLogSpaceD(assist.GetEsbTensor(), start, end, steps, base, dtype);
  return out;
}
struct LogUniformCandidateSamplerOutput {
  Tensor sampled_candidates;
  Tensor true_expected_count;
  Tensor sampled_expected_count;
};
inline LogUniformCandidateSamplerOutput LogUniformCandidateSampler(const Tensor &true_classes, int64_t num_true, int64_t num_sampled, bool unique, int64_t range_max, int64_t seed=0, int64_t seed2=0) {
  auto out = EsLogUniformCandidateSampler(true_classes.GetEsbTensor(), num_true, num_sampled, unique, range_max, seed, seed2);
  return {out.sampled_candidates, out.true_expected_count, out.sampled_expected_count};
}
inline Tensor LogicalAnd(const Tensor &x1, const Tensor &x2) {
  auto out = EsLogicalAnd(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor LogicalAnd(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return LogicalAnd(tensor, b_esb_tensor);
}
inline Tensor LogicalNot(const Tensor &x) {
  auto out = EsLogicalNot(x.GetEsbTensor());
  return out;
}
inline Tensor LogicalOr(const Tensor &x1, const Tensor &x2) {
  auto out = EsLogicalOr(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor LogicalOr(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return LogicalOr(tensor, b_esb_tensor);
}
struct LookupTableExportOutput {
  Tensor keys;
  Tensor values;
};
inline LookupTableExportOutput LookupTableExport(const Tensor &handle, ge::DataType Tkeys, ge::DataType Tvalues) {
  auto out = EsLookupTableExport(handle.GetEsbTensor(), Tkeys, Tvalues);
  return {out.keys, out.values};
}
inline Tensor LookupTableFind(const Tensor &handle, const Tensor &keys, const Tensor &default_value, ge::DataType Tout) {
  auto out = EsLookupTableFind(handle.GetEsbTensor(), keys.GetEsbTensor(), default_value.GetEsbTensor(), Tout);
  return out;
}
inline Tensor LookupTableImport(const Tensor &handle, const Tensor &keys, const Tensor &values) {
  auto out = EsLookupTableImport(handle.GetEsbTensor(), keys.GetEsbTensor(), values.GetEsbTensor());
  return out;
}
inline Tensor LookupTableInsert(const Tensor &handle, const Tensor &keys, const Tensor &values) {
  auto out = EsLookupTableInsert(handle.GetEsbTensor(), keys.GetEsbTensor(), values.GetEsbTensor());
  return out;
}
inline Tensor LookupTableRemove(const Tensor &table_handle, const Tensor &keys) {
  auto out = EsLookupTableRemove(table_handle.GetEsbTensor(), keys.GetEsbTensor());
  return out;
}
inline Tensor LookupTableSize(const Tensor &handle) {
  auto out = EsLookupTableSize(handle.GetEsbTensor());
  return out;
}
inline Tensor LoopCond(const Tensor &x) {
  auto out = EsLoopCond(x.GetEsbTensor());
  return out;
}
inline Tensor LowerBound(const Tensor &sorted_x, const Tensor &values, ge::DataType out_type=ge::DT_INT32) {
  auto out = EsLowerBound(sorted_x.GetEsbTensor(), values.GetEsbTensor(), out_type);
  return out;
}
inline Tensor LpLoss(const Tensor &predict, const Tensor &label, int64_t p, const char *reduction="mean") {
  auto out = EsLpLoss(predict.GetEsbTensor(), label.GetEsbTensor(), p, reduction);
  return out;
}
inline Tensor LpNorm(const Tensor &x, int64_t p=2, const std::vector<int64_t> &axes={}, bool keepdim=false, float epsilon=0.000000) {
  auto out = EsLpNorm(x.GetEsbTensor(), p, axes.data(), static_cast<int64_t>(axes.size()), keepdim, epsilon);
  return out;
}
inline Tensor LpNormReduce(const Tensor &x, int64_t p=2, const std::vector<int64_t> &axes={}, bool keepdim=false, float epsilon=0.000000) {
  auto out = EsLpNormReduce(x.GetEsbTensor(), p, axes.data(), static_cast<int64_t>(axes.size()), keepdim, epsilon);
  return out;
}
inline Tensor LpNormReduceV2(const Tensor &x, float p=2.000000, const std::vector<int64_t> &axes={}, bool keepdim=false, float epsilon=0.000000) {
  auto out = EsLpNormReduceV2(x.GetEsbTensor(), p, axes.data(), static_cast<int64_t>(axes.size()), keepdim, epsilon);
  return out;
}
inline Tensor LpNormUpdate(const Tensor &x, int64_t p=2, float epsilon=0.000000) {
  auto out = EsLpNormUpdate(x.GetEsbTensor(), p, epsilon);
  return out;
}
inline Tensor LpNormUpdateV2(const Tensor &x, float p=2.000000, float epsilon=0.000000) {
  auto out = EsLpNormUpdateV2(x.GetEsbTensor(), p, epsilon);
  return out;
}
inline Tensor LpNormV2(const Tensor &x, float p=2.000000, const std::vector<int64_t> &axes={}, bool keepdim=false, float epsilon=0.000000) {
  auto out = EsLpNormV2(x.GetEsbTensor(), p, axes.data(), static_cast<int64_t>(axes.size()), keepdim, epsilon);
  return out;
}
inline Tensor LruCache(const Graph &owner_graph, ge::DataType dtype, const char *container="", const char *shared_name="LruCache", int64_t cache_size=100000, float load_factor=1.000000) {
  auto out = EsLruCache(owner_graph.GetEsbGraph(), dtype, container, shared_name, cache_size, load_factor);
  return out;
}
struct LuOutput {
  Tensor lu;
  Tensor p;
};
inline LuOutput Lu(const Tensor &input, ge::DataType output_idx_type) {
  auto out = EsLu(input.GetEsbTensor(), output_idx_type);
  return {out.lu, out.p};
}
inline Tensor MVN(const Tensor &x, bool normalize_variance=true, bool across_channels=false, float eps=0.000000) {
  auto out = EsMVN(x.GetEsbTensor(), normalize_variance, across_channels, eps);
  return out;
}
inline Tensor MVNV2(const Tensor &x, float eps=0.000000, const std::vector<int64_t> &axes={0, 2, 3}) {
  auto out = EsMVNV2(x.GetEsbTensor(), eps, axes.data(), static_cast<int64_t>(axes.size()));
  return out;
}
inline Tensor MapIndex(const Tensor &x, const Tensor &data_seq, const Tensor &level_index=nullptr) {
  auto out = EsMapIndex(x.GetEsbTensor(), data_seq.GetEsbTensor(), level_index.GetEsbTensor());
  return out;
}
inline Tensor Mask2Argmax(const Tensor &x, const Tensor &mask, const std::vector<int64_t> &ksize, const std::vector<int64_t> &strides, const char *padding, const std::vector<int64_t> &originshape) {
  auto out = EsMask2Argmax(x.GetEsbTensor(), mask.GetEsbTensor(), ksize.data(), static_cast<int64_t>(ksize.size()), strides.data(), static_cast<int64_t>(strides.size()), padding, originshape.data(), static_cast<int64_t>(originshape.size()));
  return out;
}
inline Tensor MaskedFill(const Tensor &x, const Tensor &mask, const Tensor &value) {
  auto out = EsMaskedFill(x.GetEsbTensor(), mask.GetEsbTensor(), value.GetEsbTensor());
  return out;
}
inline Tensor MaskedFillRange(const Tensor &x, const Tensor &start, const Tensor &end, const Tensor &value, int64_t axis) {
  auto out = EsMaskedFillRange(x.GetEsbTensor(), start.GetEsbTensor(), end.GetEsbTensor(), value.GetEsbTensor(), axis);
  return out;
}
inline Tensor MaskedScale(const Tensor &x, const Tensor &mask, float value) {
  auto out = EsMaskedScale(x.GetEsbTensor(), mask.GetEsbTensor(), value);
  return out;
}
inline Tensor MaskedScatter(const Tensor &x, const Tensor &mask, const Tensor &updates) {
  auto out = EsMaskedScatter(x.GetEsbTensor(), mask.GetEsbTensor(), updates.GetEsbTensor());
  return out;
}
inline Tensor MaskedSelect(const Tensor &x, const Tensor &mask) {
  auto out = EsMaskedSelect(x.GetEsbTensor(), mask.GetEsbTensor());
  return out;
}
inline Tensor MaskedSelectV2(const Tensor &x, const Tensor &mask) {
  auto out = EsMaskedSelectV2(x.GetEsbTensor(), mask.GetEsbTensor());
  return out;
}
inline Tensor MaskedSoftmaxWithRelPosBias(const Tensor &x, const Tensor &atten_mask, const Tensor &relative_pos_bias, float scale_value=1.000000, int64_t inner_precision_mode=0) {
  auto out = EsMaskedSoftmaxWithRelPosBias(x.GetEsbTensor(), atten_mask.GetEsbTensor(), relative_pos_bias.GetEsbTensor(), scale_value, inner_precision_mode);
  return out;
}
inline Tensor MatMul(const Tensor &x1, const Tensor &x2, const Tensor &bias=nullptr, bool transpose_x1=false, bool transpose_x2=false) {
  auto out = EsMatMul(x1.GetEsbTensor(), x2.GetEsbTensor(), bias.GetEsbTensor(), transpose_x1, transpose_x2);
  return out;
}
inline Tensor MatMulV2(const Tensor &x1, const Tensor &x2, const Tensor &bias=nullptr, const Tensor &offset_w=nullptr, bool transpose_x1=false, bool transpose_x2=false, int64_t offset_x=0) {
  auto out = EsMatMulV2(x1.GetEsbTensor(), x2.GetEsbTensor(), bias.GetEsbTensor(), offset_w.GetEsbTensor(), transpose_x1, transpose_x2, offset_x);
  return out;
}
inline Tensor MatMulV2Compress(const Tensor &x1, const Tensor &x2, const Tensor &compress_index, const Tensor &bias=nullptr, const Tensor &offset_w=nullptr, bool transpose_x1=false, bool transpose_x2=false, int64_t offset_x=0, const char *alg="weight_unzip") {
  auto out = EsMatMulV2Compress(x1.GetEsbTensor(), x2.GetEsbTensor(), compress_index.GetEsbTensor(), bias.GetEsbTensor(), offset_w.GetEsbTensor(), transpose_x1, transpose_x2, offset_x, alg);
  return out;
}
inline Tensor MatMulV2CompressDequant(const Tensor &x1, const Tensor &x2, const Tensor &compress_index, const Tensor &deq_scale, const Tensor &bias=nullptr, const Tensor &offset_w=nullptr, bool transpose_x1=false, bool transpose_x2=false, const std::vector<int64_t> &compress_info={1, 1, 1, 1, 1}, int64_t offset_x=0, const char *alg="weight_unzip") {
  auto out = EsMatMulV2CompressDequant(x1.GetEsbTensor(), x2.GetEsbTensor(), compress_index.GetEsbTensor(), deq_scale.GetEsbTensor(), bias.GetEsbTensor(), offset_w.GetEsbTensor(), transpose_x1, transpose_x2, compress_info.data(), static_cast<int64_t>(compress_info.size()), offset_x, alg);
  return out;
}
inline Tensor MatMulV3(const Tensor &x1, const Tensor &x2, const Tensor &bias=nullptr, const Tensor &offset_w=nullptr, bool transpose_x1=false, bool transpose_x2=false, int64_t offset_x=0, bool enable_hf32=false) {
  auto out = EsMatMulV3(x1.GetEsbTensor(), x2.GetEsbTensor(), bias.GetEsbTensor(), offset_w.GetEsbTensor(), transpose_x1, transpose_x2, offset_x, enable_hf32);
  return out;
}
inline Tensor MatmulAllReduce(const Tensor &x1, const Tensor &x2, const Tensor &bias, const Tensor &x3, const Tensor &antiquant_scale, const Tensor &antiquant_offset, const Tensor &dequant_scale, const Tensor &pertoken_scale, const Tensor &comm_quant_scale_1, const Tensor &comm_quant_scale_2, const char *group, const char *reduce_op="sum", bool is_trans_a=false, bool is_trans_b=false, int64_t comm_turn=0, int64_t antiquant_group_size=0) {
  auto out = EsMatmulAllReduce(x1.GetEsbTensor(), x2.GetEsbTensor(), bias.GetEsbTensor(), x3.GetEsbTensor(), antiquant_scale.GetEsbTensor(), antiquant_offset.GetEsbTensor(), dequant_scale.GetEsbTensor(), pertoken_scale.GetEsbTensor(), comm_quant_scale_1.GetEsbTensor(), comm_quant_scale_2.GetEsbTensor(), group, reduce_op, is_trans_a, is_trans_b, comm_turn, antiquant_group_size);
  return out;
}
struct MatmulAllReduceAddRmsNormOutput {
  Tensor y;
  Tensor norm_out;
};
inline MatmulAllReduceAddRmsNormOutput MatmulAllReduceAddRmsNorm(const Tensor &x1, const Tensor &x2, const Tensor &bias, const Tensor &residual, const Tensor &gamma, const Tensor &antiquant_scale, const Tensor &antiquant_offset, const Tensor &dequant_scale, const char *group, const char *reduce_op="sum", bool is_trans_a=false, bool is_trans_b=false, int64_t comm_turn=0, int64_t antiquant_group_size=0, float epsilon=0.000001) {
  auto out = EsMatmulAllReduceAddRmsNorm(x1.GetEsbTensor(), x2.GetEsbTensor(), bias.GetEsbTensor(), residual.GetEsbTensor(), gamma.GetEsbTensor(), antiquant_scale.GetEsbTensor(), antiquant_offset.GetEsbTensor(), dequant_scale.GetEsbTensor(), group, reduce_op, is_trans_a, is_trans_b, comm_turn, antiquant_group_size, epsilon);
  return {out.y, out.norm_out};
}
struct MatmulLayerNormReduceOutput {
  Tensor x2;
  Tensor sum;
  Tensor square_sum;
};
inline MatmulLayerNormReduceOutput MatmulLayerNormReduce(const Tensor &x1, const Tensor &weight, const Tensor &bias, const Tensor &x2, const Tensor &x3=nullptr) {
  auto out = EsMatmulLayerNormReduce(x1.GetEsbTensor(), weight.GetEsbTensor(), bias.GetEsbTensor(), x2.GetEsbTensor(), x3.GetEsbTensor());
  return {out.x2, out.sum, out.square_sum};
}
inline Tensor MatmulReduceScatter(const Tensor &x1, const Tensor &x2, const Tensor &bias, const char *group, const char *reduce_op="sum", bool is_trans_a=false, bool is_trans_b=false, int64_t comm_turn=0, int64_t rank_size=0) {
  auto out = EsMatmulReduceScatter(x1.GetEsbTensor(), x2.GetEsbTensor(), bias.GetEsbTensor(), group, reduce_op, is_trans_a, is_trans_b, comm_turn, rank_size);
  return out;
}
inline Tensor MatrixBandPart(const Tensor &x, const Tensor &num_lower, const Tensor &num_upper) {
  auto out = EsMatrixBandPart(x.GetEsbTensor(), num_lower.GetEsbTensor(), num_upper.GetEsbTensor());
  return out;
}
inline Tensor MatrixDeterminant(const Tensor &x) {
  auto out = EsMatrixDeterminant(x.GetEsbTensor());
  return out;
}
inline Tensor MatrixDiag(const Tensor &x) {
  auto out = EsMatrixDiag(x.GetEsbTensor());
  return out;
}
inline Tensor MatrixDiagD(const Tensor &x, const Tensor &assist) {
  auto out = EsMatrixDiagD(x.GetEsbTensor(), assist.GetEsbTensor());
  return out;
}
inline Tensor MatrixDiagPart(const Tensor &x) {
  auto out = EsMatrixDiagPart(x.GetEsbTensor());
  return out;
}
inline Tensor MatrixDiagPartD(const Tensor &x, const Tensor &assist) {
  auto out = EsMatrixDiagPartD(x.GetEsbTensor(), assist.GetEsbTensor());
  return out;
}
inline Tensor MatrixDiagPartV2(const Tensor &input, const Tensor &k, const Tensor &padding_value) {
  auto out = EsMatrixDiagPartV2(input.GetEsbTensor(), k.GetEsbTensor(), padding_value.GetEsbTensor());
  return out;
}
inline Tensor MatrixDiagPartV3(const Tensor &x, const Tensor &k, const Tensor &padding_value, const char *align="RIGHT_LEFT") {
  auto out = EsMatrixDiagPartV3(x.GetEsbTensor(), k.GetEsbTensor(), padding_value.GetEsbTensor(), align);
  return out;
}
inline Tensor MatrixDiagV2(const Tensor &diagonal, const Tensor &k, const Tensor &num_rows, const Tensor &num_cols, const Tensor &padding_value) {
  auto out = EsMatrixDiagV2(diagonal.GetEsbTensor(), k.GetEsbTensor(), num_rows.GetEsbTensor(), num_cols.GetEsbTensor(), padding_value.GetEsbTensor());
  return out;
}
inline Tensor MatrixDiagV3(const Tensor &x, const Tensor &k, const Tensor &num_rows, const Tensor &num_cols, const Tensor &padding_value, const char *align="RIGHT_LEFT") {
  auto out = EsMatrixDiagV3(x.GetEsbTensor(), k.GetEsbTensor(), num_rows.GetEsbTensor(), num_cols.GetEsbTensor(), padding_value.GetEsbTensor(), align);
  return out;
}
inline Tensor MatrixInverse(const Tensor &x, bool adjoint=false) {
  auto out = EsMatrixInverse(x.GetEsbTensor(), adjoint);
  return out;
}
inline Tensor MatrixSetDiag(const Tensor &x, const Tensor &diagonal) {
  auto out = EsMatrixSetDiag(x.GetEsbTensor(), diagonal.GetEsbTensor());
  return out;
}
inline Tensor MatrixSetDiagD(const Tensor &x, const Tensor &diagonal, const Tensor &assist) {
  auto out = EsMatrixSetDiagD(x.GetEsbTensor(), diagonal.GetEsbTensor(), assist.GetEsbTensor());
  return out;
}
inline Tensor MatrixSetDiagV2(const Tensor &input, const Tensor &diagonal, const Tensor &k) {
  auto out = EsMatrixSetDiagV2(input.GetEsbTensor(), diagonal.GetEsbTensor(), k.GetEsbTensor());
  return out;
}
inline Tensor MatrixSetDiagV3(const Tensor &input, const Tensor &diagonal, const Tensor &k, const char *align="RIGHT_LEFT") {
  auto out = EsMatrixSetDiagV3(input.GetEsbTensor(), diagonal.GetEsbTensor(), k.GetEsbTensor(), align);
  return out;
}
inline Tensor MatrixSolve(const Tensor &matrix, const Tensor &rhs, bool adjoint=false) {
  auto out = EsMatrixSolve(matrix.GetEsbTensor(), rhs.GetEsbTensor(), adjoint);
  return out;
}
inline Tensor MatrixSolveLs(const Tensor &matrix, const Tensor &rhs, const Tensor &l2, bool fast=true) {
  auto out = EsMatrixSolveLs(matrix.GetEsbTensor(), rhs.GetEsbTensor(), l2.GetEsbTensor(), fast);
  return out;
}
inline Tensor MatrixSquareRoot(const Tensor &input) {
  auto out = EsMatrixSquareRoot(input.GetEsbTensor());
  return out;
}
inline Tensor MatrixTriangularSolve(const Tensor &matrix, const Tensor &rhs, bool lower=true, bool adjoint=false) {
  auto out = EsMatrixTriangularSolve(matrix.GetEsbTensor(), rhs.GetEsbTensor(), lower, adjoint);
  return out;
}
inline Tensor MaxN(const std::vector<Tensor> &x) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsMaxN(esb_x.data(), static_cast<int64_t>(esb_x.size()));
  return out;
}
inline Tensor MaxPool(const Tensor &x, const std::vector<int64_t> &ksize, const std::vector<int64_t> &strides, const char *padding, const char *data_format="NHWC") {
  auto out = EsMaxPool(x.GetEsbTensor(), ksize.data(), static_cast<int64_t>(ksize.size()), strides.data(), static_cast<int64_t>(strides.size()), padding, data_format);
  return out;
}
inline Tensor MaxPool3D(const Tensor &x, const std::vector<int64_t> &ksize, const std::vector<int64_t> &strides, const char *padding, const std::vector<int64_t> &pads={0, 0, 0, 0, 0, 0}, const std::vector<int64_t> &dilation={1, 1, 1, 1, 1}, int64_t ceil_mode=0, const char *data_format="NDHWC") {
  auto out = EsMaxPool3D(x.GetEsbTensor(), ksize.data(), static_cast<int64_t>(ksize.size()), strides.data(), static_cast<int64_t>(strides.size()), padding, pads.data(), static_cast<int64_t>(pads.size()), dilation.data(), static_cast<int64_t>(dilation.size()), ceil_mode, data_format);
  return out;
}
inline Tensor MaxPool3DGrad(const Tensor &orig_x, const Tensor &orig_y, const Tensor &grads, const std::vector<int64_t> &ksize, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const char *padding="SAME", const char *data_format="NDHWC") {
  auto out = EsMaxPool3DGrad(orig_x.GetEsbTensor(), orig_y.GetEsbTensor(), grads.GetEsbTensor(), ksize.data(), static_cast<int64_t>(ksize.size()), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), padding, data_format);
  return out;
}
inline Tensor MaxPool3DGradGrad(const Tensor &orig_x, const Tensor &orig_y, const Tensor &grads, const std::vector<int64_t> &ksize, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const char *data_format="NDHWC") {
  auto out = EsMaxPool3DGradGrad(orig_x.GetEsbTensor(), orig_y.GetEsbTensor(), grads.GetEsbTensor(), ksize.data(), static_cast<int64_t>(ksize.size()), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), data_format);
  return out;
}
struct MaxPool3DWithArgmaxOutput {
  Tensor y;
  Tensor argmax;
};
inline MaxPool3DWithArgmaxOutput MaxPool3DWithArgmax(const Tensor &x, const std::vector<int64_t> &ksize, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const std::vector<int64_t> &dilation={1, 1, 1, 1, 1}, bool ceil_mode=false, const char *data_format="NCDHW", const char *argmax_type="bitmask") {
  auto out = EsMaxPool3DWithArgmax(x.GetEsbTensor(), ksize.data(), static_cast<int64_t>(ksize.size()), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dilation.data(), static_cast<int64_t>(dilation.size()), ceil_mode, data_format, argmax_type);
  return {out.y, out.argmax};
}
inline Tensor MaxPoolExt2(const Tensor &x, const std::vector<int64_t> &ksize, const std::vector<int64_t> &strides, const char *padding, const char *data_format="NHWC") {
  auto out = EsMaxPoolExt2(x.GetEsbTensor(), ksize.data(), static_cast<int64_t>(ksize.size()), strides.data(), static_cast<int64_t>(strides.size()), padding, data_format);
  return out;
}
inline Tensor MaxPoolGrad(const Tensor &x1, const Tensor &x2, const Tensor &grad, const std::vector<int64_t> &ksize, const std::vector<int64_t> &strides, const char *padding, const char *data_format="NHWC") {
  auto out = EsMaxPoolGrad(x1.GetEsbTensor(), x2.GetEsbTensor(), grad.GetEsbTensor(), ksize.data(), static_cast<int64_t>(ksize.size()), strides.data(), static_cast<int64_t>(strides.size()), padding, data_format);
  return out;
}
inline Tensor MaxPoolGradGrad(const Tensor &x1, const Tensor &x2, const Tensor &grad, const std::vector<int64_t> &ksize, const std::vector<int64_t> &strides, const char *padding, const char *data_format="NHWC") {
  auto out = EsMaxPoolGradGrad(x1.GetEsbTensor(), x2.GetEsbTensor(), grad.GetEsbTensor(), ksize.data(), static_cast<int64_t>(ksize.size()), strides.data(), static_cast<int64_t>(strides.size()), padding, data_format);
  return out;
}
inline Tensor MaxPoolGradGradWithArgmax(const Tensor &x, const Tensor &grad, const Tensor &argmax, const std::vector<int64_t> &ksize, const std::vector<int64_t> &strides, const char *padding) {
  auto out = EsMaxPoolGradGradWithArgmax(x.GetEsbTensor(), grad.GetEsbTensor(), argmax.GetEsbTensor(), ksize.data(), static_cast<int64_t>(ksize.size()), strides.data(), static_cast<int64_t>(strides.size()), padding);
  return out;
}
inline Tensor MaxPoolGradWithArgmax(const Tensor &x, const Tensor &grad, const Tensor &argmax, const std::vector<int64_t> &ksize, const std::vector<int64_t> &strides, const char *padding) {
  auto out = EsMaxPoolGradWithArgmax(x.GetEsbTensor(), grad.GetEsbTensor(), argmax.GetEsbTensor(), ksize.data(), static_cast<int64_t>(ksize.size()), strides.data(), static_cast<int64_t>(strides.size()), padding);
  return out;
}
inline Tensor MaxPoolGradWithArgmaxV1(const Tensor &x, const Tensor &grad, const Tensor &argmax, const std::vector<int64_t> &ksize, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, int64_t dtype=3, const std::vector<int64_t> &dilation={1, 1, 1, 1}, bool ceil_mode=false) {
  auto out = EsMaxPoolGradWithArgmaxV1(x.GetEsbTensor(), grad.GetEsbTensor(), argmax.GetEsbTensor(), ksize.data(), static_cast<int64_t>(ksize.size()), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dtype, dilation.data(), static_cast<int64_t>(dilation.size()), ceil_mode);
  return out;
}
inline Tensor MaxPoolGradWithArgmaxV2(const Tensor &x, const Tensor &grad, const Tensor &argmax, const std::vector<int64_t> &ksize, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, int64_t dtype=3, const std::vector<int64_t> &dilation={1, 1, 1, 1}, bool ceil_mode=false) {
  auto out = EsMaxPoolGradWithArgmaxV2(x.GetEsbTensor(), grad.GetEsbTensor(), argmax.GetEsbTensor(), ksize.data(), static_cast<int64_t>(ksize.size()), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dtype, dilation.data(), static_cast<int64_t>(dilation.size()), ceil_mode);
  return out;
}
inline Tensor MaxPoolV2(const Tensor &x, const Tensor &ksize, const Tensor &strides, const char *padding, const char *data_format="NHWC") {
  auto out = EsMaxPoolV2(x.GetEsbTensor(), ksize.GetEsbTensor(), strides.GetEsbTensor(), padding, data_format);
  return out;
}
inline Tensor MaxPoolV3(const Tensor &x, const std::vector<int64_t> &ksize, const std::vector<int64_t> &strides, const char *padding_mode="CALCULATED", const std::vector<int64_t> &pads={0, 0, 0, 0}, const char *data_format="NCHW", bool global_pooling=false, bool ceil_mode=false) {
  auto out = EsMaxPoolV3(x.GetEsbTensor(), ksize.data(), static_cast<int64_t>(ksize.size()), strides.data(), static_cast<int64_t>(strides.size()), padding_mode, pads.data(), static_cast<int64_t>(pads.size()), data_format, global_pooling, ceil_mode);
  return out;
}
inline Tensor MaxPoolV3Grad(const Tensor &orig_input, const Tensor &orig_output, const Tensor &grad, const std::vector<int64_t> &ksize, const std::vector<int64_t> &strides, const char *padding_mode="CALCULATED", const std::vector<int64_t> &pads={0, 0, 0, 0}, const char *data_format="NCHW", bool global_pooling=false, bool ceil_mode=false) {
  auto out = EsMaxPoolV3Grad(orig_input.GetEsbTensor(), orig_output.GetEsbTensor(), grad.GetEsbTensor(), ksize.data(), static_cast<int64_t>(ksize.size()), strides.data(), static_cast<int64_t>(strides.size()), padding_mode, pads.data(), static_cast<int64_t>(pads.size()), data_format, global_pooling, ceil_mode);
  return out;
}
struct MaxPoolWithArgmaxOutput {
  Tensor y;
  Tensor argmax;
};
inline MaxPoolWithArgmaxOutput MaxPoolWithArgmax(const Tensor &x, const std::vector<int64_t> &ksize, const std::vector<int64_t> &strides, const char *padding, int64_t Targmax=7) {
  auto out = EsMaxPoolWithArgmax(x.GetEsbTensor(), ksize.data(), static_cast<int64_t>(ksize.size()), strides.data(), static_cast<int64_t>(strides.size()), padding, Targmax);
  return {out.y, out.argmax};
}
struct MaxPoolWithArgmaxV1Output {
  Tensor y;
  Tensor argmax;
};
inline MaxPoolWithArgmaxV1Output MaxPoolWithArgmaxV1(const Tensor &x, const std::vector<int64_t> &ksize, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, int64_t dtype=3, const std::vector<int64_t> &dilation={1, 1, 1, 1}, bool ceil_mode=false) {
  auto out = EsMaxPoolWithArgmaxV1(x.GetEsbTensor(), ksize.data(), static_cast<int64_t>(ksize.size()), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dtype, dilation.data(), static_cast<int64_t>(dilation.size()), ceil_mode);
  return {out.y, out.argmax};
}
struct MaxPoolWithArgmaxV2Output {
  Tensor y;
  Tensor argmax;
};
inline MaxPoolWithArgmaxV2Output MaxPoolWithArgmaxV2(const Tensor &x, const std::vector<int64_t> &ksize, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, int64_t dtype=3, const std::vector<int64_t> &dilation={1, 1, 1, 1}, bool ceil_mode=false) {
  auto out = EsMaxPoolWithArgmaxV2(x.GetEsbTensor(), ksize.data(), static_cast<int64_t>(ksize.size()), strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dtype, dilation.data(), static_cast<int64_t>(dilation.size()), ceil_mode);
  return {out.y, out.argmax};
}
inline Tensor Maximum(const Tensor &x1, const Tensor &x2) {
  auto out = EsMaximum(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor Maximum(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return Maximum(tensor, b_esb_tensor);
}
struct MaximumGradOutput {
  Tensor y1;
  Tensor y2;
};
inline MaximumGradOutput MaximumGrad(const Tensor &grads, const Tensor &x1, const Tensor &x2, bool grad_x=true, bool grad_y=true) {
  auto out = EsMaximumGrad(grads.GetEsbTensor(), x1.GetEsbTensor(), x2.GetEsbTensor(), grad_x, grad_y);
  return {out.y1, out.y2};
}
struct MergeOutput {
  Tensor y;
  Tensor value_index;
};
inline MergeOutput Merge(const std::vector<Tensor> &x) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsMerge(esb_x.data(), static_cast<int64_t>(esb_x.size()));
  return {out.y, out.value_index};
}
inline Tensor Mfcc(const Tensor &spectrogram, const Tensor &sample_rate, float upper_frequency_limit=4000.000000, float lower_frequency_limit=20.000000, int64_t filterbank_channel_count=40, int64_t dct_coefficient_count=13) {
  auto out = EsMfcc(spectrogram.GetEsbTensor(), sample_rate.GetEsbTensor(), upper_frequency_limit, lower_frequency_limit, filterbank_channel_count, dct_coefficient_count);
  return out;
}
inline Tensor MinAreaPolygons(const Tensor &pointsets) {
  auto out = EsMinAreaPolygons(pointsets.GetEsbTensor());
  return out;
}
inline Tensor Minimum(const Tensor &x1, const Tensor &x2) {
  auto out = EsMinimum(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor Minimum(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return Minimum(tensor, b_esb_tensor);
}
struct MinimumGradOutput {
  Tensor y1;
  Tensor y2;
};
inline MinimumGradOutput MinimumGrad(const Tensor &grads, const Tensor &x1, const Tensor &x2, bool grad_x=true, bool grad_y=true) {
  auto out = EsMinimumGrad(grads.GetEsbTensor(), x1.GetEsbTensor(), x2.GetEsbTensor(), grad_x, grad_y);
  return {out.y1, out.y2};
}
inline Tensor MirrorPad(const Tensor &x, const Tensor &paddings, const char *mode) {
  auto out = EsMirrorPad(x.GetEsbTensor(), paddings.GetEsbTensor(), mode);
  return out;
}
inline Tensor MirrorPadGrad(const Tensor &x, const Tensor &paddings, const char *mode) {
  auto out = EsMirrorPadGrad(x.GetEsbTensor(), paddings.GetEsbTensor(), mode);
  return out;
}
inline Tensor Mish(const Tensor &x) {
  auto out = EsMish(x.GetEsbTensor());
  return out;
}
inline Tensor MishGrad(const Tensor &grad, const Tensor &x, const Tensor &tanhx=nullptr) {
  auto out = EsMishGrad(grad.GetEsbTensor(), x.GetEsbTensor(), tanhx.GetEsbTensor());
  return out;
}
inline Tensor Mod(const Tensor &x1, const Tensor &x2) {
  auto out = EsMod(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor Mod(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return Mod(tensor, b_esb_tensor);
}
inline Tensor MoeComputeExpertTokens(const Tensor &sorted_experts, int64_t num_experts) {
  auto out = EsMoeComputeExpertTokens(sorted_experts.GetEsbTensor(), num_experts);
  return out;
}
inline Tensor MoeFinalizeRouting(const Tensor &expanded_x, const Tensor &x1, const Tensor &x2, const Tensor &bias, const Tensor &scales, const Tensor &expanded_row_idx, const Tensor &expanded_expert_idx) {
  auto out = EsMoeFinalizeRouting(expanded_x.GetEsbTensor(), x1.GetEsbTensor(), x2.GetEsbTensor(), bias.GetEsbTensor(), scales.GetEsbTensor(), expanded_row_idx.GetEsbTensor(), expanded_expert_idx.GetEsbTensor());
  return out;
}
inline Tensor MoeFinalizeRoutingV2(const Tensor &expanded_x, const Tensor &expanded_row_idx, const Tensor &x1=nullptr, const Tensor &x2=nullptr, const Tensor &bias=nullptr, const Tensor &scales=nullptr, const Tensor &expert_idx=nullptr, int64_t drop_pad_mode=0) {
  auto out = EsMoeFinalizeRoutingV2(expanded_x.GetEsbTensor(), expanded_row_idx.GetEsbTensor(), x1.GetEsbTensor(), x2.GetEsbTensor(), bias.GetEsbTensor(), scales.GetEsbTensor(), expert_idx.GetEsbTensor(), drop_pad_mode);
  return out;
}
struct MoeFinalizeRoutingV2GradOutput {
  Tensor grad_expanded_x;
  Tensor grad_scales;
};
inline MoeFinalizeRoutingV2GradOutput MoeFinalizeRoutingV2Grad(const Tensor &grad_y, const Tensor &expanded_row_idx, const Tensor &expanded_x=nullptr, const Tensor &scales=nullptr, const Tensor &expert_idx=nullptr, const Tensor &bias=nullptr, int64_t drop_pad_mode=0, int64_t active_num=0, int64_t expert_num=0, int64_t expert_capacity=0) {
  auto out = EsMoeFinalizeRoutingV2Grad(grad_y.GetEsbTensor(), expanded_row_idx.GetEsbTensor(), expanded_x.GetEsbTensor(), scales.GetEsbTensor(), expert_idx.GetEsbTensor(), bias.GetEsbTensor(), drop_pad_mode, active_num, expert_num, expert_capacity);
  return {out.grad_expanded_x, out.grad_scales};
}
struct MoeGatingTopKSoftmaxOutput {
  Tensor y;
  Tensor expert_idx;
  Tensor row_idx;
};
inline MoeGatingTopKSoftmaxOutput MoeGatingTopKSoftmax(const Tensor &x, const Tensor &finished, int64_t k) {
  auto out = EsMoeGatingTopKSoftmax(x.GetEsbTensor(), finished.GetEsbTensor(), k);
  return {out.y, out.expert_idx, out.row_idx};
}
struct MoeGatingTopKSoftmaxV2Output {
  Tensor y;
  Tensor expert_idx;
  Tensor softmax_result;
};
inline MoeGatingTopKSoftmaxV2Output MoeGatingTopKSoftmaxV2(const Tensor &x, const Tensor &finished, int64_t k, int64_t renorm=0, bool output_softmax_result_flag=false) {
  auto out = EsMoeGatingTopKSoftmaxV2(x.GetEsbTensor(), finished.GetEsbTensor(), k, renorm, output_softmax_result_flag);
  return {out.y, out.expert_idx, out.softmax_result};
}
struct MoeInitRoutingOutput {
  Tensor expanded_x;
  Tensor expanded_row_idx;
  Tensor expanded_expert_idx;
};
inline MoeInitRoutingOutput MoeInitRouting(const Tensor &x, const Tensor &row_idx, const Tensor &expert_idx, int64_t active_num) {
  auto out = EsMoeInitRouting(x.GetEsbTensor(), row_idx.GetEsbTensor(), expert_idx.GetEsbTensor(), active_num);
  return {out.expanded_x, out.expanded_row_idx, out.expanded_expert_idx};
}
struct MoeInitRoutingQuantOutput {
  Tensor expanded_x;
  Tensor expanded_row_idx;
  Tensor expanded_expert_idx;
};
inline MoeInitRoutingQuantOutput MoeInitRoutingQuant(const Tensor &x, const Tensor &row_idx, const Tensor &expert_idx, int64_t active_num, float scale, float offset) {
  auto out = EsMoeInitRoutingQuant(x.GetEsbTensor(), row_idx.GetEsbTensor(), expert_idx.GetEsbTensor(), active_num, scale, offset);
  return {out.expanded_x, out.expanded_row_idx, out.expanded_expert_idx};
}
struct MoeInitRoutingQuantV2Output {
  Tensor expanded_x;
  Tensor expanded_row_idx;
  Tensor expert_tokens_count_or_cumsum;
  Tensor expert_tokens_before_capacity;
  Tensor dynamic_quant_scale;
};
inline MoeInitRoutingQuantV2Output MoeInitRoutingQuantV2(const Tensor &x, const Tensor &expert_idx, const Tensor &scale=nullptr, const Tensor &offset=nullptr, int64_t active_num=0, int64_t expert_capacity=0, int64_t expert_num=0, int64_t drop_pad_mode=0, int64_t expert_tokens_count_or_cumsum_flag=0, bool expert_tokens_before_capacity_flag=false, int64_t quant_mode=0) {
  auto out = EsMoeInitRoutingQuantV2(x.GetEsbTensor(), expert_idx.GetEsbTensor(), scale.GetEsbTensor(), offset.GetEsbTensor(), active_num, expert_capacity, expert_num, drop_pad_mode, expert_tokens_count_or_cumsum_flag, expert_tokens_before_capacity_flag, quant_mode);
  return {out.expanded_x, out.expanded_row_idx, out.expert_tokens_count_or_cumsum, out.expert_tokens_before_capacity, out.dynamic_quant_scale};
}
inline Tensor MoeInitRoutingV2Grad(const Tensor &grad_expanded_x, const Tensor &expanded_row_idx, int64_t top_k, int64_t drop_pad_mode=0, int64_t active_num=0) {
  auto out = EsMoeInitRoutingV2Grad(grad_expanded_x.GetEsbTensor(), expanded_row_idx.GetEsbTensor(), top_k, drop_pad_mode, active_num);
  return out;
}
inline Tensor MovingSumWithSigmoid(const Tensor &alpha, const Tensor &energy, const Tensor &offset, int64_t ksize) {
  auto out = EsMovingSumWithSigmoid(alpha.GetEsbTensor(), energy.GetEsbTensor(), offset.GetEsbTensor(), ksize);
  return out;
}
inline Tensor MseLoss(const Tensor &predict, const Tensor &label, const char *reduction="mean") {
  auto out = EsMseLoss(predict.GetEsbTensor(), label.GetEsbTensor(), reduction);
  return out;
}
inline Tensor MseLossGrad(const Tensor &predict, const Tensor &label, const Tensor &dout, const char *reduction="mean") {
  auto out = EsMseLossGrad(predict.GetEsbTensor(), label.GetEsbTensor(), dout.GetEsbTensor(), reduction);
  return out;
}
inline Tensor Mul(const Tensor &x1, const Tensor &x2) {
  auto out = EsMul(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor Mul(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return Mul(tensor, b_esb_tensor);
}
inline Tensor MulNoNan(const Tensor &x1, const Tensor &x2) {
  auto out = EsMulNoNan(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor MulNoNan(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return MulNoNan(tensor, b_esb_tensor);
}
inline Tensor Muls(const Tensor &x, float value) {
  auto out = EsMuls(x.GetEsbTensor(), value);
  return out;
}
struct MultiHeadAttentionOutput {
  Tensor y;
  Tensor dropout_mask;
  Tensor query_res;
  Tensor key_res;
  Tensor value_res;
  Tensor attn_scores;
  Tensor attn_res;
  Tensor context;
};
inline MultiHeadAttentionOutput MultiHeadAttention(const Tensor &query, const Tensor &key, const Tensor &value, const Tensor &query_weight, const Tensor &key_weight, const Tensor &value_weight, const Tensor &attn_mask, const Tensor &out_proj_weight, const Tensor &query_bias, const Tensor &key_bias, const Tensor &value_bias, const Tensor &out_proj_bias, const Tensor &dropout_mask_input, int64_t attn_head_num, int64_t attn_dim_per_head, int64_t src_len, int64_t tgt_len, float keep_prob, bool softmax_use_float) {
  auto out = EsMultiHeadAttention(query.GetEsbTensor(), key.GetEsbTensor(), value.GetEsbTensor(), query_weight.GetEsbTensor(), key_weight.GetEsbTensor(), value_weight.GetEsbTensor(), attn_mask.GetEsbTensor(), out_proj_weight.GetEsbTensor(), query_bias.GetEsbTensor(), key_bias.GetEsbTensor(), value_bias.GetEsbTensor(), out_proj_bias.GetEsbTensor(), dropout_mask_input.GetEsbTensor(), attn_head_num, attn_dim_per_head, src_len, tgt_len, keep_prob, softmax_use_float);
  return {out.y, out.dropout_mask, out.query_res, out.key_res, out.value_res, out.attn_scores, out.attn_res, out.context};
}
struct MultiHeadAttentionGradOutput {
  Tensor query_weight_grad;
  Tensor key_weight_grad;
  Tensor value_weight_grad;
  Tensor out_proj_weight_grad;
  Tensor query_grad;
  Tensor key_grad;
  Tensor value_grad;
  Tensor query_bias_grad;
  Tensor key_bias_grad;
  Tensor value_bias_grad;
  Tensor out_proj_bias_grad;
};
inline MultiHeadAttentionGradOutput MultiHeadAttentionGrad(const Tensor &query, const Tensor &key, const Tensor &value, const Tensor &query_weight, const Tensor &key_weight, const Tensor &value_weight, const Tensor &out_proj_weight, const Tensor &query_res, const Tensor &key_res, const Tensor &value_res, const Tensor &attn_scores, const Tensor &attn_res, const Tensor &context, const Tensor &y_grad, const Tensor &dropout_mask, int64_t attn_head_num, int64_t attn_dim_per_head, int64_t src_len, int64_t tgt_len, float keep_prob, bool softmax_use_float, const std::vector<uint8_t> &bias_grad_mask) {
  auto out = EsMultiHeadAttentionGrad(query.GetEsbTensor(), key.GetEsbTensor(), value.GetEsbTensor(), query_weight.GetEsbTensor(), key_weight.GetEsbTensor(), value_weight.GetEsbTensor(), out_proj_weight.GetEsbTensor(), query_res.GetEsbTensor(), key_res.GetEsbTensor(), value_res.GetEsbTensor(), attn_scores.GetEsbTensor(), attn_res.GetEsbTensor(), context.GetEsbTensor(), y_grad.GetEsbTensor(), dropout_mask.GetEsbTensor(), attn_head_num, attn_dim_per_head, src_len, tgt_len, keep_prob, softmax_use_float, static_cast<const bool *>(static_cast<const void *>(bias_grad_mask.data())), static_cast<int64_t>(bias_grad_mask.size()));
  return {out.query_weight_grad, out.key_weight_grad, out.value_weight_grad, out.out_proj_weight_grad, out.query_grad, out.key_grad, out.value_grad, out.query_bias_grad, out.key_bias_grad, out.value_bias_grad, out.out_proj_bias_grad};
}
struct MultiHeadAttentionScoreOutput {
  Tensor softmax_out;
  Tensor attention_out;
};
inline MultiHeadAttentionScoreOutput MultiHeadAttentionScore(const Tensor &query, const Tensor &key, const Tensor &value, const Tensor &pse_shift, const Tensor &drop_mask, const Tensor &padding_mask, const Tensor &atten_mask, int64_t head_num, const char *input_layout, float scale_value=1.000000, float keep_prob=1.000000, int64_t pre_tockens=2147483647, int64_t next_tockens=2147483647) {
  auto out = EsMultiHeadAttentionScore(query.GetEsbTensor(), key.GetEsbTensor(), value.GetEsbTensor(), pse_shift.GetEsbTensor(), drop_mask.GetEsbTensor(), padding_mask.GetEsbTensor(), atten_mask.GetEsbTensor(), head_num, input_layout, scale_value, keep_prob, pre_tockens, next_tockens);
  return {out.softmax_out, out.attention_out};
}
struct MultiHeadAttentionScoreGradOutput {
  Tensor dq;
  Tensor dk;
  Tensor dv;
  Tensor dpse;
};
inline MultiHeadAttentionScoreGradOutput MultiHeadAttentionScoreGrad(const Tensor &query, const Tensor &key, const Tensor &value, const Tensor &dy, const Tensor &pse_shift, const Tensor &drop_mask, const Tensor &padding_mask, const Tensor &atten_mask, const Tensor &softmax_in, const Tensor &attention_in, int64_t head_num, const char *input_layout, float scale_value=1.000000, float keep_prob=1.000000, int64_t pre_tockens=65536, int64_t next_tockens=65536) {
  auto out = EsMultiHeadAttentionScoreGrad(query.GetEsbTensor(), key.GetEsbTensor(), value.GetEsbTensor(), dy.GetEsbTensor(), pse_shift.GetEsbTensor(), drop_mask.GetEsbTensor(), padding_mask.GetEsbTensor(), atten_mask.GetEsbTensor(), softmax_in.GetEsbTensor(), attention_in.GetEsbTensor(), head_num, input_layout, scale_value, keep_prob, pre_tockens, next_tockens);
  return {out.dq, out.dk, out.dv, out.dpse};
}
struct MultiMergeOutput {
  Tensor output_proposal;
  Tensor output_index;
};
inline MultiMergeOutput MultiMerge(const Tensor &input_proposal, int64_t k_num, bool include_index=false, bool largest=true) {
  auto out = EsMultiMerge(input_proposal.GetEsbTensor(), k_num, include_index, largest);
  return {out.output_proposal, out.output_index};
}
struct MultiScaleDeformableAttentionGradOutput {
  Tensor grad_value;
  Tensor grad_sampling_locations;
  Tensor grad_attention_weights;
};
inline MultiScaleDeformableAttentionGradOutput MultiScaleDeformableAttentionGrad(const Tensor &value, const Tensor &value_spatial_shapes, const Tensor &value_level_start_index, const Tensor &sampling_locations, const Tensor &attention_weights, const Tensor &grad_output) {
  auto out = EsMultiScaleDeformableAttentionGrad(value.GetEsbTensor(), value_spatial_shapes.GetEsbTensor(), value_level_start_index.GetEsbTensor(), sampling_locations.GetEsbTensor(), attention_weights.GetEsbTensor(), grad_output.GetEsbTensor());
  return {out.grad_value, out.grad_sampling_locations, out.grad_attention_weights};
}
inline Tensor MultiScaleDeformableAttnFunction(const Tensor &value, const Tensor &value_spatial_shapes, const Tensor &value_level_start_index, const Tensor &sampling_locations, const Tensor &attention_weights) {
  auto out = EsMultiScaleDeformableAttnFunction(value.GetEsbTensor(), value_spatial_shapes.GetEsbTensor(), value_level_start_index.GetEsbTensor(), sampling_locations.GetEsbTensor(), attention_weights.GetEsbTensor());
  return out;
}
struct MultilabelMarginLossOutput {
  Tensor y;
  Tensor is_target;
};
inline MultilabelMarginLossOutput MultilabelMarginLoss(const Tensor &x, const Tensor &target, const char *reduction="mean") {
  auto out = EsMultilabelMarginLoss(x.GetEsbTensor(), target.GetEsbTensor(), reduction);
  return {out.y, out.is_target};
}
inline Tensor Multinomial(const Tensor &logits, const Tensor &num_samples, ge::DataType dtype=ge::DT_INT64, int64_t seed=0, int64_t seed2=0) {
  auto out = EsMultinomial(logits.GetEsbTensor(), num_samples.GetEsbTensor(), dtype, seed, seed2);
  return out;
}
inline Tensor MultinomialAliasDraw(const Tensor &q, const Tensor &j, int64_t num_samples, int64_t seed=0) {
  auto out = EsMultinomialAliasDraw(q.GetEsbTensor(), j.GetEsbTensor(), num_samples, seed);
  return out;
}
struct MultinomialAliasSetupOutput {
  Tensor j;
  Tensor q;
};
inline MultinomialAliasSetupOutput MultinomialAliasSetup(const Tensor &probs) {
  auto out = EsMultinomialAliasSetup(probs.GetEsbTensor());
  return {out.j, out.q};
}
inline Tensor MultinomialFuss(const Tensor &x, int64_t dtype=6, int64_t sample_size=1, float seed=0.000000) {
  auto out = EsMultinomialFuss(x.GetEsbTensor(), dtype, sample_size, seed);
  return out;
}
inline Tensor MultinomialWithReplacement(const Tensor &x, const Tensor &seed, const Tensor &offset, int64_t numsamples, bool replacement=false) {
  auto out = EsMultinomialWithReplacement(x.GetEsbTensor(), seed.GetEsbTensor(), offset.GetEsbTensor(), numsamples, replacement);
  return out;
}
inline Tensor MutableDenseHashTable(const Tensor &empty_key, const Tensor &deleted_key, ge::DataType value_dtype, const char *container="", const char *shared_name="", bool use_node_name_sharing=false, const std::vector<int64_t> &value_shape={}, int64_t initial_num_buckets=131072, float max_load_factor=0.800000) {
  auto out = EsMutableDenseHashTable(empty_key.GetEsbTensor(), deleted_key.GetEsbTensor(), value_dtype, container, shared_name, use_node_name_sharing, value_shape.data(), static_cast<int64_t>(value_shape.size()), initial_num_buckets, max_load_factor);
  return out;
}
inline Tensor MutableHashTable(const Graph &owner_graph, ge::DataType key_dtype, ge::DataType value_dtype, const char *container="", const char *shared_name="", bool use_node_name_sharing=false) {
  auto out = EsMutableHashTable(owner_graph.GetEsbGraph(), key_dtype, value_dtype, container, shared_name, use_node_name_sharing);
  return out;
}
inline Tensor MutableHashTableOfTensors(const Graph &owner_graph, ge::DataType key_dtype, ge::DataType value_dtype, const char *container="", const char *shared_name="", bool use_node_name_sharing=false, const std::vector<int64_t> &value_shape={}) {
  auto out = EsMutableHashTableOfTensors(owner_graph.GetEsbGraph(), key_dtype, value_dtype, container, shared_name, use_node_name_sharing, value_shape.data(), static_cast<int64_t>(value_shape.size()));
  return out;
}
struct NLLLossOutput {
  Tensor y;
  Tensor total_weight;
};
inline NLLLossOutput NLLLoss(const Tensor &x, const Tensor &target, const Tensor &weight=nullptr, const char *reduction="mean", int64_t ignore_index=-100) {
  auto out = EsNLLLoss(x.GetEsbTensor(), target.GetEsbTensor(), weight.GetEsbTensor(), reduction, ignore_index);
  return {out.y, out.total_weight};
}
inline Tensor NLLLossGrad(const Tensor &x, const Tensor &y_grad, const Tensor &target, const Tensor &weight, const Tensor &total_weight, const char *reduction="mean", int64_t ignore_index=-100) {
  auto out = EsNLLLossGrad(x.GetEsbTensor(), y_grad.GetEsbTensor(), target.GetEsbTensor(), weight.GetEsbTensor(), total_weight.GetEsbTensor(), reduction, ignore_index);
  return out;
}
struct NMSWithMaskOutput {
  Tensor selected_boxes;
  Tensor selected_idx;
  Tensor selected_mask;
};
inline NMSWithMaskOutput NMSWithMask(const Tensor &box_scores, float iou_threshold=0.500000) {
  auto out = EsNMSWithMask(box_scores.GetEsbTensor(), iou_threshold);
  return {out.selected_boxes, out.selected_idx, out.selected_mask};
}
inline Tensor NPUAllocFloatStatus(const Graph &owner_graph) {
  auto out = EsNPUAllocFloatStatus(owner_graph.GetEsbGraph());
  return out;
}
inline Tensor NPUAllocFloatStatusOperator(const Graph &owner_graph) {
  auto out = EsNPUAllocFloatStatusOperator(owner_graph.GetEsbGraph());
  return out;
}
inline Tensor NPUClearFloatDebugStatus(const Graph &owner_graph) {
  auto out = EsNPUClearFloatDebugStatus(owner_graph.GetEsbGraph());
  return out;
}
inline Tensor NPUClearFloatStatus(const Tensor &addr) {
  auto out = EsNPUClearFloatStatus(addr.GetEsbTensor());
  return out;
}
inline Tensor NPUClearFloatStatusOperator(const Tensor &addr) {
  auto out = EsNPUClearFloatStatusOperator(addr.GetEsbTensor());
  return out;
}
inline Tensor NPUClearFloatStatusV2(const Graph &owner_graph) {
  auto out = EsNPUClearFloatStatusV2(owner_graph.GetEsbGraph());
  return out;
}
inline Tensor NPUGetFloatDebugStatus(const Graph &owner_graph) {
  auto out = EsNPUGetFloatDebugStatus(owner_graph.GetEsbGraph());
  return out;
}
inline Tensor NPUGetFloatStatus(const Tensor &addr) {
  auto out = EsNPUGetFloatStatus(addr.GetEsbTensor());
  return out;
}
inline Tensor NPUGetFloatStatusOperator(const Tensor &addr) {
  auto out = EsNPUGetFloatStatusOperator(addr.GetEsbTensor());
  return out;
}
inline Tensor NPUGetFloatStatusV2(const Graph &owner_graph) {
  auto out = EsNPUGetFloatStatusV2(owner_graph.GetEsbGraph());
  return out;
}
inline Tensor NanToNum(const Tensor &x, float nan, float posinf, float neginf) {
  auto out = EsNanToNum(x.GetEsbTensor(), nan, posinf, neginf);
  return out;
}
inline Tensor Ndtri(const Tensor &x) {
  auto out = EsNdtri(x.GetEsbTensor());
  return out;
}
inline Tensor Neg(const Tensor &x) {
  auto out = EsNeg(x.GetEsbTensor());
  return out;
}
inline Tensor NextAfter(const Tensor &x1, const Tensor &x2) {
  auto out = EsNextAfter(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
inline Tensor NextIteration(const Tensor &x) {
  auto out = EsNextIteration(x.GetEsbTensor());
  return out;
}
inline Tensor NoOp(const Graph &owner_graph) {
  auto out = EsNoOp(owner_graph.GetEsbGraph());
  return out;
}
inline Tensor NonDeterministicInts(const Tensor &shape, ge::DataType dtype) {
  auto out = EsNonDeterministicInts(shape.GetEsbTensor(), dtype);
  return out;
}
inline Tensor NonFiniteCheck(const std::vector<Tensor> &tensor_list) {
  auto esb_tensor_list = TensorsToEsbTensors(tensor_list);
  auto out = EsNonFiniteCheck(esb_tensor_list.data(), static_cast<int64_t>(esb_tensor_list.size()));
  return out;
}
inline Tensor NonMaxSuppression(const Tensor &boxes, const Tensor &scores, const Tensor &max_output_size, float iou_threshold=0.500000) {
  auto out = EsNonMaxSuppression(boxes.GetEsbTensor(), scores.GetEsbTensor(), max_output_size.GetEsbTensor(), iou_threshold);
  return out;
}
struct NonMaxSuppressionBucketizeOutput {
  Tensor output_nmsed_boxes;
  Tensor output_nmsed_score;
  Tensor output_nmsed_class;
};
inline NonMaxSuppressionBucketizeOutput NonMaxSuppressionBucketize(const Tensor &input_nmsed_boxes, const Tensor &input_nmsed_score, const Tensor &input_nmsed_class, const Tensor &input_nmsed_num) {
  auto out = EsNonMaxSuppressionBucketize(input_nmsed_boxes.GetEsbTensor(), input_nmsed_score.GetEsbTensor(), input_nmsed_class.GetEsbTensor(), input_nmsed_num.GetEsbTensor());
  return {out.output_nmsed_boxes, out.output_nmsed_score, out.output_nmsed_class};
}
inline Tensor NonMaxSuppressionV2(const Tensor &boxes, const Tensor &scores, const Tensor &max_output_size, const Tensor &iou_threshold) {
  auto out = EsNonMaxSuppressionV2(boxes.GetEsbTensor(), scores.GetEsbTensor(), max_output_size.GetEsbTensor(), iou_threshold.GetEsbTensor());
  return out;
}
inline Tensor NonMaxSuppressionV3(const Tensor &boxes, const Tensor &scores, const Tensor &max_output_size, const Tensor &iou_threshold, const Tensor &score_threshold, int64_t offset=0) {
  auto out = EsNonMaxSuppressionV3(boxes.GetEsbTensor(), scores.GetEsbTensor(), max_output_size.GetEsbTensor(), iou_threshold.GetEsbTensor(), score_threshold.GetEsbTensor(), offset);
  return out;
}
struct NonMaxSuppressionV4Output {
  Tensor selected_indices;
  Tensor valid_outputs;
};
inline NonMaxSuppressionV4Output NonMaxSuppressionV4(const Tensor &boxes, const Tensor &scores, const Tensor &max_output_size, const Tensor &iou_threshold, const Tensor &score_threshold, bool pad_to_max_output_size=false) {
  auto out = EsNonMaxSuppressionV4(boxes.GetEsbTensor(), scores.GetEsbTensor(), max_output_size.GetEsbTensor(), iou_threshold.GetEsbTensor(), score_threshold.GetEsbTensor(), pad_to_max_output_size);
  return {out.selected_indices, out.valid_outputs};
}
struct NonMaxSuppressionV5Output {
  Tensor selected_indices;
  Tensor selected_scores;
  Tensor valid_outputs;
};
inline NonMaxSuppressionV5Output NonMaxSuppressionV5(const Tensor &boxes, const Tensor &scores, const Tensor &max_output_size, const Tensor &iou_threshold, const Tensor &score_threshold, const Tensor &soft_nms_sigma, ge::DataType T, bool pad_to_max_output_size=false) {
  auto out = EsNonMaxSuppressionV5(boxes.GetEsbTensor(), scores.GetEsbTensor(), max_output_size.GetEsbTensor(), iou_threshold.GetEsbTensor(), score_threshold.GetEsbTensor(), soft_nms_sigma.GetEsbTensor(), T, pad_to_max_output_size);
  return {out.selected_indices, out.selected_scores, out.valid_outputs};
}
inline Tensor NonMaxSuppressionV6(const Tensor &boxes, const Tensor &scores, const Tensor &max_output_size=nullptr, const Tensor &iou_threshold=nullptr, const Tensor &score_threshold=nullptr, int64_t center_point_box=0, int64_t max_boxes_size=0) {
  auto out = EsNonMaxSuppressionV6(boxes.GetEsbTensor(), scores.GetEsbTensor(), max_output_size.GetEsbTensor(), iou_threshold.GetEsbTensor(), score_threshold.GetEsbTensor(), center_point_box, max_boxes_size);
  return out;
}
inline Tensor NonMaxSuppressionV7(const Tensor &boxes, const Tensor &scores, const Tensor &max_output_size=nullptr, const Tensor &iou_threshold=nullptr, const Tensor &score_threshold=nullptr, const Tensor &index_id=nullptr, int64_t center_point_box=0, int64_t max_boxes_size=0) {
  auto out = EsNonMaxSuppressionV7(boxes.GetEsbTensor(), scores.GetEsbTensor(), max_output_size.GetEsbTensor(), iou_threshold.GetEsbTensor(), score_threshold.GetEsbTensor(), index_id.GetEsbTensor(), center_point_box, max_boxes_size);
  return out;
}
inline Tensor NonMaxSuppressionWithOverlaps(const Tensor &overlaps, const Tensor &scores, const Tensor &max_output_size, const Tensor &overlap_threshold, const Tensor &score_threshold) {
  auto out = EsNonMaxSuppressionWithOverlaps(overlaps.GetEsbTensor(), scores.GetEsbTensor(), max_output_size.GetEsbTensor(), overlap_threshold.GetEsbTensor(), score_threshold.GetEsbTensor());
  return out;
}
inline Tensor NonZero(const Tensor &x, bool transpose=false, ge::DataType dtype=ge::DT_INT64) {
  auto out = EsNonZero(x.GetEsbTensor(), transpose, dtype);
  return out;
}
struct NonZeroWithValueOutput {
  Tensor value;
  Tensor index;
  Tensor count;
};
inline NonZeroWithValueOutput NonZeroWithValue(const Tensor &x, bool transpose=false, ge::DataType dtype=ge::DT_INT32) {
  auto out = EsNonZeroWithValue(x.GetEsbTensor(), transpose, dtype);
  return {out.value, out.index, out.count};
}
struct NonZeroWithValueShapeOutput {
  Tensor out_value;
  Tensor out_index;
};
inline NonZeroWithValueShapeOutput NonZeroWithValueShape(const Tensor &value, const Tensor &index, const Tensor &count) {
  auto out = EsNonZeroWithValueShape(value.GetEsbTensor(), index.GetEsbTensor(), count.GetEsbTensor());
  return {out.out_value, out.out_index};
}
struct NonZeroWithValueShapeV2Output {
  Tensor value;
  Tensor index;
};
inline NonZeroWithValueShapeV2Output NonZeroWithValueShapeV2(const Tensor &value, const Tensor &index, const Tensor &count) {
  auto out = EsNonZeroWithValueShapeV2(value.GetEsbTensor(), index.GetEsbTensor(), count.GetEsbTensor());
  return {out.value, out.index};
}
inline Tensor Normal(const Tensor &mean, const Tensor &std) {
  auto out = EsNormal(mean.GetEsbTensor(), std.GetEsbTensor());
  return out;
}
inline Tensor Normalize(const Tensor &x1, const Tensor &x2, bool across_spatial=true, bool channel_shared=true, float eps=0.000000) {
  auto out = EsNormalize(x1.GetEsbTensor(), x2.GetEsbTensor(), across_spatial, channel_shared, eps);
  return out;
}
inline Tensor NormalizeBBox(const Tensor &boxes, const Tensor &shape_hw, bool reversed_box=false) {
  auto out = EsNormalizeBBox(boxes.GetEsbTensor(), shape_hw.GetEsbTensor(), reversed_box);
  return out;
}
inline Tensor NormalizeBatch(const Tensor &input_x, const Tensor &seq_len, const char *normalize_type, float epsilon=0.000010) {
  auto out = EsNormalizeBatch(input_x.GetEsbTensor(), seq_len.GetEsbTensor(), normalize_type, epsilon);
  return out;
}
inline Tensor NormalizeV2(const Tensor &x, const Tensor &mean, const Tensor &variance, ge::DataType dtype=ge::DT_FLOAT) {
  auto out = EsNormalizeV2(x.GetEsbTensor(), mean.GetEsbTensor(), variance.GetEsbTensor(), dtype);
  return out;
}
inline Tensor NotEqual(const Tensor &x1, const Tensor &x2) {
  auto out = EsNotEqual(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor NotEqual(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return NotEqual(tensor, b_esb_tensor);
}
inline Tensor NthElement(const Tensor &x, const Tensor &n, bool reverse=false) {
  auto out = EsNthElement(x.GetEsbTensor(), n.GetEsbTensor(), reverse);
  return out;
}
struct OCRDetectionPostHandleOutput {
  Tensor imgs_data;
  Tensor imgs_offset;
  Tensor imgs_size;
  Tensor rect_points;
};
inline OCRDetectionPostHandleOutput OCRDetectionPostHandle(const Tensor &img, const Tensor &polys_data, const Tensor &polys_offset, const Tensor &polys_size, const char *data_format="NHWC") {
  auto out = EsOCRDetectionPostHandle(img.GetEsbTensor(), polys_data.GetEsbTensor(), polys_offset.GetEsbTensor(), polys_size.GetEsbTensor(), data_format);
  return {out.imgs_data, out.imgs_offset, out.imgs_size, out.rect_points};
}
struct OCRDetectionPreHandleOutput {
  Tensor resized_img;
  Tensor h_scale;
  Tensor w_scale;
};
inline OCRDetectionPreHandleOutput OCRDetectionPreHandle(const Tensor &img, const char *data_format="NHWC") {
  auto out = EsOCRDetectionPreHandle(img.GetEsbTensor(), data_format);
  return {out.resized_img, out.h_scale, out.w_scale};
}
struct OCRFindContoursOutput {
  Tensor polys_data;
  Tensor polys_offset;
  Tensor polys_size;
};
inline OCRFindContoursOutput OCRFindContours(const Tensor &img, int64_t value_mode=0) {
  auto out = EsOCRFindContours(img.GetEsbTensor(), value_mode);
  return {out.polys_data, out.polys_offset, out.polys_size};
}
inline Tensor OCRIdentifyPreHandle(const Tensor &imgs_data, const Tensor &imgs_offset, const Tensor &imgs_size, const std::vector<int64_t> &size, const char *data_format="NHWC") {
  auto out = EsOCRIdentifyPreHandle(imgs_data.GetEsbTensor(), imgs_offset.GetEsbTensor(), imgs_size.GetEsbTensor(), size.data(), static_cast<int64_t>(size.size()), data_format);
  return out;
}
struct OCRRecognitionPreHandleOutput {
  Tensor imgs;
  Tensor imgs_relation;
  Tensor imgs_lang;
  Tensor imgs_piece_fillers;
};
inline OCRRecognitionPreHandleOutput OCRRecognitionPreHandle(const Tensor &imgs_data, const Tensor &imgs_offset, const Tensor &imgs_size, const Tensor &langs, const Tensor &langs_score, int64_t batch_size=8, const char *data_format="NHWC", const char *pad_mode="REPLICATE") {
  auto out = EsOCRRecognitionPreHandle(imgs_data.GetEsbTensor(), imgs_offset.GetEsbTensor(), imgs_size.GetEsbTensor(), langs.GetEsbTensor(), langs_score.GetEsbTensor(), batch_size, data_format, pad_mode);
  return {out.imgs, out.imgs_relation, out.imgs_lang, out.imgs_piece_fillers};
}
inline Tensor OneHot(const Tensor &x, const Tensor &depth, const Tensor &on_value, const Tensor &off_value, int64_t axis=-1) {
  auto out = EsOneHot(x.GetEsbTensor(), depth.GetEsbTensor(), on_value.GetEsbTensor(), off_value.GetEsbTensor(), axis);
  return out;
}
inline Tensor OneHotD(const Tensor &x, const Tensor &on_value, const Tensor &off_value, int64_t depth, int64_t axis=-1) {
  auto out = EsOneHotD(x.GetEsbTensor(), on_value.GetEsbTensor(), off_value.GetEsbTensor(), depth, axis);
  return out;
}
inline Tensor OnesLike(const Tensor &x) {
  auto out = EsOnesLike(x.GetEsbTensor());
  return out;
}
struct OpTilingOutput {
  Tensor tiling_data;
  Tensor tiling_key;
  Tensor block_dim;
  Tensor tiling_cond;
};
inline OpTilingOutput OpTiling(const std::vector<Tensor> &x, const std::vector<Tensor> &output_shape, const char *tiling_node, const char *op_type) {
  auto esb_x = TensorsToEsbTensors(x);
  auto esb_output_shape = TensorsToEsbTensors(output_shape);
  auto out = EsOpTiling(esb_x.data(), static_cast<int64_t>(esb_x.size()), esb_output_shape.data(), static_cast<int64_t>(esb_output_shape.size()), tiling_node, op_type);
  return {out.tiling_data, out.tiling_key, out.block_dim, out.tiling_cond};
}
inline Tensor OutfeedEnqueueOp(const std::vector<Tensor> &x, const char *channel_name="") {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsOutfeedEnqueueOp(esb_x.data(), static_cast<int64_t>(esb_x.size()), channel_name);
  return out;
}
inline Tensor OutfeedEnqueueOpV2(const std::vector<Tensor> &x, const Tensor &tensor_name, const char *channel_name="", int64_t slice_size=0, int64_t wait_time=0, bool slice_sync=false) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsOutfeedEnqueueOpV2(esb_x.data(), static_cast<int64_t>(esb_x.size()), tensor_name.GetEsbTensor(), channel_name, slice_size, wait_time, slice_sync);
  return out;
}
inline Tensor PRelu(const Tensor &x, const Tensor &weight) {
  auto out = EsPRelu(x.GetEsbTensor(), weight.GetEsbTensor());
  return out;
}
struct PReluGradOutput {
  Tensor dx;
  Tensor da;
};
inline PReluGradOutput PReluGrad(const Tensor &grads, const Tensor &features, const Tensor &weights) {
  auto out = EsPReluGrad(grads.GetEsbTensor(), features.GetEsbTensor(), weights.GetEsbTensor());
  return {out.dx, out.da};
}
inline Tensor PSAMask(const Tensor &x, int64_t psa_type, int64_t num, int64_t h_feature, int64_t w_feature, int64_t h_mask, int64_t w_mask, int64_t half_h_mask, int64_t half_w_mask) {
  auto out = EsPSAMask(x.GetEsbTensor(), psa_type, num, h_feature, w_feature, h_mask, w_mask, half_h_mask, half_w_mask);
  return out;
}
inline Tensor PSAMaskGrad(const Tensor &y_grad, int64_t psa_type, int64_t num, int64_t h_feature, int64_t w_feature, int64_t h_mask, int64_t w_mask, int64_t half_h_mask, int64_t half_w_mask) {
  auto out = EsPSAMaskGrad(y_grad.GetEsbTensor(), psa_type, num, h_feature, w_feature, h_mask, w_mask, half_h_mask, half_w_mask);
  return out;
}
inline Tensor PSROIPooling(const Tensor &x, const Tensor &rois, int64_t output_dim, int64_t group_size, float spatial_scale) {
  auto out = EsPSROIPooling(x.GetEsbTensor(), rois.GetEsbTensor(), output_dim, group_size, spatial_scale);
  return out;
}
inline Tensor PSROIPoolingGradV2D(const Tensor &x, const Tensor &rois, float spatial_scale, int64_t output_dim, int64_t group_size, const std::vector<int64_t> &input_size) {
  auto out = EsPSROIPoolingGradV2D(x.GetEsbTensor(), rois.GetEsbTensor(), spatial_scale, output_dim, group_size, input_size.data(), static_cast<int64_t>(input_size.size()));
  return out;
}
inline Tensor PSROIPoolingV2(const Tensor &x, const Tensor &rois, float spatial_scale, int64_t output_dim, int64_t group_size) {
  auto out = EsPSROIPoolingV2(x.GetEsbTensor(), rois.GetEsbTensor(), spatial_scale, output_dim, group_size);
  return out;
}
inline Tensor Pack(const std::vector<Tensor> &x, int64_t axis=0, int64_t N=1) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsPack(esb_x.data(), static_cast<int64_t>(esb_x.size()), axis, N);
  return out;
}
inline Tensor Pad(const Tensor &x, const Tensor &paddings) {
  auto out = EsPad(x.GetEsbTensor(), paddings.GetEsbTensor());
  return out;
}
inline Tensor PadV2(const Tensor &x, const Tensor &paddings, const Tensor &constant_values) {
  auto out = EsPadV2(x.GetEsbTensor(), paddings.GetEsbTensor(), constant_values.GetEsbTensor());
  return out;
}
inline Tensor PadV3(const Tensor &x, const Tensor &paddings, const Tensor &constant_values=nullptr, const char *mode="constant", bool paddings_contiguous=true) {
  auto out = EsPadV3(x.GetEsbTensor(), paddings.GetEsbTensor(), constant_values.GetEsbTensor(), mode, paddings_contiguous);
  return out;
}
inline Tensor PadV3Grad(const Tensor &x, const Tensor &paddings, const char *mode="reflect", bool paddings_contiguous=true) {
  auto out = EsPadV3Grad(x.GetEsbTensor(), paddings.GetEsbTensor(), mode, paddings_contiguous);
  return out;
}
inline Tensor ParallelConcat(const std::vector<Tensor> &values, const std::vector<int64_t> &shape, int64_t N) {
  auto esb_values = TensorsToEsbTensors(values);
  auto out = EsParallelConcat(esb_values.data(), static_cast<int64_t>(esb_values.size()), shape.data(), static_cast<int64_t>(shape.size()), N);
  return out;
}
inline Tensor ParallelDynamicStitch(const std::vector<Tensor> &indices, const std::vector<Tensor> &x, int64_t N=1) {
  auto esb_indices = TensorsToEsbTensors(indices);
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsParallelDynamicStitch(esb_indices.data(), static_cast<int64_t>(esb_indices.size()), esb_x.data(), static_cast<int64_t>(esb_x.size()), N);
  return out;
}
inline Tensor ParameterizedTruncatedNormal(const Tensor &shape, const Tensor &means, const Tensor &stdevs, const Tensor &min, const Tensor &max, int64_t seed=0, int64_t seed2=0) {
  auto out = EsParameterizedTruncatedNormal(shape.GetEsbTensor(), means.GetEsbTensor(), stdevs.GetEsbTensor(), min.GetEsbTensor(), max.GetEsbTensor(), seed, seed2);
  return out;
}
inline Tensor ParseTensor(const Tensor &serialized, ge::DataType out_type=ge::DT_FLOAT) {
  auto out = EsParseTensor(serialized.GetEsbTensor(), out_type);
  return out;
}
inline Tensor PassThrough(const Tensor &x, int64_t stride=2, bool reverse=false) {
  auto out = EsPassThrough(x.GetEsbTensor(), stride, reverse);
  return out;
}
inline Tensor PasteSubImg(const Tensor &patch_img, const Tensor &patch_coord, const Tensor &core_area_coord, const Tensor &combine_img, float scale) {
  auto out = EsPasteSubImg(patch_img.GetEsbTensor(), patch_coord.GetEsbTensor(), core_area_coord.GetEsbTensor(), combine_img.GetEsbTensor(), scale);
  return out;
}
inline Tensor Pdist(const Tensor &x, float p=2.000000) {
  auto out = EsPdist(x.GetEsbTensor(), p);
  return out;
}
inline Tensor Permute(const Tensor &x, const std::vector<int64_t> &order={0}) {
  auto out = EsPermute(x.GetEsbTensor(), order.data(), static_cast<int64_t>(order.size()));
  return out;
}
inline Tensor PhonyConcat(const std::vector<Tensor> &x, const std::vector<int64_t> &concat_dim, const std::vector<int64_t> &N, bool keep_input_offset=true) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsPhonyConcat(esb_x.data(), static_cast<int64_t>(esb_x.size()), concat_dim.data(), static_cast<int64_t>(concat_dim.size()), N.data(), static_cast<int64_t>(N.size()), keep_input_offset);
  return out;
}
inline Tensor Pinverse(const Tensor &x, float rcond=0.000000) {
  auto out = EsPinverse(x.GetEsbTensor(), rcond);
  return out;
}
inline Tensor PlaceHolder(const Tensor &x, int64_t peerIndex=0, const char *parentId="", const char *parentOpType="", int64_t anchorIndex=0) {
  auto out = EsPlaceHolder(x.GetEsbTensor(), peerIndex, parentId, parentOpType, anchorIndex);
  return out;
}
inline Tensor PlaceholderWithDefault(const Tensor &x, const std::vector<int64_t> &shape) {
  auto out = EsPlaceholderWithDefault(x.GetEsbTensor(), shape.data(), static_cast<int64_t>(shape.size()));
  return out;
}
inline Tensor PointsInPolygons(const Tensor &points, const Tensor &polygons) {
  auto out = EsPointsInPolygons(points.GetEsbTensor(), polygons.GetEsbTensor());
  return out;
}
inline Tensor Poisson(const Tensor &x, int64_t seed=0) {
  auto out = EsPoisson(x.GetEsbTensor(), seed);
  return out;
}
inline Tensor PoissonNllLoss(const Tensor &input_x, const Tensor &target, bool log_input=true, bool full=false, float eps=0.000000, const char *reduction="mean") {
  auto out = EsPoissonNllLoss(input_x.GetEsbTensor(), target.GetEsbTensor(), log_input, full, eps, reduction);
  return out;
}
inline Tensor Pooling(const Tensor &x, int64_t mode=0, bool global_pooling=false, const std::vector<int64_t> &window={1, 1}, const std::vector<int64_t> &stride={1, 1}, const std::vector<int64_t> &pad={0, 0, 0, 0}, const std::vector<int64_t> &dilation={1, 1, 1, 1}, int64_t ceil_mode=0, const char *data_format="NCHW") {
  auto out = EsPooling(x.GetEsbTensor(), mode, global_pooling, window.data(), static_cast<int64_t>(window.size()), stride.data(), static_cast<int64_t>(stride.size()), pad.data(), static_cast<int64_t>(pad.size()), dilation.data(), static_cast<int64_t>(dilation.size()), ceil_mode, data_format);
  return out;
}
inline Tensor PopulationCount(const Tensor &x) {
  auto out = EsPopulationCount(x.GetEsbTensor());
  return out;
}
inline Tensor Pow(const Tensor &x1, const Tensor &x2) {
  auto out = EsPow(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor Pow(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return Pow(tensor, b_esb_tensor);
}
inline Tensor Power(const Tensor &x, float power=1.000000, float scale=1.000000, float shift=0.000000) {
  auto out = EsPower(x.GetEsbTensor(), power, scale, shift);
  return out;
}
inline Tensor Pows(const Tensor &x1, const Tensor &x2) {
  auto out = EsPows(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
inline Tensor PreventGradient(const Tensor &x, const char *message="") {
  auto out = EsPreventGradient(x.GetEsbTensor(), message);
  return out;
}
inline Tensor Print(const std::vector<Tensor> &x) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsPrint(esb_x.data(), static_cast<int64_t>(esb_x.size()));
  return out;
}
inline Tensor PrintV2(const Tensor &x, const char *output_stream="stderr") {
  auto out = EsPrintV2(x.GetEsbTensor(), output_stream);
  return out;
}
inline Tensor PrintV3(const Tensor &x, const std::vector<Tensor> &data, const char *message="", int64_t first_n=-1, int64_t summarize=3) {
  auto esb_data = TensorsToEsbTensors(data);
  auto out = EsPrintV3(x.GetEsbTensor(), esb_data.data(), static_cast<int64_t>(esb_data.size()), message, first_n, summarize);
  return out;
}
inline Tensor PriorBox(const Tensor &x, const Tensor &img, const std::vector<float> &min_size, const std::vector<float> &max_size, const std::vector<float> &aspect_ratio, int64_t img_h=0, int64_t img_w=0, float step_h=0.000000, float step_w=0.000000, bool flip=true, bool clip=false, float offset=0.500000, const std::vector<float> &variance={0.100000}) {
  auto out = EsPriorBox(x.GetEsbTensor(), img.GetEsbTensor(), min_size.data(), static_cast<int64_t>(min_size.size()), max_size.data(), static_cast<int64_t>(max_size.size()), aspect_ratio.data(), static_cast<int64_t>(aspect_ratio.size()), img_h, img_w, step_h, step_w, flip, clip, offset, variance.data(), static_cast<int64_t>(variance.size()));
  return out;
}
inline Tensor PriorBoxD(const Tensor &x, const Tensor &img, const Tensor &data_h, const Tensor &data_w, const Tensor &box_height, const Tensor &box_width, const std::vector<float> &min_size, const std::vector<float> &max_size, int64_t img_h=0, int64_t img_w=0, float step_h=0.000000, float step_w=0.000000, bool flip=true, bool clip=false, float offset=0.500000, const std::vector<float> &variance={0.100000}) {
  auto out = EsPriorBoxD(x.GetEsbTensor(), img.GetEsbTensor(), data_h.GetEsbTensor(), data_w.GetEsbTensor(), box_height.GetEsbTensor(), box_width.GetEsbTensor(), min_size.data(), static_cast<int64_t>(min_size.size()), max_size.data(), static_cast<int64_t>(max_size.size()), img_h, img_w, step_h, step_w, flip, clip, offset, variance.data(), static_cast<int64_t>(variance.size()));
  return out;
}
inline Tensor PriorBoxDV2(const Tensor &x, const Tensor &img, const Tensor &boxes, const std::vector<float> &min_size, const std::vector<float> &max_size, int64_t img_h=0, int64_t img_w=0, float step_h=0.000000, float step_w=0.000000, bool flip=true, bool clip=false, float offset=0.500000, const std::vector<float> &variance={0.100000}) {
  auto out = EsPriorBoxDV2(x.GetEsbTensor(), img.GetEsbTensor(), boxes.GetEsbTensor(), min_size.data(), static_cast<int64_t>(min_size.size()), max_size.data(), static_cast<int64_t>(max_size.size()), img_h, img_w, step_h, step_w, flip, clip, offset, variance.data(), static_cast<int64_t>(variance.size()));
  return out;
}
struct ProdEnvMatAOutput {
  Tensor descrpt;
  Tensor descrpt_deriv;
  Tensor rij;
  Tensor nlist;
};
inline ProdEnvMatAOutput ProdEnvMatA(const Tensor &coord, const Tensor &type, const Tensor &natoms, const Tensor &box, const Tensor &mesh, const Tensor &davg, const Tensor &dstd, float rcut_a=1.000000, float rcut_r=1.000000, float rcut_r_smth=1.000000, const std::vector<int64_t> &sel_a={}, const std::vector<int64_t> &sel_r={}) {
  auto out = EsProdEnvMatA(coord.GetEsbTensor(), type.GetEsbTensor(), natoms.GetEsbTensor(), box.GetEsbTensor(), mesh.GetEsbTensor(), davg.GetEsbTensor(), dstd.GetEsbTensor(), rcut_a, rcut_r, rcut_r_smth, sel_a.data(), static_cast<int64_t>(sel_a.size()), sel_r.data(), static_cast<int64_t>(sel_r.size()));
  return {out.descrpt, out.descrpt_deriv, out.rij, out.nlist};
}
struct ProdEnvMatACalcDescrptOutput {
  Tensor descrpt;
  Tensor descrpt_deriv;
};
inline ProdEnvMatACalcDescrptOutput ProdEnvMatACalcDescrpt(const Tensor &distance, const Tensor &rij_x, const Tensor &rij_y, const Tensor &rij_z, const Tensor &type, const Tensor &natoms, const Tensor &mesh, const Tensor &davg, const Tensor &dstd, float rcut_a=1.000000, float rcut_r=1.000000, float rcut_r_smth=1.000000, const std::vector<int64_t> &sel_a={}, const std::vector<int64_t> &sel_r={}) {
  auto out = EsProdEnvMatACalcDescrpt(distance.GetEsbTensor(), rij_x.GetEsbTensor(), rij_y.GetEsbTensor(), rij_z.GetEsbTensor(), type.GetEsbTensor(), natoms.GetEsbTensor(), mesh.GetEsbTensor(), davg.GetEsbTensor(), dstd.GetEsbTensor(), rcut_a, rcut_r, rcut_r_smth, sel_a.data(), static_cast<int64_t>(sel_a.size()), sel_r.data(), static_cast<int64_t>(sel_r.size()));
  return {out.descrpt, out.descrpt_deriv};
}
struct ProdEnvMatACalcRijOutput {
  Tensor rij;
  Tensor nlist;
  Tensor distance;
  Tensor rij_x;
  Tensor rij_y;
  Tensor rij_z;
};
inline ProdEnvMatACalcRijOutput ProdEnvMatACalcRij(const Tensor &coord, const Tensor &type, const Tensor &natoms, const Tensor &box, const Tensor &mesh, float rcut_a=1.000000, float rcut_r=1.000000, float rcut_r_smth=1.000000, const std::vector<int64_t> &sel_a={}, const std::vector<int64_t> &sel_r={}) {
  auto out = EsProdEnvMatACalcRij(coord.GetEsbTensor(), type.GetEsbTensor(), natoms.GetEsbTensor(), box.GetEsbTensor(), mesh.GetEsbTensor(), rcut_a, rcut_r, rcut_r_smth, sel_a.data(), static_cast<int64_t>(sel_a.size()), sel_r.data(), static_cast<int64_t>(sel_r.size()));
  return {out.rij, out.nlist, out.distance, out.rij_x, out.rij_y, out.rij_z};
}
inline Tensor ProdForceSeA(const Tensor &net_deriv, const Tensor &in_deriv, const Tensor &nlist, const Tensor &natoms, int64_t n_a_sel, int64_t n_r_sel) {
  auto out = EsProdForceSeA(net_deriv.GetEsbTensor(), in_deriv.GetEsbTensor(), nlist.GetEsbTensor(), natoms.GetEsbTensor(), n_a_sel, n_r_sel);
  return out;
}
struct ProdVirialSeAOutput {
  Tensor virial;
  Tensor atom_virial;
};
inline ProdVirialSeAOutput ProdVirialSeA(const Tensor &net_deriv, const Tensor &in_deriv, const Tensor &rij, const Tensor &nlist, const Tensor &natoms, int64_t n_a_sel, int64_t n_r_sel) {
  auto out = EsProdVirialSeA(net_deriv.GetEsbTensor(), in_deriv.GetEsbTensor(), rij.GetEsbTensor(), nlist.GetEsbTensor(), natoms.GetEsbTensor(), n_a_sel, n_r_sel);
  return {out.virial, out.atom_virial};
}
inline Tensor PromptFlashAttention(const Tensor &query, const Tensor &key, const Tensor &value, const Tensor &pse_shift, const Tensor &atten_mask, const Tensor &actual_seq_lengths, const Tensor &actual_seq_lengths_kv, const Tensor &deq_scale1, const Tensor &quant_scale1, const Tensor &deq_scale2, const Tensor &quant_scale2, const Tensor &quant_offset2, int64_t num_heads, float scale_value=1.000000, int64_t pre_tokens=214748647, int64_t next_tokens=0, const char *input_layout="BSH", int64_t num_key_value_heads=0, int64_t sparse_mode=0, int64_t inner_precise=1) {
  auto out = EsPromptFlashAttention(query.GetEsbTensor(), key.GetEsbTensor(), value.GetEsbTensor(), pse_shift.GetEsbTensor(), atten_mask.GetEsbTensor(), actual_seq_lengths.GetEsbTensor(), actual_seq_lengths_kv.GetEsbTensor(), deq_scale1.GetEsbTensor(), quant_scale1.GetEsbTensor(), deq_scale2.GetEsbTensor(), quant_scale2.GetEsbTensor(), quant_offset2.GetEsbTensor(), num_heads, scale_value, pre_tokens, next_tokens, input_layout, num_key_value_heads, sparse_mode, inner_precise);
  return out;
}
struct ProposalOutput {
  Tensor rois;
  Tensor actual_rois_num;
};
inline ProposalOutput Proposal(const Tensor &cls_prob, const Tensor &bbox_delta, const Tensor &im_info, float feat_stride=16.000000, float base_size=16.000000, float min_size=16.000000, const std::vector<float> &ratio={0.500000, 1.000000, 2.000000}, const std::vector<float> &scale={8.000000, 16.000000, 32.000000}, int64_t pre_nms_topn=3000, int64_t post_nms_topn=304, float iou_threshold=0.700000, bool output_actual_rois_num=false) {
  auto out = EsProposal(cls_prob.GetEsbTensor(), bbox_delta.GetEsbTensor(), im_info.GetEsbTensor(), feat_stride, base_size, min_size, ratio.data(), static_cast<int64_t>(ratio.size()), scale.data(), static_cast<int64_t>(scale.size()), pre_nms_topn, post_nms_topn, iou_threshold, output_actual_rois_num);
  return {out.rois, out.actual_rois_num};
}
struct ProposalDOutput {
  Tensor rois;
  Tensor actual_rois_num;
};
inline ProposalDOutput ProposalD(const Tensor &cls_prob, const Tensor &bbox_delta, const Tensor &im_info, const Tensor &rpn_bbox, float feat_stride=16.000000, float base_size=16.000000, float min_size=16.000000, const std::vector<float> &ratio={0.500000, 1.000000, 2.000000}, const std::vector<float> &scale={8.000000, 16.000000, 32.000000}, int64_t pre_nms_topn=3000, int64_t post_nms_topn=304, float iou_threshold=0.700000, bool output_actual_rois_num=false) {
  auto out = EsProposalD(cls_prob.GetEsbTensor(), bbox_delta.GetEsbTensor(), im_info.GetEsbTensor(), rpn_bbox.GetEsbTensor(), feat_stride, base_size, min_size, ratio.data(), static_cast<int64_t>(ratio.size()), scale.data(), static_cast<int64_t>(scale.size()), pre_nms_topn, post_nms_topn, iou_threshold, output_actual_rois_num);
  return {out.rois, out.actual_rois_num};
}
inline Tensor PtIou(const Tensor &bboxes, const Tensor &gtboxes, const char *mode="iou") {
  auto out = EsPtIou(bboxes.GetEsbTensor(), gtboxes.GetEsbTensor(), mode);
  return out;
}
struct QrOutput {
  Tensor q;
  Tensor r;
};
inline QrOutput Qr(const Tensor &x, bool full_matrices=false) {
  auto out = EsQr(x.GetEsbTensor(), full_matrices);
  return {out.q, out.r};
}
inline Tensor QuantBatchMatmul(const Tensor &x1, const Tensor &x2, const Tensor &deq_scale, const Tensor &bias=nullptr, bool adj_x1=false, bool adj_x2=false) {
  auto out = EsQuantBatchMatmul(x1.GetEsbTensor(), x2.GetEsbTensor(), deq_scale.GetEsbTensor(), bias.GetEsbTensor(), adj_x1, adj_x2);
  return out;
}
inline Tensor QuantBatchMatmulV3(const Tensor &x1, const Tensor &x2, const Tensor &scale, const Tensor &offset, const Tensor &bias, const Tensor &pertoken_scale, int64_t dtype, bool transpose_x1=false, bool transpose_x2=false) {
  auto out = EsQuantBatchMatmulV3(x1.GetEsbTensor(), x2.GetEsbTensor(), scale.GetEsbTensor(), offset.GetEsbTensor(), bias.GetEsbTensor(), pertoken_scale.GetEsbTensor(), dtype, transpose_x1, transpose_x2);
  return out;
}
inline Tensor QuantConv2D(const Tensor &x, const Tensor &filter, const Tensor &scale, const Tensor &bias, const Tensor &offset, int64_t dtype, const std::vector<int64_t> &strides, const std::vector<int64_t> &pads, const std::vector<int64_t> &dilations={1, 1, 1, 1}, int64_t groups=1, const char *data_format="NHWC", int64_t offset_x=0, const char *round_mode="rint") {
  auto out = EsQuantConv2D(x.GetEsbTensor(), filter.GetEsbTensor(), scale.GetEsbTensor(), bias.GetEsbTensor(), offset.GetEsbTensor(), dtype, strides.data(), static_cast<int64_t>(strides.size()), pads.data(), static_cast<int64_t>(pads.size()), dilations.data(), static_cast<int64_t>(dilations.size()), groups, data_format, offset_x, round_mode);
  return out;
}
inline Tensor QuantUpdateScatter(const Tensor &var, const Tensor &indices, const Tensor &updates, const Tensor &quant_scales, const Tensor &quant_zero_points, const char *reduce, int64_t axis=0, int64_t quant_axis=1, bool reciprocal_scale=false) {
  auto out = EsQuantUpdateScatter(var.GetEsbTensor(), indices.GetEsbTensor(), updates.GetEsbTensor(), quant_scales.GetEsbTensor(), quant_zero_points.GetEsbTensor(), reduce, axis, quant_axis, reciprocal_scale);
  return out;
}
inline Tensor Quantize(const Tensor &x, const Tensor &scales, const Tensor &zero_points, const char *dtype, int64_t axis=1) {
  auto out = EsQuantize(x.GetEsbTensor(), scales.GetEsbTensor(), zero_points.GetEsbTensor(), dtype, axis);
  return out;
}
struct QuantizeAddLayerNormOutput {
  Tensor y;
  Tensor x;
};
inline QuantizeAddLayerNormOutput QuantizeAddLayerNorm(const Tensor &x1, const Tensor &x2, const Tensor &gamma, const Tensor &beta, const Tensor &bias, const Tensor &scales, const Tensor &zero_points, int64_t dtype, int64_t axis=-1, float epsilon=0.000010, bool additional_output=false) {
  auto out = EsQuantizeAddLayerNorm(x1.GetEsbTensor(), x2.GetEsbTensor(), gamma.GetEsbTensor(), beta.GetEsbTensor(), bias.GetEsbTensor(), scales.GetEsbTensor(), zero_points.GetEsbTensor(), dtype, axis, epsilon, additional_output);
  return {out.y, out.x};
}
struct QuantizedResizeBilinearOutput {
  Tensor resized_images;
  Tensor y_min;
  Tensor y_max;
};
inline QuantizedResizeBilinearOutput QuantizedResizeBilinear(const Tensor &images, const Tensor &size, const Tensor &min, const Tensor &max, bool align_corners=false, bool half_pixel_centers=false) {
  auto out = EsQuantizedResizeBilinear(images.GetEsbTensor(), size.GetEsbTensor(), min.GetEsbTensor(), max.GetEsbTensor(), align_corners, half_pixel_centers);
  return {out.resized_images, out.y_min, out.y_max};
}
inline Tensor QueueClose(const Tensor &handle, bool cancel_pending_enqueues=false) {
  auto out = EsQueueClose(handle.GetEsbTensor(), cancel_pending_enqueues);
  return out;
}
inline Tensor QueueEnqueue(const Tensor &handle, const std::vector<Tensor> &components, int64_t timeout_ms=-1) {
  auto esb_components = TensorsToEsbTensors(components);
  auto out = EsQueueEnqueue(handle.GetEsbTensor(), esb_components.data(), static_cast<int64_t>(esb_components.size()), timeout_ms);
  return out;
}
inline Tensor QueueEnqueueMany(const Tensor &handle, const std::vector<Tensor> &components, int64_t timeout_ms=-1) {
  auto esb_components = TensorsToEsbTensors(components);
  auto out = EsQueueEnqueueMany(handle.GetEsbTensor(), esb_components.data(), static_cast<int64_t>(esb_components.size()), timeout_ms);
  return out;
}
inline Tensor QueueIsClosed(const Tensor &handle) {
  auto out = EsQueueIsClosed(handle.GetEsbTensor());
  return out;
}
inline Tensor QueueSize(const Tensor &handle) {
  auto out = EsQueueSize(handle.GetEsbTensor());
  return out;
}
inline Tensor RFFT(const Tensor &input, const Tensor &fft_length) {
  auto out = EsRFFT(input.GetEsbTensor(), fft_length.GetEsbTensor());
  return out;
}
inline Tensor RGB2YUV422(const Tensor &rgb) {
  auto out = EsRGB2YUV422(rgb.GetEsbTensor());
  return out;
}
inline Tensor RGBToHSV(const Tensor &images) {
  auto out = EsRGBToHSV(images.GetEsbTensor());
  return out;
}
struct RNNOutput {
  Tensor o;
  Tensor h_t;
};
inline RNNOutput RNN(const Tensor &x, const Tensor &cont, const Tensor &x_static, const Tensor &h_0, const Tensor &w_xh, const Tensor &bias_h, const Tensor &w_sh, const Tensor &w_hh, const Tensor &w_ho, const Tensor &bias_o, int64_t num_output=0, bool expose_hidden=false) {
  auto out = EsRNN(x.GetEsbTensor(), cont.GetEsbTensor(), x_static.GetEsbTensor(), h_0.GetEsbTensor(), w_xh.GetEsbTensor(), bias_h.GetEsbTensor(), w_sh.GetEsbTensor(), w_hh.GetEsbTensor(), w_ho.GetEsbTensor(), bias_o.GetEsbTensor(), num_output, expose_hidden);
  return {out.o, out.h_t};
}
struct RNNTLossOutput {
  Tensor costs;
  Tensor grads;
};
inline RNNTLossOutput RNNTLoss(const Tensor &acts, const Tensor &labels, const Tensor &input_lengths, const Tensor &label_lengths, int64_t blank_label=0) {
  auto out = EsRNNTLoss(acts.GetEsbTensor(), labels.GetEsbTensor(), input_lengths.GetEsbTensor(), label_lengths.GetEsbTensor(), blank_label);
  return {out.costs, out.grads};
}
inline Tensor ROIAlign(const Tensor &features, const Tensor &rois, const Tensor &rois_n, float spatial_scale, int64_t pooled_height, int64_t pooled_width, int64_t sample_num=2, int64_t roi_end_mode=1, const char *pool_mode="avg") {
  auto out = EsROIAlign(features.GetEsbTensor(), rois.GetEsbTensor(), rois_n.GetEsbTensor(), spatial_scale, pooled_height, pooled_width, sample_num, roi_end_mode, pool_mode);
  return out;
}
inline Tensor ROIAlignGrad(const Tensor &ydiff, const Tensor &rois, const Tensor &rois_n, const std::vector<int64_t> &xdiff_shape, int64_t pooled_width, int64_t pooled_height, float spatial_scale, int64_t sample_num=2, int64_t roi_end_mode=1) {
  auto out = EsROIAlignGrad(ydiff.GetEsbTensor(), rois.GetEsbTensor(), rois_n.GetEsbTensor(), xdiff_shape.data(), static_cast<int64_t>(xdiff_shape.size()), pooled_width, pooled_height, spatial_scale, sample_num, roi_end_mode);
  return out;
}
inline Tensor ROIPooling(const Tensor &x, const Tensor &rois, const Tensor &roi_actual_num, int64_t pooled_h, int64_t pooled_w, float spatial_scale_h, float spatial_scale_w) {
  auto out = EsROIPooling(x.GetEsbTensor(), rois.GetEsbTensor(), roi_actual_num.GetEsbTensor(), pooled_h, pooled_w, spatial_scale_h, spatial_scale_w);
  return out;
}
inline Tensor RaggedBinCount(const Tensor &splits, const Tensor &values, const Tensor &size, const Tensor &weights, bool binary_output=false) {
  auto out = EsRaggedBinCount(splits.GetEsbTensor(), values.GetEsbTensor(), size.GetEsbTensor(), weights.GetEsbTensor(), binary_output);
  return out;
}
inline Tensor RaggedBincount(const Tensor &splits, const Tensor &values, const Tensor &size, const Tensor &weights, bool binary_output=false) {
  auto out = EsRaggedBincount(splits.GetEsbTensor(), values.GetEsbTensor(), size.GetEsbTensor(), weights.GetEsbTensor(), binary_output);
  return out;
}
struct RaggedCountSparseOutputOutput {
  Tensor output_indices;
  Tensor output_values;
  Tensor output_dense_shape;
};
inline RaggedCountSparseOutputOutput RaggedCountSparseOutput(const Tensor &splits, const Tensor &values, const Tensor &weights, bool binary_output, int64_t minlength=-1, int64_t maxlength=-1) {
  auto out = EsRaggedCountSparseOutput(splits.GetEsbTensor(), values.GetEsbTensor(), weights.GetEsbTensor(), binary_output, minlength, maxlength);
  return {out.output_indices, out.output_values, out.output_dense_shape};
}
struct RaggedRangeOutput {
  Tensor rt_nested_splits;
  Tensor rt_dense_values;
};
inline RaggedRangeOutput RaggedRange(const Tensor &starts, const Tensor &limits, const Tensor &deltas, ge::DataType Tsplits) {
  auto out = EsRaggedRange(starts.GetEsbTensor(), limits.GetEsbTensor(), deltas.GetEsbTensor(), Tsplits);
  return {out.rt_nested_splits, out.rt_dense_values};
}
struct RaggedTensorToSparseOutput {
  Tensor sparse_indices;
  Tensor sparse_values;
  Tensor sparse_dense_shape;
};
inline RaggedTensorToSparseOutput RaggedTensorToSparse(const std::vector<Tensor> &rt_nested_splits, const Tensor &rt_dense_values, int64_t RAGGED_RANK=1, ge::DataType Tsplits=ge::DT_INT64) {
  auto esb_rt_nested_splits = TensorsToEsbTensors(rt_nested_splits);
  auto out = EsRaggedTensorToSparse(esb_rt_nested_splits.data(), static_cast<int64_t>(esb_rt_nested_splits.size()), rt_dense_values.GetEsbTensor(), RAGGED_RANK, Tsplits);
  return {out.sparse_indices, out.sparse_values, out.sparse_dense_shape};
}
struct RandomChoiceWithMaskOutput {
  Tensor y;
  Tensor mask;
};
inline RandomChoiceWithMaskOutput RandomChoiceWithMask(const Tensor &x, int64_t count=0, int64_t seed=0, int64_t seed2=0) {
  auto out = EsRandomChoiceWithMask(x.GetEsbTensor(), count, seed, seed2);
  return {out.y, out.mask};
}
inline Tensor RandomGamma(const Tensor &shape, const Tensor &alpha, int64_t seed=0, int64_t seed2=0) {
  auto out = EsRandomGamma(shape.GetEsbTensor(), alpha.GetEsbTensor(), seed, seed2);
  return out;
}
inline Tensor RandomGammaGrad(const Tensor &alpha, const Tensor &sample) {
  auto out = EsRandomGammaGrad(alpha.GetEsbTensor(), sample.GetEsbTensor());
  return out;
}
inline Tensor RandomPoisson(const Tensor &shape, const Tensor &rate, ge::DataType dtype=ge::DT_INT64, int64_t seed=0, int64_t seed2=0) {
  auto out = EsRandomPoisson(shape.GetEsbTensor(), rate.GetEsbTensor(), dtype, seed, seed2);
  return out;
}
inline Tensor RandomShuffle(const Tensor &x, int64_t seed=0, int64_t seed2=0) {
  auto out = EsRandomShuffle(x.GetEsbTensor(), seed, seed2);
  return out;
}
inline Tensor RandomStandardNormal(const Tensor &shape, ge::DataType dtype, int64_t seed=0, int64_t seed2=0) {
  auto out = EsRandomStandardNormal(shape.GetEsbTensor(), dtype, seed, seed2);
  return out;
}
inline Tensor RandomUniform(const Tensor &shape, ge::DataType dtype, int64_t seed=0, int64_t seed2=0) {
  auto out = EsRandomUniform(shape.GetEsbTensor(), dtype, seed, seed2);
  return out;
}
inline Tensor RandomUniformInt(const Tensor &shape, const Tensor &min, const Tensor &max, int64_t seed=0, int64_t seed2=0) {
  auto out = EsRandomUniformInt(shape.GetEsbTensor(), min.GetEsbTensor(), max.GetEsbTensor(), seed, seed2);
  return out;
}
inline Tensor Randperm(const Graph &owner_graph, int64_t n, int64_t layout=0, ge::DataType dtype=ge::DT_INT64) {
  auto out = EsRandperm(owner_graph.GetEsbGraph(), n, layout, dtype);
  return out;
}
inline Tensor Range(const Tensor &start, const Tensor &limit, const Tensor &delta, bool is_closed=false) {
  auto out = EsRange(start.GetEsbTensor(), limit.GetEsbTensor(), delta.GetEsbTensor(), is_closed);
  return out;
}
inline Tensor RangeD(const Tensor &x, float start, float limit, float delta) {
  auto out = EsRangeD(x.GetEsbTensor(), start, limit, delta);
  return out;
}
inline Tensor Rank(const Tensor &x) {
  auto out = EsRank(x.GetEsbTensor());
  return out;
}
inline Tensor ReadSelect(const Tensor &x, const std::vector<int64_t> &stride_list={1, 1, 1, 1, 1}) {
  auto out = EsReadSelect(x.GetEsbTensor(), stride_list.data(), static_cast<int64_t>(stride_list.size()));
  return out;
}
inline Tensor ReadVariableOp(const Tensor &x, int64_t dtype=3) {
  auto out = EsReadVariableOp(x.GetEsbTensor(), dtype);
  return out;
}
inline Tensor Real(const Tensor &input, int64_t Tout=0) {
  auto out = EsReal(input.GetEsbTensor(), Tout);
  return out;
}
inline Tensor RealDiv(const Tensor &x1, const Tensor &x2) {
  auto out = EsRealDiv(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor RealDiv(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return RealDiv(tensor, b_esb_tensor);
}
inline Tensor Reciprocal(const Tensor &x) {
  auto out = EsReciprocal(x.GetEsbTensor());
  return out;
}
inline Tensor ReciprocalGrad(const Tensor &y, const Tensor &dy) {
  auto out = EsReciprocalGrad(y.GetEsbTensor(), dy.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor ReciprocalGrad(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return ReciprocalGrad(tensor, b_esb_tensor);
}
inline Tensor RecordInput(const Graph &owner_graph, const char *file_pattern, int64_t file_random_seed=301, float file_shuffle_shift_ratio=0.000000, int64_t file_buffer_size=10000, int64_t file_parallelism=16, int64_t batch_size=32, const char *compression_type="") {
  auto out = EsRecordInput(owner_graph.GetEsbGraph(), file_pattern, file_random_seed, file_shuffle_shift_ratio, file_buffer_size, file_parallelism, batch_size, compression_type);
  return out;
}
inline Tensor ReduceAll(const Tensor &x, const Tensor &axes, bool keep_dims=false) {
  auto out = EsReduceAll(x.GetEsbTensor(), axes.GetEsbTensor(), keep_dims);
  return out;
}
inline Tensor ReduceAllD(const Tensor &x, const std::vector<int64_t> &axes, bool keep_dims=false) {
  auto out = EsReduceAllD(x.GetEsbTensor(), axes.data(), static_cast<int64_t>(axes.size()), keep_dims);
  return out;
}
inline Tensor ReduceAny(const Tensor &x, const Tensor &axes, bool keep_dims=false) {
  auto out = EsReduceAny(x.GetEsbTensor(), axes.GetEsbTensor(), keep_dims);
  return out;
}
inline Tensor ReduceAnyD(const Tensor &x, const std::vector<int64_t> &axes, bool keep_dims=false) {
  auto out = EsReduceAnyD(x.GetEsbTensor(), axes.data(), static_cast<int64_t>(axes.size()), keep_dims);
  return out;
}
inline Tensor ReduceJoin(const Tensor &input, const Tensor &reduction_indices, bool keep_dims=true, const char *separator="") {
  auto out = EsReduceJoin(input.GetEsbTensor(), reduction_indices.GetEsbTensor(), keep_dims, separator);
  return out;
}
inline Tensor ReduceLogSum(const Tensor &x, const Tensor &axes, bool keep_dims=false) {
  auto out = EsReduceLogSum(x.GetEsbTensor(), axes.GetEsbTensor(), keep_dims);
  return out;
}
inline Tensor ReduceLogSumExp(const Tensor &x, const Tensor &axes, bool keep_dims=false) {
  auto out = EsReduceLogSumExp(x.GetEsbTensor(), axes.GetEsbTensor(), keep_dims);
  return out;
}
inline Tensor ReduceMax(const Tensor &x, const Tensor &axes, bool keep_dims=false) {
  auto out = EsReduceMax(x.GetEsbTensor(), axes.GetEsbTensor(), keep_dims);
  return out;
}
inline Tensor ReduceMaxD(const Tensor &x, const std::vector<int64_t> &axes, bool keep_dims=false) {
  auto out = EsReduceMaxD(x.GetEsbTensor(), axes.data(), static_cast<int64_t>(axes.size()), keep_dims);
  return out;
}
inline Tensor ReduceMean(const Tensor &x, const Tensor &axes, bool keep_dims=false, bool noop_with_empty_axes=true) {
  auto out = EsReduceMean(x.GetEsbTensor(), axes.GetEsbTensor(), keep_dims, noop_with_empty_axes);
  return out;
}
inline Tensor ReduceMeanD(const Tensor &x, const std::vector<int64_t> &axes, bool keep_dims=false, bool noop_with_empty_axes=false) {
  auto out = EsReduceMeanD(x.GetEsbTensor(), axes.data(), static_cast<int64_t>(axes.size()), keep_dims, noop_with_empty_axes);
  return out;
}
struct ReduceMeanVarianceOutput {
  Tensor mean;
  Tensor variance;
};
inline ReduceMeanVarianceOutput ReduceMeanVariance(const Tensor &x, const std::vector<int64_t> &axes={}, bool keep_dims=true) {
  auto out = EsReduceMeanVariance(x.GetEsbTensor(), axes.data(), static_cast<int64_t>(axes.size()), keep_dims);
  return {out.mean, out.variance};
}
inline Tensor ReduceMeanWithCount(const Tensor &x, const Tensor &count, const Tensor &count_sum, const std::vector<int64_t> &axes, bool keep_dims=false) {
  auto out = EsReduceMeanWithCount(x.GetEsbTensor(), count.GetEsbTensor(), count_sum.GetEsbTensor(), axes.data(), static_cast<int64_t>(axes.size()), keep_dims);
  return out;
}
inline Tensor ReduceMin(const Tensor &x, const Tensor &axes, bool keep_dims=false) {
  auto out = EsReduceMin(x.GetEsbTensor(), axes.GetEsbTensor(), keep_dims);
  return out;
}
inline Tensor ReduceMinD(const Tensor &x, const std::vector<int64_t> &axes, bool keep_dims=false) {
  auto out = EsReduceMinD(x.GetEsbTensor(), axes.data(), static_cast<int64_t>(axes.size()), keep_dims);
  return out;
}
inline Tensor ReduceNansum(const Tensor &x, const Tensor &axes, bool keep_dims=false) {
  auto out = EsReduceNansum(x.GetEsbTensor(), axes.GetEsbTensor(), keep_dims);
  return out;
}
inline Tensor ReduceProd(const Tensor &x, const Tensor &axes, bool keep_dims=false) {
  auto out = EsReduceProd(x.GetEsbTensor(), axes.GetEsbTensor(), keep_dims);
  return out;
}
inline Tensor ReduceProdD(const Tensor &x, const std::vector<int64_t> &axes, bool keep_dims=false) {
  auto out = EsReduceProdD(x.GetEsbTensor(), axes.data(), static_cast<int64_t>(axes.size()), keep_dims);
  return out;
}
struct ReduceStdOutput {
  Tensor y1;
  Tensor y2;
};
inline ReduceStdOutput ReduceStd(const Tensor &x, const std::vector<int64_t> &dim={}, bool unbiased=true, bool keepdim=false) {
  auto out = EsReduceStd(x.GetEsbTensor(), dim.data(), static_cast<int64_t>(dim.size()), unbiased, keepdim);
  return {out.y1, out.y2};
}
inline Tensor ReduceStdV2Update(const Tensor &x, const Tensor &mean, const std::vector<int64_t> &dim, bool if_std=false, bool unbiased=true, bool keepdim=false, int64_t correction=1) {
  auto out = EsReduceStdV2Update(x.GetEsbTensor(), mean.GetEsbTensor(), dim.data(), static_cast<int64_t>(dim.size()), if_std, unbiased, keepdim, correction);
  return out;
}
inline Tensor ReduceStdWithMean(const Tensor &x, const Tensor &mean, const std::vector<int64_t> &dim={}, bool unbiased=true, bool keepdim=false, bool invert=false, float epsilon=0.001000, int64_t correction=1) {
  auto out = EsReduceStdWithMean(x.GetEsbTensor(), mean.GetEsbTensor(), dim.data(), static_cast<int64_t>(dim.size()), unbiased, keepdim, invert, epsilon, correction);
  return out;
}
inline Tensor ReduceSum(const Tensor &x, const Tensor &axes, bool keep_dims=false) {
  auto out = EsReduceSum(x.GetEsbTensor(), axes.GetEsbTensor(), keep_dims);
  return out;
}
inline Tensor ReduceSumD(const Tensor &x, const std::vector<int64_t> &axes, bool keep_dims=false) {
  auto out = EsReduceSumD(x.GetEsbTensor(), axes.data(), static_cast<int64_t>(axes.size()), keep_dims);
  return out;
}
inline Tensor Reduction(const Tensor &x, int64_t operation=1, int64_t axis=0, float coeff=1.000000) {
  auto out = EsReduction(x.GetEsbTensor(), operation, axis, coeff);
  return out;
}
inline Tensor RefEnter(const Tensor &x, const char *frame_name, bool is_constant) {
  auto out = EsRefEnter(x.GetEsbTensor(), frame_name, is_constant);
  return out;
}
inline Tensor RefExit(const Tensor &x) {
  auto out = EsRefExit(x.GetEsbTensor());
  return out;
}
struct RefMergeOutput {
  Tensor y;
  Tensor value_index;
};
inline RefMergeOutput RefMerge(const std::vector<Tensor> &x) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsRefMerge(esb_x.data(), static_cast<int64_t>(esb_x.size()));
  return {out.y, out.value_index};
}
inline Tensor RefNextIteration(const Tensor &x) {
  auto out = EsRefNextIteration(x.GetEsbTensor());
  return out;
}
struct RefSwitchOutput {
  Tensor output_false;
  Tensor output_true;
};
inline RefSwitchOutput RefSwitch(const Tensor &data, const Tensor &pred) {
  auto out = EsRefSwitch(data.GetEsbTensor(), pred.GetEsbTensor());
  return {out.output_false, out.output_true};
}
inline Tensor RegexFullMatch(const Tensor &x, const Tensor &pattern) {
  auto out = EsRegexFullMatch(x.GetEsbTensor(), pattern.GetEsbTensor());
  return out;
}
inline Tensor RegexReplace(const Tensor &x, const Tensor &pattern, const Tensor &rewrite, bool replace_global=true) {
  auto out = EsRegexReplace(x.GetEsbTensor(), pattern.GetEsbTensor(), rewrite.GetEsbTensor(), replace_global);
  return out;
}
inline Tensor Relu(const Tensor &x) {
  auto out = EsRelu(x.GetEsbTensor());
  return out;
}
inline Tensor Relu6(const Tensor &x) {
  auto out = EsRelu6(x.GetEsbTensor());
  return out;
}
inline Tensor Relu6D(const Tensor &x, float scale=1.000000) {
  auto out = EsRelu6D(x.GetEsbTensor(), scale);
  return out;
}
inline Tensor Relu6Grad(const Tensor &gradients, const Tensor &features) {
  auto out = EsRelu6Grad(gradients.GetEsbTensor(), features.GetEsbTensor());
  return out;
}
inline Tensor ReluGrad(const Tensor &gradients, const Tensor &features) {
  auto out = EsReluGrad(gradients.GetEsbTensor(), features.GetEsbTensor());
  return out;
}
inline Tensor ReluGradV2(const Tensor &gradients, const Tensor &mask) {
  auto out = EsReluGradV2(gradients.GetEsbTensor(), mask.GetEsbTensor());
  return out;
}
struct ReluV2Output {
  Tensor y;
  Tensor mask;
};
inline ReluV2Output ReluV2(const Tensor &x) {
  auto out = EsReluV2(x.GetEsbTensor());
  return {out.y, out.mask};
}
inline Tensor Remap(const Tensor &img, const Tensor &map_offset) {
  auto out = EsRemap(img.GetEsbTensor(), map_offset.GetEsbTensor());
  return out;
}
inline Tensor Renorm(const Tensor &x, float p, int64_t dim, float maxnorm) {
  auto out = EsRenorm(x.GetEsbTensor(), p, dim, maxnorm);
  return out;
}
inline Tensor RepeatInterleave(const Tensor &x, const Tensor &repeats, int64_t axis=1000) {
  auto out = EsRepeatInterleave(x.GetEsbTensor(), repeats.GetEsbTensor(), axis);
  return out;
}
inline Tensor RepeatInterleaveGrad(const Tensor &y_grad, const Tensor &repeats, int64_t axis=-1) {
  auto out = EsRepeatInterleaveGrad(y_grad.GetEsbTensor(), repeats.GetEsbTensor(), axis);
  return out;
}
inline Tensor Reshape(const Tensor &x, const Tensor &shape, int64_t axis=0, int64_t num_axes=-1) {
  auto out = EsReshape(x.GetEsbTensor(), shape.GetEsbTensor(), axis, num_axes);
  return out;
}
inline Tensor Resize(const Tensor &x, const Tensor &roi=nullptr, const Tensor &scales=nullptr, const Tensor &sizes=nullptr, const char *coordinate_transformation_mode="half_pixel", float cubic_coeff_a=-0.750000, int64_t exclude_outside=0, float extrapolation_value=0.000000, const char *mode="nearest", const char *nearest_mode="round_prefer_floor") {
  auto out = EsResize(x.GetEsbTensor(), roi.GetEsbTensor(), scales.GetEsbTensor(), sizes.GetEsbTensor(), coordinate_transformation_mode, cubic_coeff_a, exclude_outside, extrapolation_value, mode, nearest_mode);
  return out;
}
struct ResizeAndClipPolysOutput {
  Tensor clipped_polys_data;
  Tensor clipped_polys_offset;
  Tensor clipped_polys_size;
  Tensor clipped_polys_num;
};
inline ResizeAndClipPolysOutput ResizeAndClipPolys(const Tensor &polys_data, const Tensor &polys_offset, const Tensor &polys_size, const Tensor &h_scale, const Tensor &w_scale, const Tensor &img_h, const Tensor &img_w) {
  auto out = EsResizeAndClipPolys(polys_data.GetEsbTensor(), polys_offset.GetEsbTensor(), polys_size.GetEsbTensor(), h_scale.GetEsbTensor(), w_scale.GetEsbTensor(), img_h.GetEsbTensor(), img_w.GetEsbTensor());
  return {out.clipped_polys_data, out.clipped_polys_offset, out.clipped_polys_size, out.clipped_polys_num};
}
inline Tensor ResizeArea(const Tensor &images, const Tensor &size, bool align_corners=false) {
  auto out = EsResizeArea(images.GetEsbTensor(), size.GetEsbTensor(), align_corners);
  return out;
}
inline Tensor ResizeBicubic(const Tensor &images, const Tensor &size, bool align_corners=false, bool half_pixel_centers=false, ge::DataType dtype=ge::DT_FLOAT) {
  auto out = EsResizeBicubic(images.GetEsbTensor(), size.GetEsbTensor(), align_corners, half_pixel_centers, dtype);
  return out;
}
inline Tensor ResizeBicubicGrad(const Tensor &grads, const Tensor &original_image, bool align_corners=false, bool half_pixel_centers=false) {
  auto out = EsResizeBicubicGrad(grads.GetEsbTensor(), original_image.GetEsbTensor(), align_corners, half_pixel_centers);
  return out;
}
inline Tensor ResizeBilinearV2(const Tensor &x, const Tensor &size, bool align_corners=false, bool half_pixel_centers=false, ge::DataType dtype=ge::DT_FLOAT) {
  auto out = EsResizeBilinearV2(x.GetEsbTensor(), size.GetEsbTensor(), align_corners, half_pixel_centers, dtype);
  return out;
}
inline Tensor ResizeBilinearV2D(const Tensor &x, const std::vector<int64_t> &size, bool align_corners=false, bool half_pixel_centers=false) {
  auto out = EsResizeBilinearV2D(x.GetEsbTensor(), size.data(), static_cast<int64_t>(size.size()), align_corners, half_pixel_centers);
  return out;
}
inline Tensor ResizeBilinearV2Grad(const Tensor &grads, const Tensor &original_image, bool align_corners=false, bool half_pixel_centers=false) {
  auto out = EsResizeBilinearV2Grad(grads.GetEsbTensor(), original_image.GetEsbTensor(), align_corners, half_pixel_centers);
  return out;
}
inline Tensor ResizeD(const Tensor &x, const std::vector<int64_t> &sizes, const std::vector<float> &scales={}, const std::vector<int64_t> &roi={}, const char *coordinate_transformation_mode="half_pixel", float cubic_coeff_a=-0.750000, int64_t exclude_outside=0, float extrapolation_value=0.000000, const char *mode="nearest", const char *nearest_mode="round_prefer_floor", const char *data_format="NCHW") {
  auto out = EsResizeD(x.GetEsbTensor(), sizes.data(), static_cast<int64_t>(sizes.size()), scales.data(), static_cast<int64_t>(scales.size()), roi.data(), static_cast<int64_t>(roi.size()), coordinate_transformation_mode, cubic_coeff_a, exclude_outside, extrapolation_value, mode, nearest_mode, data_format);
  return out;
}
inline Tensor ResizeGrad(const Tensor &grads, const Tensor &roi, const Tensor &scales, const Tensor &original_size, const char *coordinate_transformation_mode="half_pixel", float cubic_coeff_a=-0.750000, int64_t exclude_outside=0, float extrapolation_value=0.000000, const char *mode="nearest", const char *nearest_mode="round_prefer_floor") {
  auto out = EsResizeGrad(grads.GetEsbTensor(), roi.GetEsbTensor(), scales.GetEsbTensor(), original_size.GetEsbTensor(), coordinate_transformation_mode, cubic_coeff_a, exclude_outside, extrapolation_value, mode, nearest_mode);
  return out;
}
inline Tensor ResizeGradD(const Tensor &grads, const std::vector<int64_t> &original_size, const std::vector<int64_t> &roi={}, const std::vector<float> &scales={}, const char *coordinate_transformation_mode="half_pixel", float cubic_coeff_a=-0.750000, int64_t exclude_outside=0, float extrapolation_value=0.000000, const char *mode="nearest", const char *nearest_mode="round_prefer_floor", const char *data_format="NCHW") {
  auto out = EsResizeGradD(grads.GetEsbTensor(), original_size.data(), static_cast<int64_t>(original_size.size()), roi.data(), static_cast<int64_t>(roi.size()), scales.data(), static_cast<int64_t>(scales.size()), coordinate_transformation_mode, cubic_coeff_a, exclude_outside, extrapolation_value, mode, nearest_mode, data_format);
  return out;
}
inline Tensor ResizeNearestNeighborV2(const Tensor &x, const Tensor &size, bool align_corners=false, bool half_pixel_centers=false) {
  auto out = EsResizeNearestNeighborV2(x.GetEsbTensor(), size.GetEsbTensor(), align_corners, half_pixel_centers);
  return out;
}
inline Tensor ResizeNearestNeighborV2D(const Tensor &x, const std::vector<int64_t> &size, bool align_corners=false, bool half_pixel_centers=false) {
  auto out = EsResizeNearestNeighborV2D(x.GetEsbTensor(), size.data(), static_cast<int64_t>(size.size()), align_corners, half_pixel_centers);
  return out;
}
inline Tensor ResizeNearestNeighborV2Grad(const Tensor &grads, const Tensor &size, bool align_corners=false, bool half_pixel_centers=false) {
  auto out = EsResizeNearestNeighborV2Grad(grads.GetEsbTensor(), size.GetEsbTensor(), align_corners, half_pixel_centers);
  return out;
}
inline Tensor ResizeNearestNeighborV2GradD(const Tensor &grads, const std::vector<int64_t> &size, bool align_corners=false, bool half_pixel_centers=false) {
  auto out = EsResizeNearestNeighborV2GradD(grads.GetEsbTensor(), size.data(), static_cast<int64_t>(size.size()), align_corners, half_pixel_centers);
  return out;
}
inline Tensor ResizeTrilinear(const Tensor &x, const Tensor &size, bool align_corners=false, bool half_pixel_centers=false) {
  auto out = EsResizeTrilinear(x.GetEsbTensor(), size.GetEsbTensor(), align_corners, half_pixel_centers);
  return out;
}
inline Tensor ResizeV2(const Tensor &x, const Tensor &dst_size, const char *interpolation="nearest", const char *data_format="HWC") {
  auto out = EsResizeV2(x.GetEsbTensor(), dst_size.GetEsbTensor(), interpolation, data_format);
  return out;
}
inline Tensor ResourceAccumulatorApplyGradient(const Tensor &handle, const Tensor &local_step, const Tensor &gradient) {
  auto out = EsResourceAccumulatorApplyGradient(handle.GetEsbTensor(), local_step.GetEsbTensor(), gradient.GetEsbTensor());
  return out;
}
inline Tensor ResourceAccumulatorNumAccumulated(const Tensor &handle) {
  auto out = EsResourceAccumulatorNumAccumulated(handle.GetEsbTensor());
  return out;
}
inline Tensor ResourceAccumulatorSetGlobalStep(const Tensor &handle, const Tensor &new_global_step) {
  auto out = EsResourceAccumulatorSetGlobalStep(handle.GetEsbTensor(), new_global_step.GetEsbTensor());
  return out;
}
inline Tensor ResourceAccumulatorTakeGradient(const Tensor &handle, const Tensor &num_required, ge::DataType dtype) {
  auto out = EsResourceAccumulatorTakeGradient(handle.GetEsbTensor(), num_required.GetEsbTensor(), dtype);
  return out;
}
inline Tensor ResourceConditionalAccumulator(const Graph &owner_graph, ge::DataType dtype, const std::vector<int64_t> &shape, const char *container="", const char *shared_name="", const char *reduction_type="MEAN") {
  auto out = EsResourceConditionalAccumulator(owner_graph.GetEsbGraph(), dtype, shape.data(), static_cast<int64_t>(shape.size()), container, shared_name, reduction_type);
  return out;
}
inline Tensor ReverseSequence(const Tensor &x, const Tensor &seq_lengths, int64_t seq_dim, int64_t batch_dim=0) {
  auto out = EsReverseSequence(x.GetEsbTensor(), seq_lengths.GetEsbTensor(), seq_dim, batch_dim);
  return out;
}
inline Tensor ReverseV2(const Tensor &x, const Tensor &axis) {
  auto out = EsReverseV2(x.GetEsbTensor(), axis.GetEsbTensor());
  return out;
}
inline Tensor ReverseV2D(const Tensor &x, const std::vector<int64_t> &axis) {
  auto out = EsReverseV2D(x.GetEsbTensor(), axis.data(), static_cast<int64_t>(axis.size()));
  return out;
}
inline Tensor RgbToGrayscale(const Tensor &images, const char *data_format="HWC", int64_t output_channels=1) {
  auto out = EsRgbToGrayscale(images.GetEsbTensor(), data_format, output_channels);
  return out;
}
inline Tensor RightShift(const Tensor &x, const Tensor &y) {
  auto out = EsRightShift(x.GetEsbTensor(), y.GetEsbTensor());
  return out;
}
struct RingAttentionUpdateOutput {
  Tensor attn_out;
  Tensor softmax_max;
  Tensor softmax_sum;
};
inline RingAttentionUpdateOutput RingAttentionUpdate(const Tensor &prev_attn_out, const Tensor &prev_softmax_max, const Tensor &prev_softmax_sum, const Tensor &cur_attn_out, const Tensor &cur_softmax_max, const Tensor &cur_softmax_sum, const Tensor &actual_seq_qlen=nullptr, const char *input_layout="SBH") {
  auto out = EsRingAttentionUpdate(prev_attn_out.GetEsbTensor(), prev_softmax_max.GetEsbTensor(), prev_softmax_sum.GetEsbTensor(), cur_attn_out.GetEsbTensor(), cur_softmax_max.GetEsbTensor(), cur_softmax_sum.GetEsbTensor(), actual_seq_qlen.GetEsbTensor(), input_layout);
  return {out.attn_out, out.softmax_max, out.softmax_sum};
}
inline Tensor Rint(const Tensor &x) {
  auto out = EsRint(x.GetEsbTensor());
  return out;
}
struct RmsNormOutput {
  Tensor y;
  Tensor rstd;
};
inline RmsNormOutput RmsNorm(const Tensor &x, const Tensor &gamma, float epsilon=0.000001) {
  auto out = EsRmsNorm(x.GetEsbTensor(), gamma.GetEsbTensor(), epsilon);
  return {out.y, out.rstd};
}
struct RmsNormGradOutput {
  Tensor dx;
  Tensor dgamma;
};
inline RmsNormGradOutput RmsNormGrad(const Tensor &dy, const Tensor &x, const Tensor &rstd, const Tensor &gamma) {
  auto out = EsRmsNormGrad(dy.GetEsbTensor(), x.GetEsbTensor(), rstd.GetEsbTensor(), gamma.GetEsbTensor());
  return {out.dx, out.dgamma};
}
inline Tensor RngReadAndSkipV2(const Tensor &value, const Tensor &algorithm, const Tensor &delta) {
  auto out = EsRngReadAndSkipV2(value.GetEsbTensor(), algorithm.GetEsbTensor(), delta.GetEsbTensor());
  return out;
}
inline Tensor RngSkip(const Tensor &x, const Tensor &algorithm, const Tensor &delta) {
  auto out = EsRngSkip(x.GetEsbTensor(), algorithm.GetEsbTensor(), delta.GetEsbTensor());
  return out;
}
inline Tensor RnnGenMask(const Tensor &seq_length, int64_t num_step, int64_t hidden_size) {
  auto out = EsRnnGenMask(seq_length.GetEsbTensor(), num_step, hidden_size);
  return out;
}
inline Tensor RnnGenMaskV2(const Tensor &seq_length, const Tensor &x, int64_t hidden_size) {
  auto out = EsRnnGenMaskV2(seq_length.GetEsbTensor(), x.GetEsbTensor(), hidden_size);
  return out;
}
inline Tensor RoiAlignRotatedGrad(const Tensor &x_grad, const Tensor &rois, const std::vector<int64_t> &y_grad_shape, int64_t pooled_h, int64_t pooled_w, float spatial_scale, int64_t sampling_ratio=0, bool aligned=true, bool clockwise=false) {
  auto out = EsRoiAlignRotatedGrad(x_grad.GetEsbTensor(), rois.GetEsbTensor(), y_grad_shape.data(), static_cast<int64_t>(y_grad_shape.size()), pooled_h, pooled_w, spatial_scale, sampling_ratio, aligned, clockwise);
  return out;
}
inline Tensor RoiExtractor(const std::vector<Tensor> &features, const Tensor &rois, const Tensor &index=nullptr, int64_t finest_scale=56, float roi_scale_factor=0.000000, const std::vector<float> &spatial_scale={0.250000, 0.125000, 0.062500, 0.031250}, int64_t pooled_height=7, int64_t pooled_width=7, int64_t sample_num=0, const char *pool_mode="avg", bool aligned=true) {
  auto esb_features = TensorsToEsbTensors(features);
  auto out = EsRoiExtractor(esb_features.data(), static_cast<int64_t>(esb_features.size()), rois.GetEsbTensor(), index.GetEsbTensor(), finest_scale, roi_scale_factor, spatial_scale.data(), static_cast<int64_t>(spatial_scale.size()), pooled_height, pooled_width, sample_num, pool_mode, aligned);
  return out;
}
inline Tensor RoiPoolingGradWithArgMax(const Tensor &grad, const Tensor &x, const Tensor &rois, const Tensor &roi_actual_num, const Tensor &argmax, int64_t pooled_h, int64_t pooled_w, float spatial_scale_h, float spatial_scale_w, int64_t pool_channel) {
  auto out = EsRoiPoolingGradWithArgMax(grad.GetEsbTensor(), x.GetEsbTensor(), rois.GetEsbTensor(), roi_actual_num.GetEsbTensor(), argmax.GetEsbTensor(), pooled_h, pooled_w, spatial_scale_h, spatial_scale_w, pool_channel);
  return out;
}
struct RoiPoolingWithArgMaxOutput {
  Tensor y;
  Tensor argmax;
};
inline RoiPoolingWithArgMaxOutput RoiPoolingWithArgMax(const Tensor &x, const Tensor &rois, const Tensor &roi_actual_num, int64_t pooled_h, int64_t pooled_w, float spatial_scale_h, float spatial_scale_w, int64_t pool_channel) {
  auto out = EsRoiPoolingWithArgMax(x.GetEsbTensor(), rois.GetEsbTensor(), roi_actual_num.GetEsbTensor(), pooled_h, pooled_w, spatial_scale_h, spatial_scale_w, pool_channel);
  return {out.y, out.argmax};
}
inline Tensor Roll(const Tensor &x, const std::vector<int64_t> &shifts, const std::vector<int64_t> &dims={}) {
  auto out = EsRoll(x.GetEsbTensor(), shifts.data(), static_cast<int64_t>(shifts.size()), dims.data(), static_cast<int64_t>(dims.size()));
  return out;
}
inline Tensor RollV2(const Tensor &input, const Tensor &shift, const Tensor &axes) {
  auto out = EsRollV2(input.GetEsbTensor(), shift.GetEsbTensor(), axes.GetEsbTensor());
  return out;
}
struct RopeQuantKvcacheOutput {
  Tensor q;
  Tensor k;
  Tensor v;
  Tensor k_cache;
  Tensor v_cache;
};
inline RopeQuantKvcacheOutput RopeQuantKvcache(const Tensor &qkv, const Tensor &cos, const Tensor &sin, const Tensor &quant_scale, const Tensor &quant_offset, const Tensor &k_cache, const Tensor &v_cache, const Tensor &indice, const std::vector<int64_t> &size_splits={}, const char *layout="BSND", bool kv_output=false) {
  auto out = EsRopeQuantKvcache(qkv.GetEsbTensor(), cos.GetEsbTensor(), sin.GetEsbTensor(), quant_scale.GetEsbTensor(), quant_offset.GetEsbTensor(), k_cache.GetEsbTensor(), v_cache.GetEsbTensor(), indice.GetEsbTensor(), size_splits.data(), static_cast<int64_t>(size_splits.size()), layout, kv_output);
  return {out.q, out.k, out.v, out.k_cache, out.v_cache};
}
inline Tensor RotaryMul(const Tensor &x, const Tensor &r1, const Tensor &r2) {
  auto out = EsRotaryMul(x.GetEsbTensor(), r1.GetEsbTensor(), r2.GetEsbTensor());
  return out;
}
struct RotaryMulGradOutput {
  Tensor dx;
  Tensor dr1;
  Tensor dr2;
};
inline RotaryMulGradOutput RotaryMulGrad(const Tensor &x, const Tensor &r1, const Tensor &r2, const Tensor &dy, bool need_backward=true) {
  auto out = EsRotaryMulGrad(x.GetEsbTensor(), r1.GetEsbTensor(), r2.GetEsbTensor(), dy.GetEsbTensor(), need_backward);
  return {out.dx, out.dr1, out.dr2};
}
inline Tensor RotaryPositionEmbedding(const Tensor &x, const Tensor &cos, const Tensor &sin, int64_t mode=0) {
  auto out = EsRotaryPositionEmbedding(x.GetEsbTensor(), cos.GetEsbTensor(), sin.GetEsbTensor(), mode);
  return out;
}
struct RotaryPositionEmbeddingGradOutput {
  Tensor dx;
  Tensor dcos;
  Tensor dsin;
};
inline RotaryPositionEmbeddingGradOutput RotaryPositionEmbeddingGrad(const Tensor &dy, const Tensor &cos, const Tensor &sin, const Tensor &x=nullptr, int64_t mode=0) {
  auto out = EsRotaryPositionEmbeddingGrad(dy.GetEsbTensor(), cos.GetEsbTensor(), sin.GetEsbTensor(), x.GetEsbTensor(), mode);
  return {out.dx, out.dcos, out.dsin};
}
inline Tensor Rotate(const Tensor &x, float angle, const std::vector<int64_t> &center={}, bool expand=false, const char *interpolation="nearest", const char *padding_mode="constant", float padding_value=0.000000, const char *data_format="HWC") {
  auto out = EsRotate(x.GetEsbTensor(), angle, center.data(), static_cast<int64_t>(center.size()), expand, interpolation, padding_mode, padding_value, data_format);
  return out;
}
inline Tensor RotatedBoxDecode(const Tensor &anchor_box, const Tensor &deltas, const std::vector<float> &weight={1.000000, 1.000000, 1.000000, 1.000000, 1.000000}) {
  auto out = EsRotatedBoxDecode(anchor_box.GetEsbTensor(), deltas.GetEsbTensor(), weight.data(), static_cast<int64_t>(weight.size()));
  return out;
}
inline Tensor RotatedBoxEncode(const Tensor &anchor_box, const Tensor &gt_box, const std::vector<float> &weight={1.000000, 1.000000, 1.000000, 1.000000, 1.000000}) {
  auto out = EsRotatedBoxEncode(anchor_box.GetEsbTensor(), gt_box.GetEsbTensor(), weight.data(), static_cast<int64_t>(weight.size()));
  return out;
}
inline Tensor RotatedFeatureAlign(const Tensor &x, const Tensor &bboxes, float spatial_scale, int64_t points=1) {
  auto out = EsRotatedFeatureAlign(x.GetEsbTensor(), bboxes.GetEsbTensor(), spatial_scale, points);
  return out;
}
inline Tensor RotatedFeatureAlignGrad(const Tensor &dy, const Tensor &bboxes, float spatial_scale, int64_t points=1) {
  auto out = EsRotatedFeatureAlignGrad(dy.GetEsbTensor(), bboxes.GetEsbTensor(), spatial_scale, points);
  return out;
}
inline Tensor RotatedIou(const Tensor &boxes, const Tensor &query_boxes, bool trans=false, const char *mode="iou", bool is_cross=true, float v_threshold=0.000000, float e_threshold=0.000000) {
  auto out = EsRotatedIou(boxes.GetEsbTensor(), query_boxes.GetEsbTensor(), trans, mode, is_cross, v_threshold, e_threshold);
  return out;
}
struct RotatedNMSOutput {
  Tensor selected_detections;
  Tensor keep_indices;
};
inline RotatedNMSOutput RotatedNMS(const Tensor &boxes, const Tensor &scores, const Tensor &labels, float iou_threshold, bool is_angle=true) {
  auto out = EsRotatedNMS(boxes.GetEsbTensor(), scores.GetEsbTensor(), labels.GetEsbTensor(), iou_threshold, is_angle);
  return {out.selected_detections, out.keep_indices};
}
inline Tensor RotatedOverlaps(const Tensor &boxes, const Tensor &query_boxes, bool trans=false) {
  auto out = EsRotatedOverlaps(boxes.GetEsbTensor(), query_boxes.GetEsbTensor(), trans);
  return out;
}
inline Tensor Round(const Tensor &x, int64_t decimals=0) {
  auto out = EsRound(x.GetEsbTensor(), decimals);
  return out;
}
inline Tensor RpnProposalPostProcessing(const Tensor &sorted_proposal, const Tensor &proposal_num, const std::vector<int64_t> &img_size, float score_threshold, int64_t k, float min_size, float nms_threshold, int64_t post_nms_num, bool box_filter=true, int64_t core_max_num=8) {
  auto out = EsRpnProposalPostProcessing(sorted_proposal.GetEsbTensor(), proposal_num.GetEsbTensor(), img_size.data(), static_cast<int64_t>(img_size.size()), score_threshold, k, min_size, nms_threshold, post_nms_num, box_filter, core_max_num);
  return out;
}
inline Tensor RpnProposals(const Tensor &rois, const Tensor &cls_bg_prob, const Tensor &img_size, float score_threshold, int64_t k, float min_size, float nms_threshold, int64_t post_nms_num, bool score_filter=true, bool box_filter=true, bool score_sigmoid=false) {
  auto out = EsRpnProposals(rois.GetEsbTensor(), cls_bg_prob.GetEsbTensor(), img_size.GetEsbTensor(), score_threshold, k, min_size, nms_threshold, post_nms_num, score_filter, box_filter, score_sigmoid);
  return out;
}
inline Tensor RpnProposalsD(const Tensor &rois, const Tensor &cls_bg_prob, const std::vector<int64_t> &img_size, float score_threshold, int64_t k, float min_size, float nms_threshold, int64_t post_nms_num, bool score_filter=true, bool box_filter=true, bool score_sigmoid=false) {
  auto out = EsRpnProposalsD(rois.GetEsbTensor(), cls_bg_prob.GetEsbTensor(), img_size.data(), static_cast<int64_t>(img_size.size()), score_threshold, k, min_size, nms_threshold, post_nms_num, score_filter, box_filter, score_sigmoid);
  return out;
}
inline Tensor Rsqrt(const Tensor &x) {
  auto out = EsRsqrt(x.GetEsbTensor());
  return out;
}
inline Tensor RsqrtGrad(const Tensor &y, const Tensor &dy) {
  auto out = EsRsqrtGrad(y.GetEsbTensor(), dy.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor RsqrtGrad(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return RsqrtGrad(tensor, b_esb_tensor);
}
inline Tensor SGD(const Tensor &parameters, const Tensor &gradient, const Tensor &learning_rate, const Tensor &accum, const Tensor &momentum, const Tensor &stat, float dampening=0.000000, float weight_decay=0.000000, bool nesterov=false) {
  auto out = EsSGD(parameters.GetEsbTensor(), gradient.GetEsbTensor(), learning_rate.GetEsbTensor(), accum.GetEsbTensor(), momentum.GetEsbTensor(), stat.GetEsbTensor(), dampening, weight_decay, nesterov);
  return out;
}
inline Tensor SPP(const Tensor &x, int64_t pyramid_height, int64_t pool_method=0) {
  auto out = EsSPP(x.GetEsbTensor(), pyramid_height, pool_method);
  return out;
}
struct SSDDetectionOutputOutput {
  Tensor out_boxnum;
  Tensor y;
};
inline SSDDetectionOutputOutput SSDDetectionOutput(const Tensor &bbox_delta, const Tensor &score, const Tensor &anchors, int64_t num_classes=2, bool share_location=true, int64_t background_label_id=0, float iou_threshold=0.300000, int64_t top_k=200, float eta=1.000000, bool variance_encoded_in_target=false, int64_t code_type=1, int64_t keep_top_k=-1, float confidence_threshold=0.000000) {
  auto out = EsSSDDetectionOutput(bbox_delta.GetEsbTensor(), score.GetEsbTensor(), anchors.GetEsbTensor(), num_classes, share_location, background_label_id, iou_threshold, top_k, eta, variance_encoded_in_target, code_type, keep_top_k, confidence_threshold);
  return {out.out_boxnum, out.y};
}
inline Tensor STFT(const Tensor &x, const Tensor &window, int64_t n_fft, int64_t hop_length=0, int64_t win_length=0, bool normalized=false, bool onesided=true, bool return_complex=true) {
  auto out = EsSTFT(x.GetEsbTensor(), window.GetEsbTensor(), n_fft, hop_length, win_length, normalized, onesided, return_complex);
  return out;
}
struct SampleDistortedBoundingBoxOutput {
  Tensor begin;
  Tensor size;
  Tensor bboxes;
};
inline SampleDistortedBoundingBoxOutput SampleDistortedBoundingBox(const Tensor &image_size, const Tensor &bounding_boxes, int64_t seed=0, int64_t seed2=0, float min_object_covered=0.100000, const std::vector<float> &aspect_ratio_range={0.750000, 1.330000}, const std::vector<float> &area_range={0.050000, 1.000000}, int64_t max_attempts=100, bool use_image_if_no_bounding_boxes=false) {
  auto out = EsSampleDistortedBoundingBox(image_size.GetEsbTensor(), bounding_boxes.GetEsbTensor(), seed, seed2, min_object_covered, aspect_ratio_range.data(), static_cast<int64_t>(aspect_ratio_range.size()), area_range.data(), static_cast<int64_t>(area_range.size()), max_attempts, use_image_if_no_bounding_boxes);
  return {out.begin, out.size, out.bboxes};
}
struct SampleDistortedBoundingBoxExt2Output {
  Tensor begin;
  Tensor size;
  Tensor bboxes;
};
inline SampleDistortedBoundingBoxExt2Output SampleDistortedBoundingBoxExt2(const Tensor &image_size, const Tensor &bounding_boxes, const Tensor &min_object_covered, int64_t seed=0, int64_t seed2=0, const std::vector<float> &aspect_ratio_range={0.750000, 1.330000}, const std::vector<float> &area_range={0.050000, 1.000000}, int64_t max_attempts=100, bool use_image_if_no_bounding_boxes=false) {
  auto out = EsSampleDistortedBoundingBoxExt2(image_size.GetEsbTensor(), bounding_boxes.GetEsbTensor(), min_object_covered.GetEsbTensor(), seed, seed2, aspect_ratio_range.data(), static_cast<int64_t>(aspect_ratio_range.size()), area_range.data(), static_cast<int64_t>(area_range.size()), max_attempts, use_image_if_no_bounding_boxes);
  return {out.begin, out.size, out.bboxes};
}
inline Tensor Scale(const Tensor &x, const Tensor &scale, const Tensor &bias=nullptr, int64_t axis=1, int64_t num_axes=1, bool scale_from_blob=true) {
  auto out = EsScale(x.GetEsbTensor(), scale.GetEsbTensor(), bias.GetEsbTensor(), axis, num_axes, scale_from_blob);
  return out;
}
inline Tensor ScaleAndTranslate(const Tensor &images, const Tensor &size, const Tensor &scale, const Tensor &translation, const char *kernel_type="lanczos3", bool antialias=true) {
  auto out = EsScaleAndTranslate(images.GetEsbTensor(), size.GetEsbTensor(), scale.GetEsbTensor(), translation.GetEsbTensor(), kernel_type, antialias);
  return out;
}
inline Tensor ScaleAndTranslateGrad(const Tensor &grads, const Tensor &original_image, const Tensor &scale, const Tensor &translation, const char *kernel_type="lanczos3", bool antialias=true) {
  auto out = EsScaleAndTranslateGrad(grads.GetEsbTensor(), original_image.GetEsbTensor(), scale.GetEsbTensor(), translation.GetEsbTensor(), kernel_type, antialias);
  return out;
}
inline Tensor ScaledMaskedSoftmax(const Tensor &x, const Tensor &mask=nullptr, float scale=1.000000, bool fixed_triu_mask=false) {
  auto out = EsScaledMaskedSoftmax(x.GetEsbTensor(), mask.GetEsbTensor(), scale, fixed_triu_mask);
  return out;
}
inline Tensor ScaledMaskedSoftmaxGrad(const Tensor &y_grad, const Tensor &y, const Tensor &mask=nullptr, float scale=1.000000, bool fixed_triu_mask=false) {
  auto out = EsScaledMaskedSoftmaxGrad(y_grad.GetEsbTensor(), y.GetEsbTensor(), mask.GetEsbTensor(), scale, fixed_triu_mask);
  return out;
}
struct ScanPQCodesOutput {
  Tensor actual_count;
  Tensor pq_distance;
  Tensor grouped_extreme_distance;
  Tensor pq_ivf;
  Tensor pq_index;
};
inline ScanPQCodesOutput ScanPQCodes(const Tensor &ivf, const Tensor &bucket_list, const Tensor &bucket_base_distance, const Tensor &bucket_limits, const Tensor &bucket_offsets, const Tensor &adc_tables, int64_t total_limit, int64_t group_size=64, int64_t extreme_mode=0, int64_t split_count=1, int64_t split_index=0) {
  auto out = EsScanPQCodes(ivf.GetEsbTensor(), bucket_list.GetEsbTensor(), bucket_base_distance.GetEsbTensor(), bucket_limits.GetEsbTensor(), bucket_offsets.GetEsbTensor(), adc_tables.GetEsbTensor(), total_limit, group_size, extreme_mode, split_count, split_index);
  return {out.actual_count, out.pq_distance, out.grouped_extreme_distance, out.pq_ivf, out.pq_index};
}
struct ScanSQCodesOutput {
  Tensor actual_count;
  Tensor sq_distance;
  Tensor grouped_extreme_distance;
  Tensor sq_ivf;
  Tensor sq_index;
};
inline ScanSQCodesOutput ScanSQCodes(const Tensor &ivf, const Tensor &query, const Tensor &bucket_list, const Tensor &bucket_limits, const Tensor &bucket_offsets, const Tensor &vmin, const Tensor &vdiff, int64_t total_limit, int64_t group_size=64, int64_t extreme_mode=0) {
  auto out = EsScanSQCodes(ivf.GetEsbTensor(), query.GetEsbTensor(), bucket_list.GetEsbTensor(), bucket_limits.GetEsbTensor(), bucket_offsets.GetEsbTensor(), vmin.GetEsbTensor(), vdiff.GetEsbTensor(), total_limit, group_size, extreme_mode);
  return {out.actual_count, out.sq_distance, out.grouped_extreme_distance, out.sq_ivf, out.sq_index};
}
inline Tensor Scatter(const Tensor &var, const Tensor &indices, const Tensor &updates, const char *reduce, int64_t axis=0) {
  auto out = EsScatter(var.GetEsbTensor(), indices.GetEsbTensor(), updates.GetEsbTensor(), reduce, axis);
  return out;
}
inline Tensor ScatterAdd(const Tensor &var, const Tensor &indices, const Tensor &updates, bool use_locking=false) {
  auto out = EsScatterAdd(var.GetEsbTensor(), indices.GetEsbTensor(), updates.GetEsbTensor(), use_locking);
  return out;
}
inline Tensor ScatterAddWithAxis(const Tensor &var, const Tensor &indices, const Tensor &updates, int64_t axis) {
  auto out = EsScatterAddWithAxis(var.GetEsbTensor(), indices.GetEsbTensor(), updates.GetEsbTensor(), axis);
  return out;
}
inline Tensor ScatterDiv(const Tensor &var, const Tensor &indices, const Tensor &updates, bool use_locking=false) {
  auto out = EsScatterDiv(var.GetEsbTensor(), indices.GetEsbTensor(), updates.GetEsbTensor(), use_locking);
  return out;
}
inline Tensor ScatterElements(const Tensor &data, const Tensor &indices, const Tensor &updates, int64_t axis=0, const char *reduction="none") {
  auto out = EsScatterElements(data.GetEsbTensor(), indices.GetEsbTensor(), updates.GetEsbTensor(), axis, reduction);
  return out;
}
inline Tensor ScatterElementsV2(const Tensor &var, const Tensor &indices, const Tensor &updates, int64_t axis=0, const char *reduction="none") {
  auto out = EsScatterElementsV2(var.GetEsbTensor(), indices.GetEsbTensor(), updates.GetEsbTensor(), axis, reduction);
  return out;
}
inline Tensor ScatterMax(const Tensor &var, const Tensor &indices, const Tensor &updates, bool use_locking=false) {
  auto out = EsScatterMax(var.GetEsbTensor(), indices.GetEsbTensor(), updates.GetEsbTensor(), use_locking);
  return out;
}
struct ScatterMaxWithArgmaxOutput {
  Tensor y;
  Tensor argmax;
};
inline ScatterMaxWithArgmaxOutput ScatterMaxWithArgmax(const Tensor &x, const Tensor &indices, const Tensor &updates) {
  auto out = EsScatterMaxWithArgmax(x.GetEsbTensor(), indices.GetEsbTensor(), updates.GetEsbTensor());
  return {out.y, out.argmax};
}
inline Tensor ScatterMin(const Tensor &var, const Tensor &indices, const Tensor &updates, bool use_locking=false) {
  auto out = EsScatterMin(var.GetEsbTensor(), indices.GetEsbTensor(), updates.GetEsbTensor(), use_locking);
  return out;
}
inline Tensor ScatterMul(const Tensor &var, const Tensor &indices, const Tensor &updates, bool use_locking=false) {
  auto out = EsScatterMul(var.GetEsbTensor(), indices.GetEsbTensor(), updates.GetEsbTensor(), use_locking);
  return out;
}
inline Tensor ScatterNd(const Tensor &indices, const Tensor &x, const Tensor &shape) {
  auto out = EsScatterNd(indices.GetEsbTensor(), x.GetEsbTensor(), shape.GetEsbTensor());
  return out;
}
inline Tensor ScatterNdAdd(const Tensor &var, const Tensor &indices, const Tensor &updates, bool use_locking=false) {
  auto out = EsScatterNdAdd(var.GetEsbTensor(), indices.GetEsbTensor(), updates.GetEsbTensor(), use_locking);
  return out;
}
inline Tensor ScatterNdD(const Tensor &indices, const Tensor &x, const std::vector<int64_t> &shape) {
  auto out = EsScatterNdD(indices.GetEsbTensor(), x.GetEsbTensor(), shape.data(), static_cast<int64_t>(shape.size()));
  return out;
}
inline Tensor ScatterNdMax(const Tensor &var, const Tensor &indices, const Tensor &updates, bool use_locking=false) {
  auto out = EsScatterNdMax(var.GetEsbTensor(), indices.GetEsbTensor(), updates.GetEsbTensor(), use_locking);
  return out;
}
inline Tensor ScatterNdMin(const Tensor &var, const Tensor &indices, const Tensor &updates, bool use_locking=false) {
  auto out = EsScatterNdMin(var.GetEsbTensor(), indices.GetEsbTensor(), updates.GetEsbTensor(), use_locking);
  return out;
}
inline Tensor ScatterNdSub(const Tensor &var, const Tensor &indices, const Tensor &updates, bool use_locking=false) {
  auto out = EsScatterNdSub(var.GetEsbTensor(), indices.GetEsbTensor(), updates.GetEsbTensor(), use_locking);
  return out;
}
inline Tensor ScatterNdUpdate(const Tensor &var, const Tensor &indices, const Tensor &updates, bool use_locking=false) {
  auto out = EsScatterNdUpdate(var.GetEsbTensor(), indices.GetEsbTensor(), updates.GetEsbTensor(), use_locking);
  return out;
}
inline Tensor ScatterNonAliasingAdd(const Tensor &x, const Tensor &indices, const Tensor &updates) {
  auto out = EsScatterNonAliasingAdd(x.GetEsbTensor(), indices.GetEsbTensor(), updates.GetEsbTensor());
  return out;
}
inline Tensor ScatterSub(const Tensor &var, const Tensor &indices, const Tensor &updates, bool use_locking=false) {
  auto out = EsScatterSub(var.GetEsbTensor(), indices.GetEsbTensor(), updates.GetEsbTensor(), use_locking);
  return out;
}
inline Tensor ScatterUpdate(const Tensor &var, const Tensor &indices, const Tensor &updates, bool use_locking=false) {
  auto out = EsScatterUpdate(var.GetEsbTensor(), indices.GetEsbTensor(), updates.GetEsbTensor(), use_locking);
  return out;
}
inline Tensor SearchN(const Tensor &x, const Tensor &scale_d, const Tensor &scale_w) {
  auto out = EsSearchN(x.GetEsbTensor(), scale_d.GetEsbTensor(), scale_w.GetEsbTensor());
  return out;
}
inline Tensor SearchSorted(const Tensor &sorted_sequence, const Tensor &values, const Tensor &sorter=nullptr, ge::DataType dtype=ge::DT_INT64, bool right=false) {
  auto out = EsSearchSorted(sorted_sequence.GetEsbTensor(), values.GetEsbTensor(), sorter.GetEsbTensor(), dtype, right);
  return out;
}
inline Tensor SegmentMax(const Tensor &x, const Tensor &segment_ids) {
  auto out = EsSegmentMax(x.GetEsbTensor(), segment_ids.GetEsbTensor());
  return out;
}
inline Tensor SegmentMaxD(const Tensor &x, const std::vector<int64_t> &segment_ids) {
  auto out = EsSegmentMaxD(x.GetEsbTensor(), segment_ids.data(), static_cast<int64_t>(segment_ids.size()));
  return out;
}
inline Tensor SegmentSort(const Tensor &input_data, const Tensor &input_index, int64_t k_num, bool largest=true) {
  auto out = EsSegmentSort(input_data.GetEsbTensor(), input_index.GetEsbTensor(), k_num, largest);
  return out;
}
inline Tensor SegmentSum(const Tensor &x, const Tensor &segment_ids) {
  auto out = EsSegmentSum(x.GetEsbTensor(), segment_ids.GetEsbTensor());
  return out;
}
inline Tensor Select(const Tensor &condition, const Tensor &x1, const Tensor &x2) {
  auto out = EsSelect(condition.GetEsbTensor(), x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
inline Tensor SelectV2(const Tensor &condition, const Tensor &then, const Tensor &in_else) {
  auto out = EsSelectV2(condition.GetEsbTensor(), then.GetEsbTensor(), in_else.GetEsbTensor());
  return out;
}
struct SelfAdjointEigOutput {
  Tensor eigen_value;
  Tensor eigen_vector;
};
inline SelfAdjointEigOutput SelfAdjointEig(const Tensor &x, bool compute_v=true) {
  auto out = EsSelfAdjointEig(x.GetEsbTensor(), compute_v);
  return {out.eigen_value, out.eigen_vector};
}
inline Tensor Selu(const Tensor &x) {
  auto out = EsSelu(x.GetEsbTensor());
  return out;
}
inline Tensor SeluGrad(const Tensor &gradients, const Tensor &outputs) {
  auto out = EsSeluGrad(gradients.GetEsbTensor(), outputs.GetEsbTensor());
  return out;
}
inline Tensor SequenceAt(const Tensor &handle, const Tensor &index) {
  auto out = EsSequenceAt(handle.GetEsbTensor(), index.GetEsbTensor());
  return out;
}
inline Tensor SequenceConstruct(const std::vector<Tensor> &inputs) {
  auto esb_inputs = TensorsToEsbTensors(inputs);
  auto out = EsSequenceConstruct(esb_inputs.data(), static_cast<int64_t>(esb_inputs.size()));
  return out;
}
inline Tensor SequenceEmpty(const Graph &owner_graph, ge::DataType dtype=ge::DT_FLOAT) {
  auto out = EsSequenceEmpty(owner_graph.GetEsbGraph(), dtype);
  return out;
}
inline Tensor SequenceErase(const Tensor &handle, const Tensor &index=nullptr) {
  auto out = EsSequenceErase(handle.GetEsbTensor(), index.GetEsbTensor());
  return out;
}
inline Tensor SequenceInsert(const Tensor &handle, const Tensor &value, const Tensor &index=nullptr) {
  auto out = EsSequenceInsert(handle.GetEsbTensor(), value.GetEsbTensor(), index.GetEsbTensor());
  return out;
}
inline Tensor SequenceLength(const Tensor &handle) {
  auto out = EsSequenceLength(handle.GetEsbTensor());
  return out;
}
inline Tensor SerializeManySparse(const Tensor &indices, const Tensor &values, const Tensor &shape, ge::DataType out_type=ge::DT_STRING) {
  auto out = EsSerializeManySparse(indices.GetEsbTensor(), values.GetEsbTensor(), shape.GetEsbTensor(), out_type);
  return out;
}
inline Tensor SerializeSparse(const Tensor &indices, const Tensor &values, const Tensor &shape, ge::DataType out_type=ge::DT_STRING) {
  auto out = EsSerializeSparse(indices.GetEsbTensor(), values.GetEsbTensor(), shape.GetEsbTensor(), out_type);
  return out;
}
inline Tensor SetSize(const Tensor &set_indices, const Tensor &set_values, const Tensor &set_shape, bool validate_indices=true) {
  auto out = EsSetSize(set_indices.GetEsbTensor(), set_values.GetEsbTensor(), set_shape.GetEsbTensor(), validate_indices);
  return out;
}
inline Tensor Shape(const Tensor &x, int64_t dtype=3) {
  auto out = EsShape(x.GetEsbTensor(), dtype);
  return out;
}
inline Tensor Shrink(const Tensor &input_x, float lambd=0.500000, float bias=0.000000) {
  auto out = EsShrink(input_x.GetEsbTensor(), lambd, bias);
  return out;
}
inline Tensor ShuffleChannel(const Tensor &x, int64_t group=1) {
  auto out = EsShuffleChannel(x.GetEsbTensor(), group);
  return out;
}
inline Tensor Sigmoid(const Tensor &x) {
  auto out = EsSigmoid(x.GetEsbTensor());
  return out;
}
inline Tensor SigmoidCrossEntropyWithLogits(const Tensor &predict, const Tensor &target) {
  auto out = EsSigmoidCrossEntropyWithLogits(predict.GetEsbTensor(), target.GetEsbTensor());
  return out;
}
inline Tensor SigmoidCrossEntropyWithLogitsGrad(const Tensor &predict, const Tensor &target, const Tensor &dout) {
  auto out = EsSigmoidCrossEntropyWithLogitsGrad(predict.GetEsbTensor(), target.GetEsbTensor(), dout.GetEsbTensor());
  return out;
}
inline Tensor SigmoidCrossEntropyWithLogitsGradV2(const Tensor &predict, const Tensor &target, const Tensor &dout, const Tensor &weight=nullptr, const Tensor &pos_weight=nullptr, const char *reduction="mean") {
  auto out = EsSigmoidCrossEntropyWithLogitsGradV2(predict.GetEsbTensor(), target.GetEsbTensor(), dout.GetEsbTensor(), weight.GetEsbTensor(), pos_weight.GetEsbTensor(), reduction);
  return out;
}
inline Tensor SigmoidCrossEntropyWithLogitsV2(const Tensor &predict, const Tensor &target, const Tensor &weight=nullptr, const Tensor &pos_weight=nullptr, const char *reduction="mean") {
  auto out = EsSigmoidCrossEntropyWithLogitsV2(predict.GetEsbTensor(), target.GetEsbTensor(), weight.GetEsbTensor(), pos_weight.GetEsbTensor(), reduction);
  return out;
}
inline Tensor SigmoidFocalLoss(const Tensor &pred, const Tensor &target, const Tensor &weight=nullptr, float gamma=2.000000, float alpha=0.250000, const char *reduction="mean") {
  auto out = EsSigmoidFocalLoss(pred.GetEsbTensor(), target.GetEsbTensor(), weight.GetEsbTensor(), gamma, alpha, reduction);
  return out;
}
inline Tensor SigmoidFocalLossGrad(const Tensor &pred, const Tensor &target, const Tensor &dout, const Tensor &weight=nullptr, float alpha=0.250000, float gamma=2.000000, const char *reduction="mean") {
  auto out = EsSigmoidFocalLossGrad(pred.GetEsbTensor(), target.GetEsbTensor(), dout.GetEsbTensor(), weight.GetEsbTensor(), alpha, gamma, reduction);
  return out;
}
inline Tensor SigmoidGrad(const Tensor &y, const Tensor &dy, bool complex_conj=false) {
  auto out = EsSigmoidGrad(y.GetEsbTensor(), dy.GetEsbTensor(), complex_conj);
  return out;
}
inline Tensor Sign(const Tensor &x) {
  auto out = EsSign(x.GetEsbTensor());
  return out;
}
inline Tensor SignBitsPack(const Tensor &x, int64_t size) {
  auto out = EsSignBitsPack(x.GetEsbTensor(), size);
  return out;
}
inline Tensor SignBitsUnpack(const Tensor &x, int64_t size, ge::DataType dtype) {
  auto out = EsSignBitsUnpack(x.GetEsbTensor(), size, dtype);
  return out;
}
struct SilentCheckOutput {
  Tensor input_grad;
  Tensor pre_val;
  Tensor min_val;
  Tensor max_val;
  Tensor result;
};
inline SilentCheckOutput SilentCheck(const Tensor &val, const Tensor &input_grad, const Tensor &pre_val, const Tensor &min_val, const Tensor &max_val, const Tensor &val_counter, int64_t c_min_steps=7, float c_thresh_l1=1000000.000000, float c_coeff_l1=100000.000000, float c_thresh_l2=10000.000000, float c_coeff_l2=5000.000000) {
  auto out = EsSilentCheck(val.GetEsbTensor(), input_grad.GetEsbTensor(), pre_val.GetEsbTensor(), min_val.GetEsbTensor(), max_val.GetEsbTensor(), val_counter.GetEsbTensor(), c_min_steps, c_thresh_l1, c_coeff_l1, c_thresh_l2, c_coeff_l2);
  return {out.input_grad, out.pre_val, out.min_val, out.max_val, out.result};
}
struct SilentCheckV2Output {
  Tensor input_grad;
  Tensor sfda;
  Tensor step;
  Tensor result;
};
inline SilentCheckV2Output SilentCheckV2(const Tensor &val, const Tensor &input_grad, const Tensor &sfda, const Tensor &step, int64_t c_min_steps=7, float c_thresh_l1=1000000.000000, float c_coeff_l1=100000.000000, float c_thresh_l2=10000.000000, float c_coeff_l2=5000.000000, int64_t npu_asd_detect=1) {
  auto out = EsSilentCheckV2(val.GetEsbTensor(), input_grad.GetEsbTensor(), sfda.GetEsbTensor(), step.GetEsbTensor(), c_min_steps, c_thresh_l1, c_coeff_l1, c_thresh_l2, c_coeff_l2, npu_asd_detect);
  return {out.input_grad, out.sfda, out.step, out.result};
}
struct SilentCheckV3Output {
  Tensor avg;
  Tensor input_grad;
  Tensor step;
  Tensor result;
};
inline SilentCheckV3Output SilentCheckV3(const Tensor &val, const Tensor &max, const Tensor &avg, const Tensor &input_grad, const Tensor &step, const Tensor &dst_size, const Tensor &dst_stride, const Tensor &dst_offset, float c_thresh_l1=1000000.000000, float c_thresh_l2=10000.000000, float beta1=0.990000, int64_t npu_asd_detect=1) {
  auto out = EsSilentCheckV3(val.GetEsbTensor(), max.GetEsbTensor(), avg.GetEsbTensor(), input_grad.GetEsbTensor(), step.GetEsbTensor(), dst_size.GetEsbTensor(), dst_stride.GetEsbTensor(), dst_offset.GetEsbTensor(), c_thresh_l1, c_thresh_l2, beta1, npu_asd_detect);
  return {out.avg, out.input_grad, out.step, out.result};
}
inline Tensor SiluGrad(const Tensor &dy, const Tensor &x) {
  auto out = EsSiluGrad(dy.GetEsbTensor(), x.GetEsbTensor());
  return out;
}
inline Tensor Sin(const Tensor &x) {
  auto out = EsSin(x.GetEsbTensor());
  return out;
}
struct SingleMergeOutput {
  Tensor output_data;
  Tensor output_index;
};
inline SingleMergeOutput SingleMerge(const Tensor &input_proposal, int64_t k_num, bool largest=true) {
  auto out = EsSingleMerge(input_proposal.GetEsbTensor(), k_num, largest);
  return {out.output_data, out.output_index};
}
inline Tensor Sinh(const Tensor &x) {
  auto out = EsSinh(x.GetEsbTensor());
  return out;
}
inline Tensor Size(const Tensor &x, int64_t dtype=3) {
  auto out = EsSize(x.GetEsbTensor(), dtype);
  return out;
}
inline Tensor Slice(const Tensor &x, const Tensor &offsets, const Tensor &size) {
  auto out = EsSlice(x.GetEsbTensor(), offsets.GetEsbTensor(), size.GetEsbTensor());
  return out;
}
inline Tensor SliceD(const Tensor &x, const std::vector<int64_t> &offsets, const std::vector<int64_t> &size) {
  auto out = EsSliceD(x.GetEsbTensor(), offsets.data(), static_cast<int64_t>(offsets.size()), size.data(), static_cast<int64_t>(size.size()));
  return out;
}
inline Tensor SliceDV2(const Tensor &x, const Tensor &offsets, const std::vector<int64_t> &size) {
  auto out = EsSliceDV2(x.GetEsbTensor(), offsets.GetEsbTensor(), size.data(), static_cast<int64_t>(size.size()));
  return out;
}
inline Tensor SliceLastDim(const Tensor &x, int64_t start, int64_t end, int64_t stride=1) {
  auto out = EsSliceLastDim(x.GetEsbTensor(), start, end, stride);
  return out;
}
inline Tensor SliceWithAxes(const Tensor &x, const Tensor &offsets, const Tensor &size, const std::vector<int64_t> &axes) {
  auto out = EsSliceWithAxes(x.GetEsbTensor(), offsets.GetEsbTensor(), size.GetEsbTensor(), axes.data(), static_cast<int64_t>(axes.size()));
  return out;
}
inline Tensor SliceWrite(const Tensor &x, const Tensor &begin, const Tensor &value) {
  auto out = EsSliceWrite(x.GetEsbTensor(), begin.GetEsbTensor(), value.GetEsbTensor());
  return out;
}
struct SlogdetOutput {
  Tensor sign;
  Tensor y;
};
inline SlogdetOutput Slogdet(const Tensor &x) {
  auto out = EsSlogdet(x.GetEsbTensor());
  return {out.sign, out.y};
}
inline Tensor SmoothL1Loss(const Tensor &predict, const Tensor &label, float sigma=1.000000) {
  auto out = EsSmoothL1Loss(predict.GetEsbTensor(), label.GetEsbTensor(), sigma);
  return out;
}
inline Tensor SmoothL1LossGrad(const Tensor &predict, const Tensor &label, const Tensor &dout, float sigma=1.000000) {
  auto out = EsSmoothL1LossGrad(predict.GetEsbTensor(), label.GetEsbTensor(), dout.GetEsbTensor(), sigma);
  return out;
}
inline Tensor SmoothL1LossGradV2(const Tensor &predict, const Tensor &label, const Tensor &dout, float sigma=1.000000, const char *reduction="mean") {
  auto out = EsSmoothL1LossGradV2(predict.GetEsbTensor(), label.GetEsbTensor(), dout.GetEsbTensor(), sigma, reduction);
  return out;
}
inline Tensor SmoothL1LossV2(const Tensor &predict, const Tensor &label, float sigma=1.000000, const char *reduction="mean") {
  auto out = EsSmoothL1LossV2(predict.GetEsbTensor(), label.GetEsbTensor(), sigma, reduction);
  return out;
}
inline Tensor Snapshot(const Tensor &x) {
  auto out = EsSnapshot(x.GetEsbTensor());
  return out;
}
inline Tensor SobolSample(const Tensor &dim, const Tensor &num_results, const Tensor &skip, ge::DataType dtype=ge::DT_FLOAT) {
  auto out = EsSobolSample(dim.GetEsbTensor(), num_results.GetEsbTensor(), skip.GetEsbTensor(), dtype);
  return out;
}
inline Tensor SoftMarginLoss(const Tensor &input_x, const Tensor &input_y, const char *reduction="mean") {
  auto out = EsSoftMarginLoss(input_x.GetEsbTensor(), input_y.GetEsbTensor(), reduction);
  return out;
}
inline Tensor SoftMarginLossGrad(const Tensor &predict, const Tensor &label, const Tensor &dout, const char *reduction="mean") {
  auto out = EsSoftMarginLossGrad(predict.GetEsbTensor(), label.GetEsbTensor(), dout.GetEsbTensor(), reduction);
  return out;
}
inline Tensor SoftShrink(const Tensor &input_x, float lambd=0.500000) {
  auto out = EsSoftShrink(input_x.GetEsbTensor(), lambd);
  return out;
}
inline Tensor SoftShrinkGrad(const Tensor &input_grad, const Tensor &input_x, float lambd=0.500000) {
  auto out = EsSoftShrinkGrad(input_grad.GetEsbTensor(), input_x.GetEsbTensor(), lambd);
  return out;
}
struct SoftmaxCrossEntropyLossOutput {
  Tensor loss;
  Tensor log_prop;
};
inline SoftmaxCrossEntropyLossOutput SoftmaxCrossEntropyLoss(const Tensor &scores, const Tensor &labels, const Tensor &weights=nullptr, int64_t ignore_index=0, const char *reduction="mean") {
  auto out = EsSoftmaxCrossEntropyLoss(scores.GetEsbTensor(), labels.GetEsbTensor(), weights.GetEsbTensor(), ignore_index, reduction);
  return {out.loss, out.log_prop};
}
struct SoftmaxCrossEntropyWithLogitsOutput {
  Tensor loss;
  Tensor backprop;
};
inline SoftmaxCrossEntropyWithLogitsOutput SoftmaxCrossEntropyWithLogits(const Tensor &features, const Tensor &labels) {
  auto out = EsSoftmaxCrossEntropyWithLogits(features.GetEsbTensor(), labels.GetEsbTensor());
  return {out.loss, out.backprop};
}
inline Tensor SoftmaxFocalLoss(const Tensor &pred, const Tensor &target, const Tensor &weight=nullptr, float gamma=2.000000, float alpha=0.250000, const char *reduction="mean") {
  auto out = EsSoftmaxFocalLoss(pred.GetEsbTensor(), target.GetEsbTensor(), weight.GetEsbTensor(), gamma, alpha, reduction);
  return out;
}
inline Tensor SoftmaxFocalLossGrad(const Tensor &pred, const Tensor &target, const Tensor &dout, const Tensor &weight=nullptr, float alpha=0.250000, float gamma=2.000000, const char *reduction="mean") {
  auto out = EsSoftmaxFocalLossGrad(pred.GetEsbTensor(), target.GetEsbTensor(), dout.GetEsbTensor(), weight.GetEsbTensor(), alpha, gamma, reduction);
  return out;
}
inline Tensor SoftmaxGrad(const Tensor &softmax, const Tensor &grad_softmax, const std::vector<int64_t> &axes={-1}) {
  auto out = EsSoftmaxGrad(softmax.GetEsbTensor(), grad_softmax.GetEsbTensor(), axes.data(), static_cast<int64_t>(axes.size()));
  return out;
}
inline Tensor SoftmaxGradExt(const Tensor &grad, const Tensor &x1, const Tensor &x2, int64_t axes=1, bool keep_dims=false) {
  auto out = EsSoftmaxGradExt(grad.GetEsbTensor(), x1.GetEsbTensor(), x2.GetEsbTensor(), axes, keep_dims);
  return out;
}
inline Tensor SoftmaxV2(const Tensor &x, const std::vector<int64_t> &axes={-1}, bool half_to_float=false) {
  auto out = EsSoftmaxV2(x.GetEsbTensor(), axes.data(), static_cast<int64_t>(axes.size()), half_to_float);
  return out;
}
struct SoftmaxV2WithDropOutDoMaskV3DOutput {
  Tensor y1;
  Tensor y2;
};
inline SoftmaxV2WithDropOutDoMaskV3DOutput SoftmaxV2WithDropOutDoMaskV3D(const Tensor &x, const Tensor &mask, float keep_prob, const std::vector<int64_t> &axes={-1}) {
  auto out = EsSoftmaxV2WithDropOutDoMaskV3D(x.GetEsbTensor(), mask.GetEsbTensor(), keep_prob, axes.data(), static_cast<int64_t>(axes.size()));
  return {out.y1, out.y2};
}
inline Tensor Softplus(const Tensor &x) {
  auto out = EsSoftplus(x.GetEsbTensor());
  return out;
}
inline Tensor SoftplusGrad(const Tensor &gradients, const Tensor &features) {
  auto out = EsSoftplusGrad(gradients.GetEsbTensor(), features.GetEsbTensor());
  return out;
}
inline Tensor SoftplusV2(const Tensor &x, float beta=1.000000, float threshold=20.000000) {
  auto out = EsSoftplusV2(x.GetEsbTensor(), beta, threshold);
  return out;
}
inline Tensor SoftplusV2Grad(const Tensor &input_gradients, const Tensor &input_features, float beta=1.000000, float threshold=20.000000) {
  auto out = EsSoftplusV2Grad(input_gradients.GetEsbTensor(), input_features.GetEsbTensor(), beta, threshold);
  return out;
}
inline Tensor Softsign(const Tensor &x) {
  auto out = EsSoftsign(x.GetEsbTensor());
  return out;
}
inline Tensor SoftsignGrad(const Tensor &gradients, const Tensor &features) {
  auto out = EsSoftsignGrad(gradients.GetEsbTensor(), features.GetEsbTensor());
  return out;
}
struct SortOutput {
  Tensor y1;
  Tensor y2;
};
inline SortOutput Sort(const Tensor &x, int64_t axis=-1, bool descending=false, bool stable=false) {
  auto out = EsSort(x.GetEsbTensor(), axis, descending, stable);
  return {out.y1, out.y2};
}
inline Tensor SortV2(const Tensor &x, int64_t axis=-1, bool descending=false) {
  auto out = EsSortV2(x.GetEsbTensor(), axis, descending);
  return out;
}
inline Tensor SortedNMS(const Tensor &boxes, const Tensor &sorted_scores, const Tensor &input_indices, const Tensor &max_output_size, const Tensor &iou_threshold, const Tensor &score_threshold, int64_t offset=0) {
  auto out = EsSortedNMS(boxes.GetEsbTensor(), sorted_scores.GetEsbTensor(), input_indices.GetEsbTensor(), max_output_size.GetEsbTensor(), iou_threshold.GetEsbTensor(), score_threshold.GetEsbTensor(), offset);
  return out;
}
inline Tensor SpaceToBatch(const Tensor &x, const Tensor &paddings, int64_t block_size) {
  auto out = EsSpaceToBatch(x.GetEsbTensor(), paddings.GetEsbTensor(), block_size);
  return out;
}
inline Tensor SpaceToBatchD(const Tensor &x, int64_t block_size, const std::vector<int64_t> &paddings) {
  auto out = EsSpaceToBatchD(x.GetEsbTensor(), block_size, paddings.data(), static_cast<int64_t>(paddings.size()));
  return out;
}
inline Tensor SpaceToBatchND(const Tensor &x, const Tensor &block_shape, const Tensor &paddings) {
  auto out = EsSpaceToBatchND(x.GetEsbTensor(), block_shape.GetEsbTensor(), paddings.GetEsbTensor());
  return out;
}
inline Tensor SpaceToBatchNDD(const Tensor &x, const std::vector<int64_t> &block_shape, const std::vector<int64_t> &paddings) {
  auto out = EsSpaceToBatchNDD(x.GetEsbTensor(), block_shape.data(), static_cast<int64_t>(block_shape.size()), paddings.data(), static_cast<int64_t>(paddings.size()));
  return out;
}
inline Tensor SpaceToDepth(const Tensor &x, int64_t block_size, const char *data_format="NHWC") {
  auto out = EsSpaceToDepth(x.GetEsbTensor(), block_size, data_format);
  return out;
}
inline Tensor SparseAccumulatorApplyGradient(const Tensor &handle, const Tensor &local_step, const Tensor &indices, const Tensor &values, const Tensor &shape, bool has_known_shape, ge::DataType dtype) {
  auto out = EsSparseAccumulatorApplyGradient(handle.GetEsbTensor(), local_step.GetEsbTensor(), indices.GetEsbTensor(), values.GetEsbTensor(), shape.GetEsbTensor(), has_known_shape, dtype);
  return out;
}
struct SparseAccumulatorTakeGradientOutput {
  Tensor indices;
  Tensor values;
  Tensor shape;
};
inline SparseAccumulatorTakeGradientOutput SparseAccumulatorTakeGradient(const Tensor &handle, const Tensor &num_required, ge::DataType dtype) {
  auto out = EsSparseAccumulatorTakeGradient(handle.GetEsbTensor(), num_required.GetEsbTensor(), dtype);
  return {out.indices, out.values, out.shape};
}
struct SparseAddOutput {
  Tensor sum_indices;
  Tensor sum_values;
  Tensor sum_shape;
};
inline SparseAddOutput SparseAdd(const Tensor &x1_indices, const Tensor &x1_values, const Tensor &x1_shape, const Tensor &x2_indices, const Tensor &x2_values, const Tensor &x2_shape, const Tensor &thresh) {
  auto out = EsSparseAdd(x1_indices.GetEsbTensor(), x1_values.GetEsbTensor(), x1_shape.GetEsbTensor(), x2_indices.GetEsbTensor(), x2_values.GetEsbTensor(), x2_shape.GetEsbTensor(), thresh.GetEsbTensor());
  return {out.sum_indices, out.sum_values, out.sum_shape};
}
struct SparseAddGradOutput {
  Tensor x1_val_grad;
  Tensor x2_val_grad;
};
inline SparseAddGradOutput SparseAddGrad(const Tensor &backprop_val_grad, const Tensor &x1_indices, const Tensor &x2_indices, const Tensor &sum_indices) {
  auto out = EsSparseAddGrad(backprop_val_grad.GetEsbTensor(), x1_indices.GetEsbTensor(), x2_indices.GetEsbTensor(), sum_indices.GetEsbTensor());
  return {out.x1_val_grad, out.x2_val_grad};
}
struct SparseApplyAdadeltaOutput {
  Tensor var;
  Tensor accum;
  Tensor accum_update;
};
inline SparseApplyAdadeltaOutput SparseApplyAdadelta(const Tensor &var, const Tensor &accum, const Tensor &accum_update, const Tensor &lr, const Tensor &rho, const Tensor &epsilon, const Tensor &grad, const Tensor &indices, bool use_locking=false) {
  auto out = EsSparseApplyAdadelta(var.GetEsbTensor(), accum.GetEsbTensor(), accum_update.GetEsbTensor(), lr.GetEsbTensor(), rho.GetEsbTensor(), epsilon.GetEsbTensor(), grad.GetEsbTensor(), indices.GetEsbTensor(), use_locking);
  return {out.var, out.accum, out.accum_update};
}
struct SparseApplyAdadeltaDOutput {
  Tensor var;
  Tensor accum;
  Tensor accum_update;
};
inline SparseApplyAdadeltaDOutput SparseApplyAdadeltaD(const Tensor &var, const Tensor &accum, const Tensor &accum_update, const Tensor &lr, const Tensor &rho, const Tensor &grad, const Tensor &indices, float epsilon, bool use_locking=false) {
  auto out = EsSparseApplyAdadeltaD(var.GetEsbTensor(), accum.GetEsbTensor(), accum_update.GetEsbTensor(), lr.GetEsbTensor(), rho.GetEsbTensor(), grad.GetEsbTensor(), indices.GetEsbTensor(), epsilon, use_locking);
  return {out.var, out.accum, out.accum_update};
}
struct SparseApplyAdagradOutput {
  Tensor var;
  Tensor accum;
};
inline SparseApplyAdagradOutput SparseApplyAdagrad(const Tensor &var, const Tensor &accum, const Tensor &lr, const Tensor &grad, const Tensor &indices, bool use_locking=false, bool update_slots=true) {
  auto out = EsSparseApplyAdagrad(var.GetEsbTensor(), accum.GetEsbTensor(), lr.GetEsbTensor(), grad.GetEsbTensor(), indices.GetEsbTensor(), use_locking, update_slots);
  return {out.var, out.accum};
}
struct SparseApplyAdagradDOutput {
  Tensor var;
  Tensor accum;
};
inline SparseApplyAdagradDOutput SparseApplyAdagradD(const Tensor &var, const Tensor &accum, const Tensor &grad, const Tensor &indices, float lr, bool use_locking=false, bool update_slots=true) {
  auto out = EsSparseApplyAdagradD(var.GetEsbTensor(), accum.GetEsbTensor(), grad.GetEsbTensor(), indices.GetEsbTensor(), lr, use_locking, update_slots);
  return {out.var, out.accum};
}
struct SparseApplyAdagradV2Output {
  Tensor var;
  Tensor accum;
};
inline SparseApplyAdagradV2Output SparseApplyAdagradV2(const Tensor &var, const Tensor &accum, const Tensor &lr, const Tensor &epsilon, const Tensor &grad, const Tensor &indices, bool use_locking=false, bool update_slots=true) {
  auto out = EsSparseApplyAdagradV2(var.GetEsbTensor(), accum.GetEsbTensor(), lr.GetEsbTensor(), epsilon.GetEsbTensor(), grad.GetEsbTensor(), indices.GetEsbTensor(), use_locking, update_slots);
  return {out.var, out.accum};
}
struct SparseApplyAdagradV2DOutput {
  Tensor var;
  Tensor accum;
};
inline SparseApplyAdagradV2DOutput SparseApplyAdagradV2D(const Tensor &var, const Tensor &accum, const Tensor &grad, const Tensor &indices, float lr, float epsilon, bool use_locking=false, bool update_slots=true) {
  auto out = EsSparseApplyAdagradV2D(var.GetEsbTensor(), accum.GetEsbTensor(), grad.GetEsbTensor(), indices.GetEsbTensor(), lr, epsilon, use_locking, update_slots);
  return {out.var, out.accum};
}
struct SparseApplyFtrlOutput {
  Tensor var;
  Tensor accum;
  Tensor linear;
};
inline SparseApplyFtrlOutput SparseApplyFtrl(const Tensor &var, const Tensor &accum, const Tensor &linear, const Tensor &grad, const Tensor &indices, const Tensor &lr, const Tensor &l1, const Tensor &l2, const Tensor &lr_power, bool use_locking=false) {
  auto out = EsSparseApplyFtrl(var.GetEsbTensor(), accum.GetEsbTensor(), linear.GetEsbTensor(), grad.GetEsbTensor(), indices.GetEsbTensor(), lr.GetEsbTensor(), l1.GetEsbTensor(), l2.GetEsbTensor(), lr_power.GetEsbTensor(), use_locking);
  return {out.var, out.accum, out.linear};
}
struct SparseApplyFtrlDOutput {
  Tensor var;
  Tensor accum;
  Tensor linear;
};
inline SparseApplyFtrlDOutput SparseApplyFtrlD(const Tensor &var, const Tensor &accum, const Tensor &linear, const Tensor &grad, const Tensor &indices, float lr, float l1, float l2, float lr_power, bool use_locking=false) {
  auto out = EsSparseApplyFtrlD(var.GetEsbTensor(), accum.GetEsbTensor(), linear.GetEsbTensor(), grad.GetEsbTensor(), indices.GetEsbTensor(), lr, l1, l2, lr_power, use_locking);
  return {out.var, out.accum, out.linear};
}
struct SparseApplyFtrlV2Output {
  Tensor var;
  Tensor accum;
  Tensor linear;
};
inline SparseApplyFtrlV2Output SparseApplyFtrlV2(const Tensor &var, const Tensor &accum, const Tensor &linear, const Tensor &grad, const Tensor &indices, const Tensor &lr, const Tensor &l1, const Tensor &l2, const Tensor &l2_shrinkage, const Tensor &lr_power, bool use_locking=false) {
  auto out = EsSparseApplyFtrlV2(var.GetEsbTensor(), accum.GetEsbTensor(), linear.GetEsbTensor(), grad.GetEsbTensor(), indices.GetEsbTensor(), lr.GetEsbTensor(), l1.GetEsbTensor(), l2.GetEsbTensor(), l2_shrinkage.GetEsbTensor(), lr_power.GetEsbTensor(), use_locking);
  return {out.var, out.accum, out.linear};
}
struct SparseApplyFtrlV2DOutput {
  Tensor var;
  Tensor accum;
  Tensor linear;
};
inline SparseApplyFtrlV2DOutput SparseApplyFtrlV2D(const Tensor &var, const Tensor &accum, const Tensor &linear, const Tensor &grad, const Tensor &indices, float lr, float l1, float l2, float l2_shrinkage, float lr_power, bool use_locking=false) {
  auto out = EsSparseApplyFtrlV2D(var.GetEsbTensor(), accum.GetEsbTensor(), linear.GetEsbTensor(), grad.GetEsbTensor(), indices.GetEsbTensor(), lr, l1, l2, l2_shrinkage, lr_power, use_locking);
  return {out.var, out.accum, out.linear};
}
struct SparseApplyProximalAdagradOutput {
  Tensor var;
  Tensor accum;
};
inline SparseApplyProximalAdagradOutput SparseApplyProximalAdagrad(const Tensor &var, const Tensor &accum, const Tensor &lr, const Tensor &l1, const Tensor &l2, const Tensor &grad, const Tensor &indices, bool use_locking=false) {
  auto out = EsSparseApplyProximalAdagrad(var.GetEsbTensor(), accum.GetEsbTensor(), lr.GetEsbTensor(), l1.GetEsbTensor(), l2.GetEsbTensor(), grad.GetEsbTensor(), indices.GetEsbTensor(), use_locking);
  return {out.var, out.accum};
}
struct SparseApplyProximalAdagradDOutput {
  Tensor var;
  Tensor accum;
};
inline SparseApplyProximalAdagradDOutput SparseApplyProximalAdagradD(const Tensor &var, const Tensor &accum, const Tensor &lr, const Tensor &l1, const Tensor &l2, const Tensor &grad, const Tensor &indices, bool use_locking=false) {
  auto out = EsSparseApplyProximalAdagradD(var.GetEsbTensor(), accum.GetEsbTensor(), lr.GetEsbTensor(), l1.GetEsbTensor(), l2.GetEsbTensor(), grad.GetEsbTensor(), indices.GetEsbTensor(), use_locking);
  return {out.var, out.accum};
}
struct SparseApplyRMSPropOutput {
  Tensor var;
  Tensor ms;
  Tensor mom;
};
inline SparseApplyRMSPropOutput SparseApplyRMSProp(const Tensor &var, const Tensor &ms, const Tensor &mom, const Tensor &lr, const Tensor &rho, const Tensor &momentum, const Tensor &epsilon, const Tensor &grad, const Tensor &indices, bool use_locking=false) {
  auto out = EsSparseApplyRMSProp(var.GetEsbTensor(), ms.GetEsbTensor(), mom.GetEsbTensor(), lr.GetEsbTensor(), rho.GetEsbTensor(), momentum.GetEsbTensor(), epsilon.GetEsbTensor(), grad.GetEsbTensor(), indices.GetEsbTensor(), use_locking);
  return {out.var, out.ms, out.mom};
}
struct SparseApplyRMSPropDOutput {
  Tensor var;
  Tensor ms;
  Tensor mom;
};
inline SparseApplyRMSPropDOutput SparseApplyRMSPropD(const Tensor &var, const Tensor &ms, const Tensor &mom, const Tensor &lr, const Tensor &grad, const Tensor &indices, float rho, float momentum, float epsilon, bool use_locking=false) {
  auto out = EsSparseApplyRMSPropD(var.GetEsbTensor(), ms.GetEsbTensor(), mom.GetEsbTensor(), lr.GetEsbTensor(), grad.GetEsbTensor(), indices.GetEsbTensor(), rho, momentum, epsilon, use_locking);
  return {out.var, out.ms, out.mom};
}
inline Tensor SparseBincount(const Tensor &indices, const Tensor &values, const Tensor &dense_shape, const Tensor &size, const Tensor &weights, bool binary_output=false) {
  auto out = EsSparseBincount(indices.GetEsbTensor(), values.GetEsbTensor(), dense_shape.GetEsbTensor(), size.GetEsbTensor(), weights.GetEsbTensor(), binary_output);
  return out;
}
struct SparseConcatOutput {
  Tensor y_indices;
  Tensor y_values;
  Tensor y_shape;
};
inline SparseConcatOutput SparseConcat(const std::vector<Tensor> &indices, const std::vector<Tensor> &values, const std::vector<Tensor> &shapes, int64_t concat_dim=0, int64_t N=1) {
  auto esb_indices = TensorsToEsbTensors(indices);
  auto esb_values = TensorsToEsbTensors(values);
  auto esb_shapes = TensorsToEsbTensors(shapes);
  auto out = EsSparseConcat(esb_indices.data(), static_cast<int64_t>(esb_indices.size()), esb_values.data(), static_cast<int64_t>(esb_values.size()), esb_shapes.data(), static_cast<int64_t>(esb_shapes.size()), concat_dim, N);
  return {out.y_indices, out.y_values, out.y_shape};
}
inline Tensor SparseConditionalAccumulator(const Graph &owner_graph, const std::vector<int64_t> &shape, ge::DataType dtype, const char *container="", const char *shared_name="", const char *reduction_type="MEAN") {
  auto out = EsSparseConditionalAccumulator(owner_graph.GetEsbGraph(), shape.data(), static_cast<int64_t>(shape.size()), dtype, container, shared_name, reduction_type);
  return out;
}
struct SparseCountSparseOutputOutput {
  Tensor output_indices;
  Tensor output_values;
  Tensor output_dense_shape;
};
inline SparseCountSparseOutputOutput SparseCountSparseOutput(const Tensor &indices, const Tensor &values, const Tensor &dense_shape, const Tensor &weights, bool binary_output, int64_t minlength=-1, int64_t maxlength=-1) {
  auto out = EsSparseCountSparseOutput(indices.GetEsbTensor(), values.GetEsbTensor(), dense_shape.GetEsbTensor(), weights.GetEsbTensor(), binary_output, minlength, maxlength);
  return {out.output_indices, out.output_values, out.output_dense_shape};
}
struct SparseCrossOutput {
  Tensor output_indices;
  Tensor output_values;
  Tensor output_shape;
};
inline SparseCrossOutput SparseCross(const std::vector<Tensor> &indices, const std::vector<Tensor> &values, const std::vector<Tensor> &shapes, const std::vector<Tensor> &dense_inputs, bool hashed_output, int64_t hash_key, ge::DataType out_type, ge::DataType internal_type, int64_t N=0, int64_t num_buckets=0) {
  auto esb_indices = TensorsToEsbTensors(indices);
  auto esb_values = TensorsToEsbTensors(values);
  auto esb_shapes = TensorsToEsbTensors(shapes);
  auto esb_dense_inputs = TensorsToEsbTensors(dense_inputs);
  auto out = EsSparseCross(esb_indices.data(), static_cast<int64_t>(esb_indices.size()), esb_values.data(), static_cast<int64_t>(esb_values.size()), esb_shapes.data(), static_cast<int64_t>(esb_shapes.size()), esb_dense_inputs.data(), static_cast<int64_t>(esb_dense_inputs.size()), hashed_output, hash_key, out_type, internal_type, N, num_buckets);
  return {out.output_indices, out.output_values, out.output_shape};
}
inline Tensor SparseDenseCwiseAdd(const Tensor &x1_indices, const Tensor &x1_values, const Tensor &x1_shape, const Tensor &x2) {
  auto out = EsSparseDenseCwiseAdd(x1_indices.GetEsbTensor(), x1_values.GetEsbTensor(), x1_shape.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
inline Tensor SparseDenseCwiseDiv(const Tensor &x1_indices, const Tensor &x1_values, const Tensor &x1_shape, const Tensor &x2) {
  auto out = EsSparseDenseCwiseDiv(x1_indices.GetEsbTensor(), x1_values.GetEsbTensor(), x1_shape.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
inline Tensor SparseDenseCwiseMul(const Tensor &x1_indices, const Tensor &x1_values, const Tensor &x1_shape, const Tensor &x2) {
  auto out = EsSparseDenseCwiseMul(x1_indices.GetEsbTensor(), x1_values.GetEsbTensor(), x1_shape.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
struct SparseFillEmptyRowsOutput {
  Tensor y_indices;
  Tensor y_values;
  Tensor empty_row_indicator;
  Tensor reverse_index_map;
};
inline SparseFillEmptyRowsOutput SparseFillEmptyRows(const Tensor &indices, const Tensor &values, const Tensor &dense_shape, const Tensor &default_value) {
  auto out = EsSparseFillEmptyRows(indices.GetEsbTensor(), values.GetEsbTensor(), dense_shape.GetEsbTensor(), default_value.GetEsbTensor());
  return {out.y_indices, out.y_values, out.empty_row_indicator, out.reverse_index_map};
}
struct SparseFillEmptyRowsGradOutput {
  Tensor y_value;
  Tensor y_default_value;
};
inline SparseFillEmptyRowsGradOutput SparseFillEmptyRowsGrad(const Tensor &reverse_index_map, const Tensor &grad_values) {
  auto out = EsSparseFillEmptyRowsGrad(reverse_index_map.GetEsbTensor(), grad_values.GetEsbTensor());
  return {out.y_value, out.y_default_value};
}
inline Tensor SparseReduceMax(const Tensor &x_indices, const Tensor &x_values, const Tensor &x_shape, const Tensor &reduction_axes, bool keep_dims=false) {
  auto out = EsSparseReduceMax(x_indices.GetEsbTensor(), x_values.GetEsbTensor(), x_shape.GetEsbTensor(), reduction_axes.GetEsbTensor(), keep_dims);
  return out;
}
struct SparseReduceMaxSparseOutput {
  Tensor y_indices;
  Tensor y_values;
  Tensor y_shape;
};
inline SparseReduceMaxSparseOutput SparseReduceMaxSparse(const Tensor &x_indices, const Tensor &x_values, const Tensor &x_shape, const Tensor &reduction_axes, bool keep_dims=false) {
  auto out = EsSparseReduceMaxSparse(x_indices.GetEsbTensor(), x_values.GetEsbTensor(), x_shape.GetEsbTensor(), reduction_axes.GetEsbTensor(), keep_dims);
  return {out.y_indices, out.y_values, out.y_shape};
}
inline Tensor SparseReduceSum(const Tensor &x_indices, const Tensor &x_values, const Tensor &x_shape, const Tensor &reduction_axes, bool keep_dims=false) {
  auto out = EsSparseReduceSum(x_indices.GetEsbTensor(), x_values.GetEsbTensor(), x_shape.GetEsbTensor(), reduction_axes.GetEsbTensor(), keep_dims);
  return out;
}
struct SparseReduceSumSparseOutput {
  Tensor y_indices;
  Tensor y_values;
  Tensor y_shape;
};
inline SparseReduceSumSparseOutput SparseReduceSumSparse(const Tensor &x_indices, const Tensor &x_values, const Tensor &x_shape, const Tensor &reduction_axes, bool keep_dims=false) {
  auto out = EsSparseReduceSumSparse(x_indices.GetEsbTensor(), x_values.GetEsbTensor(), x_shape.GetEsbTensor(), reduction_axes.GetEsbTensor(), keep_dims);
  return {out.y_indices, out.y_values, out.y_shape};
}
struct SparseReorderOutput {
  Tensor y_indices;
  Tensor y_values;
};
inline SparseReorderOutput SparseReorder(const Tensor &indices, const Tensor &values, const Tensor &shape) {
  auto out = EsSparseReorder(indices.GetEsbTensor(), values.GetEsbTensor(), shape.GetEsbTensor());
  return {out.y_indices, out.y_values};
}
struct SparseReshapeOutput {
  Tensor y_indices;
  Tensor y_shape;
};
inline SparseReshapeOutput SparseReshape(const Tensor &indices, const Tensor &shape, const Tensor &new_shape) {
  auto out = EsSparseReshape(indices.GetEsbTensor(), shape.GetEsbTensor(), new_shape.GetEsbTensor());
  return {out.y_indices, out.y_shape};
}
inline Tensor SparseSegmentMean(const Tensor &x, const Tensor &indices, const Tensor &segment_ids) {
  auto out = EsSparseSegmentMean(x.GetEsbTensor(), indices.GetEsbTensor(), segment_ids.GetEsbTensor());
  return out;
}
inline Tensor SparseSegmentMeanGrad(const Tensor &x, const Tensor &indices, const Tensor &segment_ids, const Tensor &output_dim0) {
  auto out = EsSparseSegmentMeanGrad(x.GetEsbTensor(), indices.GetEsbTensor(), segment_ids.GetEsbTensor(), output_dim0.GetEsbTensor());
  return out;
}
inline Tensor SparseSegmentSum(const Tensor &x, const Tensor &indices, const Tensor &segment_ids) {
  auto out = EsSparseSegmentSum(x.GetEsbTensor(), indices.GetEsbTensor(), segment_ids.GetEsbTensor());
  return out;
}
inline Tensor SparseSegmentSumGrad(const Tensor &grad, const Tensor &indices, const Tensor &segment_ids, const Tensor &output_dim0) {
  auto out = EsSparseSegmentSumGrad(grad.GetEsbTensor(), indices.GetEsbTensor(), segment_ids.GetEsbTensor(), output_dim0.GetEsbTensor());
  return out;
}
struct SparseSliceOutput {
  Tensor y_indices;
  Tensor y_values;
  Tensor y_shape;
};
inline SparseSliceOutput SparseSlice(const Tensor &indices, const Tensor &values, const Tensor &shape, const Tensor &start, const Tensor &size) {
  auto out = EsSparseSlice(indices.GetEsbTensor(), values.GetEsbTensor(), shape.GetEsbTensor(), start.GetEsbTensor(), size.GetEsbTensor());
  return {out.y_indices, out.y_values, out.y_shape};
}
inline Tensor SparseSliceGrad(const Tensor &backprop_val_grad, const Tensor &indices, const Tensor &start, const Tensor &new_indices) {
  auto out = EsSparseSliceGrad(backprop_val_grad.GetEsbTensor(), indices.GetEsbTensor(), start.GetEsbTensor(), new_indices.GetEsbTensor());
  return out;
}
inline Tensor SparseSoftmax(const Tensor &indices, const Tensor &values, const Tensor &shape) {
  auto out = EsSparseSoftmax(indices.GetEsbTensor(), values.GetEsbTensor(), shape.GetEsbTensor());
  return out;
}
struct SparseSoftmaxCrossEntropyWithLogitsOutput {
  Tensor loss;
  Tensor backprop;
};
inline SparseSoftmaxCrossEntropyWithLogitsOutput SparseSoftmaxCrossEntropyWithLogits(const Tensor &features, const Tensor &labels) {
  auto out = EsSparseSoftmaxCrossEntropyWithLogits(features.GetEsbTensor(), labels.GetEsbTensor());
  return {out.loss, out.backprop};
}
struct SparseSparseMaximumOutput {
  Tensor y_indices;
  Tensor y_values;
};
inline SparseSparseMaximumOutput SparseSparseMaximum(const Tensor &x1_indices, const Tensor &x1_values, const Tensor &x1_shape, const Tensor &x2_indices, const Tensor &x2_values, const Tensor &x2_shape) {
  auto out = EsSparseSparseMaximum(x1_indices.GetEsbTensor(), x1_values.GetEsbTensor(), x1_shape.GetEsbTensor(), x2_indices.GetEsbTensor(), x2_values.GetEsbTensor(), x2_shape.GetEsbTensor());
  return {out.y_indices, out.y_values};
}
struct SparseSparseMinimumOutput {
  Tensor y_indices;
  Tensor y_values;
};
inline SparseSparseMinimumOutput SparseSparseMinimum(const Tensor &x1_indices, const Tensor &x1_values, const Tensor &x1_shape, const Tensor &x2_indices, const Tensor &x2_values, const Tensor &x2_shape) {
  auto out = EsSparseSparseMinimum(x1_indices.GetEsbTensor(), x1_values.GetEsbTensor(), x1_shape.GetEsbTensor(), x2_indices.GetEsbTensor(), x2_values.GetEsbTensor(), x2_shape.GetEsbTensor());
  return {out.y_indices, out.y_values};
}
inline Tensor SparseTensorDenseAdd(const Tensor &x1_indices, const Tensor &x1_values, const Tensor &x1_shape, const Tensor &x2) {
  auto out = EsSparseTensorDenseAdd(x1_indices.GetEsbTensor(), x1_values.GetEsbTensor(), x1_shape.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
inline Tensor SparseTensorDenseMatMul(const Tensor &x1_indices, const Tensor &x1_values, const Tensor &x1_shape, const Tensor &x2, bool adjoint_a=false, bool adjoint_b=false) {
  auto out = EsSparseTensorDenseMatMul(x1_indices.GetEsbTensor(), x1_values.GetEsbTensor(), x1_shape.GetEsbTensor(), x2.GetEsbTensor(), adjoint_a, adjoint_b);
  return out;
}
inline Tensor SparseToDense(const Tensor &indices, const Tensor &output_shape, const Tensor &values, const Tensor &default_value, bool validate_indices=true) {
  auto out = EsSparseToDense(indices.GetEsbTensor(), output_shape.GetEsbTensor(), values.GetEsbTensor(), default_value.GetEsbTensor(), validate_indices);
  return out;
}
struct SparseToSparseSetOperationOutput {
  Tensor y_indices;
  Tensor y_values;
  Tensor y_shape;
};
inline SparseToSparseSetOperationOutput SparseToSparseSetOperation(const Tensor &x1_indices, const Tensor &x1_values, const Tensor &x1_shape, const Tensor &x2_indices, const Tensor &x2_values, const Tensor &x2_shape, const char *set_operation="", bool validate_indices=true) {
  auto out = EsSparseToSparseSetOperation(x1_indices.GetEsbTensor(), x1_values.GetEsbTensor(), x1_shape.GetEsbTensor(), x2_indices.GetEsbTensor(), x2_values.GetEsbTensor(), x2_shape.GetEsbTensor(), set_operation, validate_indices);
  return {out.y_indices, out.y_values, out.y_shape};
}
inline Tensor SpatialTransformer(const Tensor &x, const Tensor &theta=nullptr, const std::vector<int64_t> &output_size={-1, -1}, const std::vector<float> &default_theta={}, bool align_corners=false, const std::vector<int64_t> &use_default_theta={}) {
  auto out = EsSpatialTransformer(x.GetEsbTensor(), theta.GetEsbTensor(), output_size.data(), static_cast<int64_t>(output_size.size()), default_theta.data(), static_cast<int64_t>(default_theta.size()), align_corners, use_default_theta.data(), static_cast<int64_t>(use_default_theta.size()));
  return out;
}
inline Tensor SpatialTransformerD(const Tensor &x, const Tensor &theta=nullptr, const std::vector<int64_t> &output_size={-1, -1}, const std::vector<float> &default_theta={}, bool align_corners=false, const std::vector<uint8_t> &use_default_theta={}) {
  auto out = EsSpatialTransformerD(x.GetEsbTensor(), theta.GetEsbTensor(), output_size.data(), static_cast<int64_t>(output_size.size()), default_theta.data(), static_cast<int64_t>(default_theta.size()), align_corners, static_cast<const bool *>(static_cast<const void *>(use_default_theta.data())), static_cast<int64_t>(use_default_theta.size()));
  return out;
}
inline Tensor Spence(const Tensor &x) {
  auto out = EsSpence(x.GetEsbTensor());
  return out;
}
inline Tensor SplitToSequence(const Tensor &x, const Tensor &split=nullptr, int64_t axis=0, bool keepdims=true) {
  auto out = EsSplitToSequence(x.GetEsbTensor(), split.GetEsbTensor(), axis, keepdims);
  return out;
}
inline Tensor Sqrt(const Tensor &x) {
  auto out = EsSqrt(x.GetEsbTensor());
  return out;
}
inline Tensor SqrtGrad(const Tensor &y, const Tensor &dy) {
  auto out = EsSqrtGrad(y.GetEsbTensor(), dy.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor SqrtGrad(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return SqrtGrad(tensor, b_esb_tensor);
}
inline Tensor Square(const Tensor &x) {
  auto out = EsSquare(x.GetEsbTensor());
  return out;
}
struct SquareSumAllOutput {
  Tensor y1;
  Tensor y2;
};
inline SquareSumAllOutput SquareSumAll(const Tensor &x1, const Tensor &x2) {
  auto out = EsSquareSumAll(x1.GetEsbTensor(), x2.GetEsbTensor());
  return {out.y1, out.y2};
}
inline Tensor SquareSumV1(const Tensor &x, const std::vector<int64_t> &axis, bool keep_dims=false) {
  auto out = EsSquareSumV1(x.GetEsbTensor(), axis.data(), static_cast<int64_t>(axis.size()), keep_dims);
  return out;
}
struct SquareSumV2Output {
  Tensor y1;
  Tensor y2;
};
inline SquareSumV2Output SquareSumV2(const Tensor &x, const std::vector<int64_t> &axis, bool keep_dims=false) {
  auto out = EsSquareSumV2(x.GetEsbTensor(), axis.data(), static_cast<int64_t>(axis.size()), keep_dims);
  return {out.y1, out.y2};
}
inline Tensor SquaredDifference(const Tensor &x1, const Tensor &x2) {
  auto out = EsSquaredDifference(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor SquaredDifference(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return SquaredDifference(tensor, b_esb_tensor);
}
inline Tensor Squeeze(const Tensor &x, const std::vector<int64_t> &axis={}) {
  auto out = EsSqueeze(x.GetEsbTensor(), axis.data(), static_cast<int64_t>(axis.size()));
  return out;
}
inline Tensor SqueezeV2(const Tensor &x, const std::vector<int64_t> &axis={}) {
  auto out = EsSqueezeV2(x.GetEsbTensor(), axis.data(), static_cast<int64_t>(axis.size()));
  return out;
}
inline Tensor SqueezeV3(const Tensor &x, const Tensor &axes=nullptr) {
  auto out = EsSqueezeV3(x.GetEsbTensor(), axes.GetEsbTensor());
  return out;
}
inline Tensor Stack(const Tensor &max_size, ge::DataType elem_type, const char *stack_name="") {
  auto out = EsStack(max_size.GetEsbTensor(), elem_type, stack_name);
  return out;
}
inline Tensor StackBallQuery(const Tensor &xyz, const Tensor &center_xyz, const Tensor &xyz_batch_cnt, const Tensor &center_xyz_batch_cnt, float max_radius, int64_t sample_num) {
  auto out = EsStackBallQuery(xyz.GetEsbTensor(), center_xyz.GetEsbTensor(), xyz_batch_cnt.GetEsbTensor(), center_xyz_batch_cnt.GetEsbTensor(), max_radius, sample_num);
  return out;
}
inline Tensor StackClose(const Tensor &handle) {
  auto out = EsStackClose(handle.GetEsbTensor());
  return out;
}
inline Tensor StackGroupPoints(const Tensor &features, const Tensor &features_batch_cnt, const Tensor &indices, const Tensor &indices_batch_cnt) {
  auto out = EsStackGroupPoints(features.GetEsbTensor(), features_batch_cnt.GetEsbTensor(), indices.GetEsbTensor(), indices_batch_cnt.GetEsbTensor());
  return out;
}
inline Tensor StackPop(const Tensor &handle, ge::DataType elem_type) {
  auto out = EsStackPop(handle.GetEsbTensor(), elem_type);
  return out;
}
inline Tensor StackPush(const Tensor &handle, const Tensor &element, bool swap_memory=false) {
  auto out = EsStackPush(handle.GetEsbTensor(), element.GetEsbTensor(), swap_memory);
  return out;
}
inline Tensor Stage(const std::vector<Tensor> &values, int64_t capacity=0, int64_t memory_limit=0, const char *container="", const char *shared_name="") {
  auto esb_values = TensorsToEsbTensors(values);
  auto out = EsStage(esb_values.data(), static_cast<int64_t>(esb_values.size()), capacity, memory_limit, container, shared_name);
  return out;
}
inline Tensor StatefulRandomBinomial(const Tensor &x, const Tensor &algorithm, const Tensor &shape, const Tensor &counts, const Tensor &probs, ge::DataType dtype) {
  auto out = EsStatefulRandomBinomial(x.GetEsbTensor(), algorithm.GetEsbTensor(), shape.GetEsbTensor(), counts.GetEsbTensor(), probs.GetEsbTensor(), dtype);
  return out;
}
inline Tensor StatefulStandardNormalV2(const Tensor &x, const Tensor &algorithm, const Tensor &shape) {
  auto out = EsStatefulStandardNormalV2(x.GetEsbTensor(), algorithm.GetEsbTensor(), shape.GetEsbTensor());
  return out;
}
inline Tensor StatefulTruncatedNormal(const Tensor &x, const Tensor &algorithm, const Tensor &shape) {
  auto out = EsStatefulTruncatedNormal(x.GetEsbTensor(), algorithm.GetEsbTensor(), shape.GetEsbTensor());
  return out;
}
inline Tensor StatefulUniform(const Tensor &x, const Tensor &algorithm, const Tensor &shape) {
  auto out = EsStatefulUniform(x.GetEsbTensor(), algorithm.GetEsbTensor(), shape.GetEsbTensor());
  return out;
}
inline Tensor StatefulUniformFullInt(const Tensor &x, const Tensor &algorithm, const Tensor &shape) {
  auto out = EsStatefulUniformFullInt(x.GetEsbTensor(), algorithm.GetEsbTensor(), shape.GetEsbTensor());
  return out;
}
inline Tensor StatefulUniformInt(const Tensor &x, const Tensor &algorithm, const Tensor &shape, const Tensor &minval, const Tensor &maxval) {
  auto out = EsStatefulUniformInt(x.GetEsbTensor(), algorithm.GetEsbTensor(), shape.GetEsbTensor(), minval.GetEsbTensor(), maxval.GetEsbTensor());
  return out;
}
inline Tensor StatelessBernoulli(const Tensor &shape, const Tensor &prob, const Tensor &seed, const Tensor &offset, ge::DataType dtype=ge::DT_FLOAT) {
  auto out = EsStatelessBernoulli(shape.GetEsbTensor(), prob.GetEsbTensor(), seed.GetEsbTensor(), offset.GetEsbTensor(), dtype);
  return out;
}
inline Tensor StatelessBernoulliV2(const Tensor &x, const Tensor &seed, const Tensor &offset, ge::DataType dtype=ge::DT_UNDEFINED) {
  auto out = EsStatelessBernoulliV2(x.GetEsbTensor(), seed.GetEsbTensor(), offset.GetEsbTensor(), dtype);
  return out;
}
inline Tensor StatelessDropOutGenMask(const Tensor &shape, const Tensor &prob, const Tensor &seed, const Tensor &seed1, const Tensor &offset=nullptr) {
  auto out = EsStatelessDropOutGenMask(shape.GetEsbTensor(), prob.GetEsbTensor(), seed.GetEsbTensor(), seed1.GetEsbTensor(), offset.GetEsbTensor());
  return out;
}
inline Tensor StatelessMultinomial(const Tensor &logits, const Tensor &num_samples, const Tensor &seed, ge::DataType output_dtype=ge::DT_INT64) {
  auto out = EsStatelessMultinomial(logits.GetEsbTensor(), num_samples.GetEsbTensor(), seed.GetEsbTensor(), output_dtype);
  return out;
}
inline Tensor StatelessParameterizedTruncatedNormal(const Tensor &shape, const Tensor &seed, const Tensor &means, const Tensor &stdevs, const Tensor &min, const Tensor &max) {
  auto out = EsStatelessParameterizedTruncatedNormal(shape.GetEsbTensor(), seed.GetEsbTensor(), means.GetEsbTensor(), stdevs.GetEsbTensor(), min.GetEsbTensor(), max.GetEsbTensor());
  return out;
}
inline Tensor StatelessRandomBinomial(const Tensor &shape, const Tensor &seed, const Tensor &counts, const Tensor &probs, ge::DataType dtype=ge::DT_INT32) {
  auto out = EsStatelessRandomBinomial(shape.GetEsbTensor(), seed.GetEsbTensor(), counts.GetEsbTensor(), probs.GetEsbTensor(), dtype);
  return out;
}
inline Tensor StatelessRandomGammaV2(const Tensor &shape, const Tensor &seed, const Tensor &alpha) {
  auto out = EsStatelessRandomGammaV2(shape.GetEsbTensor(), seed.GetEsbTensor(), alpha.GetEsbTensor());
  return out;
}
inline Tensor StatelessRandomGetAlg(const Graph &owner_graph) {
  auto out = EsStatelessRandomGetAlg(owner_graph.GetEsbGraph());
  return out;
}
struct StatelessRandomGetKeyCounterOutput {
  Tensor key;
  Tensor counter;
};
inline StatelessRandomGetKeyCounterOutput StatelessRandomGetKeyCounter(const Tensor &seed) {
  auto out = EsStatelessRandomGetKeyCounter(seed.GetEsbTensor());
  return {out.key, out.counter};
}
struct StatelessRandomGetKeyCounterAlgOutput {
  Tensor key;
  Tensor counter;
  Tensor alg;
};
inline StatelessRandomGetKeyCounterAlgOutput StatelessRandomGetKeyCounterAlg(const Tensor &seed) {
  auto out = EsStatelessRandomGetKeyCounterAlg(seed.GetEsbTensor());
  return {out.key, out.counter, out.alg};
}
inline Tensor StatelessRandomNormalV2(const Tensor &shape, const Tensor &key, const Tensor &counter, const Tensor &alg, ge::DataType dtype=ge::DT_FLOAT) {
  auto out = EsStatelessRandomNormalV2(shape.GetEsbTensor(), key.GetEsbTensor(), counter.GetEsbTensor(), alg.GetEsbTensor(), dtype);
  return out;
}
inline Tensor StatelessRandomPoisson(const Tensor &shape, const Tensor &seed, const Tensor &lam, ge::DataType dtype) {
  auto out = EsStatelessRandomPoisson(shape.GetEsbTensor(), seed.GetEsbTensor(), lam.GetEsbTensor(), dtype);
  return out;
}
inline Tensor StatelessRandomUniformFullInt(const Tensor &shape, const Tensor &seed, ge::DataType dtype=ge::DT_INT32) {
  auto out = EsStatelessRandomUniformFullInt(shape.GetEsbTensor(), seed.GetEsbTensor(), dtype);
  return out;
}
inline Tensor StatelessRandomUniformFullIntV2(const Tensor &shape, const Tensor &key, const Tensor &counter, const Tensor &alg, ge::DataType dtype=ge::DT_INT32) {
  auto out = EsStatelessRandomUniformFullIntV2(shape.GetEsbTensor(), key.GetEsbTensor(), counter.GetEsbTensor(), alg.GetEsbTensor(), dtype);
  return out;
}
inline Tensor StatelessRandomUniformInt(const Tensor &shape, const Tensor &seed, const Tensor &minval, const Tensor &maxval) {
  auto out = EsStatelessRandomUniformInt(shape.GetEsbTensor(), seed.GetEsbTensor(), minval.GetEsbTensor(), maxval.GetEsbTensor());
  return out;
}
inline Tensor StatelessRandomUniformIntV2(const Tensor &shape, const Tensor &key, const Tensor &counter, const Tensor &alg, const Tensor &minval, const Tensor &maxval) {
  auto out = EsStatelessRandomUniformIntV2(shape.GetEsbTensor(), key.GetEsbTensor(), counter.GetEsbTensor(), alg.GetEsbTensor(), minval.GetEsbTensor(), maxval.GetEsbTensor());
  return out;
}
inline Tensor StatelessRandomUniformV2(const Tensor &shape, const Tensor &key, const Tensor &counter, const Tensor &alg, ge::DataType dtype=ge::DT_FLOAT) {
  auto out = EsStatelessRandomUniformV2(shape.GetEsbTensor(), key.GetEsbTensor(), counter.GetEsbTensor(), alg.GetEsbTensor(), dtype);
  return out;
}
inline Tensor StatelessRandperm(const Tensor &n, const Tensor &seed, const Tensor &offset, int64_t layout=0, ge::DataType dtype=ge::DT_INT64) {
  auto out = EsStatelessRandperm(n.GetEsbTensor(), seed.GetEsbTensor(), offset.GetEsbTensor(), layout, dtype);
  return out;
}
struct StatelessSampleDistortedBoundingBoxOutput {
  Tensor begin;
  Tensor size;
  Tensor bboxes;
};
inline StatelessSampleDistortedBoundingBoxOutput StatelessSampleDistortedBoundingBox(const Tensor &image_size, const Tensor &bounding_boxes, const Tensor &min_object_covered, const Tensor &seed, const std::vector<float> &aspect_ratio_range={0.750000, 1.330000}, const std::vector<float> &area_range={0.050000, 1.000000}, int64_t max_attempts=100, bool use_image_if_no_bounding_boxes=false) {
  auto out = EsStatelessSampleDistortedBoundingBox(image_size.GetEsbTensor(), bounding_boxes.GetEsbTensor(), min_object_covered.GetEsbTensor(), seed.GetEsbTensor(), aspect_ratio_range.data(), static_cast<int64_t>(aspect_ratio_range.size()), area_range.data(), static_cast<int64_t>(area_range.size()), max_attempts, use_image_if_no_bounding_boxes);
  return {out.begin, out.size, out.bboxes};
}
inline Tensor StatelessTruncatedNormalV2(const Tensor &shape, const Tensor &key, const Tensor &counter, const Tensor &alg, ge::DataType dtype=ge::DT_FLOAT) {
  auto out = EsStatelessTruncatedNormalV2(shape.GetEsbTensor(), key.GetEsbTensor(), counter.GetEsbTensor(), alg.GetEsbTensor(), dtype);
  return out;
}
inline Tensor StaticRegexFullMatch(const Tensor &input, const char *pattern="") {
  auto out = EsStaticRegexFullMatch(input.GetEsbTensor(), pattern);
  return out;
}
inline Tensor StaticRegexReplace(const Tensor &input, const char *pattern="", const char *rewrite="", bool replace_global=true) {
  auto out = EsStaticRegexReplace(input.GetEsbTensor(), pattern, rewrite, replace_global);
  return out;
}
inline Tensor StopGradient(const Tensor &x) {
  auto out = EsStopGradient(x.GetEsbTensor());
  return out;
}
inline Tensor StrideAdd(const Tensor &x1, const Tensor &x2, int64_t x1_c1_offset, int64_t x2_c1_offset, int64_t c1_len) {
  auto out = EsStrideAdd(x1.GetEsbTensor(), x2.GetEsbTensor(), x1_c1_offset, x2_c1_offset, c1_len);
  return out;
}
inline Tensor StridedRead(const Tensor &x, int64_t axis=1, int64_t stride=1) {
  auto out = EsStridedRead(x.GetEsbTensor(), axis, stride);
  return out;
}
inline Tensor StridedSlice(const Tensor &x, const Tensor &begin, const Tensor &end, const Tensor &strides, int64_t begin_mask=0, int64_t end_mask=0, int64_t ellipsis_mask=0, int64_t new_axis_mask=0, int64_t shrink_axis_mask=0) {
  auto out = EsStridedSlice(x.GetEsbTensor(), begin.GetEsbTensor(), end.GetEsbTensor(), strides.GetEsbTensor(), begin_mask, end_mask, ellipsis_mask, new_axis_mask, shrink_axis_mask);
  return out;
}
inline Tensor StridedSliceAssign(const Tensor &var, const Tensor &begin, const Tensor &end, const Tensor &strides, const Tensor &input_value, int64_t begin_mask=0, int64_t end_mask=0, int64_t ellipsis_mask=0, int64_t new_axis_mask=0, int64_t shrink_axis_mask=0) {
  auto out = EsStridedSliceAssign(var.GetEsbTensor(), begin.GetEsbTensor(), end.GetEsbTensor(), strides.GetEsbTensor(), input_value.GetEsbTensor(), begin_mask, end_mask, ellipsis_mask, new_axis_mask, shrink_axis_mask);
  return out;
}
inline Tensor StridedSliceAssignD(const Tensor &var, const Tensor &input_value, const std::vector<int64_t> &begin, const std::vector<int64_t> &end, const std::vector<int64_t> &strides, int64_t begin_mask=0, int64_t end_mask=0, int64_t ellipsis_mask=0, int64_t new_axis_mask=0, int64_t shrink_axis_mask=0) {
  auto out = EsStridedSliceAssignD(var.GetEsbTensor(), input_value.GetEsbTensor(), begin.data(), static_cast<int64_t>(begin.size()), end.data(), static_cast<int64_t>(end.size()), strides.data(), static_cast<int64_t>(strides.size()), begin_mask, end_mask, ellipsis_mask, new_axis_mask, shrink_axis_mask);
  return out;
}
inline Tensor StridedSliceAssignV2(const Tensor &var, const Tensor &input_value, const Tensor &begin, const Tensor &end, const Tensor &strides, const Tensor &axes=nullptr) {
  auto out = EsStridedSliceAssignV2(var.GetEsbTensor(), input_value.GetEsbTensor(), begin.GetEsbTensor(), end.GetEsbTensor(), strides.GetEsbTensor(), axes.GetEsbTensor());
  return out;
}
inline Tensor StridedSliceD(const Tensor &x, const std::vector<int64_t> &begin, const std::vector<int64_t> &end, const std::vector<int64_t> &strides, int64_t begin_mask=0, int64_t end_mask=0, int64_t ellipsis_mask=0, int64_t new_axis_mask=0, int64_t shrink_axis_mask=0) {
  auto out = EsStridedSliceD(x.GetEsbTensor(), begin.data(), static_cast<int64_t>(begin.size()), end.data(), static_cast<int64_t>(end.size()), strides.data(), static_cast<int64_t>(strides.size()), begin_mask, end_mask, ellipsis_mask, new_axis_mask, shrink_axis_mask);
  return out;
}
inline Tensor StridedSliceGrad(const Tensor &shape, const Tensor &begin, const Tensor &end, const Tensor &strides, const Tensor &dy, int64_t begin_mask=0, int64_t end_mask=0, int64_t ellipsis_mask=0, int64_t new_axis_mask=0, int64_t shrink_axis_mask=0) {
  auto out = EsStridedSliceGrad(shape.GetEsbTensor(), begin.GetEsbTensor(), end.GetEsbTensor(), strides.GetEsbTensor(), dy.GetEsbTensor(), begin_mask, end_mask, ellipsis_mask, new_axis_mask, shrink_axis_mask);
  return out;
}
inline Tensor StridedSliceGradD(const Tensor &dy, const std::vector<int64_t> &shape, const std::vector<int64_t> &begin, const std::vector<int64_t> &end, const std::vector<int64_t> &strides, int64_t begin_mask=0, int64_t end_mask=0, int64_t ellipsis_mask=0, int64_t new_axis_mask=0, int64_t shrink_axis_mask=0) {
  auto out = EsStridedSliceGradD(dy.GetEsbTensor(), shape.data(), static_cast<int64_t>(shape.size()), begin.data(), static_cast<int64_t>(begin.size()), end.data(), static_cast<int64_t>(end.size()), strides.data(), static_cast<int64_t>(strides.size()), begin_mask, end_mask, ellipsis_mask, new_axis_mask, shrink_axis_mask);
  return out;
}
inline Tensor StridedSliceV2(const Tensor &x, const Tensor &begin, const Tensor &end, const Tensor &axes=nullptr, const Tensor &strides=nullptr, int64_t begin_mask=0, int64_t end_mask=0, int64_t ellipsis_mask=0, int64_t new_axis_mask=0, int64_t shrink_axis_mask=0) {
  auto out = EsStridedSliceV2(x.GetEsbTensor(), begin.GetEsbTensor(), end.GetEsbTensor(), axes.GetEsbTensor(), strides.GetEsbTensor(), begin_mask, end_mask, ellipsis_mask, new_axis_mask, shrink_axis_mask);
  return out;
}
inline Tensor StridedSliceV3(const Tensor &x, const Tensor &begin, const Tensor &end, const Tensor &axes=nullptr, const Tensor &strides=nullptr) {
  auto out = EsStridedSliceV3(x.GetEsbTensor(), begin.GetEsbTensor(), end.GetEsbTensor(), axes.GetEsbTensor(), strides.GetEsbTensor());
  return out;
}
inline Tensor StridedWrite(const Tensor &x, int64_t axis=1, int64_t stride=1) {
  auto out = EsStridedWrite(x.GetEsbTensor(), axis, stride);
  return out;
}
inline Tensor StringFormat(const std::vector<Tensor> &x, const char *attr_template="%s", const char *placeholder="%s", int64_t summarize=3) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsStringFormat(esb_x.data(), static_cast<int64_t>(esb_x.size()), attr_template, placeholder, summarize);
  return out;
}
inline Tensor StringJoin(const std::vector<Tensor> &x, int64_t N, const char *separator="") {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsStringJoin(esb_x.data(), static_cast<int64_t>(esb_x.size()), N, separator);
  return out;
}
inline Tensor StringLength(const Tensor &x, const char *unit="BYTE") {
  auto out = EsStringLength(x.GetEsbTensor(), unit);
  return out;
}
inline Tensor StringLower(const Tensor &input, const char *encoding="") {
  auto out = EsStringLower(input.GetEsbTensor(), encoding);
  return out;
}
struct StringNGramsOutput {
  Tensor ngrams;
  Tensor ngrams_splits;
};
inline StringNGramsOutput StringNGrams(const Tensor &data, const Tensor &data_splits, const char *separator, const char *left_pad, const char *right_pad, int64_t pad_width, bool preserve_short_sequences, const std::vector<int64_t> &ngram_widths={}) {
  auto out = EsStringNGrams(data.GetEsbTensor(), data_splits.GetEsbTensor(), separator, left_pad, right_pad, pad_width, preserve_short_sequences, ngram_widths.data(), static_cast<int64_t>(ngram_widths.size()));
  return {out.ngrams, out.ngrams_splits};
}
struct StringSplitOutput {
  Tensor indices;
  Tensor values;
  Tensor shape;
};
inline StringSplitOutput StringSplit(const Tensor &input, const Tensor &delimiter, bool skip_empty=true) {
  auto out = EsStringSplit(input.GetEsbTensor(), delimiter.GetEsbTensor(), skip_empty);
  return {out.indices, out.values, out.shape};
}
struct StringSplitV2Output {
  Tensor indices;
  Tensor values;
  Tensor shape;
};
inline StringSplitV2Output StringSplitV2(const Tensor &input, const Tensor &sep, int64_t maxsplit=-1) {
  auto out = EsStringSplitV2(input.GetEsbTensor(), sep.GetEsbTensor(), maxsplit);
  return {out.indices, out.values, out.shape};
}
inline Tensor StringStrip(const Tensor &x) {
  auto out = EsStringStrip(x.GetEsbTensor());
  return out;
}
inline Tensor StringToHashBucket(const Tensor &string_tensor, int64_t num_buckets=1) {
  auto out = EsStringToHashBucket(string_tensor.GetEsbTensor(), num_buckets);
  return out;
}
inline Tensor StringToHashBucketFast(const Tensor &x, int64_t num_buckets=1) {
  auto out = EsStringToHashBucketFast(x.GetEsbTensor(), num_buckets);
  return out;
}
inline Tensor StringToHashBucketStrong(const Tensor &x, const std::vector<int64_t> &key, int64_t num_buckets=1) {
  auto out = EsStringToHashBucketStrong(x.GetEsbTensor(), key.data(), static_cast<int64_t>(key.size()), num_buckets);
  return out;
}
inline Tensor StringToNumber(const Tensor &x, ge::DataType out_type=ge::DT_FLOAT) {
  auto out = EsStringToNumber(x.GetEsbTensor(), out_type);
  return out;
}
inline Tensor StringUpper(const Tensor &input, const char *encoding="") {
  auto out = EsStringUpper(input.GetEsbTensor(), encoding);
  return out;
}
inline Tensor Sub(const Tensor &x1, const Tensor &x2) {
  auto out = EsSub(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor Sub(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return Sub(tensor, b_esb_tensor);
}
inline Tensor SubSample(const Tensor &labels, int64_t batch_size_per_images, float positive_fraction) {
  auto out = EsSubSample(labels.GetEsbTensor(), batch_size_per_images, positive_fraction);
  return out;
}
inline Tensor SubSampleLabels(const Tensor &labels, const Tensor &shuffle_matrix, int64_t batch_size_per_images, float positive_fraction) {
  auto out = EsSubSampleLabels(labels.GetEsbTensor(), shuffle_matrix.GetEsbTensor(), batch_size_per_images, positive_fraction);
  return out;
}
inline Tensor Substr(const Tensor &input, const Tensor &pos, const Tensor &len) {
  auto out = EsSubstr(input.GetEsbTensor(), pos.GetEsbTensor(), len.GetEsbTensor());
  return out;
}
inline Tensor Summary(const Tensor &x) {
  auto out = EsSummary(x.GetEsbTensor());
  return out;
}
struct SvdOutput {
  Tensor sigma;
  Tensor u;
  Tensor v;
};
inline SvdOutput Svd(const Tensor &x, bool compute_uv=true, bool full_matrices=false) {
  auto out = EsSvd(x.GetEsbTensor(), compute_uv, full_matrices);
  return {out.sigma, out.u, out.v};
}
inline Tensor SwinAttentionFFN(const Tensor &x1, const Tensor &x2, const Tensor &bias, const Tensor &x3=nullptr, const std::vector<int64_t> &shifts={}) {
  auto out = EsSwinAttentionFFN(x1.GetEsbTensor(), x2.GetEsbTensor(), bias.GetEsbTensor(), x3.GetEsbTensor(), shifts.data(), static_cast<int64_t>(shifts.size()));
  return out;
}
struct SwinAttentionScoreOutput {
  Tensor attention_score;
  Tensor softmax;
};
inline SwinAttentionScoreOutput SwinAttentionScore(const Tensor &query, const Tensor &key, const Tensor &value, const Tensor &padding_mask1, const Tensor &padding_mask2, const Tensor &scale, const Tensor &drop_mask=nullptr, float keep_prob=1.000000, bool query_transpose=false, bool key_transpose=false, bool bmm_score_transpose_a=false, bool bmm_score_transpose_b=false, const std::vector<int64_t> &softmax_axes={}) {
  auto out = EsSwinAttentionScore(query.GetEsbTensor(), key.GetEsbTensor(), value.GetEsbTensor(), padding_mask1.GetEsbTensor(), padding_mask2.GetEsbTensor(), scale.GetEsbTensor(), drop_mask.GetEsbTensor(), keep_prob, query_transpose, key_transpose, bmm_score_transpose_a, bmm_score_transpose_b, softmax_axes.data(), static_cast<int64_t>(softmax_axes.size()));
  return {out.attention_score, out.softmax};
}
inline Tensor SwinAttentionScoreQuant(const Tensor &query, const Tensor &key, const Tensor &value, const Tensor &scale_quant, const Tensor &scale_dequant1, const Tensor &scale_dequant2, const Tensor &bias_quant=nullptr, const Tensor &bias_dequant1=nullptr, const Tensor &bias_dequant2=nullptr, const Tensor &padding_mask1=nullptr, const Tensor &padding_mask2=nullptr, bool query_transpose=false, bool key_transpose=false, bool value_transpose=false, int64_t softmax_axes=-1) {
  auto out = EsSwinAttentionScoreQuant(query.GetEsbTensor(), key.GetEsbTensor(), value.GetEsbTensor(), scale_quant.GetEsbTensor(), scale_dequant1.GetEsbTensor(), scale_dequant2.GetEsbTensor(), bias_quant.GetEsbTensor(), bias_dequant1.GetEsbTensor(), bias_dequant2.GetEsbTensor(), padding_mask1.GetEsbTensor(), padding_mask2.GetEsbTensor(), query_transpose, key_transpose, value_transpose, softmax_axes);
  return out;
}
struct SwinTransformerLnQKVOutput {
  Tensor query_output;
  Tensor key_output;
  Tensor value_output;
};
inline SwinTransformerLnQKVOutput SwinTransformerLnQKV(const Tensor &x, const Tensor &gamma, const Tensor &beta, const Tensor &weight, const Tensor &bias, int64_t head_num, int64_t head_dim, int64_t seq_length, const std::vector<int64_t> &shifts={}, float epsilon=0.000000) {
  auto out = EsSwinTransformerLnQKV(x.GetEsbTensor(), gamma.GetEsbTensor(), beta.GetEsbTensor(), weight.GetEsbTensor(), bias.GetEsbTensor(), head_num, head_dim, seq_length, shifts.data(), static_cast<int64_t>(shifts.size()), epsilon);
  return {out.query_output, out.key_output, out.value_output};
}
struct SwinTransformerLnQkvQuantOutput {
  Tensor query_output;
  Tensor key_output;
  Tensor value_output;
};
inline SwinTransformerLnQkvQuantOutput SwinTransformerLnQkvQuant(const Tensor &x, const Tensor &gamma, const Tensor &beta, const Tensor &weight, const Tensor &bias, const Tensor &quant_scale, const Tensor &quant_offset, const Tensor &dequant_scale, int64_t head_num, int64_t seq_length, float epsilon, int64_t ori_height, int64_t ori_weight, int64_t h_win_szie, int64_t w_win_size, bool weight_transpose) {
  auto out = EsSwinTransformerLnQkvQuant(x.GetEsbTensor(), gamma.GetEsbTensor(), beta.GetEsbTensor(), weight.GetEsbTensor(), bias.GetEsbTensor(), quant_scale.GetEsbTensor(), quant_offset.GetEsbTensor(), dequant_scale.GetEsbTensor(), head_num, seq_length, epsilon, ori_height, ori_weight, h_win_szie, w_win_size, weight_transpose);
  return {out.query_output, out.key_output, out.value_output};
}
inline Tensor Swish(const Tensor &x, float scale=1.000000) {
  auto out = EsSwish(x.GetEsbTensor(), scale);
  return out;
}
inline Tensor SwishGrad(const Tensor &grad, const Tensor &x, const Tensor &y, float scale=1.000000) {
  auto out = EsSwishGrad(grad.GetEsbTensor(), x.GetEsbTensor(), y.GetEsbTensor(), scale);
  return out;
}
struct SwitchOutput {
  Tensor output_false;
  Tensor output_true;
};
inline SwitchOutput Switch(const Tensor &data, const Tensor &pred) {
  auto out = EsSwitch(data.GetEsbTensor(), pred.GetEsbTensor());
  return {out.output_false, out.output_true};
}
inline Tensor SwitchByIndex(const Tensor &x1, const Tensor &x2) {
  auto out = EsSwitchByIndex(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
inline Tensor Sxpy(const Tensor &x1, const Tensor &x2, const Tensor &alpha=nullptr) {
  auto out = EsSxpy(x1.GetEsbTensor(), x2.GetEsbTensor(), alpha.GetEsbTensor());
  return out;
}
inline Tensor SyncBNTrainingUpdate(const Tensor &mean, const Tensor &running_mean, float momentum=0.100000) {
  auto out = EsSyncBNTrainingUpdate(mean.GetEsbTensor(), running_mean.GetEsbTensor(), momentum);
  return out;
}
inline Tensor SyncBatchNormBackwardElemt(const Tensor &grad_output, const Tensor &save_input, const Tensor &mean, const Tensor &invstd, const Tensor &weight, const Tensor &mean_dy, const Tensor &mean_dy_xmu) {
  auto out = EsSyncBatchNormBackwardElemt(grad_output.GetEsbTensor(), save_input.GetEsbTensor(), mean.GetEsbTensor(), invstd.GetEsbTensor(), weight.GetEsbTensor(), mean_dy.GetEsbTensor(), mean_dy_xmu.GetEsbTensor());
  return out;
}
struct SyncBatchNormBackwardReduceOutput {
  Tensor sum_dy_xmu;
  Tensor y;
};
inline SyncBatchNormBackwardReduceOutput SyncBatchNormBackwardReduce(const Tensor &sum_dy, const Tensor &sum_dy_dx_pad, const Tensor &mean, const Tensor &invert_std) {
  auto out = EsSyncBatchNormBackwardReduce(sum_dy.GetEsbTensor(), sum_dy_dx_pad.GetEsbTensor(), mean.GetEsbTensor(), invert_std.GetEsbTensor());
  return {out.sum_dy_xmu, out.y};
}
struct SyncBatchNormGatherStatsOutput {
  Tensor batch_mean;
  Tensor batch_invstd;
  Tensor mean;
  Tensor variance;
};
inline SyncBatchNormGatherStatsOutput SyncBatchNormGatherStats(const Tensor &total_sum, const Tensor &total_square_sum, const Tensor &sample_count, const Tensor &mean, const Tensor &variance, float momentum=0.100000, float eps=0.000010) {
  auto out = EsSyncBatchNormGatherStats(total_sum.GetEsbTensor(), total_square_sum.GetEsbTensor(), sample_count.GetEsbTensor(), mean.GetEsbTensor(), variance.GetEsbTensor(), momentum, eps);
  return {out.batch_mean, out.batch_invstd, out.mean, out.variance};
}
struct SyncBatchNormGatherStatsWithCountsOutput {
  Tensor invert_std;
  Tensor running_var_update;
};
inline SyncBatchNormGatherStatsWithCountsOutput SyncBatchNormGatherStatsWithCounts(const Tensor &mean_all, const Tensor &invert_std_all, const Tensor &count_all, const Tensor &mean_broadcast, const Tensor &count_sum, const Tensor &running_var, float momentum=0.100000, float epsilon=0.001000) {
  auto out = EsSyncBatchNormGatherStatsWithCounts(mean_all.GetEsbTensor(), invert_std_all.GetEsbTensor(), count_all.GetEsbTensor(), mean_broadcast.GetEsbTensor(), count_sum.GetEsbTensor(), running_var.GetEsbTensor(), momentum, epsilon);
  return {out.invert_std, out.running_var_update};
}
inline Tensor SyncResizeBilinearV2(const Tensor &x, const Tensor &size, const std::vector<int64_t> &ori_image_size={}, const std::vector<int64_t> &split_size={}, int64_t src_start_w=0, int64_t dst_start_w=0, bool align_corners=false, bool half_pixel_centers=false) {
  auto out = EsSyncResizeBilinearV2(x.GetEsbTensor(), size.GetEsbTensor(), ori_image_size.data(), static_cast<int64_t>(ori_image_size.size()), split_size.data(), static_cast<int64_t>(split_size.size()), src_start_w, dst_start_w, align_corners, half_pixel_centers);
  return out;
}
inline Tensor SyncResizeBilinearV2Grad(const Tensor &grads, const Tensor &original_image, const std::vector<int64_t> &size={}, const std::vector<int64_t> &ori_image_size={}, int64_t src_start_w=0, int64_t dst_start_w=0, bool align_corners=false, bool half_pixel_centers=false) {
  auto out = EsSyncResizeBilinearV2Grad(grads.GetEsbTensor(), original_image.GetEsbTensor(), size.data(), static_cast<int64_t>(size.size()), ori_image_size.data(), static_cast<int64_t>(ori_image_size.size()), src_start_w, dst_start_w, align_corners, half_pixel_centers);
  return out;
}
inline Tensor TableToResource(const Tensor &table_id) {
  auto out = EsTableToResource(table_id.GetEsbTensor());
  return out;
}
inline Tensor TableToResourceV2(const Tensor &table_id) {
  auto out = EsTableToResourceV2(table_id.GetEsbTensor());
  return out;
}
inline Tensor TabulateFusion(const Tensor &table, const Tensor &table_info, const Tensor &em_x, const Tensor &em, int64_t last_layer_size) {
  auto out = EsTabulateFusion(table.GetEsbTensor(), table_info.GetEsbTensor(), em_x.GetEsbTensor(), em.GetEsbTensor(), last_layer_size);
  return out;
}
struct TabulateFusionGradOutput {
  Tensor dy_dem_x;
  Tensor dy_dem;
};
inline TabulateFusionGradOutput TabulateFusionGrad(const Tensor &table, const Tensor &table_info, const Tensor &em_x, const Tensor &em, const Tensor &dy, const Tensor &descriptor) {
  auto out = EsTabulateFusionGrad(table.GetEsbTensor(), table_info.GetEsbTensor(), em_x.GetEsbTensor(), em.GetEsbTensor(), dy.GetEsbTensor(), descriptor.GetEsbTensor());
  return {out.dy_dem_x, out.dy_dem};
}
struct TakeManySparseFromTensorsMapOutput {
  Tensor indices;
  Tensor values;
  Tensor shape;
};
inline TakeManySparseFromTensorsMapOutput TakeManySparseFromTensorsMap(const Tensor &handles, ge::DataType dtype, const char *container="", const char *shared_name="") {
  auto out = EsTakeManySparseFromTensorsMap(handles.GetEsbTensor(), dtype, container, shared_name);
  return {out.indices, out.values, out.shape};
}
inline Tensor Tan(const Tensor &x) {
  auto out = EsTan(x.GetEsbTensor());
  return out;
}
inline Tensor Tanh(const Tensor &x) {
  auto out = EsTanh(x.GetEsbTensor());
  return out;
}
inline Tensor TanhGrad(const Tensor &y, const Tensor &dy, bool complex_conj=false) {
  auto out = EsTanhGrad(y.GetEsbTensor(), dy.GetEsbTensor(), complex_conj);
  return out;
}
inline Tensor TargetCropAndResize(const Tensor &x, const Tensor &boxes, const Tensor &box_index, int64_t output_h=224, int64_t output_w=224, const char *input_format="YUV420SP_U8") {
  auto out = EsTargetCropAndResize(x.GetEsbTensor(), boxes.GetEsbTensor(), box_index.GetEsbTensor(), output_h, output_w, input_format);
  return out;
}
inline Tensor TemporaryVariable(const Graph &owner_graph, const std::vector<int64_t> &shape, int64_t dtype, const char *var_name="") {
  auto out = EsTemporaryVariable(owner_graph.GetEsbGraph(), shape.data(), static_cast<int64_t>(shape.size()), dtype, var_name);
  return out;
}
struct TensorArrayOutput {
  Tensor handle;
  Tensor flow;
};
inline TensorArrayOutput TensorArray(const Tensor &size, ge::DataType dtype, const std::vector<int64_t> &element_shape={-2}, bool dynamic_size=false, bool clear_after_read=true, bool identical_element_shapes=false, const char *tensor_array_name="") {
  auto out = EsTensorArray(size.GetEsbTensor(), dtype, element_shape.data(), static_cast<int64_t>(element_shape.size()), dynamic_size, clear_after_read, identical_element_shapes, tensor_array_name);
  return {out.handle, out.flow};
}
inline Tensor TensorArrayClose(const Tensor &handle) {
  auto out = EsTensorArrayClose(handle.GetEsbTensor());
  return out;
}
struct TensorArrayConcatOutput {
  Tensor value;
  Tensor lengths;
};
inline TensorArrayConcatOutput TensorArrayConcat(const Tensor &handle, const Tensor &flow_in, ge::DataType dtype, const std::vector<int64_t> &element_shape_except0={-2}) {
  auto out = EsTensorArrayConcat(handle.GetEsbTensor(), flow_in.GetEsbTensor(), dtype, element_shape_except0.data(), static_cast<int64_t>(element_shape_except0.size()));
  return {out.value, out.lengths};
}
inline Tensor TensorArrayGather(const Tensor &handle, const Tensor &indices, const Tensor &flow_in, ge::DataType dtype, const std::vector<int64_t> &element_shape={-2}) {
  auto out = EsTensorArrayGather(handle.GetEsbTensor(), indices.GetEsbTensor(), flow_in.GetEsbTensor(), dtype, element_shape.data(), static_cast<int64_t>(element_shape.size()));
  return out;
}
struct TensorArrayGradOutput {
  Tensor grad_handle;
  Tensor flow_out;
};
inline TensorArrayGradOutput TensorArrayGrad(const Tensor &handle, const Tensor &flow_in, const char *source) {
  auto out = EsTensorArrayGrad(handle.GetEsbTensor(), flow_in.GetEsbTensor(), source);
  return {out.grad_handle, out.flow_out};
}
struct TensorArrayGradWithShapeOutput {
  Tensor grad_handle;
  Tensor flow_out;
};
inline TensorArrayGradWithShapeOutput TensorArrayGradWithShape(const Tensor &handle, const Tensor &flow_in, const Tensor &shape_to_prepend, const char *source="") {
  auto out = EsTensorArrayGradWithShape(handle.GetEsbTensor(), flow_in.GetEsbTensor(), shape_to_prepend.GetEsbTensor(), source);
  return {out.grad_handle, out.flow_out};
}
inline Tensor TensorArrayRead(const Tensor &handle, const Tensor &index, const Tensor &flow_in, ge::DataType dtype) {
  auto out = EsTensorArrayRead(handle.GetEsbTensor(), index.GetEsbTensor(), flow_in.GetEsbTensor(), dtype);
  return out;
}
inline Tensor TensorArrayScatter(const Tensor &handle, const Tensor &indices, const Tensor &value, const Tensor &flow_in) {
  auto out = EsTensorArrayScatter(handle.GetEsbTensor(), indices.GetEsbTensor(), value.GetEsbTensor(), flow_in.GetEsbTensor());
  return out;
}
inline Tensor TensorArraySize(const Tensor &handle, const Tensor &flow_in) {
  auto out = EsTensorArraySize(handle.GetEsbTensor(), flow_in.GetEsbTensor());
  return out;
}
inline Tensor TensorArraySplit(const Tensor &handle, const Tensor &value, const Tensor &lengths, const Tensor &flow_in) {
  auto out = EsTensorArraySplit(handle.GetEsbTensor(), value.GetEsbTensor(), lengths.GetEsbTensor(), flow_in.GetEsbTensor());
  return out;
}
inline Tensor TensorArrayWrite(const Tensor &handle, const Tensor &index, const Tensor &value, const Tensor &flow_in) {
  auto out = EsTensorArrayWrite(handle.GetEsbTensor(), index.GetEsbTensor(), value.GetEsbTensor(), flow_in.GetEsbTensor());
  return out;
}
inline Tensor TensorEqual(const Tensor &input_x, const Tensor &input_y) {
  auto out = EsTensorEqual(input_x.GetEsbTensor(), input_y.GetEsbTensor());
  return out;
}
inline Tensor TensorListConcatLists(const Tensor &input_a, const Tensor &input_b, ge::DataType element_dtype=ge::DT_INT32) {
  auto out = EsTensorListConcatLists(input_a.GetEsbTensor(), input_b.GetEsbTensor(), element_dtype);
  return out;
}
struct TensorListConcatV2Output {
  Tensor tensor;
  Tensor lengths;
};
inline TensorListConcatV2Output TensorListConcatV2(const Tensor &input_handle, const Tensor &element_shape, const Tensor &leading_dims, ge::DataType element_dtype=ge::DT_INT32) {
  auto out = EsTensorListConcatV2(input_handle.GetEsbTensor(), element_shape.GetEsbTensor(), leading_dims.GetEsbTensor(), element_dtype);
  return {out.tensor, out.lengths};
}
inline Tensor TensorListElementShape(const Tensor &input_handle, ge::DataType shape_type=ge::DT_INT32) {
  auto out = EsTensorListElementShape(input_handle.GetEsbTensor(), shape_type);
  return out;
}
inline Tensor TensorListFromTensor(const Tensor &tensor, const Tensor &element_shape, ge::DataType element_dtype=ge::DT_INT32) {
  auto out = EsTensorListFromTensor(tensor.GetEsbTensor(), element_shape.GetEsbTensor(), element_dtype);
  return out;
}
inline Tensor TensorListGather(const Tensor &input_handle, const Tensor &indices, const Tensor &element_shape, ge::DataType element_dtype=ge::DT_INT32) {
  auto out = EsTensorListGather(input_handle.GetEsbTensor(), indices.GetEsbTensor(), element_shape.GetEsbTensor(), element_dtype);
  return out;
}
inline Tensor TensorListGetItem(const Tensor &input_handle, const Tensor &index, const Tensor &element_shape, ge::DataType element_dtype=ge::DT_INT32) {
  auto out = EsTensorListGetItem(input_handle.GetEsbTensor(), index.GetEsbTensor(), element_shape.GetEsbTensor(), element_dtype);
  return out;
}
inline Tensor TensorListLength(const Tensor &input_handle) {
  auto out = EsTensorListLength(input_handle.GetEsbTensor());
  return out;
}
struct TensorListPopBackOutput {
  Tensor output_handle;
  Tensor tensor;
};
inline TensorListPopBackOutput TensorListPopBack(const Tensor &input_handle, const Tensor &element_shape, ge::DataType element_dtype=ge::DT_INT32) {
  auto out = EsTensorListPopBack(input_handle.GetEsbTensor(), element_shape.GetEsbTensor(), element_dtype);
  return {out.output_handle, out.tensor};
}
inline Tensor TensorListPushBack(const Tensor &input_handle, const Tensor &tensor, ge::DataType element_dtype=ge::DT_INT32) {
  auto out = EsTensorListPushBack(input_handle.GetEsbTensor(), tensor.GetEsbTensor(), element_dtype);
  return out;
}
inline Tensor TensorListPushBackBatch(const Tensor &input_handles, const Tensor &tensor, ge::DataType element_dtype=ge::DT_INT32) {
  auto out = EsTensorListPushBackBatch(input_handles.GetEsbTensor(), tensor.GetEsbTensor(), element_dtype);
  return out;
}
inline Tensor TensorListReserve(const Tensor &element_shape, const Tensor &num_elements, ge::DataType element_dtype=ge::DT_INT32, ge::DataType shape_type=ge::DT_INT32) {
  auto out = EsTensorListReserve(element_shape.GetEsbTensor(), num_elements.GetEsbTensor(), element_dtype, shape_type);
  return out;
}
inline Tensor TensorListResize(const Tensor &input_handle, const Tensor &size) {
  auto out = EsTensorListResize(input_handle.GetEsbTensor(), size.GetEsbTensor());
  return out;
}
inline Tensor TensorListScatterIntoExistingList(const Tensor &input_handle, const Tensor &tensor, const Tensor &indices, ge::DataType element_dtype=ge::DT_INT32) {
  auto out = EsTensorListScatterIntoExistingList(input_handle.GetEsbTensor(), tensor.GetEsbTensor(), indices.GetEsbTensor(), element_dtype);
  return out;
}
inline Tensor TensorListScatterV2(const Tensor &tensor, const Tensor &indices, const Tensor &element_shape, const Tensor &num_elements, ge::DataType element_dtype=ge::DT_INT32) {
  auto out = EsTensorListScatterV2(tensor.GetEsbTensor(), indices.GetEsbTensor(), element_shape.GetEsbTensor(), num_elements.GetEsbTensor(), element_dtype);
  return out;
}
inline Tensor TensorListSetItem(const Tensor &input_handle, const Tensor &index, const Tensor &item, ge::DataType element_dtype=ge::DT_INT32) {
  auto out = EsTensorListSetItem(input_handle.GetEsbTensor(), index.GetEsbTensor(), item.GetEsbTensor(), element_dtype);
  return out;
}
inline Tensor TensorListSplit(const Tensor &tensor, const Tensor &element_shape, const Tensor &lengths, ge::DataType element_dtype=ge::DT_INT32) {
  auto out = EsTensorListSplit(tensor.GetEsbTensor(), element_shape.GetEsbTensor(), lengths.GetEsbTensor(), element_dtype);
  return out;
}
inline Tensor TensorListStack(const Tensor &input_handle, const Tensor &element_shape, ge::DataType element_dtype=ge::DT_INT32, int64_t num_elements=-1) {
  auto out = EsTensorListStack(input_handle.GetEsbTensor(), element_shape.GetEsbTensor(), element_dtype, num_elements);
  return out;
}
inline Tensor TensorMapErase(const Tensor &input_handle, const Tensor &key) {
  auto out = EsTensorMapErase(input_handle.GetEsbTensor(), key.GetEsbTensor());
  return out;
}
inline Tensor TensorMapHasKey(const Tensor &input_handle, const Tensor &key) {
  auto out = EsTensorMapHasKey(input_handle.GetEsbTensor(), key.GetEsbTensor());
  return out;
}
inline Tensor TensorMapInsert(const Tensor &input_handle, const Tensor &key, const Tensor &value) {
  auto out = EsTensorMapInsert(input_handle.GetEsbTensor(), key.GetEsbTensor(), value.GetEsbTensor());
  return out;
}
inline Tensor TensorMapLookup(const Tensor &input_handle, const Tensor &key, ge::DataType value_dtype) {
  auto out = EsTensorMapLookup(input_handle.GetEsbTensor(), key.GetEsbTensor(), value_dtype);
  return out;
}
inline Tensor TensorMapSize(const Tensor &input_handle) {
  auto out = EsTensorMapSize(input_handle.GetEsbTensor());
  return out;
}
inline Tensor TensorMapStackKeys(const Tensor &input_handle, ge::DataType key_dtype) {
  auto out = EsTensorMapStackKeys(input_handle.GetEsbTensor(), key_dtype);
  return out;
}
inline Tensor TensorMove(const Tensor &x) {
  auto out = EsTensorMove(x.GetEsbTensor());
  return out;
}
inline Tensor TensorRedirect(const Tensor &x) {
  auto out = EsTensorRedirect(x.GetEsbTensor());
  return out;
}
inline Tensor TensorScatterAdd(const Tensor &x, const Tensor &indices, const Tensor &updates) {
  auto out = EsTensorScatterAdd(x.GetEsbTensor(), indices.GetEsbTensor(), updates.GetEsbTensor());
  return out;
}
inline Tensor TensorScatterMax(const Tensor &input, const Tensor &indices, const Tensor &updates) {
  auto out = EsTensorScatterMax(input.GetEsbTensor(), indices.GetEsbTensor(), updates.GetEsbTensor());
  return out;
}
inline Tensor TensorScatterMin(const Tensor &input, const Tensor &indices, const Tensor &updates) {
  auto out = EsTensorScatterMin(input.GetEsbTensor(), indices.GetEsbTensor(), updates.GetEsbTensor());
  return out;
}
inline Tensor TensorScatterSub(const Tensor &x, const Tensor &indices, const Tensor &updates) {
  auto out = EsTensorScatterSub(x.GetEsbTensor(), indices.GetEsbTensor(), updates.GetEsbTensor());
  return out;
}
inline Tensor TensorScatterUpdate(const Tensor &x, const Tensor &indices, const Tensor &updates) {
  auto out = EsTensorScatterUpdate(x.GetEsbTensor(), indices.GetEsbTensor(), updates.GetEsbTensor());
  return out;
}
struct ThreadUnsafeUnigramCandidateSamplerOutput {
  Tensor sampled_candidates;
  Tensor true_expected_count;
  Tensor sampled_expected_count;
};
inline ThreadUnsafeUnigramCandidateSamplerOutput ThreadUnsafeUnigramCandidateSampler(const Tensor &true_classes, int64_t num_true, int64_t num_sampled, bool unique, int64_t range_max, int64_t seed=0, int64_t seed2=0) {
  auto out = EsThreadUnsafeUnigramCandidateSampler(true_classes.GetEsbTensor(), num_true, num_sampled, unique, range_max, seed, seed2);
  return {out.sampled_candidates, out.true_expected_count, out.sampled_expected_count};
}
inline Tensor ThreeInterpolate(const Tensor &features, const Tensor &idx, const Tensor &weight) {
  auto out = EsThreeInterpolate(features.GetEsbTensor(), idx.GetEsbTensor(), weight.GetEsbTensor());
  return out;
}
inline Tensor ThreeInterpolateBackward(const Tensor &grad_x, const Tensor &idx, const Tensor &weight, int64_t m) {
  auto out = EsThreeInterpolateBackward(grad_x.GetEsbTensor(), idx.GetEsbTensor(), weight.GetEsbTensor(), m);
  return out;
}
struct ThreeNNOutput {
  Tensor dist;
  Tensor idx;
};
inline ThreeNNOutput ThreeNN(const Tensor &xyz1, const Tensor &xyz2) {
  auto out = EsThreeNN(xyz1.GetEsbTensor(), xyz2.GetEsbTensor());
  return {out.dist, out.idx};
}
inline Tensor Threshold(const Tensor &x, float threshold=0.000000) {
  auto out = EsThreshold(x.GetEsbTensor(), threshold);
  return out;
}
inline Tensor ThresholdGradV2D(const Tensor &gradients, const Tensor &features, float threshold) {
  auto out = EsThresholdGradV2D(gradients.GetEsbTensor(), features.GetEsbTensor(), threshold);
  return out;
}
inline Tensor ThresholdV2(const Tensor &x, const Tensor &threshold, const Tensor &value=nullptr) {
  auto out = EsThresholdV2(x.GetEsbTensor(), threshold.GetEsbTensor(), value.GetEsbTensor());
  return out;
}
inline Tensor ThresholdV2D(const Tensor &x, float threshold, float value) {
  auto out = EsThresholdV2D(x.GetEsbTensor(), threshold, value);
  return out;
}
inline Tensor ThresholdedRelu(const Tensor &x, float alpha=1.000000) {
  auto out = EsThresholdedRelu(x.GetEsbTensor(), alpha);
  return out;
}
inline Tensor Tile(const Tensor &x, const Tensor &multiples) {
  auto out = EsTile(x.GetEsbTensor(), multiples.GetEsbTensor());
  return out;
}
inline Tensor TileD(const Tensor &x, const std::vector<int64_t> &multiples) {
  auto out = EsTileD(x.GetEsbTensor(), multiples.data(), static_cast<int64_t>(multiples.size()));
  return out;
}
inline Tensor TileWithAxis(const Tensor &x, int64_t tiles, int64_t axis=1) {
  auto out = EsTileWithAxis(x.GetEsbTensor(), tiles, axis);
  return out;
}
inline Tensor Timestamp(const Graph &owner_graph) {
  auto out = EsTimestamp(owner_graph.GetEsbGraph());
  return out;
}
inline Tensor ToAbsoluteBBox(const Tensor &normalized_boxes, const Tensor &shape_hw, bool reversed_box=false) {
  auto out = EsToAbsoluteBBox(normalized_boxes.GetEsbTensor(), shape_hw.GetEsbTensor(), reversed_box);
  return out;
}
inline Tensor ToBool(const Tensor &input) {
  auto out = EsToBool(input.GetEsbTensor());
  return out;
}
struct TomeMergeOutput {
  Tensor unmerge_token_a;
  Tensor unreduce_token_b;
  Tensor unreduce_count;
};
inline TomeMergeOutput TomeMerge(const Tensor &token_a, const Tensor &token_b, const Tensor &topk_indice, const Tensor &arg_max, float top_rate=0.500000) {
  auto out = EsTomeMerge(token_a.GetEsbTensor(), token_b.GetEsbTensor(), topk_indice.GetEsbTensor(), arg_max.GetEsbTensor(), top_rate);
  return {out.unmerge_token_a, out.unreduce_token_b, out.unreduce_count};
}
inline Tensor TomeUnmerge(const Tensor &attention, const Tensor &ori_index_a, const Tensor &ori_index_b, const Tensor &topk_indice, const Tensor &arg_max, float top_rate=0.500000) {
  auto out = EsTomeUnmerge(attention.GetEsbTensor(), ori_index_a.GetEsbTensor(), ori_index_b.GetEsbTensor(), topk_indice.GetEsbTensor(), arg_max.GetEsbTensor(), top_rate);
  return out;
}
struct TopKOutput {
  Tensor values;
  Tensor indices;
};
inline TopKOutput TopK(const Tensor &x, const Tensor &k, bool sorted=true, bool largest=true, int64_t dim=-1) {
  auto out = EsTopK(x.GetEsbTensor(), k.GetEsbTensor(), sorted, largest, dim);
  return {out.values, out.indices};
}
struct TopKDOutput {
  Tensor values;
  Tensor indices;
};
inline TopKDOutput TopKD(const Tensor &x, const Tensor &assist_seq, int64_t k, bool sorted=true, int64_t dim=-1, bool largest=true) {
  auto out = EsTopKD(x.GetEsbTensor(), assist_seq.GetEsbTensor(), k, sorted, dim, largest);
  return {out.values, out.indices};
}
struct TopKPQDistanceOutput {
  Tensor topk_distance;
  Tensor topk_ivf;
  Tensor topk_index;
};
inline TopKPQDistanceOutput TopKPQDistance(const std::vector<Tensor> &actual_count, const std::vector<Tensor> &pq_distance, const std::vector<Tensor> &grouped_extreme_distance, const std::vector<Tensor> &pq_ivf, const std::vector<Tensor> &pq_index, int64_t k, int64_t group_size, const char *order="ASC") {
  auto esb_actual_count = TensorsToEsbTensors(actual_count);
  auto esb_pq_distance = TensorsToEsbTensors(pq_distance);
  auto esb_grouped_extreme_distance = TensorsToEsbTensors(grouped_extreme_distance);
  auto esb_pq_ivf = TensorsToEsbTensors(pq_ivf);
  auto esb_pq_index = TensorsToEsbTensors(pq_index);
  auto out = EsTopKPQDistance(esb_actual_count.data(), static_cast<int64_t>(esb_actual_count.size()), esb_pq_distance.data(), static_cast<int64_t>(esb_pq_distance.size()), esb_grouped_extreme_distance.data(), static_cast<int64_t>(esb_grouped_extreme_distance.size()), esb_pq_ivf.data(), static_cast<int64_t>(esb_pq_ivf.size()), esb_pq_index.data(), static_cast<int64_t>(esb_pq_index.size()), k, group_size, order);
  return {out.topk_distance, out.topk_ivf, out.topk_index};
}
struct TopKPQDistanceMergeOutput {
  Tensor topk_distance;
  Tensor topk_ivf;
  Tensor topk_index;
};
inline TopKPQDistanceMergeOutput TopKPQDistanceMerge(const Tensor &sorted_distance, const Tensor &pq_ivf, const Tensor &pq_index, int64_t k) {
  auto out = EsTopKPQDistanceMerge(sorted_distance.GetEsbTensor(), pq_ivf.GetEsbTensor(), pq_index.GetEsbTensor(), k);
  return {out.topk_distance, out.topk_ivf, out.topk_index};
}
struct TopKPQDistanceV2Output {
  Tensor topk_distance;
  Tensor topk_index;
};
inline TopKPQDistanceV2Output TopKPQDistanceV2(const Tensor &pq_distance, const Tensor &grouped_extreme_distance, int64_t k, int64_t group_size, const char *order="ASC") {
  auto out = EsTopKPQDistanceV2(pq_distance.GetEsbTensor(), grouped_extreme_distance.GetEsbTensor(), k, group_size, order);
  return {out.topk_distance, out.topk_index};
}
struct TopKV2Output {
  Tensor values;
  Tensor indices;
};
inline TopKV2Output TopKV2(const Tensor &x, const Tensor &k, bool sorted=true, int64_t dim=-1, bool largest=true) {
  auto out = EsTopKV2(x.GetEsbTensor(), k.GetEsbTensor(), sorted, dim, largest);
  return {out.values, out.indices};
}
struct TopKV2DOutput {
  Tensor values;
  Tensor indices;
};
inline TopKV2DOutput TopKV2D(const Tensor &x, const Tensor &k, const Tensor &assist_seq, bool sorted=true, int64_t dim=-1, bool largest=true) {
  auto out = EsTopKV2D(x.GetEsbTensor(), k.GetEsbTensor(), assist_seq.GetEsbTensor(), sorted, dim, largest);
  return {out.values, out.indices};
}
struct TopKV3Output {
  Tensor values;
  Tensor indices;
};
inline TopKV3Output TopKV3(const Tensor &x, const Tensor &k, bool sorted=true, int64_t dim=-1, bool largest=true) {
  auto out = EsTopKV3(x.GetEsbTensor(), k.GetEsbTensor(), sorted, dim, largest);
  return {out.values, out.indices};
}
inline Tensor Trace(const Tensor &x) {
  auto out = EsTrace(x.GetEsbTensor());
  return out;
}
inline Tensor TransArgb(const Tensor &x) {
  auto out = EsTransArgb(x.GetEsbTensor());
  return out;
}
inline Tensor TransData(const Tensor &src, const char *src_format, const char *dst_format, int64_t src_subformat=0, int64_t dst_subformat=0, int64_t groups=1) {
  auto out = EsTransData(src.GetEsbTensor(), src_format, dst_format, src_subformat, dst_subformat, groups);
  return out;
}
inline Tensor TransDataRNN(const Tensor &src, const char *src_format, const char *dst_format, int64_t input_size, int64_t hidden_size) {
  auto out = EsTransDataRNN(src.GetEsbTensor(), src_format, dst_format, input_size, hidden_size);
  return out;
}
inline Tensor TransQuantParamV2(const Tensor &scale, const Tensor &offset=nullptr) {
  auto out = EsTransQuantParamV2(scale.GetEsbTensor(), offset.GetEsbTensor());
  return out;
}
inline Tensor TransShape(const Tensor &x, const std::vector<int64_t> &outShape={}) {
  auto out = EsTransShape(x.GetEsbTensor(), outShape.data(), static_cast<int64_t>(outShape.size()));
  return out;
}
inline Tensor Transpose(const Tensor &x, const Tensor &perm) {
  auto out = EsTranspose(x.GetEsbTensor(), perm.GetEsbTensor());
  return out;
}
inline Tensor TransposeBatchMatMul(const Tensor &x1, const Tensor &x2, const Tensor &bias=nullptr, const Tensor &offset_w=nullptr, const std::vector<int64_t> &perm_x1={}, const std::vector<int64_t> &perm_x2={}, const std::vector<int64_t> &perm_y={}, int64_t offset_x=0) {
  auto out = EsTransposeBatchMatMul(x1.GetEsbTensor(), x2.GetEsbTensor(), bias.GetEsbTensor(), offset_w.GetEsbTensor(), perm_x1.data(), static_cast<int64_t>(perm_x1.size()), perm_x2.data(), static_cast<int64_t>(perm_x2.size()), perm_y.data(), static_cast<int64_t>(perm_y.size()), offset_x);
  return out;
}
inline Tensor TransposeD(const Tensor &x, const std::vector<int64_t> &perm) {
  auto out = EsTransposeD(x.GetEsbTensor(), perm.data(), static_cast<int64_t>(perm.size()));
  return out;
}
inline Tensor TridiagonalSolve(const Tensor &diagonals, const Tensor &rhs, bool partial_pivoting=true) {
  auto out = EsTridiagonalSolve(diagonals.GetEsbTensor(), rhs.GetEsbTensor(), partial_pivoting);
  return out;
}
inline Tensor Tril(const Tensor &x, int64_t diagonal=0) {
  auto out = EsTril(x.GetEsbTensor(), diagonal);
  return out;
}
inline Tensor Triu(const Tensor &x, int64_t diagonal=0) {
  auto out = EsTriu(x.GetEsbTensor(), diagonal);
  return out;
}
inline Tensor Trunc(const Tensor &input_x) {
  auto out = EsTrunc(input_x.GetEsbTensor());
  return out;
}
inline Tensor TruncateDiv(const Tensor &x1, const Tensor &x2) {
  auto out = EsTruncateDiv(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor TruncateDiv(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return TruncateDiv(tensor, b_esb_tensor);
}
inline Tensor TruncateMod(const Tensor &x1, const Tensor &x2) {
  auto out = EsTruncateMod(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor TruncateMod(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return TruncateMod(tensor, b_esb_tensor);
}
inline Tensor TruncatedNormal(const Tensor &shape, int64_t seed=0, int64_t seed2=0, ge::DataType dtype=ge::DT_FLOAT) {
  auto out = EsTruncatedNormal(shape.GetEsbTensor(), seed, seed2, dtype);
  return out;
}
inline Tensor Unbatch(const Tensor &x_tensor, const Tensor &index, const Tensor &id, int64_t timeout_micros, const char *container="", const char *shared_name="") {
  auto out = EsUnbatch(x_tensor.GetEsbTensor(), index.GetEsbTensor(), id.GetEsbTensor(), timeout_micros, container, shared_name);
  return out;
}
inline Tensor UnbatchGrad(const Tensor &x_input, const Tensor &index, const Tensor &grad, const Tensor &id, const char *container="", const char *shared_name="") {
  auto out = EsUnbatchGrad(x_input.GetEsbTensor(), index.GetEsbTensor(), grad.GetEsbTensor(), id.GetEsbTensor(), container, shared_name);
  return out;
}
struct UnicodeDecodeOutput {
  Tensor row_splits;
  Tensor char_values;
};
inline UnicodeDecodeOutput UnicodeDecode(const Tensor &input, const char *input_encoding, const char *errors="replace", int64_t replacement_char=65533, bool replace_control_characters=false, ge::DataType Tsplits=ge::DT_INT64) {
  auto out = EsUnicodeDecode(input.GetEsbTensor(), input_encoding, errors, replacement_char, replace_control_characters, Tsplits);
  return {out.row_splits, out.char_values};
}
struct UnicodeDecodeWithOffsetsOutput {
  Tensor row_splits;
  Tensor char_values;
  Tensor char_to_byte_starts;
};
inline UnicodeDecodeWithOffsetsOutput UnicodeDecodeWithOffsets(const Tensor &input, const char *input_encoding, const char *errors="replace", int64_t replacement_char=65533, bool replace_control_characters=false, ge::DataType Tsplits=ge::DT_INT64) {
  auto out = EsUnicodeDecodeWithOffsets(input.GetEsbTensor(), input_encoding, errors, replacement_char, replace_control_characters, Tsplits);
  return {out.row_splits, out.char_values, out.char_to_byte_starts};
}
inline Tensor UnicodeEncode(const Tensor &input_values, const Tensor &input_splits, const char *errors="replace", const char *output_encoding="UTF-8", int64_t replacement_char=65533) {
  auto out = EsUnicodeEncode(input_values.GetEsbTensor(), input_splits.GetEsbTensor(), errors, output_encoding, replacement_char);
  return out;
}
inline Tensor UnicodeScript(const Tensor &x) {
  auto out = EsUnicodeScript(x.GetEsbTensor());
  return out;
}
inline Tensor UnicodeTranscode(const Tensor &input, const char *input_encoding, const char *output_encoding="UTF-8", const char *errors="replace", int64_t replacement_char=65533, bool replace_control_characters=false) {
  auto out = EsUnicodeTranscode(input.GetEsbTensor(), input_encoding, output_encoding, errors, replacement_char, replace_control_characters);
  return out;
}
inline Tensor Uniform(const Tensor &x, float from=0.000000, float to=1.000000) {
  auto out = EsUniform(x.GetEsbTensor(), from, to);
  return out;
}
struct UniformCandidateSamplerOutput {
  Tensor sampled_candidates;
  Tensor true_expected_count;
  Tensor sampled_expected_count;
};
inline UniformCandidateSamplerOutput UniformCandidateSampler(const Tensor &true_classes, int64_t num_true, int64_t num_sampled, bool unique, int64_t range_max, int64_t seed=0, int64_t seed2=0) {
  auto out = EsUniformCandidateSampler(true_classes.GetEsbTensor(), num_true, num_sampled, unique, range_max, seed, seed2);
  return {out.sampled_candidates, out.true_expected_count, out.sampled_expected_count};
}
struct UniqueOutput {
  Tensor y;
  Tensor idx;
};
inline UniqueOutput Unique(const Tensor &x, ge::DataType out_idx=ge::DT_INT32) {
  auto out = EsUnique(x.GetEsbTensor(), out_idx);
  return {out.y, out.idx};
}
struct UniqueConsecutiveOutput {
  Tensor y;
  Tensor idx;
  Tensor count;
};
inline UniqueConsecutiveOutput UniqueConsecutive(const Tensor &x, bool return_idx=false, bool return_counts=false, int64_t axis=1000) {
  auto out = EsUniqueConsecutive(x.GetEsbTensor(), return_idx, return_counts, axis);
  return {out.y, out.idx, out.count};
}
struct UniqueExt2Output {
  Tensor y;
  Tensor idx;
};
inline UniqueExt2Output UniqueExt2(const Tensor &x, const Tensor &axis, ge::DataType out_idx=ge::DT_INT32) {
  auto out = EsUniqueExt2(x.GetEsbTensor(), axis.GetEsbTensor(), out_idx);
  return {out.y, out.idx};
}
struct UniqueWithCountsOutput {
  Tensor y;
  Tensor idx;
  Tensor count;
};
inline UniqueWithCountsOutput UniqueWithCounts(const Tensor &x, ge::DataType out_idx) {
  auto out = EsUniqueWithCounts(x.GetEsbTensor(), out_idx);
  return {out.y, out.idx, out.count};
}
struct UniqueWithCountsAndSortingOutput {
  Tensor y;
  Tensor indices;
  Tensor counts;
};
inline UniqueWithCountsAndSortingOutput UniqueWithCountsAndSorting(const Tensor &x, bool return_inverse=false, bool return_counts=false, bool sorted=true) {
  auto out = EsUniqueWithCountsAndSorting(x.GetEsbTensor(), return_inverse, return_counts, sorted);
  return {out.y, out.indices, out.counts};
}
struct UniqueWithCountsExt2Output {
  Tensor y;
  Tensor idx;
  Tensor count;
  Tensor inverse_idx;
};
inline UniqueWithCountsExt2Output UniqueWithCountsExt2(const Tensor &x, const Tensor &axis, ge::DataType out_idx=ge::DT_INT64, bool sorted=false, bool return_inverse=false) {
  auto out = EsUniqueWithCountsExt2(x.GetEsbTensor(), axis.GetEsbTensor(), out_idx, sorted, return_inverse);
  return {out.y, out.idx, out.count, out.inverse_idx};
}
inline Tensor UnravelIndex(const Tensor &indices, const Tensor &dims) {
  auto out = EsUnravelIndex(indices.GetEsbTensor(), dims.GetEsbTensor());
  return out;
}
inline Tensor UnsortedSegmentJoin(const Tensor &input, const Tensor &segment_ids, const Tensor &num_segments, const char *separator="") {
  auto out = EsUnsortedSegmentJoin(input.GetEsbTensor(), segment_ids.GetEsbTensor(), num_segments.GetEsbTensor(), separator);
  return out;
}
inline Tensor UnsortedSegmentMax(const Tensor &x, const Tensor &segment_ids, const Tensor &num_segments) {
  auto out = EsUnsortedSegmentMax(x.GetEsbTensor(), segment_ids.GetEsbTensor(), num_segments.GetEsbTensor());
  return out;
}
inline Tensor UnsortedSegmentMaxD(const Tensor &x, const Tensor &segment_ids, int64_t num_segments) {
  auto out = EsUnsortedSegmentMaxD(x.GetEsbTensor(), segment_ids.GetEsbTensor(), num_segments);
  return out;
}
inline Tensor UnsortedSegmentMin(const Tensor &x, const Tensor &segment_ids, const Tensor &num_segments) {
  auto out = EsUnsortedSegmentMin(x.GetEsbTensor(), segment_ids.GetEsbTensor(), num_segments.GetEsbTensor());
  return out;
}
inline Tensor UnsortedSegmentMinD(const Tensor &x, const Tensor &segment_ids, int64_t num_segments) {
  auto out = EsUnsortedSegmentMinD(x.GetEsbTensor(), segment_ids.GetEsbTensor(), num_segments);
  return out;
}
inline Tensor UnsortedSegmentProd(const Tensor &x, const Tensor &segment_ids, const Tensor &num_segments) {
  auto out = EsUnsortedSegmentProd(x.GetEsbTensor(), segment_ids.GetEsbTensor(), num_segments.GetEsbTensor());
  return out;
}
inline Tensor UnsortedSegmentProdD(const Tensor &x, const Tensor &segment_ids, int64_t num_segments) {
  auto out = EsUnsortedSegmentProdD(x.GetEsbTensor(), segment_ids.GetEsbTensor(), num_segments);
  return out;
}
inline Tensor UnsortedSegmentSum(const Tensor &x, const Tensor &segment_ids, const Tensor &num_segments, bool is_preprocessed=false, bool check_ids=false) {
  auto out = EsUnsortedSegmentSum(x.GetEsbTensor(), segment_ids.GetEsbTensor(), num_segments.GetEsbTensor(), is_preprocessed, check_ids);
  return out;
}
inline Tensor UnsortedSegmentSumD(const Tensor &x, const Tensor &segment_ids, int64_t num_segments) {
  auto out = EsUnsortedSegmentSumD(x.GetEsbTensor(), segment_ids.GetEsbTensor(), num_segments);
  return out;
}
inline Tensor Unsqueeze(const Tensor &x, const std::vector<int64_t> &axes={}) {
  auto out = EsUnsqueeze(x.GetEsbTensor(), axes.data(), static_cast<int64_t>(axes.size()));
  return out;
}
inline Tensor UnsqueezeV2(const Tensor &x, const std::vector<int64_t> &axis={}) {
  auto out = EsUnsqueezeV2(x.GetEsbTensor(), axis.data(), static_cast<int64_t>(axis.size()));
  return out;
}
inline Tensor UnsqueezeV3(const Tensor &x, const Tensor &axes) {
  auto out = EsUnsqueezeV3(x.GetEsbTensor(), axes.GetEsbTensor());
  return out;
}
inline Tensor UpdateTensorDesc(const Tensor &x, const std::vector<int64_t> &shape) {
  auto out = EsUpdateTensorDesc(x.GetEsbTensor(), shape.data(), static_cast<int64_t>(shape.size()));
  return out;
}
inline Tensor UpperBound(const Tensor &sorted_x, const Tensor &values, ge::DataType out_type) {
  auto out = EsUpperBound(sorted_x.GetEsbTensor(), values.GetEsbTensor(), out_type);
  return out;
}
inline Tensor Upsample(const Tensor &x, float scale=1.000000, int64_t stride_h=2, int64_t stride_w=2) {
  auto out = EsUpsample(x.GetEsbTensor(), scale, stride_h, stride_w);
  return out;
}
inline Tensor UpsampleNearest1d(const Tensor &x, const std::vector<int64_t> &output_size, const std::vector<float> &scales={}) {
  auto out = EsUpsampleNearest1d(x.GetEsbTensor(), output_size.data(), static_cast<int64_t>(output_size.size()), scales.data(), static_cast<int64_t>(scales.size()));
  return out;
}
inline Tensor UpsampleNearest1dGrad(const Tensor &grad_output, const std::vector<int64_t> &input_size, const std::vector<int64_t> &output_size, const std::vector<float> &scales={}) {
  auto out = EsUpsampleNearest1dGrad(grad_output.GetEsbTensor(), input_size.data(), static_cast<int64_t>(input_size.size()), output_size.data(), static_cast<int64_t>(output_size.size()), scales.data(), static_cast<int64_t>(scales.size()));
  return out;
}
inline Tensor UpsampleNearest3d(const Tensor &x, const std::vector<int64_t> &output_size={}, const std::vector<float> &scales={}) {
  auto out = EsUpsampleNearest3d(x.GetEsbTensor(), output_size.data(), static_cast<int64_t>(output_size.size()), scales.data(), static_cast<int64_t>(scales.size()));
  return out;
}
inline Tensor UpsampleNearest3dGrad(const Tensor &grad_output, const std::vector<int64_t> &input_size, const std::vector<int64_t> &output_size={}, const std::vector<float> &scales={}) {
  auto out = EsUpsampleNearest3dGrad(grad_output.GetEsbTensor(), input_size.data(), static_cast<int64_t>(input_size.size()), output_size.data(), static_cast<int64_t>(output_size.size()), scales.data(), static_cast<int64_t>(scales.size()));
  return out;
}
inline Tensor UpsampleNearestExact3d(const Tensor &x, const std::vector<int64_t> &output_size, const std::vector<float> &scales={0.000000, 0.000000, 0.000000}) {
  auto out = EsUpsampleNearestExact3d(x.GetEsbTensor(), output_size.data(), static_cast<int64_t>(output_size.size()), scales.data(), static_cast<int64_t>(scales.size()));
  return out;
}
inline Tensor UpsampleNearestExact3dGrad(const Tensor &grad_output, const std::vector<int64_t> &input_size, const std::vector<int64_t> &output_size={0, 0, 0}, const std::vector<float> &scales={0.000000, 0.000000, 0.000000}) {
  auto out = EsUpsampleNearestExact3dGrad(grad_output.GetEsbTensor(), input_size.data(), static_cast<int64_t>(input_size.size()), output_size.data(), static_cast<int64_t>(output_size.size()), scales.data(), static_cast<int64_t>(scales.size()));
  return out;
}
inline Tensor UpsampleTrilinear3d(const Tensor &x, const std::vector<int64_t> &output_size={}, const std::vector<float> &scales={}, bool align_corners=false) {
  auto out = EsUpsampleTrilinear3d(x.GetEsbTensor(), output_size.data(), static_cast<int64_t>(output_size.size()), scales.data(), static_cast<int64_t>(scales.size()), align_corners);
  return out;
}
inline Tensor UpsampleTrilinear3dGrad(const Tensor &grad_output, const std::vector<int64_t> &input_size, const std::vector<int64_t> &output_size={}, const std::vector<float> &scales={}, bool align_corners=false) {
  auto out = EsUpsampleTrilinear3dGrad(grad_output.GetEsbTensor(), input_size.data(), static_cast<int64_t>(input_size.size()), output_size.data(), static_cast<int64_t>(output_size.size()), scales.data(), static_cast<int64_t>(scales.size()), align_corners);
  return out;
}
inline Tensor VarHandleOp(const Graph &owner_graph, ge::DataType dtype, const char *container="", const char *shared_name="", const std::vector<int64_t> &shape={-1}) {
  auto out = EsVarHandleOp(owner_graph.GetEsbGraph(), dtype, container, shared_name, shape.data(), static_cast<int64_t>(shape.size()));
  return out;
}
inline Tensor VarIsInitializedOp(const Tensor &x) {
  auto out = EsVarIsInitializedOp(x.GetEsbTensor());
  return out;
}
inline Tensor ViewCopy(const Tensor &dst, const Tensor &dst_size, const Tensor &dst_stride, const Tensor &dst_storage_offset, const Tensor &src, const Tensor &src_size, const Tensor &src_stride, const Tensor &src_storage_offset) {
  auto out = EsViewCopy(dst.GetEsbTensor(), dst_size.GetEsbTensor(), dst_stride.GetEsbTensor(), dst_storage_offset.GetEsbTensor(), src.GetEsbTensor(), src_size.GetEsbTensor(), src_stride.GetEsbTensor(), src_storage_offset.GetEsbTensor());
  return out;
}
struct VoxelizationOutput {
  Tensor voxels;
  Tensor coors;
  Tensor num_points_per_voxel;
  Tensor voxel_num;
};
inline VoxelizationOutput Voxelization(const Tensor &points, const Tensor &voxel_size, const Tensor &coors_range, int64_t max_points=35, int64_t max_voxels=20000, bool deterministic=true) {
  auto out = EsVoxelization(points.GetEsbTensor(), voxel_size.GetEsbTensor(), coors_range.GetEsbTensor(), max_points, max_voxels, deterministic);
  return {out.voxels, out.coors, out.num_points_per_voxel, out.voxel_num};
}
inline Tensor WarpAffine(const Tensor &x, const Tensor &matrix, int64_t out_height, int64_t out_width, const char *interpolation_mode="bilinear", const char *padding_mode="const", int64_t padding_value=0) {
  auto out = EsWarpAffine(x.GetEsbTensor(), matrix.GetEsbTensor(), out_height, out_width, interpolation_mode, padding_mode, padding_value);
  return out;
}
inline Tensor WarpAffineV2(const Tensor &x, const Tensor &matrix, const Tensor &dst_size, const char *interpolation="bilinear", const char *border_type="constant", float border_value=0.000000, const char *data_format="HWC") {
  auto out = EsWarpAffineV2(x.GetEsbTensor(), matrix.GetEsbTensor(), dst_size.GetEsbTensor(), interpolation, border_type, border_value, data_format);
  return out;
}
inline Tensor WarpPerspective(const Tensor &x, const Tensor &matrix, int64_t out_height, int64_t out_width, const char *interpolation_mode="bilinear", const char *border_type="BORDER_CONSTANT", float constant=0.000000, const char *data_format="CHW") {
  auto out = EsWarpPerspective(x.GetEsbTensor(), matrix.GetEsbTensor(), out_height, out_width, interpolation_mode, border_type, constant, data_format);
  return out;
}
inline Tensor WeightQuantBatchMatmulV2(const Tensor &x, const Tensor &weight, const Tensor &antiquant_scale, const Tensor &antiquant_offset=nullptr, const Tensor &quant_scale=nullptr, const Tensor &quant_offset=nullptr, const Tensor &bias=nullptr, bool transpose_x=false, bool transpose_weight=false, int64_t antiquant_group_size=0, int64_t dtype=-1, int64_t inner_precise=0) {
  auto out = EsWeightQuantBatchMatmulV2(x.GetEsbTensor(), weight.GetEsbTensor(), antiquant_scale.GetEsbTensor(), antiquant_offset.GetEsbTensor(), quant_scale.GetEsbTensor(), quant_offset.GetEsbTensor(), bias.GetEsbTensor(), transpose_x, transpose_weight, antiquant_group_size, dtype, inner_precise);
  return out;
}
inline Tensor WeightQuantBatchmatmul(const Tensor &input_x, const Tensor &input_y, const Tensor &diagonal_matrix, const Tensor &q_bias, const Tensor &deq_scale, const Tensor &bias=nullptr, bool adj_x1=false, bool adj_x2=false) {
  auto out = EsWeightQuantBatchmatmul(input_x.GetEsbTensor(), input_y.GetEsbTensor(), diagonal_matrix.GetEsbTensor(), q_bias.GetEsbTensor(), deq_scale.GetEsbTensor(), bias.GetEsbTensor(), adj_x1, adj_x2);
  return out;
}
inline Tensor WeightQuantBatchmatmulV3(const Tensor &input_x, const Tensor &input_y, const Tensor &diagonal_matrix, const Tensor &q_bias, const Tensor &deq_scale, const Tensor &mul_scale=nullptr, const Tensor &add_offset=nullptr, const Tensor &bias=nullptr, bool adj_x1=false, bool adj_x2=false, float scale=1.000000, float offset=0.000000) {
  auto out = EsWeightQuantBatchmatmulV3(input_x.GetEsbTensor(), input_y.GetEsbTensor(), diagonal_matrix.GetEsbTensor(), q_bias.GetEsbTensor(), deq_scale.GetEsbTensor(), mul_scale.GetEsbTensor(), add_offset.GetEsbTensor(), bias.GetEsbTensor(), adj_x1, adj_x2, scale, offset);
  return out;
}
inline Tensor Where(const Tensor &x) {
  auto out = EsWhere(x.GetEsbTensor());
  return out;
}
inline Tensor WriteSelect(const Tensor &x) {
  auto out = EsWriteSelect(x.GetEsbTensor());
  return out;
}
inline Tensor WtsARQ(const Tensor &w, const Tensor &w_min, const Tensor &w_max, int64_t num_bits=8, bool offset_flag=false) {
  auto out = EsWtsARQ(w.GetEsbTensor(), w_min.GetEsbTensor(), w_max.GetEsbTensor(), num_bits, offset_flag);
  return out;
}
inline Tensor Xdivy(const Tensor &x1, const Tensor &x2) {
  auto out = EsXdivy(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor Xdivy(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return Xdivy(tensor, b_esb_tensor);
}
inline Tensor Xlog1py(const Tensor &x, const Tensor &y) {
  auto out = EsXlog1py(x.GetEsbTensor(), y.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor Xlog1py(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return Xlog1py(tensor, b_esb_tensor);
}
inline Tensor Xlogy(const Tensor &x1, const Tensor &x2) {
  auto out = EsXlogy(x1.GetEsbTensor(), x2.GetEsbTensor());
  return out;
}
template <typename T, typename std::enable_if<!std::is_same<typename std::decay<T>::type, Tensor>::value, int>::type = 0>
Tensor Xlogy(const Tensor &tensor, T &&b_val) {
  auto b_esb_tensor = EnsureTensor(std::forward<T>(b_val), tensor);
  return Xlogy(tensor, b_esb_tensor);
}
inline Tensor YUV4442YUV422(const Tensor &x) {
  auto out = EsYUV4442YUV422(x.GetEsbTensor());
  return out;
}
inline Tensor YUVToRGB(const Tensor &x, const Tensor &matrix=nullptr, int64_t matrix_type=0, int64_t rb_swap=0) {
  auto out = EsYUVToRGB(x.GetEsbTensor(), matrix.GetEsbTensor(), matrix_type, rb_swap);
  return out;
}
struct YoloOutput {
  Tensor coord_data;
  Tensor obj_prob;
  Tensor classes_prob;
};
inline YoloOutput Yolo(const Tensor &x, int64_t boxes=3, int64_t coords=4, int64_t classes=80, const char *yolo_version="V3", bool softmax=false, bool background=false, bool softmaxtree=false) {
  auto out = EsYolo(x.GetEsbTensor(), boxes, coords, classes, yolo_version, softmax, background, softmaxtree);
  return {out.coord_data, out.obj_prob, out.classes_prob};
}
inline Tensor YoloBoxesEncode(const Tensor &anchor_boxes, const Tensor &gt_bboxes, const Tensor &stride, const char *performance_mode="high_precision") {
  auto out = EsYoloBoxesEncode(anchor_boxes.GetEsbTensor(), gt_bboxes.GetEsbTensor(), stride.GetEsbTensor(), performance_mode);
  return out;
}
struct YoloPreDetectionOutput {
  Tensor coord_data;
  Tensor obj_prob;
  Tensor classes_prob;
};
inline YoloPreDetectionOutput YoloPreDetection(const Tensor &x, int64_t boxes=3, int64_t coords=4, int64_t classes=80, const char *yolo_version="V5", bool softmax=false, bool background=false, bool softmaxtree=false) {
  auto out = EsYoloPreDetection(x.GetEsbTensor(), boxes, coords, classes, yolo_version, softmax, background, softmaxtree);
  return {out.coord_data, out.obj_prob, out.classes_prob};
}
struct YoloV2DetectionOutputOutput {
  Tensor box_out;
  Tensor box_out_num;
};
inline YoloV2DetectionOutputOutput YoloV2DetectionOutput(const Tensor &coord_data, const Tensor &obj_prob, const Tensor &classes_prob, const Tensor &img_info, const std::vector<float> &biases, int64_t boxes=5, int64_t coords=4, int64_t classes=20, bool relative=true, float obj_threshold=0.500000, int64_t post_nms_topn=512, float score_threshold=0.500000, float iou_threshold=0.450000, int64_t pre_nms_topn=512) {
  auto out = EsYoloV2DetectionOutput(coord_data.GetEsbTensor(), obj_prob.GetEsbTensor(), classes_prob.GetEsbTensor(), img_info.GetEsbTensor(), biases.data(), static_cast<int64_t>(biases.size()), boxes, coords, classes, relative, obj_threshold, post_nms_topn, score_threshold, iou_threshold, pre_nms_topn);
  return {out.box_out, out.box_out_num};
}
struct YoloV2DetectionOutputDOutput {
  Tensor box_out;
  Tensor box_out_num;
};
inline YoloV2DetectionOutputDOutput YoloV2DetectionOutputD(const Tensor &coord_data, const Tensor &obj_prob, const Tensor &classes_prob, const Tensor &img_info, const Tensor &windex, const Tensor &hindex, const std::vector<float> &biases, int64_t boxes=5, int64_t coords=4, int64_t classes=20, bool relative=true, float obj_threshold=0.500000, int64_t post_nms_topn=512, float score_threshold=0.500000, float iou_threshold=0.450000, int64_t pre_nms_topn=512) {
  auto out = EsYoloV2DetectionOutputD(coord_data.GetEsbTensor(), obj_prob.GetEsbTensor(), classes_prob.GetEsbTensor(), img_info.GetEsbTensor(), windex.GetEsbTensor(), hindex.GetEsbTensor(), biases.data(), static_cast<int64_t>(biases.size()), boxes, coords, classes, relative, obj_threshold, post_nms_topn, score_threshold, iou_threshold, pre_nms_topn);
  return {out.box_out, out.box_out_num};
}
struct YoloV3DetectionOutputOutput {
  Tensor box_out;
  Tensor box_out_num;
};
inline YoloV3DetectionOutputOutput YoloV3DetectionOutput(const Tensor &coord_data_low, const Tensor &coord_data_mid, const Tensor &coord_data_high, const Tensor &obj_prob_low, const Tensor &obj_prob_mid, const Tensor &obj_prob_high, const Tensor &classes_prob_low, const Tensor &classes_prob_mid, const Tensor &classes_prob_high, const Tensor &img_info, const std::vector<float> &biases_low, const std::vector<float> &biases_mid, const std::vector<float> &biases_high, int64_t boxes=3, int64_t coords=4, int64_t classes=80, bool relative=true, float obj_threshold=0.500000, int64_t post_nms_topn=512, float score_threshold=0.500000, float iou_threshold=0.450000, int64_t pre_nms_topn=512) {
  auto out = EsYoloV3DetectionOutput(coord_data_low.GetEsbTensor(), coord_data_mid.GetEsbTensor(), coord_data_high.GetEsbTensor(), obj_prob_low.GetEsbTensor(), obj_prob_mid.GetEsbTensor(), obj_prob_high.GetEsbTensor(), classes_prob_low.GetEsbTensor(), classes_prob_mid.GetEsbTensor(), classes_prob_high.GetEsbTensor(), img_info.GetEsbTensor(), biases_low.data(), static_cast<int64_t>(biases_low.size()), biases_mid.data(), static_cast<int64_t>(biases_mid.size()), biases_high.data(), static_cast<int64_t>(biases_high.size()), boxes, coords, classes, relative, obj_threshold, post_nms_topn, score_threshold, iou_threshold, pre_nms_topn);
  return {out.box_out, out.box_out_num};
}
struct YoloV3DetectionOutputDOutput {
  Tensor box_out;
  Tensor box_out_num;
};
inline YoloV3DetectionOutputDOutput YoloV3DetectionOutputD(const Tensor &coord_data_low, const Tensor &coord_data_mid, const Tensor &coord_data_high, const Tensor &obj_prob_low, const Tensor &obj_prob_mid, const Tensor &obj_prob_high, const Tensor &classes_prob_low, const Tensor &classes_prob_mid, const Tensor &classes_prob_high, const Tensor &img_info, const Tensor &windex1, const Tensor &windex2, const Tensor &windex3, const Tensor &hindex1, const Tensor &hindex2, const Tensor &hindex3, const std::vector<float> &biases_low, const std::vector<float> &biases_mid, const std::vector<float> &biases_high, int64_t boxes=3, int64_t coords=4, int64_t classes=80, bool relative=true, float obj_threshold=0.500000, int64_t post_nms_topn=512, float score_threshold=0.500000, float iou_threshold=0.450000, int64_t pre_nms_topn=512) {
  auto out = EsYoloV3DetectionOutputD(coord_data_low.GetEsbTensor(), coord_data_mid.GetEsbTensor(), coord_data_high.GetEsbTensor(), obj_prob_low.GetEsbTensor(), obj_prob_mid.GetEsbTensor(), obj_prob_high.GetEsbTensor(), classes_prob_low.GetEsbTensor(), classes_prob_mid.GetEsbTensor(), classes_prob_high.GetEsbTensor(), img_info.GetEsbTensor(), windex1.GetEsbTensor(), windex2.GetEsbTensor(), windex3.GetEsbTensor(), hindex1.GetEsbTensor(), hindex2.GetEsbTensor(), hindex3.GetEsbTensor(), biases_low.data(), static_cast<int64_t>(biases_low.size()), biases_mid.data(), static_cast<int64_t>(biases_mid.size()), biases_high.data(), static_cast<int64_t>(biases_high.size()), boxes, coords, classes, relative, obj_threshold, post_nms_topn, score_threshold, iou_threshold, pre_nms_topn);
  return {out.box_out, out.box_out_num};
}
struct YoloV3DetectionOutputV2Output {
  Tensor box_out;
  Tensor box_out_num;
};
inline YoloV3DetectionOutputV2Output YoloV3DetectionOutputV2(const std::vector<Tensor> &x, const std::vector<float> &biases, int64_t boxes=3, int64_t coords=4, int64_t classes=80, bool relative=true, float obj_threshold=0.500000, int64_t post_nms_topn=512, float score_threshold=0.500000, float iou_threshold=0.450000, int64_t pre_nms_topn=512, int64_t N=10, bool resize_origin_img_to_net=false, int64_t out_box_dim=3) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsYoloV3DetectionOutputV2(esb_x.data(), static_cast<int64_t>(esb_x.size()), biases.data(), static_cast<int64_t>(biases.size()), boxes, coords, classes, relative, obj_threshold, post_nms_topn, score_threshold, iou_threshold, pre_nms_topn, N, resize_origin_img_to_net, out_box_dim);
  return {out.box_out, out.box_out_num};
}
struct YoloV3DetectionOutputV2DOutput {
  Tensor box_out;
  Tensor box_out_num;
};
inline YoloV3DetectionOutputV2DOutput YoloV3DetectionOutputV2D(const std::vector<Tensor> &x, const std::vector<Tensor> &windex, const std::vector<Tensor> &hindex, const std::vector<float> &biases, int64_t boxes=3, int64_t coords=4, int64_t classes=80, bool relative=true, float obj_threshold=0.500000, int64_t post_nms_topn=512, float score_threshold=0.500000, float iou_threshold=0.450000, int64_t pre_nms_topn=512, int64_t N=10, bool resize_origin_img_to_net=false, int64_t out_box_dim=3) {
  auto esb_x = TensorsToEsbTensors(x);
  auto esb_windex = TensorsToEsbTensors(windex);
  auto esb_hindex = TensorsToEsbTensors(hindex);
  auto out = EsYoloV3DetectionOutputV2D(esb_x.data(), static_cast<int64_t>(esb_x.size()), esb_windex.data(), static_cast<int64_t>(esb_windex.size()), esb_hindex.data(), static_cast<int64_t>(esb_hindex.size()), biases.data(), static_cast<int64_t>(biases.size()), boxes, coords, classes, relative, obj_threshold, post_nms_topn, score_threshold, iou_threshold, pre_nms_topn, N, resize_origin_img_to_net, out_box_dim);
  return {out.box_out, out.box_out_num};
}
struct YoloV5DetectionOutputOutput {
  Tensor box_out;
  Tensor box_out_num;
};
inline YoloV5DetectionOutputOutput YoloV5DetectionOutput(const std::vector<Tensor> &x, const std::vector<float> &biases, int64_t boxes=3, int64_t coords=4, int64_t classes=80, bool relative=true, float obj_threshold=0.500000, int64_t post_nms_topn=512, float score_threshold=0.500000, float iou_threshold=0.450000, int64_t pre_nms_topn=512, int64_t N=10, bool resize_origin_img_to_net=false, int64_t out_box_dim=3, float alpha=2.000000) {
  auto esb_x = TensorsToEsbTensors(x);
  auto out = EsYoloV5DetectionOutput(esb_x.data(), static_cast<int64_t>(esb_x.size()), biases.data(), static_cast<int64_t>(biases.size()), boxes, coords, classes, relative, obj_threshold, post_nms_topn, score_threshold, iou_threshold, pre_nms_topn, N, resize_origin_img_to_net, out_box_dim, alpha);
  return {out.box_out, out.box_out_num};
}
struct YoloV5DetectionOutputDOutput {
  Tensor box_out;
  Tensor box_out_num;
};
inline YoloV5DetectionOutputDOutput YoloV5DetectionOutputD(const std::vector<Tensor> &x, const std::vector<Tensor> &windex, const std::vector<Tensor> &hindex, const std::vector<float> &biases, int64_t boxes=3, int64_t coords=4, int64_t classes=80, bool relative=true, float obj_threshold=0.500000, int64_t post_nms_topn=512, float score_threshold=0.500000, float iou_threshold=0.450000, int64_t pre_nms_topn=512, int64_t N=10, bool resize_origin_img_to_net=false, int64_t out_box_dim=3, float alpha=2.000000) {
  auto esb_x = TensorsToEsbTensors(x);
  auto esb_windex = TensorsToEsbTensors(windex);
  auto esb_hindex = TensorsToEsbTensors(hindex);
  auto out = EsYoloV5DetectionOutputD(esb_x.data(), static_cast<int64_t>(esb_x.size()), esb_windex.data(), static_cast<int64_t>(esb_windex.size()), esb_hindex.data(), static_cast<int64_t>(esb_hindex.size()), biases.data(), static_cast<int64_t>(biases.size()), boxes, coords, classes, relative, obj_threshold, post_nms_topn, score_threshold, iou_threshold, pre_nms_topn, N, resize_origin_img_to_net, out_box_dim, alpha);
  return {out.box_out, out.box_out_num};
}
inline Tensor YoloxBoundingBoxDecode(const Tensor &priors, const Tensor &bboxes) {
  auto out = EsYoloxBoundingBoxDecode(priors.GetEsbTensor(), bboxes.GetEsbTensor());
  return out;
}
inline Tensor ZerosLike(const Tensor &x) {
  auto out = EsZerosLike(x.GetEsbTensor());
  return out;
}
inline Tensor Zeta(const Tensor &x, const Tensor &q) {
  auto out = EsZeta(x.GetEsbTensor(), q.GetEsbTensor());
  return out;
}
inline Tensor _ParallelConcatStart(const Graph &owner_graph, ge::DataType dtype=ge::DT_INT32, const std::vector<int64_t> &shape={}) {
  auto out = Es_ParallelConcatStart(owner_graph.GetEsbGraph(), dtype, shape.data(), static_cast<int64_t>(shape.size()));
  return out;
}
}  // namespace es
#endif  // AIR_CXX_COMPILER_GRAPH_EAGER_STYLE_GRAPH_BUILDER_ALL_OPS_CPP_H
