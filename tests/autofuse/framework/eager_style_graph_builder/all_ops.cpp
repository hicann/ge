/**
 * Copyright (c) 2025 Huawei Technologies Co., Ltd.
 * This program is free software, you can redistribute it and/or modify it under the terms and conditions of 
 * CANN Open Software License Agreement Version 2.0 (the "License").
 * Please refer to the License for details. You may not use this file except in compliance with the License.
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
 * INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
 * See LICENSE in the root of the software repository for the full text of the License.
 */

/*********************************************************************************************************************
 This file is GENERATED by scripts/tensor_graph_generation/ops_collector/gen_esb, do not edit it manually
*********************************************************************************************************************/

#include "all_ops.h"
#include "esb_graph.h"
#include "compliant_op_desc_builder.h"
#include "common/checker.h"
#include "graph/utils/graph_utils.h"
#include "utils/extern_math_util.h"

#ifdef __cplusplus
extern "C" {
#endif
EsbTensor *EsAGLU(EsbTensor *x, EsbTensor *weight1, EsbTensor *bias1, EsbTensor *weight2, EsbTensor *bias2, const char *activate_func, bool activate_left) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(weight1);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AGLU")
.Name(("AGLU_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"weight1", ge::kIrInputRequired, ""},
{"bias1", ge::kIrInputOptional, ""},
{"weight2", ge::kIrInputOptional, ""},
{"bias2", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"activate_func",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(activate_func))
},
{
"activate_left",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(activate_left))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight1->GetAnchor(), node->GetInDataAnchor(1)));
if (bias1 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias1->GetAnchor(), node->GetInDataAnchor(2)));
}
if (weight2 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight2->GetAnchor(), node->GetInDataAnchor(3)));
}
if (bias2 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias2->GetAnchor(), node->GetInDataAnchor(4)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsAUGRUHiddenGradCellOutput EsAUGRUHiddenGradCell(EsbTensor *weight_att, EsbTensor *dh_pre_t, EsbTensor *h, EsbTensor *dy, EsbTensor *dh, EsbTensor *update, EsbTensor *update_att, EsbTensor *reset, EsbTensor *in_new, EsbTensor *hidden_new, EsbTensor *seq_length, int64_t t_state, const char *gate_order) {
GE_ASSERT_NOTNULL(weight_att);
GE_ASSERT_NOTNULL(dh_pre_t);
GE_ASSERT_NOTNULL(h);
GE_ASSERT_NOTNULL(dy);
GE_ASSERT_NOTNULL(dh);
GE_ASSERT_NOTNULL(update);
GE_ASSERT_NOTNULL(update_att);
GE_ASSERT_NOTNULL(reset);
GE_ASSERT_NOTNULL(in_new);
GE_ASSERT_NOTNULL(hidden_new);
auto &graph = weight_att->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AUGRUHiddenGradCell")
.Name(("AUGRUHiddenGradCell_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"weight_att", ge::kIrInputRequired, ""},
{"dh_pre_t", ge::kIrInputRequired, ""},
{"h", ge::kIrInputRequired, ""},
{"dy", ge::kIrInputRequired, ""},
{"dh", ge::kIrInputRequired, ""},
{"update", ge::kIrInputRequired, ""},
{"update_att", ge::kIrInputRequired, ""},
{"reset", ge::kIrInputRequired, ""},
{"new", ge::kIrInputRequired, ""},
{"hidden_new", ge::kIrInputRequired, ""},
{"seq_length", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"dh_prev", ge::kIrOutputRequired, ""},
{"dgate_h", ge::kIrOutputRequired, ""},
{"dnt_x", ge::kIrOutputRequired, ""},
{"dw_att_t", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"t_state",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(t_state))
},
{
"gate_order",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(gate_order))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight_att->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dh_pre_t->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(h->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dh->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(update->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(update_att->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(reset->GetAnchor(), node->GetInDataAnchor(7)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(in_new->GetAnchor(), node->GetInDataAnchor(8)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(hidden_new->GetAnchor(), node->GetInDataAnchor(9)));
if (seq_length != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seq_length->GetAnchor(), node->GetInDataAnchor(10)));
}
return EsAUGRUHiddenGradCellOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsbTensor *EsAbs(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Abs")
.Name(("Abs_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAbsGrad(EsbTensor *y, EsbTensor *dy) {
GE_ASSERT_NOTNULL(y);
GE_ASSERT_NOTNULL(dy);
auto &graph = y->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AbsGrad")
.Name(("AbsGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"y", ge::kIrInputRequired, ""},
{"dy", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"z", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAccumulateNV2(EsbTensor **x, int64_t x_num, int64_t N) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AccumulateNV2")
.Name(("AccumulateNV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"N",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(N))
},
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAccumulatorApplyGradient(EsbTensor *handle, EsbTensor *local_step, EsbTensor *gradient, ge::DataType dtype) {
GE_ASSERT_NOTNULL(handle);
GE_ASSERT_NOTNULL(local_step);
GE_ASSERT_NOTNULL(gradient);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AccumulatorApplyGradient")
.Name(("AccumulatorApplyGradient_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
{"local_step", ge::kIrInputRequired, ""},
{"gradient", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
{
"dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(local_step->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gradient->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsAccumulatorNumAccumulated(EsbTensor *handle) {
GE_ASSERT_NOTNULL(handle);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AccumulatorNumAccumulated")
.Name(("AccumulatorNumAccumulated_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAccumulatorSetGlobalStep(EsbTensor *handle, EsbTensor *new_global_step) {
GE_ASSERT_NOTNULL(handle);
GE_ASSERT_NOTNULL(new_global_step);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AccumulatorSetGlobalStep")
.Name(("AccumulatorSetGlobalStep_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
{"new_global_step", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(new_global_step->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsAccumulatorTakeGradient(EsbTensor *handle, EsbTensor *num_required, ge::DataType dtype) {
GE_ASSERT_NOTNULL(handle);
GE_ASSERT_NOTNULL(num_required);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AccumulatorTakeGradient")
.Name(("AccumulatorTakeGradient_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
{"num_required", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(num_required->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAcos(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Acos")
.Name(("Acos_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAcosGrad(EsbTensor *y, EsbTensor *dy) {
GE_ASSERT_NOTNULL(y);
GE_ASSERT_NOTNULL(dy);
auto &graph = y->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AcosGrad")
.Name(("AcosGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"y", ge::kIrInputRequired, ""},
{"dy", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"z", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAcosh(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Acosh")
.Name(("Acosh_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAcoshGrad(EsbTensor *y, EsbTensor *dy) {
GE_ASSERT_NOTNULL(y);
GE_ASSERT_NOTNULL(dy);
auto &graph = y->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AcoshGrad")
.Name(("AcoshGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"y", ge::kIrInputRequired, ""},
{"dy", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"z", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsActULQClampMaxGrad(EsbTensor *y_grad, EsbTensor *clamp_max_mask, EsbTensor *x_clamped_loss) {
GE_ASSERT_NOTNULL(y_grad);
GE_ASSERT_NOTNULL(clamp_max_mask);
GE_ASSERT_NOTNULL(x_clamped_loss);
auto &graph = y_grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ActULQClampMaxGrad")
.Name(("ActULQClampMaxGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"y_grad", ge::kIrInputRequired, ""},
{"clamp_max_mask", ge::kIrInputRequired, ""},
{"x_clamped_loss", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"clamp_max_grad", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y_grad->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(clamp_max_mask->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x_clamped_loss->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsActULQClampMinGrad(EsbTensor *y_grad, EsbTensor *clamp_min_mask, EsbTensor *x_clamped_loss) {
GE_ASSERT_NOTNULL(y_grad);
GE_ASSERT_NOTNULL(clamp_min_mask);
GE_ASSERT_NOTNULL(x_clamped_loss);
auto &graph = y_grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ActULQClampMinGrad")
.Name(("ActULQClampMinGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"y_grad", ge::kIrInputRequired, ""},
{"clamp_min_mask", ge::kIrInputRequired, ""},
{"x_clamped_loss", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"clamp_min_grad", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y_grad->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(clamp_min_mask->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x_clamped_loss->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsActiveRotatedFilter(EsbTensor *x, EsbTensor *indices) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(indices);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ActiveRotatedFilter")
.Name(("ActiveRotatedFilter_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsActiveRotatedFilterGrad(EsbTensor *y_grad, EsbTensor *indices) {
GE_ASSERT_NOTNULL(y_grad);
GE_ASSERT_NOTNULL(indices);
auto &graph = y_grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ActiveRotatedFilterGrad")
.Name(("ActiveRotatedFilterGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"y_grad", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"x_grad", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y_grad->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsActsULQOutput EsActsULQ(EsbTensor *x, EsbTensor *clamp_min, EsbTensor *clamp_max, bool fixed_min, int64_t num_bits) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(clamp_min);
GE_ASSERT_NOTNULL(clamp_max);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ActsULQ")
.Name(("ActsULQ_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"clamp_min", ge::kIrInputRequired, ""},
{"clamp_max", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"clamp_min_mask", ge::kIrOutputRequired, ""},
{"clamp_max_mask", ge::kIrOutputRequired, ""},
{"x_clamped_loss", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"fixed_min",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(fixed_min))
},
{
"num_bits",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_bits))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(clamp_min->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(clamp_max->GetAnchor(), node->GetInDataAnchor(2)));
return EsActsULQOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsbTensor *EsActsULQInputGrad(EsbTensor *y_grad, EsbTensor *clamp_min_mask, EsbTensor *clamp_max_mask) {
GE_ASSERT_NOTNULL(y_grad);
GE_ASSERT_NOTNULL(clamp_min_mask);
GE_ASSERT_NOTNULL(clamp_max_mask);
auto &graph = y_grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ActsULQInputGrad")
.Name(("ActsULQInputGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"y_grad", ge::kIrInputRequired, ""},
{"clamp_min_mask", ge::kIrInputRequired, ""},
{"clamp_max_mask", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"x_grad", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y_grad->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(clamp_min_mask->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(clamp_max_mask->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAdaCast(EsbTensor *x, int64_t pixel) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AdaCast")
.Name(("AdaCast_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"pixel",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pixel))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsAdaLayerNormOutput EsAdaLayerNorm(EsbTensor *x, EsbTensor *scale, EsbTensor *shift, float epsilon) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(scale);
GE_ASSERT_NOTNULL(shift);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AdaLayerNorm")
.Name(("AdaLayerNorm_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"scale", ge::kIrInputRequired, ""},
{"shift", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"ln_res", ge::kIrOutputRequired, ""},
{"mean", ge::kIrOutputRequired, ""},
{"rstd", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shift->GetAnchor(), node->GetInDataAnchor(2)));
return EsAdaLayerNormOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsAdaLayerNormGradOutput EsAdaLayerNormGrad(EsbTensor *dy, EsbTensor *x, EsbTensor *mean, EsbTensor *rstd, EsbTensor *scale, EsbTensor *ln_res) {
GE_ASSERT_NOTNULL(dy);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(mean);
GE_ASSERT_NOTNULL(rstd);
GE_ASSERT_NOTNULL(scale);
GE_ASSERT_NOTNULL(ln_res);
auto &graph = dy->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AdaLayerNormGrad")
.Name(("AdaLayerNormGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"dy", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"mean", ge::kIrInputRequired, ""},
{"rstd", ge::kIrInputRequired, ""},
{"scale", ge::kIrInputRequired, ""},
{"ln_res", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"dx", ge::kIrOutputRequired, ""},
{"dshift", ge::kIrOutputRequired, ""},
{"dscale", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rstd->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(ln_res->GetAnchor(), node->GetInDataAnchor(5)));
return EsAdaLayerNormGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsAdamApplyOneOutput EsAdamApplyOne(EsbTensor *input0, EsbTensor *input1, EsbTensor *input2, EsbTensor *input3, EsbTensor *input4, EsbTensor *mul0_x, EsbTensor *mul1_x, EsbTensor *mul2_x, EsbTensor *mul3_x, EsbTensor *add2_y) {
GE_ASSERT_NOTNULL(input0);
GE_ASSERT_NOTNULL(input1);
GE_ASSERT_NOTNULL(input2);
GE_ASSERT_NOTNULL(input3);
GE_ASSERT_NOTNULL(input4);
GE_ASSERT_NOTNULL(mul0_x);
GE_ASSERT_NOTNULL(mul1_x);
GE_ASSERT_NOTNULL(mul2_x);
GE_ASSERT_NOTNULL(mul3_x);
GE_ASSERT_NOTNULL(add2_y);
auto &graph = input0->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AdamApplyOne")
.Name(("AdamApplyOne_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input0", ge::kIrInputRequired, ""},
{"input1", ge::kIrInputRequired, ""},
{"input2", ge::kIrInputRequired, ""},
{"input3", ge::kIrInputRequired, ""},
{"input4", ge::kIrInputRequired, ""},
{"mul0_x", ge::kIrInputRequired, ""},
{"mul1_x", ge::kIrInputRequired, ""},
{"mul2_x", ge::kIrInputRequired, ""},
{"mul3_x", ge::kIrInputRequired, ""},
{"add2_y", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output0", ge::kIrOutputRequired, ""},
{"output1", ge::kIrOutputRequired, ""},
{"output2", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input0->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input1->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input2->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input3->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input4->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mul0_x->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mul1_x->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mul2_x->GetAnchor(), node->GetInDataAnchor(7)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mul3_x->GetAnchor(), node->GetInDataAnchor(8)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(add2_y->GetAnchor(), node->GetInDataAnchor(9)));
return EsAdamApplyOneOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsAdamApplyOneAssignOutput EsAdamApplyOneAssign(EsbTensor *input0, EsbTensor *input1, EsbTensor *input2, EsbTensor *input3, EsbTensor *input4, EsbTensor *mul0_x, EsbTensor *mul1_x, EsbTensor *mul2_x, EsbTensor *mul3_x, EsbTensor *add2_y) {
GE_ASSERT_NOTNULL(input0);
GE_ASSERT_NOTNULL(input1);
GE_ASSERT_NOTNULL(input2);
GE_ASSERT_NOTNULL(input3);
GE_ASSERT_NOTNULL(input4);
GE_ASSERT_NOTNULL(mul0_x);
GE_ASSERT_NOTNULL(mul1_x);
GE_ASSERT_NOTNULL(mul2_x);
GE_ASSERT_NOTNULL(mul3_x);
GE_ASSERT_NOTNULL(add2_y);
auto &graph = input0->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AdamApplyOneAssign")
.Name(("AdamApplyOneAssign_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input0", ge::kIrInputRequired, ""},
{"input1", ge::kIrInputRequired, ""},
{"input2", ge::kIrInputRequired, ""},
{"input3", ge::kIrInputRequired, ""},
{"input4", ge::kIrInputRequired, ""},
{"mul0_x", ge::kIrInputRequired, ""},
{"mul1_x", ge::kIrInputRequired, ""},
{"mul2_x", ge::kIrInputRequired, ""},
{"mul3_x", ge::kIrInputRequired, ""},
{"add2_y", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"input1", ge::kIrOutputRequired, ""},
{"input2", ge::kIrOutputRequired, ""},
{"input3", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input0->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input1->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input2->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input3->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input4->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mul0_x->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mul1_x->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mul2_x->GetAnchor(), node->GetInDataAnchor(7)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mul3_x->GetAnchor(), node->GetInDataAnchor(8)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(add2_y->GetAnchor(), node->GetInDataAnchor(9)));
return EsAdamApplyOneAssignOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsAdamApplyOneWithDecayOutput EsAdamApplyOneWithDecay(EsbTensor *input0, EsbTensor *input1, EsbTensor *input2, EsbTensor *input3, EsbTensor *input4, EsbTensor *mul0_x, EsbTensor *mul1_x, EsbTensor *mul2_x, EsbTensor *mul3_x, EsbTensor *mul4_x, EsbTensor *add2_y) {
GE_ASSERT_NOTNULL(input0);
GE_ASSERT_NOTNULL(input1);
GE_ASSERT_NOTNULL(input2);
GE_ASSERT_NOTNULL(input3);
GE_ASSERT_NOTNULL(input4);
GE_ASSERT_NOTNULL(mul0_x);
GE_ASSERT_NOTNULL(mul1_x);
GE_ASSERT_NOTNULL(mul2_x);
GE_ASSERT_NOTNULL(mul3_x);
GE_ASSERT_NOTNULL(mul4_x);
GE_ASSERT_NOTNULL(add2_y);
auto &graph = input0->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AdamApplyOneWithDecay")
.Name(("AdamApplyOneWithDecay_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input0", ge::kIrInputRequired, ""},
{"input1", ge::kIrInputRequired, ""},
{"input2", ge::kIrInputRequired, ""},
{"input3", ge::kIrInputRequired, ""},
{"input4", ge::kIrInputRequired, ""},
{"mul0_x", ge::kIrInputRequired, ""},
{"mul1_x", ge::kIrInputRequired, ""},
{"mul2_x", ge::kIrInputRequired, ""},
{"mul3_x", ge::kIrInputRequired, ""},
{"mul4_x", ge::kIrInputRequired, ""},
{"add2_y", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output0", ge::kIrOutputRequired, ""},
{"output1", ge::kIrOutputRequired, ""},
{"output2", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input0->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input1->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input2->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input3->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input4->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mul0_x->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mul1_x->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mul2_x->GetAnchor(), node->GetInDataAnchor(7)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mul3_x->GetAnchor(), node->GetInDataAnchor(8)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mul4_x->GetAnchor(), node->GetInDataAnchor(9)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(add2_y->GetAnchor(), node->GetInDataAnchor(10)));
return EsAdamApplyOneWithDecayOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsAdamApplyOneWithDecayAssignOutput EsAdamApplyOneWithDecayAssign(EsbTensor *input0, EsbTensor *input1, EsbTensor *input2, EsbTensor *input3, EsbTensor *input4, EsbTensor *mul0_x, EsbTensor *mul1_x, EsbTensor *mul2_x, EsbTensor *mul3_x, EsbTensor *mul4_x, EsbTensor *add2_y) {
GE_ASSERT_NOTNULL(input0);
GE_ASSERT_NOTNULL(input1);
GE_ASSERT_NOTNULL(input2);
GE_ASSERT_NOTNULL(input3);
GE_ASSERT_NOTNULL(input4);
GE_ASSERT_NOTNULL(mul0_x);
GE_ASSERT_NOTNULL(mul1_x);
GE_ASSERT_NOTNULL(mul2_x);
GE_ASSERT_NOTNULL(mul3_x);
GE_ASSERT_NOTNULL(mul4_x);
GE_ASSERT_NOTNULL(add2_y);
auto &graph = input0->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AdamApplyOneWithDecayAssign")
.Name(("AdamApplyOneWithDecayAssign_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input0", ge::kIrInputRequired, ""},
{"input1", ge::kIrInputRequired, ""},
{"input2", ge::kIrInputRequired, ""},
{"input3", ge::kIrInputRequired, ""},
{"input4", ge::kIrInputRequired, ""},
{"mul0_x", ge::kIrInputRequired, ""},
{"mul1_x", ge::kIrInputRequired, ""},
{"mul2_x", ge::kIrInputRequired, ""},
{"mul3_x", ge::kIrInputRequired, ""},
{"mul4_x", ge::kIrInputRequired, ""},
{"add2_y", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"input1", ge::kIrOutputRequired, ""},
{"input2", ge::kIrOutputRequired, ""},
{"input3", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input0->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input1->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input2->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input3->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input4->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mul0_x->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mul1_x->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mul2_x->GetAnchor(), node->GetInDataAnchor(7)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mul3_x->GetAnchor(), node->GetInDataAnchor(8)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mul4_x->GetAnchor(), node->GetInDataAnchor(9)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(add2_y->GetAnchor(), node->GetInDataAnchor(10)));
return EsAdamApplyOneWithDecayAssignOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsAdaptiveAvgPool(EsbTensor *x, EsbTensor *output_size) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(output_size);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AdaptiveAvgPool")
.Name(("AdaptiveAvgPool_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"output_size", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(output_size->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAdaptiveAvgPool2d(EsbTensor *x, const int64_t *output_size, int64_t output_size_num) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AdaptiveAvgPool2d")
.Name(("AdaptiveAvgPool2d_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"output_size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(output_size, output_size + output_size_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsAdaptiveAvgPool2dAssistMatrixOutput EsAdaptiveAvgPool2dAssistMatrix(EsbTensor *input_size, const int64_t *output_size, int64_t output_size_num) {
GE_ASSERT_NOTNULL(input_size);
auto &graph = input_size->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AdaptiveAvgPool2dAssistMatrix")
.Name(("AdaptiveAvgPool2dAssistMatrix_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_size", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"left_matrix", ge::kIrOutputRequired, ""},
{"right_matrix", ge::kIrOutputRequired, ""},
{"weight_matrix", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"output_size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(output_size, output_size + output_size_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_size->GetAnchor(), node->GetInDataAnchor(0)));
return EsAdaptiveAvgPool2dAssistMatrixOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsAdaptiveAvgPool2dGrad(EsbTensor *input_grad, const int64_t *orig_input_shape, int64_t orig_input_shape_num) {
GE_ASSERT_NOTNULL(input_grad);
auto &graph = input_grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AdaptiveAvgPool2dGrad")
.Name(("AdaptiveAvgPool2dGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_grad", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_grad", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"orig_input_shape",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(orig_input_shape, orig_input_shape + orig_input_shape_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_grad->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAdaptiveAvgPool3d(EsbTensor *x, const int64_t *output_size, int64_t output_size_num, const char *data_format) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AdaptiveAvgPool3d")
.Name(("AdaptiveAvgPool3d_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"output_size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(output_size, output_size + output_size_num))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsAdaptiveAvgPoolAssistMatrixOutput EsAdaptiveAvgPoolAssistMatrix(EsbTensor *input_size, EsbTensor *output_size) {
GE_ASSERT_NOTNULL(input_size);
GE_ASSERT_NOTNULL(output_size);
auto &graph = input_size->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AdaptiveAvgPoolAssistMatrix")
.Name(("AdaptiveAvgPoolAssistMatrix_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_size", ge::kIrInputRequired, ""},
{"output_size", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"left_matrix", ge::kIrOutputRequired, ""},
{"right_matrix", ge::kIrOutputRequired, ""},
{"weight_matrix", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_size->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(output_size->GetAnchor(), node->GetInDataAnchor(1)));
return EsAdaptiveAvgPoolAssistMatrixOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsAdaptiveMaxPool2dOutput EsAdaptiveMaxPool2d(EsbTensor *x, const int64_t *output_size, int64_t output_size_num) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AdaptiveMaxPool2d")
.Name(("AdaptiveMaxPool2d_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"argmax", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"output_size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(output_size, output_size + output_size_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return EsAdaptiveMaxPool2dOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsAdd(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Add")
.Name(("Add_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsAddLayerNormOutput EsAddLayerNorm(EsbTensor *x1, EsbTensor *x2, EsbTensor *gamma, EsbTensor *beta, EsbTensor *bias, float epsilon, bool additional_output) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
GE_ASSERT_NOTNULL(gamma);
GE_ASSERT_NOTNULL(beta);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AddLayerNorm")
.Name(("AddLayerNorm_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
{"beta", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"mean", ge::kIrOutputRequired, ""},
{"rstd", ge::kIrOutputRequired, ""},
{"x", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
{
"additional_output",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(additional_output))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta->GetAnchor(), node->GetInDataAnchor(3)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(4)));
}
return EsAddLayerNormOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsAddLayerNormGradOutput EsAddLayerNormGrad(EsbTensor *dy, EsbTensor *x1, EsbTensor *x2, EsbTensor *rstd, EsbTensor *mean, EsbTensor *gamma, EsbTensor *dsum) {
GE_ASSERT_NOTNULL(dy);
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
GE_ASSERT_NOTNULL(rstd);
GE_ASSERT_NOTNULL(mean);
GE_ASSERT_NOTNULL(gamma);
auto &graph = dy->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AddLayerNormGrad")
.Name(("AddLayerNormGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"dy", ge::kIrInputRequired, ""},
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"rstd", ge::kIrInputRequired, ""},
{"mean", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
{"dsum", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"dx", ge::kIrOutputRequired, ""},
{"dgamma", ge::kIrOutputRequired, ""},
{"dbeta", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rstd->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(5)));
if (dsum != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dsum->GetAnchor(), node->GetInDataAnchor(6)));
}
return EsAddLayerNormGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsAddLayerNormQuantOutput EsAddLayerNormQuant(EsbTensor *x1, EsbTensor *x2, EsbTensor *gamma, EsbTensor *beta, EsbTensor *bias, EsbTensor *scales1, EsbTensor *scales2, EsbTensor *zero_points1, EsbTensor *zero_points2, const char *quant_mode, float epsilon, bool additional_output) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
GE_ASSERT_NOTNULL(gamma);
GE_ASSERT_NOTNULL(beta);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AddLayerNormQuant")
.Name(("AddLayerNormQuant_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
{"beta", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
{"scales1", ge::kIrInputOptional, ""},
{"scales2", ge::kIrInputOptional, ""},
{"zero_points1", ge::kIrInputOptional, ""},
{"zero_points2", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y1", ge::kIrOutputRequired, ""},
{"y2", ge::kIrOutputRequired, ""},
{"x", ge::kIrOutputRequired, ""},
{"out_scales1", ge::kIrOutputRequired, ""},
{"out_scales2", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"quant_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(quant_mode))
},
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
{
"additional_output",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(additional_output))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta->GetAnchor(), node->GetInDataAnchor(3)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(4)));
}
if (scales1 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scales1->GetAnchor(), node->GetInDataAnchor(5)));
}
if (scales2 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scales2->GetAnchor(), node->GetInDataAnchor(6)));
}
if (zero_points1 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(zero_points1->GetAnchor(), node->GetInDataAnchor(7)));
}
if (zero_points2 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(zero_points2->GetAnchor(), node->GetInDataAnchor(8)));
}
return EsAddLayerNormQuantOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
};
}
EsbTensor *EsAddManySparseToTensorsMap(EsbTensor *indices, EsbTensor *values, EsbTensor *shape, const char *container, const char *shared_name) {
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(values);
GE_ASSERT_NOTNULL(shape);
auto &graph = indices->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AddManySparseToTensorsMap")
.Name(("AddManySparseToTensorsMap_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"indices", ge::kIrInputRequired, ""},
{"values", ge::kIrInputRequired, ""},
{"shape", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"handles", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"container",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(container))
},
{
"shared_name",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(shared_name))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(values->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAddMatMatElements(EsbTensor *c, EsbTensor *a, EsbTensor *b, EsbTensor *beta, EsbTensor *alpha) {
GE_ASSERT_NOTNULL(c);
GE_ASSERT_NOTNULL(a);
GE_ASSERT_NOTNULL(b);
GE_ASSERT_NOTNULL(beta);
GE_ASSERT_NOTNULL(alpha);
auto &graph = c->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AddMatMatElements")
.Name(("AddMatMatElements_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"c", ge::kIrInputRequired, ""},
{"a", ge::kIrInputRequired, ""},
{"b", ge::kIrInputRequired, ""},
{"beta", ge::kIrInputRequired, ""},
{"alpha", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"c", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(c->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(a->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(b->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(alpha->GetAnchor(), node->GetInDataAnchor(4)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAddN(EsbTensor **x, int64_t x_num, int64_t N) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AddN")
.Name(("AddN_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"N",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(N))
},
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsAddRmsNormOutput EsAddRmsNorm(EsbTensor *x1, EsbTensor *x2, EsbTensor *gamma, float epsilon) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
GE_ASSERT_NOTNULL(gamma);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AddRmsNorm")
.Name(("AddRmsNorm_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"rstd", ge::kIrOutputRequired, ""},
{"x", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(2)));
return EsAddRmsNormOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsAddRmsNormDynamicQuantOutput EsAddRmsNormDynamicQuant(EsbTensor *x1, EsbTensor *x2, EsbTensor *gamma, EsbTensor *smooth_scale1, EsbTensor *smooth_scale2, float epsilon) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
GE_ASSERT_NOTNULL(gamma);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AddRmsNormDynamicQuant")
.Name(("AddRmsNormDynamicQuant_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
{"smooth_scale1", ge::kIrInputOptional, ""},
{"smooth_scale2", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y1", ge::kIrOutputRequired, ""},
{"y2", ge::kIrOutputRequired, ""},
{"x", ge::kIrOutputRequired, ""},
{"scale1", ge::kIrOutputRequired, ""},
{"scale2", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(2)));
if (smooth_scale1 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(smooth_scale1->GetAnchor(), node->GetInDataAnchor(3)));
}
if (smooth_scale2 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(smooth_scale2->GetAnchor(), node->GetInDataAnchor(4)));
}
return EsAddRmsNormDynamicQuantOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
};
}
EsAddRmsNormQuantOutput EsAddRmsNormQuant(EsbTensor *x1, EsbTensor *x2, EsbTensor *gamma, EsbTensor *scales1, EsbTensor *scales2, EsbTensor *zero_points1, EsbTensor *zero_points2, int64_t axis, float epsilon) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
GE_ASSERT_NOTNULL(gamma);
GE_ASSERT_NOTNULL(scales1);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AddRmsNormQuant")
.Name(("AddRmsNormQuant_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
{"scales1", ge::kIrInputRequired, ""},
{"scales2", ge::kIrInputOptional, ""},
{"zero_points1", ge::kIrInputOptional, ""},
{"zero_points2", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y1", ge::kIrOutputRequired, ""},
{"y2", ge::kIrOutputRequired, ""},
{"x", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scales1->GetAnchor(), node->GetInDataAnchor(3)));
if (scales2 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scales2->GetAnchor(), node->GetInDataAnchor(4)));
}
if (zero_points1 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(zero_points1->GetAnchor(), node->GetInDataAnchor(5)));
}
if (zero_points2 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(zero_points2->GetAnchor(), node->GetInDataAnchor(6)));
}
return EsAddRmsNormQuantOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsAddRowRanges(EsbTensor *x, EsbTensor *src, EsbTensor *indices) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(src);
GE_ASSERT_NOTNULL(indices);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AddRowRanges")
.Name(("AddRowRanges_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"src", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"x", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(src->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAddSparseToTensorsMap(EsbTensor *indices, EsbTensor *values, EsbTensor *shape, const char *container, const char *shared_name) {
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(values);
GE_ASSERT_NOTNULL(shape);
auto &graph = indices->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AddSparseToTensorsMap")
.Name(("AddSparseToTensorsMap_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"indices", ge::kIrInputRequired, ""},
{"values", ge::kIrInputRequired, ""},
{"shape", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"handle", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"container",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(container))
},
{
"shared_name",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(shared_name))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(values->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAddV2(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AddV2")
.Name(("AddV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAddcdiv(EsbTensor *input_data, EsbTensor *x1, EsbTensor *x2, EsbTensor *value) {
GE_ASSERT_NOTNULL(input_data);
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
GE_ASSERT_NOTNULL(value);
auto &graph = input_data->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Addcdiv")
.Name(("Addcdiv_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_data", ge::kIrInputRequired, ""},
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"value", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_data->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAddcmul(EsbTensor *input_data, EsbTensor *x1, EsbTensor *x2, EsbTensor *value) {
GE_ASSERT_NOTNULL(input_data);
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
GE_ASSERT_NOTNULL(value);
auto &graph = input_data->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Addcmul")
.Name(("Addcmul_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_data", ge::kIrInputRequired, ""},
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"value", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_data->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAdds(EsbTensor *x, float value) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Adds")
.Name(("Adds_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"value",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(value))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAdjustBrightness(EsbTensor *images, EsbTensor *delta) {
GE_ASSERT_NOTNULL(images);
GE_ASSERT_NOTNULL(delta);
auto &graph = images->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AdjustBrightness")
.Name(("AdjustBrightness_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"images", ge::kIrInputRequired, ""},
{"delta", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(images->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(delta->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAdjustBrightnessV2(EsbTensor *images, EsbTensor *factor) {
GE_ASSERT_NOTNULL(images);
GE_ASSERT_NOTNULL(factor);
auto &graph = images->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AdjustBrightnessV2")
.Name(("AdjustBrightnessV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"images", ge::kIrInputRequired, ""},
{"factor", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(images->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(factor->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAdjustContrast(EsbTensor *images, EsbTensor *contrast_factor, const char *data_format, const char *mean_mode) {
GE_ASSERT_NOTNULL(images);
GE_ASSERT_NOTNULL(contrast_factor);
auto &graph = images->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AdjustContrast")
.Name(("AdjustContrast_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"images", ge::kIrInputRequired, ""},
{"contrast_factor", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"mean_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(mean_mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(images->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(contrast_factor->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAdjustContrastWithMean(EsbTensor *images, EsbTensor *mean, EsbTensor *contrast_factor, const char *data_format) {
GE_ASSERT_NOTNULL(images);
GE_ASSERT_NOTNULL(mean);
GE_ASSERT_NOTNULL(contrast_factor);
auto &graph = images->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AdjustContrastWithMean")
.Name(("AdjustContrastWithMean_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"images", ge::kIrInputRequired, ""},
{"mean", ge::kIrInputRequired, ""},
{"contrast_factor", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(images->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(contrast_factor->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAdjustHue(EsbTensor *images, EsbTensor *delta, const char *data_format) {
GE_ASSERT_NOTNULL(images);
GE_ASSERT_NOTNULL(delta);
auto &graph = images->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AdjustHue")
.Name(("AdjustHue_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"images", ge::kIrInputRequired, ""},
{"delta", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(images->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(delta->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAdjustSaturation(EsbTensor *images, EsbTensor *scale) {
GE_ASSERT_NOTNULL(images);
GE_ASSERT_NOTNULL(scale);
auto &graph = images->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AdjustSaturation")
.Name(("AdjustSaturation_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"images", ge::kIrInputRequired, ""},
{"scale", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(images->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAdjustSaturationV2(EsbTensor *images, EsbTensor *scale, const char *data_format) {
GE_ASSERT_NOTNULL(images);
GE_ASSERT_NOTNULL(scale);
auto &graph = images->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AdjustSaturationV2")
.Name(("AdjustSaturationV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"images", ge::kIrInputRequired, ""},
{"scale", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(images->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAffineGrid(EsbTensor *theta, EsbTensor *output_size, bool align_corners) {
GE_ASSERT_NOTNULL(theta);
GE_ASSERT_NOTNULL(output_size);
auto &graph = theta->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AffineGrid")
.Name(("AffineGrid_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"theta", ge::kIrInputRequired, ""},
{"output_size", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"align_corners",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(align_corners))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(theta->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(output_size->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAipp(EsbTensor *images, EsbTensor *params, const char *aipp_config_path) {
GE_ASSERT_NOTNULL(images);
auto &graph = images->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Aipp")
.Name(("Aipp_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"images", ge::kIrInputRequired, ""},
{"params", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"features", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"aipp_config_path",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(aipp_config_path))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(images->GetAnchor(), node->GetInDataAnchor(0)));
if (params != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(params->GetAnchor(), node->GetInDataAnchor(1)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsAllCandidateSamplerOutput EsAllCandidateSampler(EsbTensor *true_classes, int64_t num_true, int64_t num_sampled, bool unique, int64_t seed, int64_t seed2) {
GE_ASSERT_NOTNULL(true_classes);
auto &graph = true_classes->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AllCandidateSampler")
.Name(("AllCandidateSampler_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"true_classes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"sampled_candidates", ge::kIrOutputRequired, ""},
{"true_expected_count", ge::kIrOutputRequired, ""},
{"sampled_expected_count", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_true",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_true))
},
{
"num_sampled",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_sampled))
},
{
"unique",
ge::kAttrRequired,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(unique))
},
{
"seed",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed))
},
{
"seed2",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed2))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(true_classes->GetAnchor(), node->GetInDataAnchor(0)));
return EsAllCandidateSamplerOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsAllGatherMatmulOutput EsAllGatherMatmul(EsbTensor *x1, EsbTensor *x2, EsbTensor *bias, const char *group, bool is_trans_a, bool is_trans_b, int64_t gather_index, int64_t comm_turn, int64_t rank_size, bool is_gather_out) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AllGatherMatmul")
.Name(("AllGatherMatmul_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"gather_out", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"group",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(group))
},
{
"is_trans_a",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_trans_a))
},
{
"is_trans_b",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_trans_b))
},
{
"gather_index",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(gather_index))
},
{
"comm_turn",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(comm_turn))
},
{
"rank_size",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(rank_size))
},
{
"is_gather_out",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_gather_out))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(2)));
}
return EsAllGatherMatmulOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsAlltoAllAllGatherBatchMatMulOutput EsAlltoAllAllGatherBatchMatMul(EsbTensor *x, EsbTensor *weight, EsbTensor *bias, const char *group_ep, const char *group_tp, int64_t ep_world_size, int64_t tp_world_size, int64_t x_shard_type, int64_t act_type, bool transpose_weight, bool output_y2_flag, bool output_y3_flag) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(weight);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AlltoAllAllGatherBatchMatMul")
.Name(("AlltoAllAllGatherBatchMatMul_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"weight", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y1", ge::kIrOutputRequired, ""},
{"y2", ge::kIrOutputRequired, ""},
{"y3", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"group_ep",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(group_ep))
},
{
"group_tp",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(group_tp))
},
{
"ep_world_size",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(ep_world_size))
},
{
"tp_world_size",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(tp_world_size))
},
{
"x_shard_type",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(x_shard_type))
},
{
"act_type",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(act_type))
},
{
"transpose_weight",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(transpose_weight))
},
{
"output_y2_flag",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(output_y2_flag))
},
{
"output_y3_flag",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(output_y3_flag))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight->GetAnchor(), node->GetInDataAnchor(1)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(2)));
}
return EsAlltoAllAllGatherBatchMatMulOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsAmpUpdateScaleOutput EsAmpUpdateScale(EsbTensor *current_scale, EsbTensor *growth_tracker, EsbTensor *found_inf, float growth_factor, float backoff_factor, int64_t growth_interval) {
GE_ASSERT_NOTNULL(current_scale);
GE_ASSERT_NOTNULL(growth_tracker);
GE_ASSERT_NOTNULL(found_inf);
auto &graph = current_scale->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AmpUpdateScale")
.Name(("AmpUpdateScale_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"current_scale", ge::kIrInputRequired, ""},
{"growth_tracker", ge::kIrInputRequired, ""},
{"found_inf", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"updated_scale", ge::kIrOutputRequired, ""},
{"updated_growth_tracker", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"growth_factor",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(growth_factor))
},
{
"backoff_factor",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(backoff_factor))
},
{
"growth_interval",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(growth_interval))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(current_scale->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(growth_tracker->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(found_inf->GetAnchor(), node->GetInDataAnchor(2)));
return EsAmpUpdateScaleOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsAnchorResponseFlags(EsbTensor *gt_bboxes, const int64_t *featmap_size, int64_t featmap_size_num, const int64_t *strides, int64_t strides_num, int64_t num_base_anchors) {
GE_ASSERT_NOTNULL(gt_bboxes);
auto &graph = gt_bboxes->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AnchorResponseFlags")
.Name(("AnchorResponseFlags_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"gt_bboxes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"flags", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"featmap_size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(featmap_size, featmap_size + featmap_size_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"num_base_anchors",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_base_anchors))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gt_bboxes->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAngle(EsbTensor *input, ge::DataType Tout) {
GE_ASSERT_NOTNULL(input);
auto &graph = input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Angle")
.Name(("Angle_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"Tout",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(Tout))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAngleV2(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AngleV2")
.Name(("AngleV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsAnonymousSeedGeneratorOutput EsAnonymousSeedGenerator(EsbTensor *seed, EsbTensor *seed2, EsbTensor *reshuffle) {
GE_ASSERT_NOTNULL(seed);
GE_ASSERT_NOTNULL(seed2);
GE_ASSERT_NOTNULL(reshuffle);
auto &graph = seed->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AnonymousSeedGenerator")
.Name(("AnonymousSeedGenerator_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"seed", ge::kIrInputRequired, ""},
{"seed2", ge::kIrInputRequired, ""},
{"reshuffle", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"handle", ge::kIrOutputRequired, ""},
{"deleter", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seed->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seed2->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(reshuffle->GetAnchor(), node->GetInDataAnchor(2)));
return EsAnonymousSeedGeneratorOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsApplyAdaMax(EsbTensor *var, EsbTensor *m, EsbTensor *v, EsbTensor *beta1_power, EsbTensor *lr, EsbTensor *beta1, EsbTensor *beta2, EsbTensor *epsilon, EsbTensor *grad, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(m);
GE_ASSERT_NOTNULL(v);
GE_ASSERT_NOTNULL(beta1_power);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(beta1);
GE_ASSERT_NOTNULL(beta2);
GE_ASSERT_NOTNULL(epsilon);
GE_ASSERT_NOTNULL(grad);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyAdaMax")
.Name(("ApplyAdaMax_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"m", ge::kIrInputRequired, ""},
{"v", ge::kIrInputRequired, ""},
{"beta1_power", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"beta1", ge::kIrInputRequired, ""},
{"beta2", ge::kIrInputRequired, ""},
{"epsilon", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(m->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(v->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta1_power->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta1->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta2->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(epsilon->GetAnchor(), node->GetInDataAnchor(7)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(8)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsApplyAdaMaxDOutput EsApplyAdaMaxD(EsbTensor *var, EsbTensor *m, EsbTensor *v, EsbTensor *beta1_power, EsbTensor *lr, EsbTensor *beta1, EsbTensor *beta2, EsbTensor *epsilon, EsbTensor *grad, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(m);
GE_ASSERT_NOTNULL(v);
GE_ASSERT_NOTNULL(beta1_power);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(beta1);
GE_ASSERT_NOTNULL(beta2);
GE_ASSERT_NOTNULL(epsilon);
GE_ASSERT_NOTNULL(grad);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyAdaMaxD")
.Name(("ApplyAdaMaxD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"m", ge::kIrInputRequired, ""},
{"v", ge::kIrInputRequired, ""},
{"beta1_power", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"beta1", ge::kIrInputRequired, ""},
{"beta2", ge::kIrInputRequired, ""},
{"epsilon", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"m", ge::kIrOutputRequired, ""},
{"v", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(m->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(v->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta1_power->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta1->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta2->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(epsilon->GetAnchor(), node->GetInDataAnchor(7)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(8)));
return EsApplyAdaMaxDOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsApplyAdadelta(EsbTensor *var, EsbTensor *accum, EsbTensor *accum_update, EsbTensor *lr, EsbTensor *rho, EsbTensor *epsilon, EsbTensor *grad, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(accum);
GE_ASSERT_NOTNULL(accum_update);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(rho);
GE_ASSERT_NOTNULL(epsilon);
GE_ASSERT_NOTNULL(grad);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyAdadelta")
.Name(("ApplyAdadelta_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"accum", ge::kIrInputRequired, ""},
{"accum_update", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"rho", ge::kIrInputRequired, ""},
{"epsilon", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum_update->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rho->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(epsilon->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(6)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsApplyAdadeltaDOutput EsApplyAdadeltaD(EsbTensor *var, EsbTensor *accum, EsbTensor *accum_update, EsbTensor *lr, EsbTensor *rho, EsbTensor *epsilon, EsbTensor *grad, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(accum);
GE_ASSERT_NOTNULL(accum_update);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(rho);
GE_ASSERT_NOTNULL(epsilon);
GE_ASSERT_NOTNULL(grad);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyAdadeltaD")
.Name(("ApplyAdadeltaD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"accum", ge::kIrInputRequired, ""},
{"accum_update", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"rho", ge::kIrInputRequired, ""},
{"epsilon", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"accum", ge::kIrOutputRequired, ""},
{"accum_update", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum_update->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rho->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(epsilon->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(6)));
return EsApplyAdadeltaDOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsApplyAdagrad(EsbTensor *var, EsbTensor *accum, EsbTensor *lr, EsbTensor *grad, bool update_slots, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(accum);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(grad);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyAdagrad")
.Name(("ApplyAdagrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"accum", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"update_slots",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(update_slots))
},
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsApplyAdagradDOutput EsApplyAdagradD(EsbTensor *var, EsbTensor *accum, EsbTensor *lr, EsbTensor *grad, bool update_slots, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(accum);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(grad);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyAdagradD")
.Name(("ApplyAdagradD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"accum", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"accum", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"update_slots",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(update_slots))
},
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(3)));
return EsApplyAdagradDOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsApplyAdagradDA(EsbTensor *var, EsbTensor *gradient_accumulator, EsbTensor *gradient_squared_accumulator, EsbTensor *grad, EsbTensor *lr, EsbTensor *l1, EsbTensor *l2, EsbTensor *global_step, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(gradient_accumulator);
GE_ASSERT_NOTNULL(gradient_squared_accumulator);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(l1);
GE_ASSERT_NOTNULL(l2);
GE_ASSERT_NOTNULL(global_step);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyAdagradDA")
.Name(("ApplyAdagradDA_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"gradient_accumulator", ge::kIrInputRequired, ""},
{"gradient_squared_accumulator", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"l1", ge::kIrInputRequired, ""},
{"l2", ge::kIrInputRequired, ""},
{"global_step", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gradient_accumulator->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gradient_squared_accumulator->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(l1->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(l2->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(global_step->GetAnchor(), node->GetInDataAnchor(7)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsApplyAdagradDADOutput EsApplyAdagradDAD(EsbTensor *var, EsbTensor *gradient_accumulator, EsbTensor *gradient_squared_accumulator, EsbTensor *grad, EsbTensor *lr, EsbTensor *l1, EsbTensor *l2, EsbTensor *global_step, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(gradient_accumulator);
GE_ASSERT_NOTNULL(gradient_squared_accumulator);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(l1);
GE_ASSERT_NOTNULL(l2);
GE_ASSERT_NOTNULL(global_step);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyAdagradDAD")
.Name(("ApplyAdagradDAD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"gradient_accumulator", ge::kIrInputRequired, ""},
{"gradient_squared_accumulator", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"l1", ge::kIrInputRequired, ""},
{"l2", ge::kIrInputRequired, ""},
{"global_step", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"gradient_accumulator", ge::kIrOutputRequired, ""},
{"gradient_squared_accumulator", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gradient_accumulator->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gradient_squared_accumulator->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(l1->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(l2->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(global_step->GetAnchor(), node->GetInDataAnchor(7)));
return EsApplyAdagradDADOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsApplyAdagradV2(EsbTensor *var, EsbTensor *accum, EsbTensor *lr, EsbTensor *epsilon, EsbTensor *grad, bool update_slots, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(accum);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(epsilon);
GE_ASSERT_NOTNULL(grad);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyAdagradV2")
.Name(("ApplyAdagradV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"accum", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"epsilon", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"update_slots",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(update_slots))
},
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(epsilon->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(4)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsApplyAdagradV2DOutput EsApplyAdagradV2D(EsbTensor *var, EsbTensor *accum, EsbTensor *lr, EsbTensor *grad, float epsilon, bool update_slots, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(accum);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(grad);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyAdagradV2D")
.Name(("ApplyAdagradV2D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"accum", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"accum", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"epsilon",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
{
"update_slots",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(update_slots))
},
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(3)));
return EsApplyAdagradV2DOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsApplyAdam(EsbTensor *var, EsbTensor *m, EsbTensor *v, EsbTensor *beta1_power, EsbTensor *beta2_power, EsbTensor *lr, EsbTensor *beta1, EsbTensor *beta2, EsbTensor *epsilon, EsbTensor *grad, bool use_locking, bool use_nesterov) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(m);
GE_ASSERT_NOTNULL(v);
GE_ASSERT_NOTNULL(beta1_power);
GE_ASSERT_NOTNULL(beta2_power);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(beta1);
GE_ASSERT_NOTNULL(beta2);
GE_ASSERT_NOTNULL(epsilon);
GE_ASSERT_NOTNULL(grad);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyAdam")
.Name(("ApplyAdam_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"m", ge::kIrInputRequired, ""},
{"v", ge::kIrInputRequired, ""},
{"beta1_power", ge::kIrInputRequired, ""},
{"beta2_power", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"beta1", ge::kIrInputRequired, ""},
{"beta2", ge::kIrInputRequired, ""},
{"epsilon", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
{
"use_nesterov",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_nesterov))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(m->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(v->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta1_power->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta2_power->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta1->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta2->GetAnchor(), node->GetInDataAnchor(7)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(epsilon->GetAnchor(), node->GetInDataAnchor(8)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(9)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsApplyAdamDOutput EsApplyAdamD(EsbTensor *var, EsbTensor *m, EsbTensor *v, EsbTensor *beta1_power, EsbTensor *beta2_power, EsbTensor *lr, EsbTensor *beta1, EsbTensor *beta2, EsbTensor *epsilon, EsbTensor *grad, bool use_locking, bool use_nesterov) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(m);
GE_ASSERT_NOTNULL(v);
GE_ASSERT_NOTNULL(beta1_power);
GE_ASSERT_NOTNULL(beta2_power);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(beta1);
GE_ASSERT_NOTNULL(beta2);
GE_ASSERT_NOTNULL(epsilon);
GE_ASSERT_NOTNULL(grad);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyAdamD")
.Name(("ApplyAdamD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"m", ge::kIrInputRequired, ""},
{"v", ge::kIrInputRequired, ""},
{"beta1_power", ge::kIrInputRequired, ""},
{"beta2_power", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"beta1", ge::kIrInputRequired, ""},
{"beta2", ge::kIrInputRequired, ""},
{"epsilon", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"m", ge::kIrOutputRequired, ""},
{"v", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
{
"use_nesterov",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_nesterov))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(m->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(v->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta1_power->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta2_power->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta1->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta2->GetAnchor(), node->GetInDataAnchor(7)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(epsilon->GetAnchor(), node->GetInDataAnchor(8)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(9)));
return EsApplyAdamDOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsApplyAdamV2Output EsApplyAdamV2(EsbTensor *var, EsbTensor *m, EsbTensor *v, EsbTensor *lr, EsbTensor *beta1, EsbTensor *beta2, EsbTensor *epsilon, EsbTensor *grad, EsbTensor *max_grad_norm, EsbTensor *global_grad_norm, EsbTensor *weight_decay, EsbTensor *step_size, const char *adam_mode) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(m);
GE_ASSERT_NOTNULL(v);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(beta1);
GE_ASSERT_NOTNULL(beta2);
GE_ASSERT_NOTNULL(epsilon);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(global_grad_norm);
GE_ASSERT_NOTNULL(weight_decay);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyAdamV2")
.Name(("ApplyAdamV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"m", ge::kIrInputRequired, ""},
{"v", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"beta1", ge::kIrInputRequired, ""},
{"beta2", ge::kIrInputRequired, ""},
{"epsilon", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"max_grad_norm", ge::kIrInputOptional, ""},
{"global_grad_norm", ge::kIrInputRequired, ""},
{"weight_decay", ge::kIrInputRequired, ""},
{"step_size", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"m", ge::kIrOutputRequired, ""},
{"v", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"adam_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(adam_mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(m->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(v->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta1->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta2->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(epsilon->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(7)));
if (max_grad_norm != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(max_grad_norm->GetAnchor(), node->GetInDataAnchor(8)));
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(global_grad_norm->GetAnchor(), node->GetInDataAnchor(9)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight_decay->GetAnchor(), node->GetInDataAnchor(10)));
if (step_size != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(step_size->GetAnchor(), node->GetInDataAnchor(11)));
}
return EsApplyAdamV2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsApplyAdamWOutput EsApplyAdamW(EsbTensor *var, EsbTensor *m, EsbTensor *v, EsbTensor *beta1_power, EsbTensor *beta2_power, EsbTensor *lr, EsbTensor *weight_decay, EsbTensor *beta1, EsbTensor *beta2, EsbTensor *epsilon, EsbTensor *grad, EsbTensor *max_grad_norm, bool amsgrad, bool maximize) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(m);
GE_ASSERT_NOTNULL(v);
GE_ASSERT_NOTNULL(beta1_power);
GE_ASSERT_NOTNULL(beta2_power);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(weight_decay);
GE_ASSERT_NOTNULL(beta1);
GE_ASSERT_NOTNULL(beta2);
GE_ASSERT_NOTNULL(epsilon);
GE_ASSERT_NOTNULL(grad);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyAdamW")
.Name(("ApplyAdamW_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"m", ge::kIrInputRequired, ""},
{"v", ge::kIrInputRequired, ""},
{"beta1_power", ge::kIrInputRequired, ""},
{"beta2_power", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"weight_decay", ge::kIrInputRequired, ""},
{"beta1", ge::kIrInputRequired, ""},
{"beta2", ge::kIrInputRequired, ""},
{"epsilon", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"max_grad_norm", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"m", ge::kIrOutputRequired, ""},
{"v", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"amsgrad",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(amsgrad))
},
{
"maximize",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(maximize))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(m->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(v->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta1_power->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta2_power->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight_decay->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta1->GetAnchor(), node->GetInDataAnchor(7)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta2->GetAnchor(), node->GetInDataAnchor(8)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(epsilon->GetAnchor(), node->GetInDataAnchor(9)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(10)));
if (max_grad_norm != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(max_grad_norm->GetAnchor(), node->GetInDataAnchor(11)));
}
return EsApplyAdamWOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsApplyAdamWV2(EsbTensor *var, EsbTensor *m, EsbTensor *v, EsbTensor *grad, EsbTensor *step, EsbTensor *max_grad_norm, float lr, float beta1, float beta2, float weight_decay, float eps, bool amsgrad, bool maximize) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(m);
GE_ASSERT_NOTNULL(v);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(step);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyAdamWV2")
.Name(("ApplyAdamWV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"m", ge::kIrInputRequired, ""},
{"v", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"step", ge::kIrInputRequired, ""},
{"max_grad_norm", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
{
"lr",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(lr))
},
{
"beta1",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(beta1))
},
{
"beta2",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(beta2))
},
{
"weight_decay",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(weight_decay))
},
{
"eps",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(eps))
},
{
"amsgrad",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(amsgrad))
},
{
"maximize",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(maximize))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(m->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(v->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(step->GetAnchor(), node->GetInDataAnchor(4)));
if (max_grad_norm != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(max_grad_norm->GetAnchor(), node->GetInDataAnchor(5)));
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsApplyAdamWithAmsgrad(EsbTensor *var, EsbTensor *m, EsbTensor *v, EsbTensor *vhat, EsbTensor *beta1_power, EsbTensor *beta2_power, EsbTensor *lr, EsbTensor *beta1, EsbTensor *beta2, EsbTensor *epsilon, EsbTensor *grad, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(m);
GE_ASSERT_NOTNULL(v);
GE_ASSERT_NOTNULL(vhat);
GE_ASSERT_NOTNULL(beta1_power);
GE_ASSERT_NOTNULL(beta2_power);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(beta1);
GE_ASSERT_NOTNULL(beta2);
GE_ASSERT_NOTNULL(epsilon);
GE_ASSERT_NOTNULL(grad);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyAdamWithAmsgrad")
.Name(("ApplyAdamWithAmsgrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"m", ge::kIrInputRequired, ""},
{"v", ge::kIrInputRequired, ""},
{"vhat", ge::kIrInputRequired, ""},
{"beta1_power", ge::kIrInputRequired, ""},
{"beta2_power", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"beta1", ge::kIrInputRequired, ""},
{"beta2", ge::kIrInputRequired, ""},
{"epsilon", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(m->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(v->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(vhat->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta1_power->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta2_power->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta1->GetAnchor(), node->GetInDataAnchor(7)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta2->GetAnchor(), node->GetInDataAnchor(8)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(epsilon->GetAnchor(), node->GetInDataAnchor(9)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(10)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsApplyAdamWithAmsgradDOutput EsApplyAdamWithAmsgradD(EsbTensor *var, EsbTensor *m, EsbTensor *v, EsbTensor *vhat, EsbTensor *beta1_power, EsbTensor *beta2_power, EsbTensor *lr, EsbTensor *grad, float beta1, float beta2, float epsilon, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(m);
GE_ASSERT_NOTNULL(v);
GE_ASSERT_NOTNULL(vhat);
GE_ASSERT_NOTNULL(beta1_power);
GE_ASSERT_NOTNULL(beta2_power);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(grad);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyAdamWithAmsgradD")
.Name(("ApplyAdamWithAmsgradD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"m", ge::kIrInputRequired, ""},
{"v", ge::kIrInputRequired, ""},
{"vhat", ge::kIrInputRequired, ""},
{"beta1_power", ge::kIrInputRequired, ""},
{"beta2_power", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"m", ge::kIrOutputRequired, ""},
{"v", ge::kIrOutputRequired, ""},
{"vhat", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"beta1",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(beta1))
},
{
"beta2",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(beta2))
},
{
"epsilon",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(m->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(v->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(vhat->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta1_power->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta2_power->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(7)));
return EsApplyAdamWithAmsgradDOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsApplyAdamWithAmsgradV2Output EsApplyAdamWithAmsgradV2(EsbTensor *var, EsbTensor *m, EsbTensor *v, EsbTensor *vhat, EsbTensor *beta1_power, EsbTensor *beta2_power, EsbTensor *lr, EsbTensor *beta1, EsbTensor *beta2, EsbTensor *epsilon, EsbTensor *grad, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(m);
GE_ASSERT_NOTNULL(v);
GE_ASSERT_NOTNULL(vhat);
GE_ASSERT_NOTNULL(beta1_power);
GE_ASSERT_NOTNULL(beta2_power);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(beta1);
GE_ASSERT_NOTNULL(beta2);
GE_ASSERT_NOTNULL(epsilon);
GE_ASSERT_NOTNULL(grad);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyAdamWithAmsgradV2")
.Name(("ApplyAdamWithAmsgradV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"m", ge::kIrInputRequired, ""},
{"v", ge::kIrInputRequired, ""},
{"vhat", ge::kIrInputRequired, ""},
{"beta1_power", ge::kIrInputRequired, ""},
{"beta2_power", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"beta1", ge::kIrInputRequired, ""},
{"beta2", ge::kIrInputRequired, ""},
{"epsilon", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"m", ge::kIrOutputRequired, ""},
{"v", ge::kIrOutputRequired, ""},
{"vhat", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(m->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(v->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(vhat->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta1_power->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta2_power->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta1->GetAnchor(), node->GetInDataAnchor(7)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta2->GetAnchor(), node->GetInDataAnchor(8)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(epsilon->GetAnchor(), node->GetInDataAnchor(9)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(10)));
return EsApplyAdamWithAmsgradV2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsbTensor *EsApplyAddSign(EsbTensor *var, EsbTensor *m, EsbTensor *lr, EsbTensor *alpha, EsbTensor *sign_decay, EsbTensor *beta, EsbTensor *grad, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(m);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(alpha);
GE_ASSERT_NOTNULL(sign_decay);
GE_ASSERT_NOTNULL(beta);
GE_ASSERT_NOTNULL(grad);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyAddSign")
.Name(("ApplyAddSign_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"m", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"alpha", ge::kIrInputRequired, ""},
{"sign_decay", ge::kIrInputRequired, ""},
{"beta", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(m->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(alpha->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sign_decay->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(6)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsApplyAddSignDOutput EsApplyAddSignD(EsbTensor *var, EsbTensor *m, EsbTensor *lr, EsbTensor *alpha, EsbTensor *sign_decay, EsbTensor *beta, EsbTensor *grad, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(m);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(alpha);
GE_ASSERT_NOTNULL(sign_decay);
GE_ASSERT_NOTNULL(beta);
GE_ASSERT_NOTNULL(grad);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyAddSignD")
.Name(("ApplyAddSignD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"m", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"alpha", ge::kIrInputRequired, ""},
{"sign_decay", ge::kIrInputRequired, ""},
{"beta", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"m", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(m->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(alpha->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sign_decay->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(6)));
return EsApplyAddSignDOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsApplyCenteredRMSProp(EsbTensor *var, EsbTensor *mg, EsbTensor *ms, EsbTensor *mom, EsbTensor *lr, EsbTensor *rho, EsbTensor *momentum, EsbTensor *epsilon, EsbTensor *grad, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(mg);
GE_ASSERT_NOTNULL(ms);
GE_ASSERT_NOTNULL(mom);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(rho);
GE_ASSERT_NOTNULL(momentum);
GE_ASSERT_NOTNULL(epsilon);
GE_ASSERT_NOTNULL(grad);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyCenteredRMSProp")
.Name(("ApplyCenteredRMSProp_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"mg", ge::kIrInputRequired, ""},
{"ms", ge::kIrInputRequired, ""},
{"mom", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"rho", ge::kIrInputRequired, ""},
{"momentum", ge::kIrInputRequired, ""},
{"epsilon", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mg->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(ms->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mom->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rho->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(momentum->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(epsilon->GetAnchor(), node->GetInDataAnchor(7)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(8)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsApplyCenteredRMSPropDOutput EsApplyCenteredRMSPropD(EsbTensor *var, EsbTensor *mg, EsbTensor *ms, EsbTensor *mom, EsbTensor *lr, EsbTensor *rho, EsbTensor *momentum, EsbTensor *epsilon, EsbTensor *grad, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(mg);
GE_ASSERT_NOTNULL(ms);
GE_ASSERT_NOTNULL(mom);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(rho);
GE_ASSERT_NOTNULL(momentum);
GE_ASSERT_NOTNULL(epsilon);
GE_ASSERT_NOTNULL(grad);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyCenteredRMSPropD")
.Name(("ApplyCenteredRMSPropD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"mg", ge::kIrInputRequired, ""},
{"ms", ge::kIrInputRequired, ""},
{"mom", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"rho", ge::kIrInputRequired, ""},
{"momentum", ge::kIrInputRequired, ""},
{"epsilon", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"mg", ge::kIrOutputRequired, ""},
{"ms", ge::kIrOutputRequired, ""},
{"mom", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mg->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(ms->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mom->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rho->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(momentum->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(epsilon->GetAnchor(), node->GetInDataAnchor(7)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(8)));
return EsApplyCenteredRMSPropDOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsbTensor *EsApplyFtrl(EsbTensor *var, EsbTensor *accum, EsbTensor *linear, EsbTensor *grad, EsbTensor *lr, EsbTensor *l1, EsbTensor *l2, EsbTensor *lr_power, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(accum);
GE_ASSERT_NOTNULL(linear);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(l1);
GE_ASSERT_NOTNULL(l2);
GE_ASSERT_NOTNULL(lr_power);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyFtrl")
.Name(("ApplyFtrl_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"accum", ge::kIrInputRequired, ""},
{"linear", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"l1", ge::kIrInputRequired, ""},
{"l2", ge::kIrInputRequired, ""},
{"lr_power", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(linear->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(l1->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(l2->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr_power->GetAnchor(), node->GetInDataAnchor(7)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsApplyFtrlDOutput EsApplyFtrlD(EsbTensor *var, EsbTensor *accum, EsbTensor *linear, EsbTensor *grad, EsbTensor *lr, EsbTensor *l1, EsbTensor *l2, EsbTensor *lr_power, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(accum);
GE_ASSERT_NOTNULL(linear);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(l1);
GE_ASSERT_NOTNULL(l2);
GE_ASSERT_NOTNULL(lr_power);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyFtrlD")
.Name(("ApplyFtrlD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"accum", ge::kIrInputRequired, ""},
{"linear", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"l1", ge::kIrInputRequired, ""},
{"l2", ge::kIrInputRequired, ""},
{"lr_power", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"accum", ge::kIrOutputRequired, ""},
{"linear", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(linear->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(l1->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(l2->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr_power->GetAnchor(), node->GetInDataAnchor(7)));
return EsApplyFtrlDOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsApplyFtrlV2(EsbTensor *var, EsbTensor *accum, EsbTensor *linear, EsbTensor *grad, EsbTensor *lr, EsbTensor *l1, EsbTensor *l2, EsbTensor *l2_shrinkage, EsbTensor *lr_power, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(accum);
GE_ASSERT_NOTNULL(linear);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(l1);
GE_ASSERT_NOTNULL(l2);
GE_ASSERT_NOTNULL(l2_shrinkage);
GE_ASSERT_NOTNULL(lr_power);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyFtrlV2")
.Name(("ApplyFtrlV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"accum", ge::kIrInputRequired, ""},
{"linear", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"l1", ge::kIrInputRequired, ""},
{"l2", ge::kIrInputRequired, ""},
{"l2_shrinkage", ge::kIrInputRequired, ""},
{"lr_power", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(linear->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(l1->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(l2->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(l2_shrinkage->GetAnchor(), node->GetInDataAnchor(7)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr_power->GetAnchor(), node->GetInDataAnchor(8)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsApplyFtrlV2DOutput EsApplyFtrlV2D(EsbTensor *var, EsbTensor *accum, EsbTensor *linear, EsbTensor *grad, EsbTensor *lr, EsbTensor *l1, EsbTensor *l2, EsbTensor *l2_shrinkage, EsbTensor *lr_power, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(accum);
GE_ASSERT_NOTNULL(linear);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(l1);
GE_ASSERT_NOTNULL(l2);
GE_ASSERT_NOTNULL(l2_shrinkage);
GE_ASSERT_NOTNULL(lr_power);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyFtrlV2D")
.Name(("ApplyFtrlV2D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"accum", ge::kIrInputRequired, ""},
{"linear", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"l1", ge::kIrInputRequired, ""},
{"l2", ge::kIrInputRequired, ""},
{"l2_shrinkage", ge::kIrInputRequired, ""},
{"lr_power", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"accum", ge::kIrOutputRequired, ""},
{"linear", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(linear->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(l1->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(l2->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(l2_shrinkage->GetAnchor(), node->GetInDataAnchor(7)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr_power->GetAnchor(), node->GetInDataAnchor(8)));
return EsApplyFtrlV2DOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsApplyFusedEmaAdamOutput EsApplyFusedEmaAdam(EsbTensor *grad, EsbTensor *var, EsbTensor *m, EsbTensor *v, EsbTensor *s, EsbTensor *step, float lr, float ema_decay, float beta1, float beta2, float eps, int64_t mode, bool bias_correction, float weight_decay) {
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(m);
GE_ASSERT_NOTNULL(v);
GE_ASSERT_NOTNULL(s);
GE_ASSERT_NOTNULL(step);
auto &graph = grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyFusedEmaAdam")
.Name(("ApplyFusedEmaAdam_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grad", ge::kIrInputRequired, ""},
{"var", ge::kIrInputRequired, ""},
{"m", ge::kIrInputRequired, ""},
{"v", ge::kIrInputRequired, ""},
{"s", ge::kIrInputRequired, ""},
{"step", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"m", ge::kIrOutputRequired, ""},
{"v", ge::kIrOutputRequired, ""},
{"s", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"lr",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(lr))
},
{
"ema_decay",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(ema_decay))
},
{
"beta1",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(beta1))
},
{
"beta2",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(beta2))
},
{
"eps",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(eps))
},
{
"mode",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(mode))
},
{
"bias_correction",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(bias_correction))
},
{
"weight_decay",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(weight_decay))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(m->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(v->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(s->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(step->GetAnchor(), node->GetInDataAnchor(5)));
return EsApplyFusedEmaAdamOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsbTensor *EsApplyGradientDescent(EsbTensor *var, EsbTensor *alpha, EsbTensor *delta, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(alpha);
GE_ASSERT_NOTNULL(delta);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyGradientDescent")
.Name(("ApplyGradientDescent_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"alpha", ge::kIrInputRequired, ""},
{"delta", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(alpha->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(delta->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsApplyKerasMomentum(EsbTensor *var, EsbTensor *accum, EsbTensor *lr, EsbTensor *grad, EsbTensor *momentum, bool use_locking, bool use_nesterov) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(accum);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(momentum);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyKerasMomentum")
.Name(("ApplyKerasMomentum_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"accum", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"momentum", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
{
"use_nesterov",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_nesterov))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(momentum->GetAnchor(), node->GetInDataAnchor(4)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsApplyKerasMomentumDOutput EsApplyKerasMomentumD(EsbTensor *var, EsbTensor *accum, EsbTensor *lr, EsbTensor *grad, EsbTensor *momentum, bool use_locking, bool use_nesterov) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(accum);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(momentum);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyKerasMomentumD")
.Name(("ApplyKerasMomentumD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"accum", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"momentum", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"accum", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
{
"use_nesterov",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_nesterov))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(momentum->GetAnchor(), node->GetInDataAnchor(4)));
return EsApplyKerasMomentumDOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsApplyMomentum(EsbTensor *var, EsbTensor *accum, EsbTensor *lr, EsbTensor *grad, EsbTensor *momentum, bool use_nesterov, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(accum);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(momentum);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyMomentum")
.Name(("ApplyMomentum_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"accum", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"momentum", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_nesterov",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_nesterov))
},
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(momentum->GetAnchor(), node->GetInDataAnchor(4)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsApplyMomentumDOutput EsApplyMomentumD(EsbTensor *var, EsbTensor *accum, EsbTensor *lr, EsbTensor *grad, EsbTensor *momentum, bool use_nesterov, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(accum);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(momentum);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyMomentumD")
.Name(("ApplyMomentumD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"accum", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"momentum", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"accum", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_nesterov",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_nesterov))
},
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(momentum->GetAnchor(), node->GetInDataAnchor(4)));
return EsApplyMomentumDOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsApplyPowerSign(EsbTensor *var, EsbTensor *m, EsbTensor *lr, EsbTensor *logbase, EsbTensor *sign_decay, EsbTensor *beta, EsbTensor *grad, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(m);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(logbase);
GE_ASSERT_NOTNULL(sign_decay);
GE_ASSERT_NOTNULL(beta);
GE_ASSERT_NOTNULL(grad);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyPowerSign")
.Name(("ApplyPowerSign_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"m", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"logbase", ge::kIrInputRequired, ""},
{"sign_decay", ge::kIrInputRequired, ""},
{"beta", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(m->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(logbase->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sign_decay->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(6)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsApplyPowerSignDOutput EsApplyPowerSignD(EsbTensor *var, EsbTensor *m, EsbTensor *lr, EsbTensor *logbase, EsbTensor *sign_decay, EsbTensor *beta, EsbTensor *grad, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(m);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(logbase);
GE_ASSERT_NOTNULL(sign_decay);
GE_ASSERT_NOTNULL(beta);
GE_ASSERT_NOTNULL(grad);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyPowerSignD")
.Name(("ApplyPowerSignD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"m", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"logbase", ge::kIrInputRequired, ""},
{"sign_decay", ge::kIrInputRequired, ""},
{"beta", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"m", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(m->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(logbase->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sign_decay->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(6)));
return EsApplyPowerSignDOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsApplyProximalAdagrad(EsbTensor *var, EsbTensor *accum, EsbTensor *lr, EsbTensor *l1, EsbTensor *l2, EsbTensor *grad, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(accum);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(l1);
GE_ASSERT_NOTNULL(l2);
GE_ASSERT_NOTNULL(grad);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyProximalAdagrad")
.Name(("ApplyProximalAdagrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"accum", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"l1", ge::kIrInputRequired, ""},
{"l2", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(l1->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(l2->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(5)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsApplyProximalAdagradDOutput EsApplyProximalAdagradD(EsbTensor *var, EsbTensor *accum, EsbTensor *lr, EsbTensor *l1, EsbTensor *l2, EsbTensor *grad, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(accum);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(l1);
GE_ASSERT_NOTNULL(l2);
GE_ASSERT_NOTNULL(grad);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyProximalAdagradD")
.Name(("ApplyProximalAdagradD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"accum", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"l1", ge::kIrInputRequired, ""},
{"l2", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"accum", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(l1->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(l2->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(5)));
return EsApplyProximalAdagradDOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsApplyProximalGradientDescent(EsbTensor *var, EsbTensor *alpha, EsbTensor *l1, EsbTensor *l2, EsbTensor *delta, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(alpha);
GE_ASSERT_NOTNULL(l1);
GE_ASSERT_NOTNULL(l2);
GE_ASSERT_NOTNULL(delta);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyProximalGradientDescent")
.Name(("ApplyProximalGradientDescent_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"alpha", ge::kIrInputRequired, ""},
{"l1", ge::kIrInputRequired, ""},
{"l2", ge::kIrInputRequired, ""},
{"delta", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(alpha->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(l1->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(l2->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(delta->GetAnchor(), node->GetInDataAnchor(4)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsApplyRMSProp(EsbTensor *var, EsbTensor *ms, EsbTensor *mom, EsbTensor *lr, EsbTensor *rho, EsbTensor *momentum, EsbTensor *epsilon, EsbTensor *grad, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(ms);
GE_ASSERT_NOTNULL(mom);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(rho);
GE_ASSERT_NOTNULL(momentum);
GE_ASSERT_NOTNULL(epsilon);
GE_ASSERT_NOTNULL(grad);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyRMSProp")
.Name(("ApplyRMSProp_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"ms", ge::kIrInputRequired, ""},
{"mom", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"rho", ge::kIrInputRequired, ""},
{"momentum", ge::kIrInputRequired, ""},
{"epsilon", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(ms->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mom->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rho->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(momentum->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(epsilon->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(7)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsApplyRMSPropDOutput EsApplyRMSPropD(EsbTensor *var, EsbTensor *ms, EsbTensor *mom, EsbTensor *lr, EsbTensor *grad, float rho, float momentum, float epsilon, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(ms);
GE_ASSERT_NOTNULL(mom);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(grad);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyRMSPropD")
.Name(("ApplyRMSPropD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"ms", ge::kIrInputRequired, ""},
{"mom", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"ms", ge::kIrOutputRequired, ""},
{"mom", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"rho",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(rho))
},
{
"momentum",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(momentum))
},
{
"epsilon",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(ms->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mom->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(4)));
return EsApplyRMSPropDOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsApplyRotaryPosEmbOutput EsApplyRotaryPosEmb(EsbTensor *query, EsbTensor *key, EsbTensor *cos, EsbTensor *sin, int64_t layout) {
GE_ASSERT_NOTNULL(query);
GE_ASSERT_NOTNULL(key);
GE_ASSERT_NOTNULL(cos);
GE_ASSERT_NOTNULL(sin);
auto &graph = query->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApplyRotaryPosEmb")
.Name(("ApplyRotaryPosEmb_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"query", ge::kIrInputRequired, ""},
{"key", ge::kIrInputRequired, ""},
{"cos", ge::kIrInputRequired, ""},
{"sin", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"query", ge::kIrOutputRequired, ""},
{"key", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"layout",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(layout))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(query->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(key->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(cos->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sin->GetAnchor(), node->GetInDataAnchor(3)));
return EsApplyRotaryPosEmbOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsApproximateEqual(EsbTensor *x1, EsbTensor *x2, float tolerance) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ApproximateEqual")
.Name(("ApproximateEqual_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"tolerance",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(tolerance))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsArgMaxD(EsbTensor *x, int64_t dimension, ge::DataType dtype) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ArgMaxD")
.Name(("ArgMaxD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dimension",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dimension))
},
{
"dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsArgMaxGrad(EsbTensor *var, EsbTensor *indices, EsbTensor *updates, int64_t dimension) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(updates);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ArgMaxGrad")
.Name(("ArgMaxGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"updates", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dimension",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dimension))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(updates->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsArgMaxGradD(EsbTensor *var, EsbTensor *indices, EsbTensor *updates, EsbTensor *assist, int64_t dimension) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(updates);
GE_ASSERT_NOTNULL(assist);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ArgMaxGradD")
.Name(("ArgMaxGradD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"updates", ge::kIrInputRequired, ""},
{"assist", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dimension",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dimension))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(updates->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(assist->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsArgMaxV2(EsbTensor *x, EsbTensor *dimension, ge::DataType dtype) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(dimension);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ArgMaxV2")
.Name(("ArgMaxV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"dimension", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dimension->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsArgMaxWithKOutput EsArgMaxWithK(EsbTensor *x, int64_t axis, bool out_max_val, int64_t topk) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ArgMaxWithK")
.Name(("ArgMaxWithK_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"indices", ge::kIrOutputRequired, ""},
{"values", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
{
"out_max_val",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(out_max_val))
},
{
"topk",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(topk))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return EsArgMaxWithKOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsArgMaxWithValueOutput EsArgMaxWithValue(EsbTensor *x, int64_t dimension, bool keep_dims) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ArgMaxWithValue")
.Name(("ArgMaxWithValue_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"indice", ge::kIrOutputRequired, ""},
{"values", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dimension",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dimension))
},
{
"keep_dims",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keep_dims))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return EsArgMaxWithValueOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsArgMin(EsbTensor *x, EsbTensor *dimension, ge::DataType dtype) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(dimension);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ArgMin")
.Name(("ArgMin_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"dimension", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dimension->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsArgMinD(EsbTensor *x, int64_t dimension, ge::DataType dtype) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ArgMinD")
.Name(("ArgMinD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dimension",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dimension))
},
{
"dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsArgMinWithValueOutput EsArgMinWithValue(EsbTensor *x, int64_t dimension, bool keep_dims) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ArgMinWithValue")
.Name(("ArgMinWithValue_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"indice", ge::kIrOutputRequired, ""},
{"values", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dimension",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dimension))
},
{
"keep_dims",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keep_dims))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return EsArgMinWithValueOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsAsStrided(EsbTensor *x, EsbTensor *size, EsbTensor *stride, EsbTensor *storage_offset) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(size);
GE_ASSERT_NOTNULL(stride);
GE_ASSERT_NOTNULL(storage_offset);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AsStrided")
.Name(("AsStrided_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"size", ge::kIrInputRequired, ""},
{"stride", ge::kIrInputRequired, ""},
{"storage_offset", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(size->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(stride->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(storage_offset->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAsString(EsbTensor *x, int64_t precision, bool scientific, bool shortest, int64_t width, const char *fill) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AsString")
.Name(("AsString_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"precision",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(precision))
},
{
"scientific",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(scientific))
},
{
"shortest",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(shortest))
},
{
"width",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(width))
},
{
"fill",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(fill))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAscendAntiQuant(EsbTensor *x, float scale, float offset, int64_t dtype, bool sqrt_mode) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AscendAntiQuant")
.Name(("AscendAntiQuant_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"scale",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(scale))
},
{
"offset",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(offset))
},
{
"dtype",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dtype))
},
{
"sqrt_mode",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(sqrt_mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAscendAntiQuantV2(EsbTensor *x, EsbTensor *scale, EsbTensor *offset, int64_t dst_type, bool sqrt_mode) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(scale);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AscendAntiQuantV2")
.Name(("AscendAntiQuantV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"scale", ge::kIrInputRequired, ""},
{"offset", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dst_type",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dst_type))
},
{
"sqrt_mode",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(sqrt_mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(1)));
if (offset != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset->GetAnchor(), node->GetInDataAnchor(2)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAscendDequant(EsbTensor *x, EsbTensor *deq_scale, bool sqrt_mode, bool relu_flag, int64_t dtype) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(deq_scale);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AscendDequant")
.Name(("AscendDequant_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"deq_scale", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"sqrt_mode",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(sqrt_mode))
},
{
"relu_flag",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(relu_flag))
},
{
"dtype",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(deq_scale->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAscendDequantS16(EsbTensor *x0, EsbTensor *deq_scale, EsbTensor *x1, bool relu_flag) {
GE_ASSERT_NOTNULL(x0);
GE_ASSERT_NOTNULL(deq_scale);
auto &graph = x0->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AscendDequantS16")
.Name(("AscendDequantS16_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x0", ge::kIrInputRequired, ""},
{"deq_scale", ge::kIrInputRequired, ""},
{"x1", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"relu_flag",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(relu_flag))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x0->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(deq_scale->GetAnchor(), node->GetInDataAnchor(1)));
if (x1 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(2)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAscendPadding(EsbTensor *x, int64_t pad_dim_size) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AscendPadding")
.Name(("AscendPadding_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"pad_dim_size",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pad_dim_size))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAscendQuant(EsbTensor *x, float scale, float offset, bool sqrt_mode, const char *round_mode, int64_t dst_type) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AscendQuant")
.Name(("AscendQuant_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"scale",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(scale))
},
{
"offset",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(offset))
},
{
"sqrt_mode",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(sqrt_mode))
},
{
"round_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(round_mode))
},
{
"dst_type",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dst_type))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAscendQuantV2(EsbTensor *x, EsbTensor *scale, EsbTensor *offset, bool sqrt_mode, const char *round_mode, int64_t dst_type, int64_t axis) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(scale);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AscendQuantV2")
.Name(("AscendQuantV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"scale", ge::kIrInputRequired, ""},
{"offset", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"sqrt_mode",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(sqrt_mode))
},
{
"round_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(round_mode))
},
{
"dst_type",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dst_type))
},
{
"axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(1)));
if (offset != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset->GetAnchor(), node->GetInDataAnchor(2)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAscendRequant(EsbTensor *x, EsbTensor *req_scale, bool relu_flag) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(req_scale);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AscendRequant")
.Name(("AscendRequant_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"req_scale", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"relu_flag",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(relu_flag))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(req_scale->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsAscendRequantS16Output EsAscendRequantS16(EsbTensor *x0, EsbTensor *req_scale, EsbTensor *x1, bool dual_output, bool relu_flag) {
GE_ASSERT_NOTNULL(x0);
GE_ASSERT_NOTNULL(req_scale);
auto &graph = x0->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AscendRequantS16")
.Name(("AscendRequantS16_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x0", ge::kIrInputRequired, ""},
{"req_scale", ge::kIrInputRequired, ""},
{"x1", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y0", ge::kIrOutputRequired, ""},
{"y1", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dual_output",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(dual_output))
},
{
"relu_flag",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(relu_flag))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x0->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(req_scale->GetAnchor(), node->GetInDataAnchor(1)));
if (x1 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(2)));
}
return EsAscendRequantS16Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsAscendWeightQuant(EsbTensor *x, EsbTensor *offset, int64_t dst_type) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(offset);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AscendWeightQuant")
.Name(("AscendWeightQuant_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"offset", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dst_type",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dst_type))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAsin(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Asin")
.Name(("Asin_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAsinGrad(EsbTensor *y, EsbTensor *dy) {
GE_ASSERT_NOTNULL(y);
GE_ASSERT_NOTNULL(dy);
auto &graph = y->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AsinGrad")
.Name(("AsinGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"y", ge::kIrInputRequired, ""},
{"dy", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"z", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAsinh(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Asinh")
.Name(("Asinh_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAsinhGrad(EsbTensor *y, EsbTensor *dy) {
GE_ASSERT_NOTNULL(y);
GE_ASSERT_NOTNULL(dy);
auto &graph = y->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AsinhGrad")
.Name(("AsinhGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"y", ge::kIrInputRequired, ""},
{"dy", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"z", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAssert(EsbTensor *input_condition, EsbTensor **input_data, int64_t input_data_num, int64_t summarize) {
GE_ASSERT_NOTNULL(input_condition);
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(input_data_num));
auto &graph = input_condition->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Assert")
.Name(("Assert_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_condition", ge::kIrInputRequired, ""},
{"input_data", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
{
"summarize",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(summarize))
},
})
.InstanceDynamicInputNum("input_data", static_cast<int32_t>(input_data_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_condition->GetAnchor(), node->GetInDataAnchor(0)));
if ((input_data != nullptr) && (input_data_num > 0)) {
for (int64_t i = 0; i < input_data_num; ++i) {
auto one_input_data = input_data[i];
GE_ASSERT_NOTNULL(one_input_data);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_input_data->GetAnchor(), node->GetInDataAnchor(1 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsAssign(EsbTensor *ref, EsbTensor *value, bool validate_shape, bool use_locking) {
GE_ASSERT_NOTNULL(ref);
GE_ASSERT_NOTNULL(value);
auto &graph = ref->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Assign")
.Name(("Assign_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"ref", ge::kIrInputRequired, ""},
{"value", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"ref", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"validate_shape",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(validate_shape))
},
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(ref->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAssignAdd(EsbTensor *ref, EsbTensor *value, bool use_locking) {
GE_ASSERT_NOTNULL(ref);
GE_ASSERT_NOTNULL(value);
auto &graph = ref->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AssignAdd")
.Name(("AssignAdd_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"ref", ge::kIrInputRequired, ""},
{"value", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"ref", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(ref->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAssignAddVariableOp(EsbTensor *resource, EsbTensor *value, ge::DataType dtype) {
GE_ASSERT_NOTNULL(resource);
GE_ASSERT_NOTNULL(value);
auto &graph = resource->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AssignAddVariableOp")
.Name(("AssignAddVariableOp_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"resource", ge::kIrInputRequired, ""},
{"value", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
{
"dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(resource->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsAssignSub(EsbTensor *var, EsbTensor *value, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(value);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AssignSub")
.Name(("AssignSub_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"value", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAssignSubVariableOp(EsbTensor *resource, EsbTensor *value, ge::DataType dtype) {
GE_ASSERT_NOTNULL(resource);
GE_ASSERT_NOTNULL(value);
auto &graph = resource->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AssignSubVariableOp")
.Name(("AssignSubVariableOp_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"resource", ge::kIrInputRequired, ""},
{"value", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
{
"dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(resource->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsAssignVariableOp(EsbTensor *resource, EsbTensor *value, ge::DataType dtype) {
GE_ASSERT_NOTNULL(resource);
GE_ASSERT_NOTNULL(value);
auto &graph = resource->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AssignVariableOp")
.Name(("AssignVariableOp_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"resource", ge::kIrInputRequired, ""},
{"value", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
{
"dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(resource->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsAtan(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Atan")
.Name(("Atan_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAtan2(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Atan2")
.Name(("Atan2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAtanGrad(EsbTensor *y, EsbTensor *dy) {
GE_ASSERT_NOTNULL(y);
GE_ASSERT_NOTNULL(dy);
auto &graph = y->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AtanGrad")
.Name(("AtanGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"y", ge::kIrInputRequired, ""},
{"dy", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"z", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAtanh(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Atanh")
.Name(("Atanh_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAtomicAddrClean(EsbGraph *owner_graph, const int64_t *automic_add_mem_size, int64_t automic_add_mem_size_num) {
GE_ASSERT_NOTNULL(owner_graph);
EsbGraph &graph = *owner_graph;

auto desc = ge::CompliantOpDescBuilder().OpType("AtomicAddrClean")
.Name(("AtomicAddrClean_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
})
.IrDefOutputs({
})
.IrDefAttrs({
{
"automic_add_mem_size",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(automic_add_mem_size, automic_add_mem_size + automic_add_mem_size_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsAttentionLnQKVOutput EsAttentionLnQKV(EsbTensor *x, EsbTensor *kernel_query, EsbTensor *kernel_key, EsbTensor *kernel_value, EsbTensor *gamma, EsbTensor *beta, EsbTensor *bias_query, EsbTensor *bias_key, EsbTensor *bias_value, float epsilon, bool trans_a, bool trans_b) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(kernel_query);
GE_ASSERT_NOTNULL(kernel_key);
GE_ASSERT_NOTNULL(kernel_value);
GE_ASSERT_NOTNULL(gamma);
GE_ASSERT_NOTNULL(beta);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AttentionLnQKV")
.Name(("AttentionLnQKV_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"kernel_query", ge::kIrInputRequired, ""},
{"kernel_key", ge::kIrInputRequired, ""},
{"kernel_value", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
{"beta", ge::kIrInputRequired, ""},
{"bias_query", ge::kIrInputOptional, ""},
{"bias_key", ge::kIrInputOptional, ""},
{"bias_value", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"norm", ge::kIrOutputRequired, ""},
{"query_output", ge::kIrOutputRequired, ""},
{"key_output", ge::kIrOutputRequired, ""},
{"value_output", ge::kIrOutputRequired, ""},
{"mean", ge::kIrOutputRequired, ""},
{"variance", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
{
"trans_a",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(trans_a))
},
{
"trans_b",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(trans_b))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(kernel_query->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(kernel_key->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(kernel_value->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta->GetAnchor(), node->GetInDataAnchor(5)));
if (bias_query != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias_query->GetAnchor(), node->GetInDataAnchor(6)));
}
if (bias_key != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias_key->GetAnchor(), node->GetInDataAnchor(7)));
}
if (bias_value != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias_value->GetAnchor(), node->GetInDataAnchor(8)));
}
return EsAttentionLnQKVOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
graph.GetEsbTensorFromNode(node, 5),
};
}
EsAttentionQKVGradWOutput EsAttentionQKVGradW(EsbTensor *x, EsbTensor *query_dx, EsbTensor *key_dw, EsbTensor *value_dw, bool trans_a, bool trans_b, bool trans_dw) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(query_dx);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AttentionQKVGradW")
.Name(("AttentionQKVGradW_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"query_dx", ge::kIrInputRequired, ""},
{"key_dw", ge::kIrInputOptional, ""},
{"value_dw", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"dw_query", ge::kIrOutputRequired, ""},
{"dw_key", ge::kIrOutputRequired, ""},
{"dw_value", ge::kIrOutputRequired, ""},
{"dbias_query", ge::kIrOutputRequired, ""},
{"dbias_key", ge::kIrOutputRequired, ""},
{"dbias_value", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"trans_a",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(trans_a))
},
{
"trans_b",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(trans_b))
},
{
"trans_dw",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(trans_dw))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(query_dx->GetAnchor(), node->GetInDataAnchor(1)));
if (key_dw != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(key_dw->GetAnchor(), node->GetInDataAnchor(2)));
}
if (value_dw != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value_dw->GetAnchor(), node->GetInDataAnchor(3)));
}
return EsAttentionQKVGradWOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
graph.GetEsbTensorFromNode(node, 5),
};
}
EsbTensor *EsAttentionQKVGradX(EsbTensor *ln_dx, EsbTensor *query_dx, EsbTensor *key_dw, EsbTensor *value_dw, EsbTensor *kernel_query, EsbTensor *kernel_key, EsbTensor *kernel_value, bool trans_a, bool trans_b) {
GE_ASSERT_NOTNULL(query_dx);
GE_ASSERT_NOTNULL(key_dw);
GE_ASSERT_NOTNULL(value_dw);
GE_ASSERT_NOTNULL(kernel_query);
GE_ASSERT_NOTNULL(kernel_key);
GE_ASSERT_NOTNULL(kernel_value);
auto &graph = query_dx->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AttentionQKVGradX")
.Name(("AttentionQKVGradX_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"ln_dx", ge::kIrInputOptional, ""},
{"query_dx", ge::kIrInputRequired, ""},
{"key_dw", ge::kIrInputRequired, ""},
{"value_dw", ge::kIrInputRequired, ""},
{"kernel_query", ge::kIrInputRequired, ""},
{"kernel_key", ge::kIrInputRequired, ""},
{"kernel_value", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"dx", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"trans_a",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(trans_a))
},
{
"trans_b",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(trans_b))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if (ln_dx != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(ln_dx->GetAnchor(), node->GetInDataAnchor(0)));
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(query_dx->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(key_dw->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value_dw->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(kernel_query->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(kernel_key->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(kernel_value->GetAnchor(), node->GetInDataAnchor(6)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsAttentionScoreOutput EsAttentionScore(EsbTensor *query, EsbTensor *key, EsbTensor *value, EsbTensor *padding_mask, EsbTensor *scale, EsbTensor *drop_mask, float keep_prob, bool query_transpose, bool key_transpose, bool bmm_score_transpose_a, bool bmm_score_transpose_b, const int64_t *softmax_axes, int64_t softmax_axes_num) {
GE_ASSERT_NOTNULL(query);
GE_ASSERT_NOTNULL(key);
GE_ASSERT_NOTNULL(value);
GE_ASSERT_NOTNULL(padding_mask);
GE_ASSERT_NOTNULL(scale);
auto &graph = query->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AttentionScore")
.Name(("AttentionScore_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"query", ge::kIrInputRequired, ""},
{"key", ge::kIrInputRequired, ""},
{"value", ge::kIrInputRequired, ""},
{"padding_mask", ge::kIrInputRequired, ""},
{"scale", ge::kIrInputRequired, ""},
{"drop_mask", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"attention_score", ge::kIrOutputRequired, ""},
{"softmax_output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"keep_prob",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(keep_prob))
},
{
"query_transpose",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(query_transpose))
},
{
"key_transpose",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(key_transpose))
},
{
"bmm_score_transpose_a",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(bmm_score_transpose_a))
},
{
"bmm_score_transpose_b",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(bmm_score_transpose_b))
},
{
"softmax_axes",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(softmax_axes, softmax_axes + softmax_axes_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(query->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(key->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(padding_mask->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(4)));
if (drop_mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(drop_mask->GetAnchor(), node->GetInDataAnchor(5)));
}
return EsAttentionScoreOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsAttentionScoreGradOutput EsAttentionScoreGrad(EsbTensor *attention_score, EsbTensor *dx, EsbTensor *query, EsbTensor *key, EsbTensor *value, EsbTensor *scale, EsbTensor *drop_mask, float keep_prob, bool query_transpose, bool key_transpose, bool value_transpose, bool dx_transpose, int64_t softmax_axes) {
GE_ASSERT_NOTNULL(attention_score);
GE_ASSERT_NOTNULL(dx);
GE_ASSERT_NOTNULL(query);
GE_ASSERT_NOTNULL(key);
GE_ASSERT_NOTNULL(value);
GE_ASSERT_NOTNULL(scale);
auto &graph = attention_score->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AttentionScoreGrad")
.Name(("AttentionScoreGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"attention_score", ge::kIrInputRequired, ""},
{"dx", ge::kIrInputRequired, ""},
{"query", ge::kIrInputRequired, ""},
{"key", ge::kIrInputRequired, ""},
{"value", ge::kIrInputRequired, ""},
{"scale", ge::kIrInputRequired, ""},
{"drop_mask", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"value_dw", ge::kIrOutputRequired, ""},
{"query_dx", ge::kIrOutputRequired, ""},
{"key_dw", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"keep_prob",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(keep_prob))
},
{
"query_transpose",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(query_transpose))
},
{
"key_transpose",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(key_transpose))
},
{
"value_transpose",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(value_transpose))
},
{
"dx_transpose",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(dx_transpose))
},
{
"softmax_axes",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(softmax_axes))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(attention_score->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dx->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(query->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(key->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(5)));
if (drop_mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(drop_mask->GetAnchor(), node->GetInDataAnchor(6)));
}
return EsAttentionScoreGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsAudioSpectrogram(EsbTensor *x, int64_t window_size, int64_t stride, bool magnitude_squared) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AudioSpectrogram")
.Name(("AudioSpectrogram_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"spectrogram", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"window_size",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(window_size))
},
{
"stride",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(stride))
},
{
"magnitude_squared",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(magnitude_squared))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAvgPool(EsbTensor *x, const int64_t *ksize, int64_t ksize_num, const int64_t *strides, int64_t strides_num, const char *padding, const char *data_format) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AvgPool")
.Name(("AvgPool_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ksize",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ksize, ksize + ksize_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"padding",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(padding))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAvgPool1D(EsbTensor *x, int64_t ksize, int64_t strides, const int64_t *pads, int64_t pads_num, bool ceil_mode, bool count_include_pad) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AvgPool1D")
.Name(("AvgPool1D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ksize",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(ksize))
},
{
"strides",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(strides))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"ceil_mode",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(ceil_mode))
},
{
"count_include_pad",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(count_include_pad))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAvgPool1DAvgMatrix(EsbTensor *x, int64_t ksize, int64_t strides, const int64_t *pads, int64_t pads_num, bool ceil_mode, bool count_include_pad) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AvgPool1DAvgMatrix")
.Name(("AvgPool1DAvgMatrix_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ksize",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(ksize))
},
{
"strides",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(strides))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"ceil_mode",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(ceil_mode))
},
{
"count_include_pad",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(count_include_pad))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAvgPool1DD(EsbTensor *x, EsbTensor *assist_matrix, int64_t ksize, int64_t strides, const int64_t *pads, int64_t pads_num, bool ceil_mode, bool count_include_pad) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(assist_matrix);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AvgPool1DD")
.Name(("AvgPool1DD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"assist_matrix", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ksize",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(ksize))
},
{
"strides",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(strides))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"ceil_mode",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(ceil_mode))
},
{
"count_include_pad",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(count_include_pad))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(assist_matrix->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAvgPool3D(EsbTensor *x, const int64_t *ksize, int64_t ksize_num, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, bool ceil_mode, bool count_include_pad, int64_t divisor_override, const char *data_format) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AvgPool3D")
.Name(("AvgPool3D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ksize",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ksize, ksize + ksize_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"ceil_mode",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(ceil_mode))
},
{
"count_include_pad",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(count_include_pad))
},
{
"divisor_override",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(divisor_override))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAvgPool3DD(EsbTensor *x, EsbTensor *filter, EsbTensor *multiplier, const int64_t *ksize, int64_t ksize_num, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, bool ceil_mode, bool count_include_pad, int64_t divisor_override, const char *data_format) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AvgPool3DD")
.Name(("AvgPool3DD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"filter", ge::kIrInputOptional, ""},
{"multiplier", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ksize",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ksize, ksize + ksize_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"ceil_mode",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(ceil_mode))
},
{
"count_include_pad",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(count_include_pad))
},
{
"divisor_override",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(divisor_override))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
if (filter != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(filter->GetAnchor(), node->GetInDataAnchor(1)));
}
if (multiplier != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(multiplier->GetAnchor(), node->GetInDataAnchor(2)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAvgPool3DGrad(EsbTensor *orig_input_shape, EsbTensor *grads, const int64_t *ksize, int64_t ksize_num, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, bool ceil_mode, bool count_include_pad, int64_t divisor_override, const char *data_format) {
GE_ASSERT_NOTNULL(orig_input_shape);
GE_ASSERT_NOTNULL(grads);
auto &graph = orig_input_shape->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AvgPool3DGrad")
.Name(("AvgPool3DGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"orig_input_shape", ge::kIrInputRequired, ""},
{"grads", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ksize",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ksize, ksize + ksize_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"ceil_mode",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(ceil_mode))
},
{
"count_include_pad",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(count_include_pad))
},
{
"divisor_override",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(divisor_override))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(orig_input_shape->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grads->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAvgPool3DGradD(EsbTensor *grads, EsbTensor *filter, EsbTensor *multiplier, const int64_t *orig_input_shape, int64_t orig_input_shape_num, const int64_t *ksize, int64_t ksize_num, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, bool ceil_mode, bool count_include_pad, int64_t divisor_override, const char *data_format) {
GE_ASSERT_NOTNULL(grads);
auto &graph = grads->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AvgPool3DGradD")
.Name(("AvgPool3DGradD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grads", ge::kIrInputRequired, ""},
{"filter", ge::kIrInputOptional, ""},
{"multiplier", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"orig_input_shape",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(orig_input_shape, orig_input_shape + orig_input_shape_num))
},
{
"ksize",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ksize, ksize + ksize_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"ceil_mode",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(ceil_mode))
},
{
"count_include_pad",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(count_include_pad))
},
{
"divisor_override",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(divisor_override))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grads->GetAnchor(), node->GetInDataAnchor(0)));
if (filter != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(filter->GetAnchor(), node->GetInDataAnchor(1)));
}
if (multiplier != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(multiplier->GetAnchor(), node->GetInDataAnchor(2)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAvgPoolGrad(EsbTensor *orig_input_shape, EsbTensor *input_grad, const int64_t *ksize, int64_t ksize_num, const int64_t *strides, int64_t strides_num, const char *padding, const char *data_format) {
GE_ASSERT_NOTNULL(orig_input_shape);
GE_ASSERT_NOTNULL(input_grad);
auto &graph = orig_input_shape->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AvgPoolGrad")
.Name(("AvgPoolGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"orig_input_shape", ge::kIrInputRequired, ""},
{"input_grad", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"out_grad", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ksize",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ksize, ksize + ksize_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"padding",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(padding))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(orig_input_shape->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_grad->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAvgPoolGradD(EsbTensor *input_grad, EsbTensor *mean_matrix, EsbTensor *kernel_matrix, const int64_t *orig_input_shape, int64_t orig_input_shape_num, const int64_t *ksize, int64_t ksize_num, const int64_t *strides, int64_t strides_num, const char *padding, const char *data_format) {
GE_ASSERT_NOTNULL(input_grad);
GE_ASSERT_NOTNULL(mean_matrix);
GE_ASSERT_NOTNULL(kernel_matrix);
auto &graph = input_grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AvgPoolGradD")
.Name(("AvgPoolGradD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_grad", ge::kIrInputRequired, ""},
{"mean_matrix", ge::kIrInputRequired, ""},
{"kernel_matrix", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"out_grad", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"orig_input_shape",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(orig_input_shape, orig_input_shape + orig_input_shape_num))
},
{
"ksize",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ksize, ksize + ksize_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"padding",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(padding))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_grad->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean_matrix->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(kernel_matrix->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAvgPoolUpdate(EsbTensor *x1, EsbTensor *x2, const int64_t *ksize, int64_t ksize_num, const int64_t *strides, int64_t strides_num, const char *padding_mode, const int64_t *pads, int64_t pads_num, const char *data_format, bool ceil_mode, bool exclusive) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AvgPoolUpdate")
.Name(("AvgPoolUpdate_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ksize",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ksize, ksize + ksize_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"padding_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(padding_mode))
},
{
"pads",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"ceil_mode",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(ceil_mode))
},
{
"exclusive",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(exclusive))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAvgPoolV2(EsbTensor *x, const int64_t *ksize, int64_t ksize_num, const int64_t *strides, int64_t strides_num, const char *padding_mode, const int64_t *pads, int64_t pads_num, const char *data_format, bool global_pooling, bool ceil_mode, bool exclusive, int64_t divisor_override) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AvgPoolV2")
.Name(("AvgPoolV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ksize",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ksize, ksize + ksize_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"padding_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(padding_mode))
},
{
"pads",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"global_pooling",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(global_pooling))
},
{
"ceil_mode",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(ceil_mode))
},
{
"exclusive",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(exclusive))
},
{
"divisor_override",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(divisor_override))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAvgPoolV2Grad(EsbTensor *orig_input_shape, EsbTensor *input_grad, const int64_t *ksize, int64_t ksize_num, const int64_t *strides, int64_t strides_num, const char *padding_mode, const int64_t *pads, int64_t pads_num, const char *data_format, bool global_pooling, bool ceil_mode, bool exclusive) {
GE_ASSERT_NOTNULL(orig_input_shape);
GE_ASSERT_NOTNULL(input_grad);
auto &graph = orig_input_shape->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AvgPoolV2Grad")
.Name(("AvgPoolV2Grad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"orig_input_shape", ge::kIrInputRequired, ""},
{"input_grad", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"out_grad", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ksize",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ksize, ksize + ksize_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"padding_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(padding_mode))
},
{
"pads",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"global_pooling",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(global_pooling))
},
{
"ceil_mode",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(ceil_mode))
},
{
"exclusive",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(exclusive))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(orig_input_shape->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_grad->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAvgPoolV2GradD(EsbTensor *input_grad, EsbTensor *mean_matrix, EsbTensor *kernel_matrix, const int64_t *orig_input_shape, int64_t orig_input_shape_num, const int64_t *ksize, int64_t ksize_num, const int64_t *strides, int64_t strides_num, const char *padding_mode, const int64_t *pads, int64_t pads_num, const char *data_format, bool global_pooling, bool ceil_mode, bool exclusive) {
GE_ASSERT_NOTNULL(input_grad);
auto &graph = input_grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AvgPoolV2GradD")
.Name(("AvgPoolV2GradD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_grad", ge::kIrInputRequired, ""},
{"mean_matrix", ge::kIrInputOptional, ""},
{"kernel_matrix", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"out_grad", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"orig_input_shape",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(orig_input_shape, orig_input_shape + orig_input_shape_num))
},
{
"ksize",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ksize, ksize + ksize_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"padding_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(padding_mode))
},
{
"pads",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"global_pooling",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(global_pooling))
},
{
"ceil_mode",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(ceil_mode))
},
{
"exclusive",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(exclusive))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_grad->GetAnchor(), node->GetInDataAnchor(0)));
if (mean_matrix != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean_matrix->GetAnchor(), node->GetInDataAnchor(1)));
}
if (kernel_matrix != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(kernel_matrix->GetAnchor(), node->GetInDataAnchor(2)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAxpy(EsbTensor *x1, EsbTensor *x2, float alpha) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Axpy")
.Name(("Axpy_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"alpha",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(alpha))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsAxpyV2(EsbTensor *x1, EsbTensor *x2, EsbTensor *alpha) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
GE_ASSERT_NOTNULL(alpha);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AxpyV2")
.Name(("AxpyV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"alpha", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(alpha->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsAxpyWithSoftmaxAndDropOutDoMaskOutput EsAxpyWithSoftmaxAndDropOutDoMask(EsbTensor *x1, EsbTensor *x2, EsbTensor *mask, float alpha, float input_keep_prob, const int64_t *axis, int64_t axis_num) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
GE_ASSERT_NOTNULL(mask);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("AxpyWithSoftmaxAndDropOutDoMask")
.Name(("AxpyWithSoftmaxAndDropOutDoMask_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"mask", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y1", ge::kIrOutputRequired, ""},
{"y2", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"alpha",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(alpha))
},
{
"input_keep_prob",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(input_keep_prob))
},
{
"axis",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(axis, axis + axis_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mask->GetAnchor(), node->GetInDataAnchor(2)));
return EsAxpyWithSoftmaxAndDropOutDoMaskOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsBN3DTrainingReduceOutput EsBN3DTrainingReduce(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BN3DTrainingReduce")
.Name(("BN3DTrainingReduce_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"sum", ge::kIrOutputRequired, ""},
{"square_sum", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return EsBN3DTrainingReduceOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsBN3DTrainingReduceGrad(EsbTensor *grads, EsbTensor *x, EsbTensor *diff_scale, EsbTensor *diff_offset, EsbTensor *scale, EsbTensor *batch_mean, EsbTensor *batch_variance, float epsilon) {
GE_ASSERT_NOTNULL(grads);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(diff_scale);
GE_ASSERT_NOTNULL(diff_offset);
GE_ASSERT_NOTNULL(scale);
GE_ASSERT_NOTNULL(batch_mean);
GE_ASSERT_NOTNULL(batch_variance);
auto &graph = grads->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BN3DTrainingReduceGrad")
.Name(("BN3DTrainingReduceGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grads", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"diff_scale", ge::kIrInputRequired, ""},
{"diff_offset", ge::kIrInputRequired, ""},
{"scale", ge::kIrInputRequired, ""},
{"batch_mean", ge::kIrInputRequired, ""},
{"batch_variance", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grads->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(diff_scale->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(diff_offset->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(batch_mean->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(batch_variance->GetAnchor(), node->GetInDataAnchor(6)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsBN3DTrainingUpdateOutput EsBN3DTrainingUpdate(EsbTensor *x, EsbTensor *sum, EsbTensor *square_sum, EsbTensor *scale, EsbTensor *offset, EsbTensor *mean, EsbTensor *variance, float factor, float epsilon) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(sum);
GE_ASSERT_NOTNULL(square_sum);
GE_ASSERT_NOTNULL(scale);
GE_ASSERT_NOTNULL(offset);
GE_ASSERT_NOTNULL(mean);
GE_ASSERT_NOTNULL(variance);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BN3DTrainingUpdate")
.Name(("BN3DTrainingUpdate_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"sum", ge::kIrInputRequired, ""},
{"square_sum", ge::kIrInputRequired, ""},
{"scale", ge::kIrInputRequired, ""},
{"offset", ge::kIrInputRequired, ""},
{"mean", ge::kIrInputRequired, ""},
{"variance", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"mean", ge::kIrOutputRequired, ""},
{"variance", ge::kIrOutputRequired, ""},
{"batch_mean", ge::kIrOutputRequired, ""},
{"batch_variance", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"factor",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(factor))
},
{
"epsilon",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(square_sum->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(variance->GetAnchor(), node->GetInDataAnchor(6)));
return EsBN3DTrainingUpdateOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
};
}
EsBN3DTrainingUpdateGradOutput EsBN3DTrainingUpdateGrad(EsbTensor *grads, EsbTensor *x, EsbTensor *batch_mean, EsbTensor *batch_variance, float epsilon) {
GE_ASSERT_NOTNULL(grads);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(batch_mean);
GE_ASSERT_NOTNULL(batch_variance);
auto &graph = grads->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BN3DTrainingUpdateGrad")
.Name(("BN3DTrainingUpdateGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grads", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"batch_mean", ge::kIrInputRequired, ""},
{"batch_variance", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"diff_scale", ge::kIrOutputRequired, ""},
{"diff_offset", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grads->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(batch_mean->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(batch_variance->GetAnchor(), node->GetInDataAnchor(3)));
return EsBN3DTrainingUpdateGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsBNInfer(EsbTensor *x, EsbTensor *scale, EsbTensor *offset, EsbTensor *mean, EsbTensor *variance, float epsilon) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(scale);
GE_ASSERT_NOTNULL(offset);
GE_ASSERT_NOTNULL(mean);
GE_ASSERT_NOTNULL(variance);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BNInfer")
.Name(("BNInfer_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"scale", ge::kIrInputRequired, ""},
{"offset", ge::kIrInputRequired, ""},
{"mean", ge::kIrInputRequired, ""},
{"variance", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"epsilon",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(variance->GetAnchor(), node->GetInDataAnchor(4)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsBNInferGrad(EsbTensor *grads, EsbTensor *scale, EsbTensor *batch_variance, float epsilon) {
GE_ASSERT_NOTNULL(grads);
GE_ASSERT_NOTNULL(scale);
GE_ASSERT_NOTNULL(batch_variance);
auto &graph = grads->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BNInferGrad")
.Name(("BNInferGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grads", ge::kIrInputRequired, ""},
{"scale", ge::kIrInputRequired, ""},
{"batch_variance", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"x_backprop", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grads->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(batch_variance->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsBNInference(EsbTensor *x, EsbTensor *mean, EsbTensor *variance, EsbTensor *momentum, EsbTensor *scale, EsbTensor *offset, float epsilon, bool use_global_stats, int64_t mode) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(mean);
GE_ASSERT_NOTNULL(variance);
GE_ASSERT_NOTNULL(momentum);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BNInference")
.Name(("BNInference_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"mean", ge::kIrInputRequired, ""},
{"variance", ge::kIrInputRequired, ""},
{"momentum", ge::kIrInputRequired, ""},
{"scale", ge::kIrInputOptional, ""},
{"offset", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
{
"use_global_stats",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_global_stats))
},
{
"mode",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(variance->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(momentum->GetAnchor(), node->GetInDataAnchor(3)));
if (scale != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(4)));
}
if (offset != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset->GetAnchor(), node->GetInDataAnchor(5)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsBNInferenceD(EsbTensor *x, EsbTensor *mean, EsbTensor *variance, EsbTensor *scale, EsbTensor *b, float momentum, float epsilon, bool use_global_stats, int64_t mode) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(mean);
GE_ASSERT_NOTNULL(variance);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BNInferenceD")
.Name(("BNInferenceD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"mean", ge::kIrInputRequired, ""},
{"variance", ge::kIrInputRequired, ""},
{"scale", ge::kIrInputOptional, ""},
{"b", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"momentum",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(momentum))
},
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
{
"use_global_stats",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_global_stats))
},
{
"mode",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(variance->GetAnchor(), node->GetInDataAnchor(2)));
if (scale != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(3)));
}
if (b != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(b->GetAnchor(), node->GetInDataAnchor(4)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsBNLL(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BNLL")
.Name(("BNLL_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsBNTrainingReduceOutput EsBNTrainingReduce(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BNTrainingReduce")
.Name(("BNTrainingReduce_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"sum", ge::kIrOutputRequired, ""},
{"square_sum", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return EsBNTrainingReduceOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsBNTrainingReduceGrad(EsbTensor *grads, EsbTensor *x, EsbTensor *diff_scale, EsbTensor *diff_offset, EsbTensor *scale, EsbTensor *batch_mean, EsbTensor *batch_variance, float epsilon) {
GE_ASSERT_NOTNULL(grads);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(diff_scale);
GE_ASSERT_NOTNULL(diff_offset);
GE_ASSERT_NOTNULL(scale);
GE_ASSERT_NOTNULL(batch_mean);
GE_ASSERT_NOTNULL(batch_variance);
auto &graph = grads->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BNTrainingReduceGrad")
.Name(("BNTrainingReduceGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grads", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"diff_scale", ge::kIrInputRequired, ""},
{"diff_offset", ge::kIrInputRequired, ""},
{"scale", ge::kIrInputRequired, ""},
{"batch_mean", ge::kIrInputRequired, ""},
{"batch_variance", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grads->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(diff_scale->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(diff_offset->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(batch_mean->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(batch_variance->GetAnchor(), node->GetInDataAnchor(6)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsBNTrainingUpdateOutput EsBNTrainingUpdate(EsbTensor *x, EsbTensor *sum, EsbTensor *square_sum, EsbTensor *scale, EsbTensor *offset, EsbTensor *mean, EsbTensor *variance, float factor, float epsilon) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(sum);
GE_ASSERT_NOTNULL(square_sum);
GE_ASSERT_NOTNULL(scale);
GE_ASSERT_NOTNULL(offset);
GE_ASSERT_NOTNULL(mean);
GE_ASSERT_NOTNULL(variance);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BNTrainingUpdate")
.Name(("BNTrainingUpdate_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"sum", ge::kIrInputRequired, ""},
{"square_sum", ge::kIrInputRequired, ""},
{"scale", ge::kIrInputRequired, ""},
{"offset", ge::kIrInputRequired, ""},
{"mean", ge::kIrInputRequired, ""},
{"variance", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"mean", ge::kIrOutputRequired, ""},
{"variance", ge::kIrOutputRequired, ""},
{"batch_mean", ge::kIrOutputRequired, ""},
{"batch_variance", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"factor",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(factor))
},
{
"epsilon",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(square_sum->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(variance->GetAnchor(), node->GetInDataAnchor(6)));
return EsBNTrainingUpdateOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
};
}
EsBNTrainingUpdateGradOutput EsBNTrainingUpdateGrad(EsbTensor *grads, EsbTensor *x, EsbTensor *batch_mean, EsbTensor *batch_variance, float epsilon) {
GE_ASSERT_NOTNULL(grads);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(batch_mean);
GE_ASSERT_NOTNULL(batch_variance);
auto &graph = grads->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BNTrainingUpdateGrad")
.Name(("BNTrainingUpdateGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grads", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"batch_mean", ge::kIrInputRequired, ""},
{"batch_variance", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"diff_scale", ge::kIrOutputRequired, ""},
{"diff_offset", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grads->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(batch_mean->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(batch_variance->GetAnchor(), node->GetInDataAnchor(3)));
return EsBNTrainingUpdateGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsBNTrainingUpdateV2Output EsBNTrainingUpdateV2(EsbTensor *x, EsbTensor *sum, EsbTensor *square_sum, EsbTensor *scale, EsbTensor *offset, float epsilon) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(sum);
GE_ASSERT_NOTNULL(square_sum);
GE_ASSERT_NOTNULL(scale);
GE_ASSERT_NOTNULL(offset);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BNTrainingUpdateV2")
.Name(("BNTrainingUpdateV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"sum", ge::kIrInputRequired, ""},
{"square_sum", ge::kIrInputRequired, ""},
{"scale", ge::kIrInputRequired, ""},
{"offset", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"batch_mean", ge::kIrOutputRequired, ""},
{"batch_variance", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"epsilon",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(square_sum->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset->GetAnchor(), node->GetInDataAnchor(4)));
return EsBNTrainingUpdateV2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsBNTrainingUpdateV3Output EsBNTrainingUpdateV3(EsbTensor *x, EsbTensor *sum, EsbTensor *square_sum, EsbTensor *scale, EsbTensor *offset, float epsilon) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(sum);
GE_ASSERT_NOTNULL(square_sum);
GE_ASSERT_NOTNULL(scale);
GE_ASSERT_NOTNULL(offset);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BNTrainingUpdateV3")
.Name(("BNTrainingUpdateV3_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"sum", ge::kIrInputRequired, ""},
{"square_sum", ge::kIrInputRequired, ""},
{"scale", ge::kIrInputRequired, ""},
{"offset", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"batch_mean", ge::kIrOutputRequired, ""},
{"batch_variance", ge::kIrOutputRequired, ""},
{"reserve_1", ge::kIrOutputRequired, ""},
{"reserve_2", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"epsilon",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(square_sum->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset->GetAnchor(), node->GetInDataAnchor(4)));
return EsBNTrainingUpdateV3Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
};
}
EsBalanceRoisOutput EsBalanceRois(EsbTensor *rois) {
GE_ASSERT_NOTNULL(rois);
auto &graph = rois->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BalanceRois")
.Name(("BalanceRois_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"rois", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"balance_rois", ge::kIrOutputRequired, ""},
{"index", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rois->GetAnchor(), node->GetInDataAnchor(0)));
return EsBalanceRoisOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsBallQuery(EsbTensor *xyz, EsbTensor *center_xyz, float min_radius, float max_radius, int64_t sample_num) {
GE_ASSERT_NOTNULL(xyz);
GE_ASSERT_NOTNULL(center_xyz);
auto &graph = xyz->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BallQuery")
.Name(("BallQuery_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"xyz", ge::kIrInputRequired, ""},
{"center_xyz", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"idx", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"min_radius",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(min_radius))
},
{
"max_radius",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(max_radius))
},
{
"sample_num",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(sample_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(xyz->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(center_xyz->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsBandedTriangularSolve(EsbTensor *bands, EsbTensor *rhs, bool lower, bool adjoint) {
GE_ASSERT_NOTNULL(bands);
GE_ASSERT_NOTNULL(rhs);
auto &graph = bands->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BandedTriangularSolve")
.Name(("BandedTriangularSolve_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"bands", ge::kIrInputRequired, ""},
{"rhs", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"lower",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(lower))
},
{
"adjoint",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(adjoint))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bands->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rhs->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsBarrierClose(EsbTensor *handle, bool cancel_pending_enqueues) {
GE_ASSERT_NOTNULL(handle);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BarrierClose")
.Name(("BarrierClose_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
{
"cancel_pending_enqueues",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(cancel_pending_enqueues))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsBarrierIncompleteSize(EsbTensor *handle) {
GE_ASSERT_NOTNULL(handle);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BarrierIncompleteSize")
.Name(("BarrierIncompleteSize_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"size", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsBarrierInsertMany(EsbTensor *handle, EsbTensor *keys, EsbTensor *values, int64_t component_index) {
GE_ASSERT_NOTNULL(handle);
GE_ASSERT_NOTNULL(keys);
GE_ASSERT_NOTNULL(values);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BarrierInsertMany")
.Name(("BarrierInsertMany_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
{"keys", ge::kIrInputRequired, ""},
{"values", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
{
"component_index",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(component_index))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(keys->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(values->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsBarrierReadySize(EsbTensor *handle) {
GE_ASSERT_NOTNULL(handle);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BarrierReadySize")
.Name(("BarrierReadySize_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"size", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsBasicLSTMCellOutput EsBasicLSTMCell(EsbTensor *x, EsbTensor *h, EsbTensor *c, EsbTensor *w, EsbTensor *b, EsbTensor *mask, float keep_prob, float forget_bias, bool state_is_tuple, const char *activation) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(h);
GE_ASSERT_NOTNULL(c);
GE_ASSERT_NOTNULL(w);
GE_ASSERT_NOTNULL(b);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BasicLSTMCell")
.Name(("BasicLSTMCell_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"h", ge::kIrInputRequired, ""},
{"c", ge::kIrInputRequired, ""},
{"w", ge::kIrInputRequired, ""},
{"b", ge::kIrInputRequired, ""},
{"mask", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"ct", ge::kIrOutputRequired, ""},
{"ht", ge::kIrOutputRequired, ""},
{"it", ge::kIrOutputRequired, ""},
{"jt", ge::kIrOutputRequired, ""},
{"ft", ge::kIrOutputRequired, ""},
{"ot", ge::kIrOutputRequired, ""},
{"tanhct", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"keep_prob",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(keep_prob))
},
{
"forget_bias",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(forget_bias))
},
{
"state_is_tuple",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(state_is_tuple))
},
{
"activation",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(activation))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(h->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(c->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(w->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(b->GetAnchor(), node->GetInDataAnchor(4)));
if (mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mask->GetAnchor(), node->GetInDataAnchor(5)));
}
return EsBasicLSTMCellOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
graph.GetEsbTensorFromNode(node, 5),
graph.GetEsbTensorFromNode(node, 6),
};
}
EsBasicLSTMCellCStateGradOutput EsBasicLSTMCellCStateGrad(EsbTensor *c, EsbTensor *dht, EsbTensor *dct, EsbTensor *it, EsbTensor *jt, EsbTensor *ft, EsbTensor *ot, EsbTensor *tanhct, float forget_bias, const char *activation) {
GE_ASSERT_NOTNULL(c);
GE_ASSERT_NOTNULL(dht);
GE_ASSERT_NOTNULL(dct);
GE_ASSERT_NOTNULL(it);
GE_ASSERT_NOTNULL(jt);
GE_ASSERT_NOTNULL(ft);
GE_ASSERT_NOTNULL(ot);
GE_ASSERT_NOTNULL(tanhct);
auto &graph = c->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BasicLSTMCellCStateGrad")
.Name(("BasicLSTMCellCStateGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"c", ge::kIrInputRequired, ""},
{"dht", ge::kIrInputRequired, ""},
{"dct", ge::kIrInputRequired, ""},
{"it", ge::kIrInputRequired, ""},
{"jt", ge::kIrInputRequired, ""},
{"ft", ge::kIrInputRequired, ""},
{"ot", ge::kIrInputRequired, ""},
{"tanhct", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"dgate", ge::kIrOutputRequired, ""},
{"dct_1", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"forget_bias",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(forget_bias))
},
{
"activation",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(activation))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(c->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dht->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dct->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(it->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(jt->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(ft->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(ot->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(tanhct->GetAnchor(), node->GetInDataAnchor(7)));
return EsBasicLSTMCellCStateGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsBasicLSTMCellInputGradOutput EsBasicLSTMCellInputGrad(EsbTensor *dgate, EsbTensor *w, EsbTensor *dropout_mask, float keep_prob) {
GE_ASSERT_NOTNULL(dgate);
GE_ASSERT_NOTNULL(w);
auto &graph = dgate->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BasicLSTMCellInputGrad")
.Name(("BasicLSTMCellInputGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"dgate", ge::kIrInputRequired, ""},
{"w", ge::kIrInputRequired, ""},
{"dropout_mask", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"dxt", ge::kIrOutputRequired, ""},
{"dht", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"keep_prob",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(keep_prob))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dgate->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(w->GetAnchor(), node->GetInDataAnchor(1)));
if (dropout_mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dropout_mask->GetAnchor(), node->GetInDataAnchor(2)));
}
return EsBasicLSTMCellInputGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsBasicLSTMCellWeightGradOutput EsBasicLSTMCellWeightGrad(EsbTensor *x, EsbTensor *h, EsbTensor *dgate) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(h);
GE_ASSERT_NOTNULL(dgate);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BasicLSTMCellWeightGrad")
.Name(("BasicLSTMCellWeightGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"h", ge::kIrInputRequired, ""},
{"dgate", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"dw", ge::kIrOutputRequired, ""},
{"db", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(h->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dgate->GetAnchor(), node->GetInDataAnchor(2)));
return EsBasicLSTMCellWeightGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsBasicRNNCellOutput EsBasicRNNCell(EsbTensor *x, EsbTensor *cont, EsbTensor *w_xh_x_static, EsbTensor *h_0, EsbTensor *w_xh, EsbTensor *bias_h, EsbTensor *w_hh, EsbTensor *w_ho, EsbTensor *bias_o, bool expose_hidden, int64_t num_output) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(w_xh);
GE_ASSERT_NOTNULL(bias_h);
GE_ASSERT_NOTNULL(w_ho);
GE_ASSERT_NOTNULL(bias_o);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BasicRNNCell")
.Name(("BasicRNNCell_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"cont", ge::kIrInputOptional, ""},
{"w_xh_x_static", ge::kIrInputOptional, ""},
{"h_0", ge::kIrInputOptional, ""},
{"w_xh", ge::kIrInputRequired, ""},
{"bias_h", ge::kIrInputRequired, ""},
{"w_hh", ge::kIrInputOptional, ""},
{"w_ho", ge::kIrInputRequired, ""},
{"bias_o", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"o_t", ge::kIrOutputRequired, ""},
{"h_t", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"expose_hidden",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(expose_hidden))
},
{
"num_output",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_output))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
if (cont != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(cont->GetAnchor(), node->GetInDataAnchor(1)));
}
if (w_xh_x_static != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(w_xh_x_static->GetAnchor(), node->GetInDataAnchor(2)));
}
if (h_0 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(h_0->GetAnchor(), node->GetInDataAnchor(3)));
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(w_xh->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias_h->GetAnchor(), node->GetInDataAnchor(5)));
if (w_hh != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(w_hh->GetAnchor(), node->GetInDataAnchor(6)));
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(w_ho->GetAnchor(), node->GetInDataAnchor(7)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias_o->GetAnchor(), node->GetInDataAnchor(8)));
return EsBasicRNNCellOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsBatchDilatePolysOutput EsBatchDilatePolys(EsbTensor *polys_data, EsbTensor *polys_offset, EsbTensor *polys_size, EsbTensor *score, EsbTensor *min_border, EsbTensor *min_area_thr, EsbTensor *score_thr, EsbTensor *expands_cale) {
GE_ASSERT_NOTNULL(polys_data);
GE_ASSERT_NOTNULL(polys_offset);
GE_ASSERT_NOTNULL(polys_size);
GE_ASSERT_NOTNULL(score);
GE_ASSERT_NOTNULL(min_border);
GE_ASSERT_NOTNULL(min_area_thr);
GE_ASSERT_NOTNULL(score_thr);
GE_ASSERT_NOTNULL(expands_cale);
auto &graph = polys_data->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BatchDilatePolys")
.Name(("BatchDilatePolys_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"polys_data", ge::kIrInputRequired, ""},
{"polys_offset", ge::kIrInputRequired, ""},
{"polys_size", ge::kIrInputRequired, ""},
{"score", ge::kIrInputRequired, ""},
{"min_border", ge::kIrInputRequired, ""},
{"min_area_thr", ge::kIrInputRequired, ""},
{"score_thr", ge::kIrInputRequired, ""},
{"expands_cale", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"dilated_polys_data", ge::kIrOutputRequired, ""},
{"dilated_polys_offset", ge::kIrOutputRequired, ""},
{"dilated_polys_size", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(polys_data->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(polys_offset->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(polys_size->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(score->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(min_border->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(min_area_thr->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(score_thr->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(expands_cale->GetAnchor(), node->GetInDataAnchor(7)));
return EsBatchDilatePolysOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsBatchEnqueue(EsbTensor *x, EsbTensor *queue_id, int64_t batch_size, const char *queue_name, int64_t queue_depth, const char *pad_mode) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BatchEnqueue")
.Name(("BatchEnqueue_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"queue_id", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"enqueue_count", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"batch_size",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(batch_size))
},
{
"queue_name",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(queue_name))
},
{
"queue_depth",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(queue_depth))
},
{
"pad_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(pad_mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
if (queue_id != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(queue_id->GetAnchor(), node->GetInDataAnchor(1)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsBatchMatMul(EsbTensor *x1, EsbTensor *x2, bool adj_x1, bool adj_x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BatchMatMul")
.Name(("BatchMatMul_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"adj_x1",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(adj_x1))
},
{
"adj_x2",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(adj_x2))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsBatchMatMulReduceScatterAlltoAll(EsbTensor *x, EsbTensor *weight, EsbTensor *bias, const char *group_ep, const char *group_tp, int64_t ep_world_size, int64_t tp_world_size, int64_t y_shard_type, bool transpose_weight) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(weight);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BatchMatMulReduceScatterAlltoAll")
.Name(("BatchMatMulReduceScatterAlltoAll_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"weight", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"group_ep",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(group_ep))
},
{
"group_tp",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(group_tp))
},
{
"ep_world_size",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(ep_world_size))
},
{
"tp_world_size",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(tp_world_size))
},
{
"y_shard_type",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(y_shard_type))
},
{
"transpose_weight",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(transpose_weight))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight->GetAnchor(), node->GetInDataAnchor(1)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(2)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsBatchMatMulV2(EsbTensor *x1, EsbTensor *x2, EsbTensor *bias, EsbTensor *offset_w, bool adj_x1, bool adj_x2, int64_t offset_x) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BatchMatMulV2")
.Name(("BatchMatMulV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
{"offset_w", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"adj_x1",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(adj_x1))
},
{
"adj_x2",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(adj_x2))
},
{
"offset_x",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(offset_x))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(2)));
}
if (offset_w != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset_w->GetAnchor(), node->GetInDataAnchor(3)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsBatchMatMulV3(EsbTensor *x1, EsbTensor *x2, EsbTensor *bias, EsbTensor *offset_w, bool adj_x1, bool adj_x2, int64_t offset_x, bool enable_hf32) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BatchMatMulV3")
.Name(("BatchMatMulV3_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
{"offset_w", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"adj_x1",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(adj_x1))
},
{
"adj_x2",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(adj_x2))
},
{
"offset_x",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(offset_x))
},
{
"enable_hf32",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(enable_hf32))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(2)));
}
if (offset_w != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset_w->GetAnchor(), node->GetInDataAnchor(3)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsBatchMatmulFixpipe(EsbTensor *x1, EsbTensor *x2, EsbTensor *quant_pre, EsbTensor *bias, bool adj_x1, bool adj_x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
GE_ASSERT_NOTNULL(quant_pre);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BatchMatmulFixpipe")
.Name(("BatchMatmulFixpipe_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"quant_pre", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"adj_x1",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(adj_x1))
},
{
"adj_x2",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(adj_x2))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(quant_pre->GetAnchor(), node->GetInDataAnchor(2)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(3)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsBatchMultiClassNonMaxSuppressionOutput EsBatchMultiClassNonMaxSuppression(EsbTensor *boxes, EsbTensor *scores, EsbTensor *clip_window, EsbTensor *num_valid_boxes, float score_threshold, float iou_threshold, int64_t max_size_per_class, int64_t max_total_size, bool change_coordinate_frame, bool transpose_box, const int64_t *image_size, int64_t image_size_num) {
GE_ASSERT_NOTNULL(boxes);
GE_ASSERT_NOTNULL(scores);
auto &graph = boxes->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BatchMultiClassNonMaxSuppression")
.Name(("BatchMultiClassNonMaxSuppression_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"boxes", ge::kIrInputRequired, ""},
{"scores", ge::kIrInputRequired, ""},
{"clip_window", ge::kIrInputOptional, ""},
{"num_valid_boxes", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"nmsed_boxes", ge::kIrOutputRequired, ""},
{"nmsed_scores", ge::kIrOutputRequired, ""},
{"nmsed_classes", ge::kIrOutputRequired, ""},
{"nmsed_num", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"score_threshold",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(score_threshold))
},
{
"iou_threshold",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(iou_threshold))
},
{
"max_size_per_class",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(max_size_per_class))
},
{
"max_total_size",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(max_total_size))
},
{
"change_coordinate_frame",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(change_coordinate_frame))
},
{
"transpose_box",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(transpose_box))
},
{
"image_size",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(image_size, image_size + image_size_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(boxes->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scores->GetAnchor(), node->GetInDataAnchor(1)));
if (clip_window != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(clip_window->GetAnchor(), node->GetInDataAnchor(2)));
}
if (num_valid_boxes != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(num_valid_boxes->GetAnchor(), node->GetInDataAnchor(3)));
}
return EsBatchMultiClassNonMaxSuppressionOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsBatchNormOutput EsBatchNorm(EsbTensor *x, EsbTensor *scale, EsbTensor *offset, EsbTensor *mean, EsbTensor *variance, float epsilon, const char *data_format, bool is_training, float exponential_avg_factor) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(scale);
GE_ASSERT_NOTNULL(offset);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BatchNorm")
.Name(("BatchNorm_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"scale", ge::kIrInputRequired, ""},
{"offset", ge::kIrInputRequired, ""},
{"mean", ge::kIrInputOptional, ""},
{"variance", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"batch_mean", ge::kIrOutputRequired, ""},
{"batch_variance", ge::kIrOutputRequired, ""},
{"reserve_space_1", ge::kIrOutputRequired, ""},
{"reserve_space_2", ge::kIrOutputRequired, ""},
{"reserve_space_3", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"is_training",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_training))
},
{
"exponential_avg_factor",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(exponential_avg_factor))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset->GetAnchor(), node->GetInDataAnchor(2)));
if (mean != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(3)));
}
if (variance != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(variance->GetAnchor(), node->GetInDataAnchor(4)));
}
return EsBatchNormOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
graph.GetEsbTensorFromNode(node, 5),
};
}
EsBatchNorm3DOutput EsBatchNorm3D(EsbTensor *x, EsbTensor *scale, EsbTensor *offset, EsbTensor *mean, EsbTensor *variance, float epsilon, const char *data_format, bool is_training) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(scale);
GE_ASSERT_NOTNULL(offset);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BatchNorm3D")
.Name(("BatchNorm3D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"scale", ge::kIrInputRequired, ""},
{"offset", ge::kIrInputRequired, ""},
{"mean", ge::kIrInputOptional, ""},
{"variance", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"batch_mean", ge::kIrOutputRequired, ""},
{"batch_variance", ge::kIrOutputRequired, ""},
{"reserve_space_1", ge::kIrOutputRequired, ""},
{"reserve_space_2", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"is_training",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_training))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset->GetAnchor(), node->GetInDataAnchor(2)));
if (mean != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(3)));
}
if (variance != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(variance->GetAnchor(), node->GetInDataAnchor(4)));
}
return EsBatchNorm3DOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
};
}
EsBatchNorm3DGradOutput EsBatchNorm3DGrad(EsbTensor *y_backprop, EsbTensor *x, EsbTensor *scale, EsbTensor *reserve_space_1, EsbTensor *reserve_space_2, float epsilon, const char *data_format, bool is_training) {
GE_ASSERT_NOTNULL(y_backprop);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(scale);
GE_ASSERT_NOTNULL(reserve_space_1);
GE_ASSERT_NOTNULL(reserve_space_2);
auto &graph = y_backprop->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BatchNorm3DGrad")
.Name(("BatchNorm3DGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"y_backprop", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"scale", ge::kIrInputRequired, ""},
{"reserve_space_1", ge::kIrInputRequired, ""},
{"reserve_space_2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"x_backprop", ge::kIrOutputRequired, ""},
{"scale_backprop", ge::kIrOutputRequired, ""},
{"offset_backprop", ge::kIrOutputRequired, ""},
{"reserve_space_4", ge::kIrOutputRequired, ""},
{"reserve_space_5", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"is_training",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_training))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y_backprop->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(reserve_space_1->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(reserve_space_2->GetAnchor(), node->GetInDataAnchor(4)));
return EsBatchNorm3DGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
};
}
EsBatchNormExt2Output EsBatchNormExt2(EsbTensor *input_x, EsbTensor *input_scale, EsbTensor *input_offset, EsbTensor *input_mean, EsbTensor *input_variance, float epsilon, const char *data_format, bool is_training) {
GE_ASSERT_NOTNULL(input_x);
GE_ASSERT_NOTNULL(input_scale);
GE_ASSERT_NOTNULL(input_offset);
auto &graph = input_x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BatchNormExt2")
.Name(("BatchNormExt2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_x", ge::kIrInputRequired, ""},
{"input_scale", ge::kIrInputRequired, ""},
{"input_offset", ge::kIrInputRequired, ""},
{"input_mean", ge::kIrInputOptional, ""},
{"input_variance", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"output_y", ge::kIrOutputRequired, ""},
{"output_mean", ge::kIrOutputRequired, ""},
{"output_variance", ge::kIrOutputRequired, ""},
{"output_reserve_space_1", ge::kIrOutputRequired, ""},
{"output_reserve_space_2", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"is_training",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_training))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_scale->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_offset->GetAnchor(), node->GetInDataAnchor(2)));
if (input_mean != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_mean->GetAnchor(), node->GetInDataAnchor(3)));
}
if (input_variance != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_variance->GetAnchor(), node->GetInDataAnchor(4)));
}
return EsBatchNormExt2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
};
}
EsBatchNormGradOutput EsBatchNormGrad(EsbTensor *y_backprop, EsbTensor *x, EsbTensor *scale, EsbTensor *reserve_space_1, EsbTensor *reserve_space_2, EsbTensor *reserve_space_3, float epsilon, const char *data_format, bool is_training) {
GE_ASSERT_NOTNULL(y_backprop);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(scale);
GE_ASSERT_NOTNULL(reserve_space_1);
GE_ASSERT_NOTNULL(reserve_space_2);
auto &graph = y_backprop->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BatchNormGrad")
.Name(("BatchNormGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"y_backprop", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"scale", ge::kIrInputRequired, ""},
{"reserve_space_1", ge::kIrInputRequired, ""},
{"reserve_space_2", ge::kIrInputRequired, ""},
{"reserve_space_3", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"x_backprop", ge::kIrOutputRequired, ""},
{"scale_backprop", ge::kIrOutputRequired, ""},
{"offset_backprop", ge::kIrOutputRequired, ""},
{"reserve_space_4", ge::kIrOutputRequired, ""},
{"reserve_space_5", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"is_training",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_training))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y_backprop->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(reserve_space_1->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(reserve_space_2->GetAnchor(), node->GetInDataAnchor(4)));
if (reserve_space_3 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(reserve_space_3->GetAnchor(), node->GetInDataAnchor(5)));
}
return EsBatchNormGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
};
}
EsBatchNormGradExt2Output EsBatchNormGradExt2(EsbTensor *y_backprop, EsbTensor *x, EsbTensor *scale, EsbTensor *reserve_space_1, EsbTensor *reserve_space_2, float epsilon, const char *data_format, bool is_training) {
GE_ASSERT_NOTNULL(y_backprop);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(scale);
GE_ASSERT_NOTNULL(reserve_space_1);
GE_ASSERT_NOTNULL(reserve_space_2);
auto &graph = y_backprop->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BatchNormGradExt2")
.Name(("BatchNormGradExt2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"y_backprop", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"scale", ge::kIrInputRequired, ""},
{"reserve_space_1", ge::kIrInputRequired, ""},
{"reserve_space_2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"x_backprop", ge::kIrOutputRequired, ""},
{"scale_backprop", ge::kIrOutputRequired, ""},
{"offset_backprop", ge::kIrOutputRequired, ""},
{"reserve_space_3", ge::kIrOutputRequired, ""},
{"reserve_space_4", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"is_training",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_training))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y_backprop->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(reserve_space_1->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(reserve_space_2->GetAnchor(), node->GetInDataAnchor(4)));
return EsBatchNormGradExt2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
};
}
EsBatchNormV3Output EsBatchNormV3(EsbTensor *x, EsbTensor *weight, EsbTensor *bias, EsbTensor *running_mean, EsbTensor *running_var, float epsilon, float momentum, bool is_training) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(weight);
GE_ASSERT_NOTNULL(bias);
GE_ASSERT_NOTNULL(running_mean);
GE_ASSERT_NOTNULL(running_var);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BatchNormV3")
.Name(("BatchNormV3_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"weight", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputRequired, ""},
{"running_mean", ge::kIrInputRequired, ""},
{"running_var", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"running_mean", ge::kIrOutputRequired, ""},
{"running_var", ge::kIrOutputRequired, ""},
{"save_mean", ge::kIrOutputRequired, ""},
{"save_rstd", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
{
"momentum",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(momentum))
},
{
"is_training",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_training))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(running_mean->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(running_var->GetAnchor(), node->GetInDataAnchor(4)));
return EsBatchNormV3Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
};
}
EsbTensor *EsBatchToSpace(EsbTensor *x, EsbTensor *crops, int64_t block_size) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(crops);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BatchToSpace")
.Name(("BatchToSpace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"crops", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"block_size",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(block_size))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(crops->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsBatchToSpaceD(EsbTensor *x, int64_t block_size, const int64_t *crops, int64_t crops_num) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BatchToSpaceD")
.Name(("BatchToSpaceD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"block_size",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(block_size))
},
{
"crops",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(crops, crops + crops_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsBatchToSpaceND(EsbTensor *x, EsbTensor *block_shape, EsbTensor *crops) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(block_shape);
GE_ASSERT_NOTNULL(crops);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BatchToSpaceND")
.Name(("BatchToSpaceND_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"block_shape", ge::kIrInputRequired, ""},
{"crops", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(block_shape->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(crops->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsBatchToSpaceNDD(EsbTensor *x, const int64_t *block_shape, int64_t block_shape_num, const int64_t *crops, int64_t crops_num) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BatchToSpaceNDD")
.Name(("BatchToSpaceNDD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"block_shape",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(block_shape, block_shape + block_shape_num))
},
{
"crops",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(crops, crops + crops_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsBesselI0e(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BesselI0e")
.Name(("BesselI0e_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsBesselI1e(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BesselI1e")
.Name(("BesselI1e_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsBetainc(EsbTensor *a, EsbTensor *b, EsbTensor *x) {
GE_ASSERT_NOTNULL(a);
GE_ASSERT_NOTNULL(b);
GE_ASSERT_NOTNULL(x);
auto &graph = a->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Betainc")
.Name(("Betainc_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"a", ge::kIrInputRequired, ""},
{"b", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"z", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(a->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(b->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsBias(EsbTensor *x, EsbTensor *bias, int64_t axis, int64_t num_axes, bool bias_from_blob) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(bias);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Bias")
.Name(("Bias_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
{
"num_axes",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_axes))
},
{
"bias_from_blob",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(bias_from_blob))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsBiasAdd(EsbTensor *x, EsbTensor *bias, const char *data_format) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(bias);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BiasAdd")
.Name(("BiasAdd_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsBiasAddGrad(EsbTensor *x, const char *data_format) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BiasAddGrad")
.Name(("BiasAddGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsBinaryCrossEntropy(EsbTensor *x, EsbTensor *y, EsbTensor *weight, const char *reduction) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(y);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BinaryCrossEntropy")
.Name(("BinaryCrossEntropy_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"y", ge::kIrInputRequired, ""},
{"weight", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"reduction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduction))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y->GetAnchor(), node->GetInDataAnchor(1)));
if (weight != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight->GetAnchor(), node->GetInDataAnchor(2)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsBinaryCrossEntropyGrad(EsbTensor *x, EsbTensor *y, EsbTensor *grad_output, EsbTensor *weight, const char *reduction) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(y);
GE_ASSERT_NOTNULL(grad_output);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BinaryCrossEntropyGrad")
.Name(("BinaryCrossEntropyGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"y", ge::kIrInputRequired, ""},
{"grad_output", ge::kIrInputRequired, ""},
{"weight", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"reduction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduction))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad_output->GetAnchor(), node->GetInDataAnchor(2)));
if (weight != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight->GetAnchor(), node->GetInDataAnchor(3)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsBincount(EsbTensor *array, EsbTensor *size, EsbTensor *weights) {
GE_ASSERT_NOTNULL(array);
GE_ASSERT_NOTNULL(size);
GE_ASSERT_NOTNULL(weights);
auto &graph = array->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Bincount")
.Name(("Bincount_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"array", ge::kIrInputRequired, ""},
{"size", ge::kIrInputRequired, ""},
{"weights", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"bins", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(array->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(size->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weights->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsBitcast(EsbTensor *x, ge::DataType type) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Bitcast")
.Name(("Bitcast_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"type",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(type))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsBitwiseAnd(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BitwiseAnd")
.Name(("BitwiseAnd_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsBitwiseOr(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BitwiseOr")
.Name(("BitwiseOr_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsBitwiseXor(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BitwiseXor")
.Name(("BitwiseXor_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsBlendFaceBgPartOneOutput EsBlendFaceBgPartOne(EsbTensor *face_img, EsbTensor *face_rect, EsbTensor *face_mask, EsbTensor *acc_face, EsbTensor *acc_mask, EsbTensor *max_mask) {
GE_ASSERT_NOTNULL(face_img);
GE_ASSERT_NOTNULL(face_rect);
GE_ASSERT_NOTNULL(face_mask);
GE_ASSERT_NOTNULL(acc_face);
GE_ASSERT_NOTNULL(acc_mask);
GE_ASSERT_NOTNULL(max_mask);
auto &graph = face_img->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BlendFaceBgPartOne")
.Name(("BlendFaceBgPartOne_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"face_img", ge::kIrInputRequired, ""},
{"face_rect", ge::kIrInputRequired, ""},
{"face_mask", ge::kIrInputRequired, ""},
{"acc_face", ge::kIrInputRequired, ""},
{"acc_mask", ge::kIrInputRequired, ""},
{"max_mask", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"acc_face", ge::kIrOutputRequired, ""},
{"acc_mask", ge::kIrOutputRequired, ""},
{"max_mask", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(face_img->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(face_rect->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(face_mask->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(acc_face->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(acc_mask->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(max_mask->GetAnchor(), node->GetInDataAnchor(5)));
return EsBlendFaceBgPartOneOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsBlendFaceBgPartTwo(EsbTensor *acc_face, EsbTensor *acc_mask, EsbTensor *max_mask, EsbTensor *bg_img, float epsilon) {
GE_ASSERT_NOTNULL(acc_face);
GE_ASSERT_NOTNULL(acc_mask);
GE_ASSERT_NOTNULL(max_mask);
GE_ASSERT_NOTNULL(bg_img);
auto &graph = acc_face->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BlendFaceBgPartTwo")
.Name(("BlendFaceBgPartTwo_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"acc_face", ge::kIrInputRequired, ""},
{"acc_mask", ge::kIrInputRequired, ""},
{"max_mask", ge::kIrInputRequired, ""},
{"bg_img", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"fused_img", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(acc_face->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(acc_mask->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(max_mask->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bg_img->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsBlendImagesCustom(EsbTensor *rgb, EsbTensor *alpha, EsbTensor *frame) {
GE_ASSERT_NOTNULL(rgb);
GE_ASSERT_NOTNULL(alpha);
GE_ASSERT_NOTNULL(frame);
auto &graph = rgb->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BlendImagesCustom")
.Name(("BlendImagesCustom_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"rgb", ge::kIrInputRequired, ""},
{"alpha", ge::kIrInputRequired, ""},
{"frame", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"out", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rgb->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(alpha->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(frame->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsBoundingBoxDecode(EsbTensor *rois, EsbTensor *deltas, const int64_t *max_shape, int64_t max_shape_num, const float *means, int64_t means_num, const float *stds, int64_t stds_num, float wh_ratio_clip) {
GE_ASSERT_NOTNULL(rois);
GE_ASSERT_NOTNULL(deltas);
auto &graph = rois->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BoundingBoxDecode")
.Name(("BoundingBoxDecode_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"rois", ge::kIrInputRequired, ""},
{"deltas", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"bboxes", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"max_shape",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(max_shape, max_shape + max_shape_num))
},
{
"means",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(means, means + means_num))
},
{
"stds",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(stds, stds + stds_num))
},
{
"wh_ratio_clip",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(wh_ratio_clip))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rois->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(deltas->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsBoundingBoxEncode(EsbTensor *anchor_box, EsbTensor *ground_truth_box, const float *means, int64_t means_num, const float *stds, int64_t stds_num) {
GE_ASSERT_NOTNULL(anchor_box);
GE_ASSERT_NOTNULL(ground_truth_box);
auto &graph = anchor_box->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BoundingBoxEncode")
.Name(("BoundingBoxEncode_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"anchor_box", ge::kIrInputRequired, ""},
{"ground_truth_box", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"delats", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"means",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(means, means + means_num))
},
{
"stds",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(stds, stds + stds_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(anchor_box->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(ground_truth_box->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsBroadcastArgs(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BroadcastArgs")
.Name(("BroadcastArgs_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsBroadcastGradientArgsOutput EsBroadcastGradientArgs(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BroadcastGradientArgs")
.Name(("BroadcastGradientArgs_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y1", ge::kIrOutputRequired, ""},
{"y2", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return EsBroadcastGradientArgsOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsBroadcastTo(EsbTensor *x, EsbTensor *shape) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(shape);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BroadcastTo")
.Name(("BroadcastTo_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"shape", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsBroadcastToD(EsbTensor *x, const int64_t *shape, int64_t shape_num) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("BroadcastToD")
.Name(("BroadcastToD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"shape",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(shape, shape + shape_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsBucketize(EsbTensor *x, const float *boundaries, int64_t boundaries_num, ge::DataType dtype, bool right) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Bucketize")
.Name(("Bucketize_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"boundaries",
ge::kAttrRequired,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(boundaries, boundaries + boundaries_num))
},
{
"dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
{
"right",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(right))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsCIoUOutput EsCIoU(EsbTensor *bboxes, EsbTensor *gtboxes, bool trans, bool is_cross, const char *mode, bool atan_sub_flag) {
GE_ASSERT_NOTNULL(bboxes);
GE_ASSERT_NOTNULL(gtboxes);
auto &graph = bboxes->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("CIoU")
.Name(("CIoU_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"bboxes", ge::kIrInputRequired, ""},
{"gtboxes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"overlap", ge::kIrOutputRequired, ""},
{"atan_sub", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"trans",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(trans))
},
{
"is_cross",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_cross))
},
{
"mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(mode))
},
{
"atan_sub_flag",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(atan_sub_flag))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bboxes->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gtboxes->GetAnchor(), node->GetInDataAnchor(1)));
return EsCIoUOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsCIoUGradOutput EsCIoUGrad(EsbTensor *dy, EsbTensor *bboxes, EsbTensor *gtboxes, EsbTensor *atan_sub, bool trans, bool is_cross, const char *mode) {
GE_ASSERT_NOTNULL(dy);
GE_ASSERT_NOTNULL(bboxes);
GE_ASSERT_NOTNULL(gtboxes);
GE_ASSERT_NOTNULL(atan_sub);
auto &graph = dy->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("CIoUGrad")
.Name(("CIoUGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"dy", ge::kIrInputRequired, ""},
{"bboxes", ge::kIrInputRequired, ""},
{"gtboxes", ge::kIrInputRequired, ""},
{"atan_sub", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"dbboxes", ge::kIrOutputRequired, ""},
{"dgtboxes", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"trans",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(trans))
},
{
"is_cross",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_cross))
},
{
"mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bboxes->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gtboxes->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(atan_sub->GetAnchor(), node->GetInDataAnchor(3)));
return EsCIoUGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsCTCGreedyDecoderOutput EsCTCGreedyDecoder(EsbTensor *inputs, EsbTensor *sequence_length, bool merge_repeated) {
GE_ASSERT_NOTNULL(inputs);
GE_ASSERT_NOTNULL(sequence_length);
auto &graph = inputs->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("CTCGreedyDecoder")
.Name(("CTCGreedyDecoder_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"inputs", ge::kIrInputRequired, ""},
{"sequence_length", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"decoded_indices", ge::kIrOutputRequired, ""},
{"decoded_values", ge::kIrOutputRequired, ""},
{"decoded_shape", ge::kIrOutputRequired, ""},
{"log_probability", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"merge_repeated",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(merge_repeated))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(inputs->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sequence_length->GetAnchor(), node->GetInDataAnchor(1)));
return EsCTCGreedyDecoderOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsCTCLossOutput EsCTCLoss(EsbTensor *inputs, EsbTensor *labels_indices, EsbTensor *labels_values, EsbTensor *sequence_length, bool preprocess_collapse_repeated, bool ctc_merge_repeated, bool ignore_longer_outputs_than_inputs) {
GE_ASSERT_NOTNULL(inputs);
GE_ASSERT_NOTNULL(labels_indices);
GE_ASSERT_NOTNULL(labels_values);
GE_ASSERT_NOTNULL(sequence_length);
auto &graph = inputs->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("CTCLoss")
.Name(("CTCLoss_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"inputs", ge::kIrInputRequired, ""},
{"labels_indices", ge::kIrInputRequired, ""},
{"labels_values", ge::kIrInputRequired, ""},
{"sequence_length", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"loss", ge::kIrOutputRequired, ""},
{"gradient", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"preprocess_collapse_repeated",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(preprocess_collapse_repeated))
},
{
"ctc_merge_repeated",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(ctc_merge_repeated))
},
{
"ignore_longer_outputs_than_inputs",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(ignore_longer_outputs_than_inputs))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(inputs->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(labels_indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(labels_values->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sequence_length->GetAnchor(), node->GetInDataAnchor(3)));
return EsCTCLossOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsCTCLossV2Output EsCTCLossV2(EsbTensor *log_probs, EsbTensor *targets, EsbTensor *input_lengths, EsbTensor *target_lengths, int64_t blank, const char *reduction, bool zero_infinity) {
GE_ASSERT_NOTNULL(log_probs);
GE_ASSERT_NOTNULL(targets);
GE_ASSERT_NOTNULL(input_lengths);
GE_ASSERT_NOTNULL(target_lengths);
auto &graph = log_probs->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("CTCLossV2")
.Name(("CTCLossV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"log_probs", ge::kIrInputRequired, ""},
{"targets", ge::kIrInputRequired, ""},
{"input_lengths", ge::kIrInputRequired, ""},
{"target_lengths", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"neg_log_likelihood", ge::kIrOutputRequired, ""},
{"log_alpha", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"blank",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(blank))
},
{
"reduction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduction))
},
{
"zero_infinity",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(zero_infinity))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(log_probs->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(targets->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_lengths->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(target_lengths->GetAnchor(), node->GetInDataAnchor(3)));
return EsCTCLossV2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsCTCLossV2Grad(EsbTensor *grad_out, EsbTensor *log_probs, EsbTensor *targets, EsbTensor *input_lengths, EsbTensor *target_lengths, EsbTensor *neg_log_likelihood, EsbTensor *log_alpha, int64_t blank, const char *reduction, bool zero_infinity) {
GE_ASSERT_NOTNULL(grad_out);
GE_ASSERT_NOTNULL(log_probs);
GE_ASSERT_NOTNULL(targets);
GE_ASSERT_NOTNULL(input_lengths);
GE_ASSERT_NOTNULL(target_lengths);
GE_ASSERT_NOTNULL(neg_log_likelihood);
GE_ASSERT_NOTNULL(log_alpha);
auto &graph = grad_out->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("CTCLossV2Grad")
.Name(("CTCLossV2Grad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grad_out", ge::kIrInputRequired, ""},
{"log_probs", ge::kIrInputRequired, ""},
{"targets", ge::kIrInputRequired, ""},
{"input_lengths", ge::kIrInputRequired, ""},
{"target_lengths", ge::kIrInputRequired, ""},
{"neg_log_likelihood", ge::kIrInputRequired, ""},
{"log_alpha", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"grad", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"blank",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(blank))
},
{
"reduction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduction))
},
{
"zero_infinity",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(zero_infinity))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad_out->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(log_probs->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(targets->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_lengths->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(target_lengths->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(neg_log_likelihood->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(log_alpha->GetAnchor(), node->GetInDataAnchor(6)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsCacheAddOutput EsCacheAdd(EsbTensor *cache, EsbTensor *ids) {
GE_ASSERT_NOTNULL(cache);
GE_ASSERT_NOTNULL(ids);
auto &graph = cache->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("CacheAdd")
.Name(("CacheAdd_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"cache", ge::kIrInputRequired, ""},
{"ids", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"swap_in_id", ge::kIrOutputRequired, ""},
{"swap_in_idx", ge::kIrOutputRequired, ""},
{"swap_out_id", ge::kIrOutputRequired, ""},
{"swap_out_idx", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(cache->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(ids->GetAnchor(), node->GetInDataAnchor(1)));
return EsCacheAddOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsbTensor *EsCacheAllIndexToLocal(EsbTensor *cache, ge::DataType dtype) {
GE_ASSERT_NOTNULL(cache);
auto &graph = cache->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("CacheAllIndexToLocal")
.Name(("CacheAllIndexToLocal_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"cache", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"local_idx", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(cache->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsCacheRemoteIndexToLocal(EsbTensor *cache, EsbTensor *ids) {
GE_ASSERT_NOTNULL(cache);
GE_ASSERT_NOTNULL(ids);
auto &graph = cache->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("CacheRemoteIndexToLocal")
.Name(("CacheRemoteIndexToLocal_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"cache", ge::kIrInputRequired, ""},
{"ids", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"local_idx", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(cache->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(ids->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsCacheUpdate(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("CacheUpdate")
.Name(("CacheUpdate_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"x", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsCalcBucketsLimitAndOffsetOutput EsCalcBucketsLimitAndOffset(EsbTensor *bucket_list, EsbTensor *ivf_counts, EsbTensor *ivf_offset, int64_t total_limit) {
GE_ASSERT_NOTNULL(bucket_list);
GE_ASSERT_NOTNULL(ivf_counts);
GE_ASSERT_NOTNULL(ivf_offset);
auto &graph = bucket_list->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("CalcBucketsLimitAndOffset")
.Name(("CalcBucketsLimitAndOffset_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"bucket_list", ge::kIrInputRequired, ""},
{"ivf_counts", ge::kIrInputRequired, ""},
{"ivf_offset", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"buckets_limit", ge::kIrOutputRequired, ""},
{"buckets_offset", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"total_limit",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(total_limit))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bucket_list->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(ivf_counts->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(ivf_offset->GetAnchor(), node->GetInDataAnchor(2)));
return EsCalcBucketsLimitAndOffsetOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsCaseCondition(EsbTensor *x, const char *algorithm) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("CaseCondition")
.Name(("CaseCondition_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"algorithm",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(algorithm))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsCast(EsbTensor *x, int64_t dst_type) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Cast")
.Name(("Cast_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dst_type",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dst_type))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsCastLike(EsbTensor *x, EsbTensor *target) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(target);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("CastLike")
.Name(("CastLike_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"target", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(target->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsCdist(EsbTensor *x1, EsbTensor *x2, float p) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Cdist")
.Name(("Cdist_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"p",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(p))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsCdistGrad(EsbTensor *grad, EsbTensor *x1, EsbTensor *x2, EsbTensor *cdist, float p) {
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
GE_ASSERT_NOTNULL(cdist);
auto &graph = grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("CdistGrad")
.Name(("CdistGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grad", ge::kIrInputRequired, ""},
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"cdist", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"p",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(p))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(cdist->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsCeil(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Ceil")
.Name(("Ceil_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsCelu(EsbTensor *x, float alpha1, float alpha2, float alpha3) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Celu")
.Name(("Celu_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"alpha1",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(alpha1))
},
{
"alpha2",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(alpha2))
},
{
"alpha3",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(alpha3))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsCeluV2(EsbTensor *x, float alpha) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("CeluV2")
.Name(("CeluV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"alpha",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(alpha))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsCentralization(EsbTensor *x, const int64_t *axes, int64_t axes_num) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Centralization")
.Name(("Centralization_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axes",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(axes, axes + axes_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsChamferDistanceOutput EsChamferDistance(EsbTensor *xyz1, EsbTensor *xyz2) {
GE_ASSERT_NOTNULL(xyz1);
GE_ASSERT_NOTNULL(xyz2);
auto &graph = xyz1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ChamferDistance")
.Name(("ChamferDistance_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"xyz1", ge::kIrInputRequired, ""},
{"xyz2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"dist1", ge::kIrOutputRequired, ""},
{"dist2", ge::kIrOutputRequired, ""},
{"idx1", ge::kIrOutputRequired, ""},
{"idx2", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(xyz1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(xyz2->GetAnchor(), node->GetInDataAnchor(1)));
return EsChamferDistanceOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsChamferDistanceGradOutput EsChamferDistanceGrad(EsbTensor *xyz1, EsbTensor *xyz2, EsbTensor *idx1, EsbTensor *idx2, EsbTensor *grad_dist1, EsbTensor *grad_dist2) {
GE_ASSERT_NOTNULL(xyz1);
GE_ASSERT_NOTNULL(xyz2);
GE_ASSERT_NOTNULL(idx1);
GE_ASSERT_NOTNULL(idx2);
GE_ASSERT_NOTNULL(grad_dist1);
GE_ASSERT_NOTNULL(grad_dist2);
auto &graph = xyz1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ChamferDistanceGrad")
.Name(("ChamferDistanceGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"xyz1", ge::kIrInputRequired, ""},
{"xyz2", ge::kIrInputRequired, ""},
{"idx1", ge::kIrInputRequired, ""},
{"idx2", ge::kIrInputRequired, ""},
{"grad_dist1", ge::kIrInputRequired, ""},
{"grad_dist2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"grad_xyz1", ge::kIrOutputRequired, ""},
{"grad_xyz2", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(xyz1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(xyz2->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(idx1->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(idx2->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad_dist1->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad_dist2->GetAnchor(), node->GetInDataAnchor(5)));
return EsChamferDistanceGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsCheckNumerics(EsbTensor *x, const char *message) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("CheckNumerics")
.Name(("CheckNumerics_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"message",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(message))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsCheckValid(EsbTensor *bbox_tensor, EsbTensor *img_metas) {
GE_ASSERT_NOTNULL(bbox_tensor);
GE_ASSERT_NOTNULL(img_metas);
auto &graph = bbox_tensor->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("CheckValid")
.Name(("CheckValid_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"bbox_tensor", ge::kIrInputRequired, ""},
{"img_metas", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"valid_tensor", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bbox_tensor->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(img_metas->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsCholesky(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Cholesky")
.Name(("Cholesky_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsCholeskyGrad(EsbTensor *x, EsbTensor *grad) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(grad);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("CholeskyGrad")
.Name(("CholeskyGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsClipBoxes(EsbTensor *boxes_input, EsbTensor *img_size) {
GE_ASSERT_NOTNULL(boxes_input);
GE_ASSERT_NOTNULL(img_size);
auto &graph = boxes_input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ClipBoxes")
.Name(("ClipBoxes_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"boxes_input", ge::kIrInputRequired, ""},
{"img_size", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"boxes_output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(boxes_input->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(img_size->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsClipBoxesD(EsbTensor *boxes_input, const int64_t *img_size, int64_t img_size_num) {
GE_ASSERT_NOTNULL(boxes_input);
auto &graph = boxes_input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ClipBoxesD")
.Name(("ClipBoxesD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"boxes_input", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"boxes_output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"img_size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(img_size, img_size + img_size_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(boxes_input->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsClipByNormNoDivSum(EsbTensor *x, EsbTensor *greater_zeros, EsbTensor *select_ones, EsbTensor *maximum_ones) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(greater_zeros);
GE_ASSERT_NOTNULL(select_ones);
GE_ASSERT_NOTNULL(maximum_ones);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ClipByNormNoDivSum")
.Name(("ClipByNormNoDivSum_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"greater_zeros", ge::kIrInputRequired, ""},
{"select_ones", ge::kIrInputRequired, ""},
{"maximum_ones", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(greater_zeros->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(select_ones->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(maximum_ones->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsClipByValue(EsbTensor *x, EsbTensor *clip_value_min, EsbTensor *clip_value_max) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(clip_value_min);
GE_ASSERT_NOTNULL(clip_value_max);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ClipByValue")
.Name(("ClipByValue_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"clip_value_min", ge::kIrInputRequired, ""},
{"clip_value_max", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(clip_value_min->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(clip_value_max->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsClipByValueV2(EsbTensor *x, EsbTensor *clip_value_min, EsbTensor *clip_value_max) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(clip_value_min);
GE_ASSERT_NOTNULL(clip_value_max);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ClipByValueV2")
.Name(("ClipByValueV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"clip_value_min", ge::kIrInputRequired, ""},
{"clip_value_max", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(clip_value_min->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(clip_value_max->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsCmo(EsbTensor *src, int64_t max_size, int64_t type, int64_t offset) {
GE_ASSERT_NOTNULL(src);
auto &graph = src->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Cmo")
.Name(("Cmo_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"src", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
{
"max_size",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(max_size))
},
{
"type",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(type))
},
{
"offset",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(offset))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(src->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsCol2ImV2(EsbTensor *x, EsbTensor *output_size, EsbTensor *kernel_size, const int64_t *dilation, int64_t dilation_num, const int64_t *padding, int64_t padding_num, const int64_t *stride, int64_t stride_num) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(output_size);
GE_ASSERT_NOTNULL(kernel_size);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Col2ImV2")
.Name(("Col2ImV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"output_size", ge::kIrInputRequired, ""},
{"kernel_size", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dilation",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilation, dilation + dilation_num))
},
{
"padding",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(padding, padding + padding_num))
},
{
"stride",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(stride, stride + stride_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(output_size->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(kernel_size->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsCol2im(EsbTensor *x, EsbTensor *output_size, const int64_t *kernel_size, int64_t kernel_size_num, const int64_t *dilation, int64_t dilation_num, const int64_t *padding, int64_t padding_num, const int64_t *stride, int64_t stride_num) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(output_size);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Col2im")
.Name(("Col2im_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"output_size", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"kernel_size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(kernel_size, kernel_size + kernel_size_num))
},
{
"dilation",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilation, dilation + dilation_num))
},
{
"padding",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(padding, padding + padding_num))
},
{
"stride",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(stride, stride + stride_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(output_size->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsCombinations(EsbTensor *x, int64_t r, bool with_replacement) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Combinations")
.Name(("Combinations_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"r",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(r))
},
{
"with_replacement",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(with_replacement))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsCombinedNonMaxSuppressionOutput EsCombinedNonMaxSuppression(EsbTensor *boxes, EsbTensor *scores, EsbTensor *max_output_size_per_class, EsbTensor *max_total_size, EsbTensor *iou_threshold, EsbTensor *score_threshold, bool pad_per_class, bool clip_boxes) {
GE_ASSERT_NOTNULL(boxes);
GE_ASSERT_NOTNULL(scores);
GE_ASSERT_NOTNULL(max_output_size_per_class);
GE_ASSERT_NOTNULL(max_total_size);
GE_ASSERT_NOTNULL(iou_threshold);
GE_ASSERT_NOTNULL(score_threshold);
auto &graph = boxes->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("CombinedNonMaxSuppression")
.Name(("CombinedNonMaxSuppression_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"boxes", ge::kIrInputRequired, ""},
{"scores", ge::kIrInputRequired, ""},
{"max_output_size_per_class", ge::kIrInputRequired, ""},
{"max_total_size", ge::kIrInputRequired, ""},
{"iou_threshold", ge::kIrInputRequired, ""},
{"score_threshold", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"nmsed_boxes", ge::kIrOutputRequired, ""},
{"nmsed_scores", ge::kIrOutputRequired, ""},
{"nmsed_classes", ge::kIrOutputRequired, ""},
{"valid_detections", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"pad_per_class",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(pad_per_class))
},
{
"clip_boxes",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(clip_boxes))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(boxes->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scores->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(max_output_size_per_class->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(max_total_size->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(iou_threshold->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(score_threshold->GetAnchor(), node->GetInDataAnchor(5)));
return EsCombinedNonMaxSuppressionOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsbTensor *EsCompareAndBitpack(EsbTensor *x, EsbTensor *threshold) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(threshold);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("CompareAndBitpack")
.Name(("CompareAndBitpack_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"threshold", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(threshold->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsComplex(EsbTensor *real, EsbTensor *imag, int64_t Tout) {
GE_ASSERT_NOTNULL(real);
GE_ASSERT_NOTNULL(imag);
auto &graph = real->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Complex")
.Name(("Complex_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"real", ge::kIrInputRequired, ""},
{"imag", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"out", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"Tout",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(Tout))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(real->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(imag->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsComplexAbs(EsbTensor *x, ge::DataType Tout) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ComplexAbs")
.Name(("ComplexAbs_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"Tout",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(Tout))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsCompressOutput EsCompress(EsbTensor *weight, const int64_t *compress_parameters, int64_t compress_parameters_num) {
GE_ASSERT_NOTNULL(weight);
auto &graph = weight->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Compress")
.Name(("Compress_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"weight", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"weight_compress", ge::kIrOutputRequired, ""},
{"compress_index", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"compress_parameters",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(compress_parameters, compress_parameters + compress_parameters_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight->GetAnchor(), node->GetInDataAnchor(0)));
return EsCompressOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsCompressFcOpOutput EsCompressFcOp(EsbTensor *weight, const int64_t *compress_parameters, int64_t compress_parameters_num) {
GE_ASSERT_NOTNULL(weight);
auto &graph = weight->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("CompressFcOp")
.Name(("CompressFcOp_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"weight", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"weight_compress", ge::kIrOutputRequired, ""},
{"compress_index", ge::kIrOutputRequired, ""},
{"compress_info", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"compress_parameters",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(compress_parameters, compress_parameters + compress_parameters_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight->GetAnchor(), node->GetInDataAnchor(0)));
return EsCompressFcOpOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsComputeAccidentalHitsOutput EsComputeAccidentalHits(EsbTensor *true_classes, EsbTensor *sampled_candidates, int64_t num_true, int64_t seed, int64_t seed2) {
GE_ASSERT_NOTNULL(true_classes);
GE_ASSERT_NOTNULL(sampled_candidates);
auto &graph = true_classes->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ComputeAccidentalHits")
.Name(("ComputeAccidentalHits_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"true_classes", ge::kIrInputRequired, ""},
{"sampled_candidates", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"indices", ge::kIrOutputRequired, ""},
{"ids", ge::kIrOutputRequired, ""},
{"weights", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_true",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_true))
},
{
"seed",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed))
},
{
"seed2",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed2))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(true_classes->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sampled_candidates->GetAnchor(), node->GetInDataAnchor(1)));
return EsComputeAccidentalHitsOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsConcat(EsbTensor *concat_dim, EsbTensor **x, int64_t x_num, int64_t N) {
GE_ASSERT_NOTNULL(concat_dim);
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
auto &graph = concat_dim->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Concat")
.Name(("Concat_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"concat_dim", ge::kIrInputRequired, ""},
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"N",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(N))
},
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(concat_dim->GetAnchor(), node->GetInDataAnchor(0)));
if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(1 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsConcatD(EsbTensor **x, int64_t x_num, int64_t concat_dim, int64_t N) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ConcatD")
.Name(("ConcatD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"concat_dim",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(concat_dim))
},
{
"N",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(N))
},
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsConcatFromSequence(EsbTensor *handle, int64_t axis, int64_t new_axis) {
GE_ASSERT_NOTNULL(handle);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ConcatFromSequence")
.Name(("ConcatFromSequence_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
{
"new_axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(new_axis))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsConcatV2(EsbTensor **x, int64_t x_num, EsbTensor *concat_dim, int64_t N) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
GE_ASSERT_NOTNULL(concat_dim);
auto &graph = concat_dim->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ConcatV2")
.Name(("ConcatV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
{"concat_dim", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"N",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(N))
},
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(concat_dim->GetAnchor(), node->GetInDataAnchor(0 + x_num)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsConcatV2D(EsbTensor **x, int64_t x_num, int64_t concat_dim, int64_t N) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ConcatV2D")
.Name(("ConcatV2D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"concat_dim",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(concat_dim))
},
{
"N",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(N))
},
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}

std::vector<EsbTensor*> EsSplit(EsbTensor *split_dim, EsbTensor *x, int64_t num_split) {
GE_ASSERT_NOTNULL(split_dim);
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(num_split));
auto &graph = split_dim->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Split")
.Name(("Split_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"split_dim", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({{"y", ge::kIrOutputDynamic, ""}})
.IrDefAttrs({{"num_split",ge::kAttrRequired,"VT_INT",ge::AnyValue::CreateFrom(static_cast<int64_t>(num_split))}})
.InstanceDynamicOutputNum("y", static_cast<int32_t>(num_split))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(split_dim->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
std::vector<EsbTensor*> ret;
ret.reserve(num_split);
for(auto i=0; i<num_split;i++) {
  ret.emplace_back(graph.GetEsbTensorFromNode(node, i));
}
return ret;
}

std::vector<EsbTensor*> EsSplitD(EsbTensor *x, int64_t split_dim, int64_t num_split) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(split_dim));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(num_split));
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SplitD")
.Name(("SplitD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({{"x", ge::kIrInputRequired, ""}})
.IrDefOutputs({{"y", ge::kIrOutputDynamic, ""}})
.IrDefAttrs({
{"split_dim", ge::kAttrRequired, "VT_INT", ge::AnyValue::CreateFrom(static_cast<int64_t>(split_dim))},
{"num_split", ge::kAttrRequired, "VT_INT", ge::AnyValue::CreateFrom(static_cast<int64_t>(num_split))}
})
.InstanceDynamicOutputNum("y", static_cast<int32_t>(num_split))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
std::vector<EsbTensor*> ret;
ret.reserve(num_split);
for(auto i=0; i<num_split;i++) {
  ret.emplace_back(graph.GetEsbTensorFromNode(node, i));
}
return ret;
}

std::vector<EsbTensor*> EsSplitV(EsbTensor *x, EsbTensor *size_splits, EsbTensor *split_dim, int64_t num_split) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(num_split));
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SplitV")
.Name(("SplitV_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"size_splits", ge::kIrInputRequired, ""},
{"split_dim", ge::kIrInputRequired, ""}
})
.IrDefOutputs({{"y", ge::kIrOutputDynamic, ""}})
.IrDefAttrs({{"num_split",ge::kAttrRequired,"VT_INT",ge::AnyValue::CreateFrom(static_cast<int64_t>(num_split))}})
.InstanceDynamicOutputNum("y", static_cast<int32_t>(num_split))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(size_splits->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(split_dim->GetAnchor(), node->GetInDataAnchor(2)));
std::vector<EsbTensor*> ret;
ret.reserve(num_split);
for(auto i=0; i<num_split;i++) {
  ret.emplace_back(graph.GetEsbTensorFromNode(node, i));
}
return ret;
}

EsCondTakeOutput EsCondTake(EsbTensor *data, EsbTensor *mask, const char *mode, float val, float eps) {
GE_ASSERT_NOTNULL(data);
GE_ASSERT_NOTNULL(mask);
auto &graph = data->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("CondTake")
.Name(("CondTake_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"data", ge::kIrInputRequired, ""},
{"mask", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"out_data", ge::kIrOutputRequired, ""},
{"out_index", ge::kIrOutputRequired, ""},
{"valid_num", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"mode",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(mode))
},
{
"val",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(val))
},
{
"eps",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(eps))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(data->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mask->GetAnchor(), node->GetInDataAnchor(1)));
return EsCondTakeOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsConditionCalc(EsbTensor **x, int64_t x_num, const char *cond_func, const int64_t *x_dependency, int64_t x_dependency_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ConditionCalc")
.Name(("ConditionCalc_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
{"cond", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"cond_func",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(cond_func))
},
{
"x_dependency",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(x_dependency, x_dependency + x_dependency_num))
},
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsConditionalAccumulator(EsbGraph *owner_graph, ge::DataType dtype, const int64_t *shape, int64_t shape_num, const char *container, const char *shared_name, const char *reduction_type) {
GE_ASSERT_NOTNULL(owner_graph);
EsbGraph &graph = *owner_graph;

auto desc = ge::CompliantOpDescBuilder().OpType("ConditionalAccumulator")
.Name(("ConditionalAccumulator_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
})
.IrDefOutputs({
{"handle", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
{
"shape",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(shape, shape + shape_num))
},
{
"container",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(container))
},
{
"shared_name",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(shared_name))
},
{
"reduction_type",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduction_type))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsConfusionMatrix(EsbTensor *labels, EsbTensor *predictions, EsbTensor *weights, int64_t num_classes, const char *dtype) {
GE_ASSERT_NOTNULL(labels);
GE_ASSERT_NOTNULL(predictions);
auto &graph = labels->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ConfusionMatrix")
.Name(("ConfusionMatrix_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"labels", ge::kIrInputRequired, ""},
{"predictions", ge::kIrInputRequired, ""},
{"weights", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_classes",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_classes))
},
{
"dtype",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(labels->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(predictions->GetAnchor(), node->GetInDataAnchor(1)));
if (weights != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weights->GetAnchor(), node->GetInDataAnchor(2)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsConfusionMulGradOutput EsConfusionMulGrad(EsbTensor *input0, EsbTensor *input1, EsbTensor *input2, const int64_t *axes, int64_t axes_num, bool keep_dims) {
GE_ASSERT_NOTNULL(input0);
GE_ASSERT_NOTNULL(input1);
GE_ASSERT_NOTNULL(input2);
auto &graph = input0->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ConfusionMulGrad")
.Name(("ConfusionMulGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input0", ge::kIrInputRequired, ""},
{"input1", ge::kIrInputRequired, ""},
{"input2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output0", ge::kIrOutputRequired, ""},
{"output1", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axes",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(axes, axes + axes_num))
},
{
"keep_dims",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keep_dims))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input0->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input1->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input2->GetAnchor(), node->GetInDataAnchor(2)));
return EsConfusionMulGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsConfusionSoftmaxGrad(EsbTensor *grad, EsbTensor *x) {
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(x);
auto &graph = grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ConfusionSoftmaxGrad")
.Name(("ConfusionSoftmaxGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grad", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsConfusionTranspose(EsbTensor *x, EsbTensor *shape, const int64_t *perm, int64_t perm_num, bool transpose_first) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(shape);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ConfusionTranspose")
.Name(("ConfusionTranspose_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"shape", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"perm",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(perm, perm + perm_num))
},
{
"transpose_first",
ge::kAttrRequired,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(transpose_first))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsConfusionTransposeD(EsbTensor *x, const int64_t *perm, int64_t perm_num, const int64_t *shape, int64_t shape_num, bool transpose_first) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ConfusionTransposeD")
.Name(("ConfusionTransposeD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"perm",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(perm, perm + perm_num))
},
{
"shape",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(shape, shape + shape_num))
},
{
"transpose_first",
ge::kAttrRequired,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(transpose_first))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsConj(EsbTensor *input) {
GE_ASSERT_NOTNULL(input);
auto &graph = input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Conj")
.Name(("Conj_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsConjugateTranspose(EsbTensor *x, EsbTensor *perm) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(perm);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ConjugateTranspose")
.Name(("ConjugateTranspose_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"perm", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(perm->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsContinuationIndicator(EsbGraph *owner_graph, int64_t time_step, int64_t batch_size) {
GE_ASSERT_NOTNULL(owner_graph);
EsbGraph &graph = *owner_graph;

auto desc = ge::CompliantOpDescBuilder().OpType("ContinuationIndicator")
.Name(("ContinuationIndicator_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"time_step",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(time_step))
},
{
"batch_size",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(batch_size))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsControlTrigger(EsbGraph *owner_graph) {
GE_ASSERT_NOTNULL(owner_graph);
EsbGraph &graph = *owner_graph;

auto desc = ge::CompliantOpDescBuilder().OpType("ControlTrigger")
.Name(("ControlTrigger_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsConv2D(EsbTensor *x, EsbTensor *filter, EsbTensor *bias, EsbTensor *offset_w, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const int64_t *dilations, int64_t dilations_num, int64_t groups, const char *data_format, int64_t offset_x) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(filter);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Conv2D")
.Name(("Conv2D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"filter", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
{"offset_w", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dilations",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"groups",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(groups))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"offset_x",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(offset_x))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(filter->GetAnchor(), node->GetInDataAnchor(1)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(2)));
}
if (offset_w != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset_w->GetAnchor(), node->GetInDataAnchor(3)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsConv2DBackpropFilter(EsbTensor *x, EsbTensor *filter_size, EsbTensor *out_backprop, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const int64_t *dilations, int64_t dilations_num, int64_t groups, const char *data_format) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(filter_size);
GE_ASSERT_NOTNULL(out_backprop);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Conv2DBackpropFilter")
.Name(("Conv2DBackpropFilter_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"filter_size", ge::kIrInputRequired, ""},
{"out_backprop", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dilations",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"groups",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(groups))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(filter_size->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(out_backprop->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsConv2DBackpropFilterD(EsbTensor *x, EsbTensor *out_backprop, const int64_t *filter_size, int64_t filter_size_num, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const int64_t *dilations, int64_t dilations_num, int64_t groups, const char *data_format) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(out_backprop);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Conv2DBackpropFilterD")
.Name(("Conv2DBackpropFilterD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"out_backprop", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"filter_size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(filter_size, filter_size + filter_size_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dilations",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"groups",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(groups))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(out_backprop->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsConv2DBackpropFilterV2(EsbTensor *x, EsbTensor *filter_size, EsbTensor *out_backprop, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const int64_t *dilations, int64_t dilations_num, int64_t groups, const char *data_format) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(filter_size);
GE_ASSERT_NOTNULL(out_backprop);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Conv2DBackpropFilterV2")
.Name(("Conv2DBackpropFilterV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"filter_size", ge::kIrInputRequired, ""},
{"out_backprop", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dilations",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"groups",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(groups))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(filter_size->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(out_backprop->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsConv2DBackpropFilterV3(EsbTensor *x, EsbTensor *filter_size, EsbTensor *out_backprop, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const int64_t *dilations, int64_t dilations_num, int64_t groups, const char *data_format) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(filter_size);
GE_ASSERT_NOTNULL(out_backprop);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Conv2DBackpropFilterV3")
.Name(("Conv2DBackpropFilterV3_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"filter_size", ge::kIrInputRequired, ""},
{"out_backprop", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dilations",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"groups",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(groups))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(filter_size->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(out_backprop->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsConv2DBackpropInput(EsbTensor *input_size, EsbTensor *filter, EsbTensor *out_backprop, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const int64_t *dilations, int64_t dilations_num, int64_t groups, const char *data_format) {
GE_ASSERT_NOTNULL(input_size);
GE_ASSERT_NOTNULL(filter);
GE_ASSERT_NOTNULL(out_backprop);
auto &graph = input_size->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Conv2DBackpropInput")
.Name(("Conv2DBackpropInput_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_size", ge::kIrInputRequired, ""},
{"filter", ge::kIrInputRequired, ""},
{"out_backprop", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dilations",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"groups",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(groups))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_size->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(filter->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(out_backprop->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsConv2DBackpropInputD(EsbTensor *filter, EsbTensor *out_backprop, const int64_t *input_size, int64_t input_size_num, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const int64_t *dilations, int64_t dilations_num, int64_t groups, const char *data_format) {
GE_ASSERT_NOTNULL(filter);
GE_ASSERT_NOTNULL(out_backprop);
auto &graph = filter->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Conv2DBackpropInputD")
.Name(("Conv2DBackpropInputD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"filter", ge::kIrInputRequired, ""},
{"out_backprop", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"input_size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(input_size, input_size + input_size_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dilations",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"groups",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(groups))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(filter->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(out_backprop->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsConv2DBackpropInputV2(EsbTensor *input_size, EsbTensor *filter, EsbTensor *out_backprop, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const int64_t *dilations, int64_t dilations_num, int64_t groups, const char *data_format) {
GE_ASSERT_NOTNULL(input_size);
GE_ASSERT_NOTNULL(filter);
GE_ASSERT_NOTNULL(out_backprop);
auto &graph = input_size->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Conv2DBackpropInputV2")
.Name(("Conv2DBackpropInputV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_size", ge::kIrInputRequired, ""},
{"filter", ge::kIrInputRequired, ""},
{"out_backprop", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dilations",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"groups",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(groups))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_size->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(filter->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(out_backprop->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsConv2DCompress(EsbTensor *x, EsbTensor *filter_compress, EsbTensor *compress_index, EsbTensor *bias, EsbTensor *offset_w, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const int64_t *dilations, int64_t dilations_num, int64_t groups, const char *data_format, int64_t offset_x, const char *alg) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(filter_compress);
GE_ASSERT_NOTNULL(compress_index);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Conv2DCompress")
.Name(("Conv2DCompress_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"filter_compress", ge::kIrInputRequired, ""},
{"compress_index", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
{"offset_w", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dilations",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"groups",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(groups))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"offset_x",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(offset_x))
},
{
"alg",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(alg))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(filter_compress->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(compress_index->GetAnchor(), node->GetInDataAnchor(2)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(3)));
}
if (offset_w != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset_w->GetAnchor(), node->GetInDataAnchor(4)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsConv2DTranspose(EsbTensor *input_size, EsbTensor *x, EsbTensor *filter, EsbTensor *bias, EsbTensor *offset_w, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const int64_t *dilations, int64_t dilations_num, int64_t groups, const char *data_format, const int64_t *output_padding, int64_t output_padding_num, int64_t offset_x) {
GE_ASSERT_NOTNULL(input_size);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(filter);
auto &graph = input_size->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Conv2DTranspose")
.Name(("Conv2DTranspose_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_size", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"filter", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
{"offset_w", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dilations",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"groups",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(groups))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"output_padding",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(output_padding, output_padding + output_padding_num))
},
{
"offset_x",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(offset_x))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_size->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(filter->GetAnchor(), node->GetInDataAnchor(2)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(3)));
}
if (offset_w != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset_w->GetAnchor(), node->GetInDataAnchor(4)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsConv2DTransposeD(EsbTensor *x, EsbTensor *filter, EsbTensor *bias, EsbTensor *offset_w, const int64_t *input_size, int64_t input_size_num, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const int64_t *dilations, int64_t dilations_num, int64_t groups, const char *data_format, const int64_t *output_padding, int64_t output_padding_num, int64_t offset_x) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(filter);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Conv2DTransposeD")
.Name(("Conv2DTransposeD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"filter", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
{"offset_w", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"input_size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(input_size, input_size + input_size_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dilations",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"groups",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(groups))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"output_padding",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(output_padding, output_padding + output_padding_num))
},
{
"offset_x",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(offset_x))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(filter->GetAnchor(), node->GetInDataAnchor(1)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(2)));
}
if (offset_w != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset_w->GetAnchor(), node->GetInDataAnchor(3)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsConv2DTransposeDCompress(EsbTensor *x, EsbTensor *filter_compress, EsbTensor *compress_index, EsbTensor *bias, EsbTensor *offset_w, const int64_t *input_size, int64_t input_size_num, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const int64_t *dilations, int64_t dilations_num, int64_t groups, const char *data_format, const int64_t *output_padding, int64_t output_padding_num, int64_t offset_x, const char *alg) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(filter_compress);
GE_ASSERT_NOTNULL(compress_index);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Conv2DTransposeDCompress")
.Name(("Conv2DTransposeDCompress_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"filter_compress", ge::kIrInputRequired, ""},
{"compress_index", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
{"offset_w", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"input_size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(input_size, input_size + input_size_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dilations",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"groups",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(groups))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"output_padding",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(output_padding, output_padding + output_padding_num))
},
{
"offset_x",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(offset_x))
},
{
"alg",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(alg))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(filter_compress->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(compress_index->GetAnchor(), node->GetInDataAnchor(2)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(3)));
}
if (offset_w != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset_w->GetAnchor(), node->GetInDataAnchor(4)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsConv2DTransposeV2(EsbTensor *input_size, EsbTensor *x, EsbTensor *filter, EsbTensor *bias, EsbTensor *offset_w, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const int64_t *dilations, int64_t dilations_num, int64_t groups, const char *data_format, const int64_t *output_padding, int64_t output_padding_num, int64_t offset_x) {
GE_ASSERT_NOTNULL(input_size);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(filter);
auto &graph = input_size->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Conv2DTransposeV2")
.Name(("Conv2DTransposeV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_size", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"filter", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
{"offset_w", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dilations",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"groups",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(groups))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"output_padding",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(output_padding, output_padding + output_padding_num))
},
{
"offset_x",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(offset_x))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_size->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(filter->GetAnchor(), node->GetInDataAnchor(2)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(3)));
}
if (offset_w != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset_w->GetAnchor(), node->GetInDataAnchor(4)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsConv3D(EsbTensor *x, EsbTensor *filter, EsbTensor *bias, EsbTensor *offset_w, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const int64_t *dilations, int64_t dilations_num, int64_t groups, const char *data_format, int64_t offset_x) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(filter);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Conv3D")
.Name(("Conv3D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"filter", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
{"offset_w", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dilations",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"groups",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(groups))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"offset_x",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(offset_x))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(filter->GetAnchor(), node->GetInDataAnchor(1)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(2)));
}
if (offset_w != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset_w->GetAnchor(), node->GetInDataAnchor(3)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsConv3DBackpropFilter(EsbTensor *x, EsbTensor *filter_size, EsbTensor *out_backprop, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const int64_t *dilations, int64_t dilations_num, int64_t groups, const char *data_format) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(filter_size);
GE_ASSERT_NOTNULL(out_backprop);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Conv3DBackpropFilter")
.Name(("Conv3DBackpropFilter_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"filter_size", ge::kIrInputRequired, ""},
{"out_backprop", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dilations",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"groups",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(groups))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(filter_size->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(out_backprop->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsConv3DBackpropFilterD(EsbTensor *x, EsbTensor *out_backprop, const int64_t *filter_size, int64_t filter_size_num, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const int64_t *dilations, int64_t dilations_num, int64_t groups, const char *data_format) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(out_backprop);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Conv3DBackpropFilterD")
.Name(("Conv3DBackpropFilterD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"out_backprop", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"filter_size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(filter_size, filter_size + filter_size_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dilations",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"groups",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(groups))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(out_backprop->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsConv3DBackpropFilterV2(EsbTensor *x, EsbTensor *filter_size, EsbTensor *out_backprop, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const int64_t *dilations, int64_t dilations_num, int64_t groups, const char *data_format) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(filter_size);
GE_ASSERT_NOTNULL(out_backprop);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Conv3DBackpropFilterV2")
.Name(("Conv3DBackpropFilterV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"filter_size", ge::kIrInputRequired, ""},
{"out_backprop", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dilations",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"groups",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(groups))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(filter_size->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(out_backprop->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsConv3DBackpropInput(EsbTensor *input_size, EsbTensor *filter, EsbTensor *out_backprop, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const int64_t *dilations, int64_t dilations_num, int64_t groups, const char *data_format) {
GE_ASSERT_NOTNULL(input_size);
GE_ASSERT_NOTNULL(filter);
GE_ASSERT_NOTNULL(out_backprop);
auto &graph = input_size->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Conv3DBackpropInput")
.Name(("Conv3DBackpropInput_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_size", ge::kIrInputRequired, ""},
{"filter", ge::kIrInputRequired, ""},
{"out_backprop", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dilations",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"groups",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(groups))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_size->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(filter->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(out_backprop->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsConv3DBackpropInputD(EsbTensor *filter, EsbTensor *out_backprop, const int64_t *input_size, int64_t input_size_num, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const int64_t *dilations, int64_t dilations_num, int64_t groups, const char *data_format) {
GE_ASSERT_NOTNULL(filter);
GE_ASSERT_NOTNULL(out_backprop);
auto &graph = filter->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Conv3DBackpropInputD")
.Name(("Conv3DBackpropInputD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"filter", ge::kIrInputRequired, ""},
{"out_backprop", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"input_size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(input_size, input_size + input_size_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dilations",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"groups",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(groups))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(filter->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(out_backprop->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsConv3DBackpropInputV2(EsbTensor *input_size, EsbTensor *filter, EsbTensor *out_backprop, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const int64_t *dilations, int64_t dilations_num, int64_t groups, const char *data_format) {
GE_ASSERT_NOTNULL(input_size);
GE_ASSERT_NOTNULL(filter);
GE_ASSERT_NOTNULL(out_backprop);
auto &graph = input_size->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Conv3DBackpropInputV2")
.Name(("Conv3DBackpropInputV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_size", ge::kIrInputRequired, ""},
{"filter", ge::kIrInputRequired, ""},
{"out_backprop", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dilations",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"groups",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(groups))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_size->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(filter->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(out_backprop->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsConv3DTranspose(EsbTensor *input_size, EsbTensor *x, EsbTensor *filter, EsbTensor *bias, EsbTensor *offset_w, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const int64_t *dilations, int64_t dilations_num, int64_t groups, const char *data_format, const int64_t *output_padding, int64_t output_padding_num, int64_t offset_x) {
GE_ASSERT_NOTNULL(input_size);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(filter);
auto &graph = input_size->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Conv3DTranspose")
.Name(("Conv3DTranspose_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_size", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"filter", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
{"offset_w", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dilations",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"groups",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(groups))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"output_padding",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(output_padding, output_padding + output_padding_num))
},
{
"offset_x",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(offset_x))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_size->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(filter->GetAnchor(), node->GetInDataAnchor(2)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(3)));
}
if (offset_w != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset_w->GetAnchor(), node->GetInDataAnchor(4)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsConv3DTransposeD(EsbTensor *x, EsbTensor *filter, EsbTensor *bias, EsbTensor *offset_w, const int64_t *input_size, int64_t input_size_num, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const int64_t *dilations, int64_t dilations_num, int64_t groups, const char *data_format, const int64_t *output_padding, int64_t output_padding_num, int64_t offset_x) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(filter);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Conv3DTransposeD")
.Name(("Conv3DTransposeD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"filter", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
{"offset_w", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"input_size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(input_size, input_size + input_size_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dilations",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"groups",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(groups))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"output_padding",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(output_padding, output_padding + output_padding_num))
},
{
"offset_x",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(offset_x))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(filter->GetAnchor(), node->GetInDataAnchor(1)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(2)));
}
if (offset_w != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset_w->GetAnchor(), node->GetInDataAnchor(3)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsConv3DTransposeV2(EsbTensor *input_size, EsbTensor *x, EsbTensor *filter, EsbTensor *bias, EsbTensor *offset_w, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const int64_t *dilations, int64_t dilations_num, int64_t groups, const char *data_format, const int64_t *output_padding, int64_t output_padding_num, int64_t offset_x) {
GE_ASSERT_NOTNULL(input_size);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(filter);
auto &graph = input_size->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Conv3DTransposeV2")
.Name(("Conv3DTransposeV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_size", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"filter", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
{"offset_w", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dilations",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"groups",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(groups))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"output_padding",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(output_padding, output_padding + output_padding_num))
},
{
"offset_x",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(offset_x))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_size->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(filter->GetAnchor(), node->GetInDataAnchor(2)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(3)));
}
if (offset_w != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset_w->GetAnchor(), node->GetInDataAnchor(4)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsConv3DV2(EsbTensor *x, EsbTensor *filter, EsbTensor *bias, EsbTensor *offset_w, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const int64_t *dilations, int64_t dilations_num, int64_t groups, const char *data_format, int64_t offset_x) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(filter);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Conv3DV2")
.Name(("Conv3DV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"filter", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
{"offset_w", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dilations",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"groups",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(groups))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"offset_x",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(offset_x))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(filter->GetAnchor(), node->GetInDataAnchor(1)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(2)));
}
if (offset_w != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset_w->GetAnchor(), node->GetInDataAnchor(3)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsCoordinates1DTo2DOutput EsCoordinates1DTo2D(EsbTensor *x, EsbTensor *shape) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(shape);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Coordinates1DTo2D")
.Name(("Coordinates1DTo2D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"shape", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"row", ge::kIrOutputRequired, ""},
{"col", ge::kIrOutputRequired, ""},
{"n", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(1)));
return EsCoordinates1DTo2DOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsCorrectBBox(EsbTensor *x, EsbTensor *grid, EsbTensor *anchor_grid, int64_t stride, const char *yolo_version) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(grid);
GE_ASSERT_NOTNULL(anchor_grid);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("CorrectBBox")
.Name(("CorrectBBox_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"grid", ge::kIrInputRequired, ""},
{"anchor_grid", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"stride",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(stride))
},
{
"yolo_version",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(yolo_version))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grid->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(anchor_grid->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsCorrelation(EsbTensor *filter, EsbTensor *x, int64_t groups) {
GE_ASSERT_NOTNULL(filter);
GE_ASSERT_NOTNULL(x);
auto &graph = filter->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Correlation")
.Name(("Correlation_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"filter", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"groups",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(groups))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(filter->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsCos(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Cos")
.Name(("Cos_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsCosh(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Cosh")
.Name(("Cosh_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsCosineEmbeddingLoss(EsbTensor *x1, EsbTensor *x2, EsbTensor *target, float margin, const char *reduction) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
GE_ASSERT_NOTNULL(target);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("CosineEmbeddingLoss")
.Name(("CosineEmbeddingLoss_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"target", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"margin",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(margin))
},
{
"reduction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduction))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(target->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsCosineSimilarity(EsbTensor *input_x1, EsbTensor *input_x2, int64_t dim, float eps) {
GE_ASSERT_NOTNULL(input_x1);
GE_ASSERT_NOTNULL(input_x2);
auto &graph = input_x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("CosineSimilarity")
.Name(("CosineSimilarity_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_x1", ge::kIrInputRequired, ""},
{"input_x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dim",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dim))
},
{
"eps",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(eps))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsCountUpTo(EsbTensor *ref, int64_t limit) {
GE_ASSERT_NOTNULL(ref);
auto &graph = ref->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("CountUpTo")
.Name(("CountUpTo_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"ref", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"limit",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(limit))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(ref->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsCrop(EsbTensor *x, EsbTensor *size, const int64_t *offsets, int64_t offsets_num, int64_t axis) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(size);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Crop")
.Name(("Crop_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"size", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"offsets",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(offsets, offsets + offsets_num))
},
{
"axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(size->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsCropAndResize(EsbTensor *x, EsbTensor *boxes, EsbTensor *box_index, EsbTensor *crop_size, float extrapolation_value, const char *method) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(boxes);
GE_ASSERT_NOTNULL(box_index);
GE_ASSERT_NOTNULL(crop_size);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("CropAndResize")
.Name(("CropAndResize_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"boxes", ge::kIrInputRequired, ""},
{"box_index", ge::kIrInputRequired, ""},
{"crop_size", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"extrapolation_value",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(extrapolation_value))
},
{
"method",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(method))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(boxes->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(box_index->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(crop_size->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsCropAndResizeD(EsbTensor *x, EsbTensor *boxes, EsbTensor *box_index, const int64_t *crop_size, int64_t crop_size_num, float extrapolation_value, const char *method) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(boxes);
GE_ASSERT_NOTNULL(box_index);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("CropAndResizeD")
.Name(("CropAndResizeD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"boxes", ge::kIrInputRequired, ""},
{"box_index", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"crop_size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(crop_size, crop_size + crop_size_num))
},
{
"extrapolation_value",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(extrapolation_value))
},
{
"method",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(method))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(boxes->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(box_index->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsCropAndResizeGradBoxes(EsbTensor *grads, EsbTensor *images, EsbTensor *boxes, EsbTensor *box_index, const char *method) {
GE_ASSERT_NOTNULL(grads);
GE_ASSERT_NOTNULL(images);
GE_ASSERT_NOTNULL(boxes);
GE_ASSERT_NOTNULL(box_index);
auto &graph = grads->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("CropAndResizeGradBoxes")
.Name(("CropAndResizeGradBoxes_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grads", ge::kIrInputRequired, ""},
{"images", ge::kIrInputRequired, ""},
{"boxes", ge::kIrInputRequired, ""},
{"box_index", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"method",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(method))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grads->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(images->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(boxes->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(box_index->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsCropAndResizeGradImage(EsbTensor *grads, EsbTensor *boxes, EsbTensor *box_index, EsbTensor *image_size, ge::DataType T, const char *method) {
GE_ASSERT_NOTNULL(grads);
GE_ASSERT_NOTNULL(boxes);
GE_ASSERT_NOTNULL(box_index);
GE_ASSERT_NOTNULL(image_size);
auto &graph = grads->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("CropAndResizeGradImage")
.Name(("CropAndResizeGradImage_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grads", ge::kIrInputRequired, ""},
{"boxes", ge::kIrInputRequired, ""},
{"box_index", ge::kIrInputRequired, ""},
{"image_size", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"T",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(T))
},
{
"method",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(method))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grads->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(boxes->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(box_index->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(image_size->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsCropAndResizeV2(EsbTensor *x, EsbTensor *boxes, EsbTensor *box_index, EsbTensor *crop_size, float extrapolation_value, const char *method, ge::DataType dtype) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(boxes);
GE_ASSERT_NOTNULL(box_index);
GE_ASSERT_NOTNULL(crop_size);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("CropAndResizeV2")
.Name(("CropAndResizeV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"boxes", ge::kIrInputRequired, ""},
{"box_index", ge::kIrInputRequired, ""},
{"crop_size", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"extrapolation_value",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(extrapolation_value))
},
{
"method",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(method))
},
{
"dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(boxes->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(box_index->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(crop_size->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsCross(EsbTensor *x1, EsbTensor *x2, int64_t dim) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Cross")
.Name(("Cross_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dim",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dim))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsCummaxOutput EsCummax(EsbTensor *x, int64_t dim) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Cummax")
.Name(("Cummax_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"indices", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dim",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dim))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return EsCummaxOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsCumminOutput EsCummin(EsbTensor *x, int64_t axis) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Cummin")
.Name(("Cummin_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"indices", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return EsCumminOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsCumprod(EsbTensor *x, EsbTensor *axis, bool exclusive, bool reverse) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(axis);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Cumprod")
.Name(("Cumprod_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"axis", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"exclusive",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(exclusive))
},
{
"reverse",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(reverse))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(axis->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsCumprodD(EsbTensor *x, int64_t axis, bool exclusive, bool reverse) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("CumprodD")
.Name(("CumprodD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
{
"exclusive",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(exclusive))
},
{
"reverse",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(reverse))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsCumsum(EsbTensor *x, EsbTensor *axis, bool exclusive, bool reverse) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(axis);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Cumsum")
.Name(("Cumsum_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"axis", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"exclusive",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(exclusive))
},
{
"reverse",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(reverse))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(axis->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsCumsumD(EsbTensor *x, int64_t axis, bool exclusive, bool reverse) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("CumsumD")
.Name(("CumsumD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
{
"exclusive",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(exclusive))
},
{
"reverse",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(reverse))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsCumulativeLogsumexp(EsbTensor *x, EsbTensor *axis, bool exclusive, bool reverse) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(axis);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("CumulativeLogsumexp")
.Name(("CumulativeLogsumexp_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"axis", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"exclusive",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(exclusive))
},
{
"reverse",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(reverse))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(axis->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsCumulativeLogsumexpD(EsbTensor *x, int64_t axis, bool exclusive, bool reverse) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("CumulativeLogsumexpD")
.Name(("CumulativeLogsumexpD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
{
"exclusive",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(exclusive))
},
{
"reverse",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(reverse))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDIoU(EsbTensor *bboxes, EsbTensor *gtboxes, bool trans, bool is_cross, const char *mode) {
GE_ASSERT_NOTNULL(bboxes);
GE_ASSERT_NOTNULL(gtboxes);
auto &graph = bboxes->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DIoU")
.Name(("DIoU_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"bboxes", ge::kIrInputRequired, ""},
{"gtboxes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"overlap", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"trans",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(trans))
},
{
"is_cross",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_cross))
},
{
"mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bboxes->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gtboxes->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsDIoUGradOutput EsDIoUGrad(EsbTensor *dy, EsbTensor *bboxes, EsbTensor *gtboxes, bool trans, bool is_cross, const char *mode) {
GE_ASSERT_NOTNULL(dy);
GE_ASSERT_NOTNULL(bboxes);
GE_ASSERT_NOTNULL(gtboxes);
auto &graph = dy->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DIoUGrad")
.Name(("DIoUGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"dy", ge::kIrInputRequired, ""},
{"bboxes", ge::kIrInputRequired, ""},
{"gtboxes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"dbboxes", ge::kIrOutputRequired, ""},
{"dgtboxes", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"trans",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(trans))
},
{
"is_cross",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_cross))
},
{
"mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bboxes->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gtboxes->GetAnchor(), node->GetInDataAnchor(2)));
return EsDIoUGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsDSAGenBitMask(EsbTensor *count, EsbTensor *seed, EsbTensor *dropout, const char *random_algorithm, const char *output_dtype) {
GE_ASSERT_NOTNULL(count);
GE_ASSERT_NOTNULL(seed);
GE_ASSERT_NOTNULL(dropout);
auto &graph = count->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DSAGenBitMask")
.Name(("DSAGenBitMask_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"count", ge::kIrInputRequired, ""},
{"seed", ge::kIrInputRequired, ""},
{"dropout", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"out", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"random_algorithm",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(random_algorithm))
},
{
"output_dtype",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(output_dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(count->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seed->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dropout->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDSARandomNormal(EsbTensor *count, EsbTensor *seed, EsbTensor *mean, EsbTensor *stdev, const char *random_algorithm) {
GE_ASSERT_NOTNULL(count);
GE_ASSERT_NOTNULL(seed);
GE_ASSERT_NOTNULL(mean);
GE_ASSERT_NOTNULL(stdev);
auto &graph = count->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DSARandomNormal")
.Name(("DSARandomNormal_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"count", ge::kIrInputRequired, ""},
{"seed", ge::kIrInputRequired, ""},
{"mean", ge::kIrInputRequired, ""},
{"stdev", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"out", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"random_algorithm",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(random_algorithm))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(count->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seed->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(stdev->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDSARandomTruncatedNormal(EsbTensor *count, EsbTensor *seed, EsbTensor *mean, EsbTensor *stdev, const char *random_algorithm) {
GE_ASSERT_NOTNULL(count);
GE_ASSERT_NOTNULL(seed);
GE_ASSERT_NOTNULL(mean);
GE_ASSERT_NOTNULL(stdev);
auto &graph = count->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DSARandomTruncatedNormal")
.Name(("DSARandomTruncatedNormal_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"count", ge::kIrInputRequired, ""},
{"seed", ge::kIrInputRequired, ""},
{"mean", ge::kIrInputRequired, ""},
{"stdev", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"out", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"random_algorithm",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(random_algorithm))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(count->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seed->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(stdev->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDSARandomUniform(EsbTensor *count, EsbTensor *seed, EsbTensor *low, EsbTensor *high, const char *random_algorithm) {
GE_ASSERT_NOTNULL(count);
GE_ASSERT_NOTNULL(seed);
GE_ASSERT_NOTNULL(low);
GE_ASSERT_NOTNULL(high);
auto &graph = count->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DSARandomUniform")
.Name(("DSARandomUniform_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"count", ge::kIrInputRequired, ""},
{"seed", ge::kIrInputRequired, ""},
{"low", ge::kIrInputRequired, ""},
{"high", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"out", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"random_algorithm",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(random_algorithm))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(count->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seed->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(low->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(high->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDSAStatelessGenBitMask(EsbTensor *count, EsbTensor *seed, EsbTensor *dropout, EsbTensor *offset, const char *random_algorithm, const char *output_dtype) {
GE_ASSERT_NOTNULL(count);
GE_ASSERT_NOTNULL(seed);
GE_ASSERT_NOTNULL(dropout);
GE_ASSERT_NOTNULL(offset);
auto &graph = count->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DSAStatelessGenBitMask")
.Name(("DSAStatelessGenBitMask_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"count", ge::kIrInputRequired, ""},
{"seed", ge::kIrInputRequired, ""},
{"dropout", ge::kIrInputRequired, ""},
{"offset", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"out", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"random_algorithm",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(random_algorithm))
},
{
"output_dtype",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(output_dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(count->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seed->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dropout->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDSAStatelessRandomNormal(EsbTensor *count, EsbTensor *seed, EsbTensor *mean, EsbTensor *stdev, EsbTensor *counter, const char *random_algorithm) {
GE_ASSERT_NOTNULL(count);
GE_ASSERT_NOTNULL(seed);
GE_ASSERT_NOTNULL(mean);
GE_ASSERT_NOTNULL(stdev);
GE_ASSERT_NOTNULL(counter);
auto &graph = count->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DSAStatelessRandomNormal")
.Name(("DSAStatelessRandomNormal_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"count", ge::kIrInputRequired, ""},
{"seed", ge::kIrInputRequired, ""},
{"mean", ge::kIrInputRequired, ""},
{"stdev", ge::kIrInputRequired, ""},
{"counter", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"out", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"random_algorithm",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(random_algorithm))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(count->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seed->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(stdev->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(counter->GetAnchor(), node->GetInDataAnchor(4)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDSAStatelessRandomTruncatedNormal(EsbTensor *count, EsbTensor *seed, EsbTensor *mean, EsbTensor *stdev, EsbTensor *counter, const char *random_algorithm) {
GE_ASSERT_NOTNULL(count);
GE_ASSERT_NOTNULL(seed);
GE_ASSERT_NOTNULL(mean);
GE_ASSERT_NOTNULL(stdev);
GE_ASSERT_NOTNULL(counter);
auto &graph = count->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DSAStatelessRandomTruncatedNormal")
.Name(("DSAStatelessRandomTruncatedNormal_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"count", ge::kIrInputRequired, ""},
{"seed", ge::kIrInputRequired, ""},
{"mean", ge::kIrInputRequired, ""},
{"stdev", ge::kIrInputRequired, ""},
{"counter", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"out", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"random_algorithm",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(random_algorithm))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(count->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seed->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(stdev->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(counter->GetAnchor(), node->GetInDataAnchor(4)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDSAStatelessRandomUniform(EsbTensor *count, EsbTensor *seed, EsbTensor *low, EsbTensor *high, EsbTensor *counter, const char *random_algorithm) {
GE_ASSERT_NOTNULL(count);
GE_ASSERT_NOTNULL(seed);
GE_ASSERT_NOTNULL(low);
GE_ASSERT_NOTNULL(high);
GE_ASSERT_NOTNULL(counter);
auto &graph = count->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DSAStatelessRandomUniform")
.Name(("DSAStatelessRandomUniform_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"count", ge::kIrInputRequired, ""},
{"seed", ge::kIrInputRequired, ""},
{"low", ge::kIrInputRequired, ""},
{"high", ge::kIrInputRequired, ""},
{"counter", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"out", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"random_algorithm",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(random_algorithm))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(count->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seed->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(low->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(high->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(counter->GetAnchor(), node->GetInDataAnchor(4)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDataCompare(EsbTensor *x1, EsbTensor *x2, float atol, float rtol) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DataCompare")
.Name(("DataCompare_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"num", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"atol",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(atol))
},
{
"rtol",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(rtol))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDataFormatDimMap(EsbTensor *x, const char *src_format, const char *dst_format) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DataFormatDimMap")
.Name(("DataFormatDimMap_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"src_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(src_format))
},
{
"dst_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(dst_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDataFormatVecPermute(EsbTensor *x, const char *src_format, const char *dst_format) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DataFormatVecPermute")
.Name(("DataFormatVecPermute_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"src_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(src_format))
},
{
"dst_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(dst_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDawsn(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Dawsn")
.Name(("Dawsn_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDecodeAndCropJpeg(EsbTensor *contents, EsbTensor *crop_window, int64_t channels, int64_t ratio, bool fancy_upscaling, bool try_recover_truncated, float acceptable_fraction, const char *dct_method, const char *dst_img_format) {
GE_ASSERT_NOTNULL(contents);
GE_ASSERT_NOTNULL(crop_window);
auto &graph = contents->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DecodeAndCropJpeg")
.Name(("DecodeAndCropJpeg_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"contents", ge::kIrInputRequired, ""},
{"crop_window", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"image", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"channels",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(channels))
},
{
"ratio",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(ratio))
},
{
"fancy_upscaling",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(fancy_upscaling))
},
{
"try_recover_truncated",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(try_recover_truncated))
},
{
"acceptable_fraction",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(acceptable_fraction))
},
{
"dct_method",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(dct_method))
},
{
"dst_img_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(dst_img_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(contents->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(crop_window->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDecodeBase64(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DecodeBase64")
.Name(("DecodeBase64_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDecodeBbox(EsbTensor *box_predictions, EsbTensor *anchors, float decode_clip) {
GE_ASSERT_NOTNULL(box_predictions);
GE_ASSERT_NOTNULL(anchors);
auto &graph = box_predictions->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DecodeBbox")
.Name(("DecodeBbox_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"box_predictions", ge::kIrInputRequired, ""},
{"anchors", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"decoded_boxes", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"decode_clip",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(decode_clip))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(box_predictions->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(anchors->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDecodeBboxV2(EsbTensor *boxes, EsbTensor *anchors, const float *scales, int64_t scales_num, float decode_clip, bool reversed_box) {
GE_ASSERT_NOTNULL(boxes);
GE_ASSERT_NOTNULL(anchors);
auto &graph = boxes->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DecodeBboxV2")
.Name(("DecodeBboxV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"boxes", ge::kIrInputRequired, ""},
{"anchors", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"scales",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(scales, scales + scales_num))
},
{
"decode_clip",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(decode_clip))
},
{
"reversed_box",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(reversed_box))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(boxes->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(anchors->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDecodeBmp(EsbTensor *contents, int64_t channels) {
GE_ASSERT_NOTNULL(contents);
auto &graph = contents->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DecodeBmp")
.Name(("DecodeBmp_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"contents", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"image", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"channels",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(channels))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(contents->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDecodeBoundariesTarget(EsbTensor *boundary_predictions, EsbTensor *anchors) {
GE_ASSERT_NOTNULL(boundary_predictions);
GE_ASSERT_NOTNULL(anchors);
auto &graph = boundary_predictions->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DecodeBoundariesTarget")
.Name(("DecodeBoundariesTarget_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"boundary_predictions", ge::kIrInputRequired, ""},
{"anchors", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"boundary_encoded", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(boundary_predictions->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(anchors->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDecodeCornerpointsTargetBG(EsbTensor *keypoints_prediction, EsbTensor *anchors) {
GE_ASSERT_NOTNULL(keypoints_prediction);
GE_ASSERT_NOTNULL(anchors);
auto &graph = keypoints_prediction->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DecodeCornerpointsTargetBG")
.Name(("DecodeCornerpointsTargetBG_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"keypoints_prediction", ge::kIrInputRequired, ""},
{"anchors", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"keypoints_decoded", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(keypoints_prediction->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(anchors->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDecodeCornerpointsTargetWrtCenterV1(EsbTensor *keypoints_prediction, EsbTensor *anchors) {
GE_ASSERT_NOTNULL(keypoints_prediction);
GE_ASSERT_NOTNULL(anchors);
auto &graph = keypoints_prediction->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DecodeCornerpointsTargetWrtCenterV1")
.Name(("DecodeCornerpointsTargetWrtCenterV1_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"keypoints_prediction", ge::kIrInputRequired, ""},
{"anchors", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"keypoints_decoded", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(keypoints_prediction->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(anchors->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDecodeGif(EsbTensor *contents) {
GE_ASSERT_NOTNULL(contents);
auto &graph = contents->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DecodeGif")
.Name(("DecodeGif_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"contents", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"image", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(contents->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDecodeImage(EsbTensor *contents, int64_t channels, ge::DataType dtype, bool expand_animations) {
GE_ASSERT_NOTNULL(contents);
auto &graph = contents->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DecodeImage")
.Name(("DecodeImage_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"contents", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"image", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"channels",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(channels))
},
{
"dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
{
"expand_animations",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(expand_animations))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(contents->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDecodeJpeg(EsbTensor *contents, int64_t channels, int64_t ratio, bool fancy_upscaling, bool try_recover_truncated, float acceptable_fraction, const char *dct_method, const char *dst_img_format) {
GE_ASSERT_NOTNULL(contents);
auto &graph = contents->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DecodeJpeg")
.Name(("DecodeJpeg_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"contents", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"image", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"channels",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(channels))
},
{
"ratio",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(ratio))
},
{
"fancy_upscaling",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(fancy_upscaling))
},
{
"try_recover_truncated",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(try_recover_truncated))
},
{
"acceptable_fraction",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(acceptable_fraction))
},
{
"dct_method",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(dct_method))
},
{
"dst_img_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(dst_img_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(contents->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDecodeJpegPre(EsbTensor *contents, const int64_t *w_range, int64_t w_range_num, const int64_t *h_range, int64_t h_range_num) {
GE_ASSERT_NOTNULL(contents);
auto &graph = contents->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DecodeJpegPre")
.Name(("DecodeJpegPre_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"contents", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"dvpp_support", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"w_range",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(w_range, w_range + w_range_num))
},
{
"h_range",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(h_range, h_range + h_range_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(contents->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDecodePng(EsbTensor *contents, ge::DataType dtype, int64_t channels) {
GE_ASSERT_NOTNULL(contents);
auto &graph = contents->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DecodePng")
.Name(("DecodePng_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"contents", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"image", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
{
"channels",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(channels))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(contents->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDecodeRaw(EsbTensor *bytes, ge::DataType out_type, bool little_endian) {
GE_ASSERT_NOTNULL(bytes);
auto &graph = bytes->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DecodeRaw")
.Name(("DecodeRaw_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"bytes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"out_type",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(out_type))
},
{
"little_endian",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(little_endian))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bytes->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsDecodeWavOutput EsDecodeWav(EsbTensor *contents, int64_t desired_channels, int64_t desired_samples) {
GE_ASSERT_NOTNULL(contents);
auto &graph = contents->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DecodeWav")
.Name(("DecodeWav_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"contents", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"audio", ge::kIrOutputRequired, ""},
{"sample_rate", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"desired_channels",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(desired_channels))
},
{
"desired_samples",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(desired_samples))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(contents->GetAnchor(), node->GetInDataAnchor(0)));
return EsDecodeWavOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsDecodeWheelsTarget(EsbTensor *boundary_predictions, EsbTensor *anchors) {
GE_ASSERT_NOTNULL(boundary_predictions);
GE_ASSERT_NOTNULL(anchors);
auto &graph = boundary_predictions->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DecodeWheelsTarget")
.Name(("DecodeWheelsTarget_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"boundary_predictions", ge::kIrInputRequired, ""},
{"anchors", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"boundary_encoded", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(boundary_predictions->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(anchors->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDeconvolution(EsbTensor *x, EsbTensor *filter, EsbTensor *bias, EsbTensor *offset_w, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const int64_t *dilations, int64_t dilations_num, int64_t groups, const char *data_format, int64_t offset_x) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(filter);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Deconvolution")
.Name(("Deconvolution_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"filter", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
{"offset_w", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"strides",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dilations",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"groups",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(groups))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"offset_x",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(offset_x))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(filter->GetAnchor(), node->GetInDataAnchor(1)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(2)));
}
if (offset_w != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset_w->GetAnchor(), node->GetInDataAnchor(3)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsDeepNormOutput EsDeepNorm(EsbTensor *x, EsbTensor *gx, EsbTensor *beta, EsbTensor *gamma, float alpha, float epsilon) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(gx);
GE_ASSERT_NOTNULL(beta);
GE_ASSERT_NOTNULL(gamma);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DeepNorm")
.Name(("DeepNorm_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"gx", ge::kIrInputRequired, ""},
{"beta", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"mean", ge::kIrOutputRequired, ""},
{"rstd", ge::kIrOutputRequired, ""},
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"alpha",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(alpha))
},
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gx->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(3)));
return EsDeepNormOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsDeepNormGradOutput EsDeepNormGrad(EsbTensor *dy, EsbTensor *x, EsbTensor *gx, EsbTensor *gamma, EsbTensor *mean, EsbTensor *rstd, float alpha) {
GE_ASSERT_NOTNULL(dy);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(gx);
GE_ASSERT_NOTNULL(gamma);
GE_ASSERT_NOTNULL(mean);
GE_ASSERT_NOTNULL(rstd);
auto &graph = dy->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DeepNormGrad")
.Name(("DeepNormGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"dy", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"gx", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
{"mean", ge::kIrInputRequired, ""},
{"rstd", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"dx", ge::kIrOutputRequired, ""},
{"dgx", ge::kIrOutputRequired, ""},
{"dbeta", ge::kIrOutputRequired, ""},
{"dgamma", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"alpha",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(alpha))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gx->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rstd->GetAnchor(), node->GetInDataAnchor(5)));
return EsDeepNormGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsbTensor *EsDeformableConv2D(EsbTensor *x, EsbTensor *filter, EsbTensor *offsets, EsbTensor *bias, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const int64_t *dilations, int64_t dilations_num, int64_t groups, const char *data_format, int64_t deformable_groups, bool modulated) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(filter);
GE_ASSERT_NOTNULL(offsets);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DeformableConv2D")
.Name(("DeformableConv2D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"filter", ge::kIrInputRequired, ""},
{"offsets", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dilations",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"groups",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(groups))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"deformable_groups",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(deformable_groups))
},
{
"modulated",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(modulated))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(filter->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offsets->GetAnchor(), node->GetInDataAnchor(2)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(3)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDeformableOffsets(EsbTensor *x, EsbTensor *offsets, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const int64_t *ksize, int64_t ksize_num, const int64_t *dilations, int64_t dilations_num, const char *data_format, int64_t deformable_groups, bool modulated) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(offsets);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DeformableOffsets")
.Name(("DeformableOffsets_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"offsets", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"ksize",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ksize, ksize + ksize_num))
},
{
"dilations",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"deformable_groups",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(deformable_groups))
},
{
"modulated",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(modulated))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offsets->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsDeformableOffsetsGradOutput EsDeformableOffsetsGrad(EsbTensor *grad, EsbTensor *x, EsbTensor *offsets, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const int64_t *ksize, int64_t ksize_num, const int64_t *dilations, int64_t dilations_num, const char *data_format, int64_t deformable_groups, bool modulated) {
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(offsets);
auto &graph = grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DeformableOffsetsGrad")
.Name(("DeformableOffsetsGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grad", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"offsets", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"grad_x", ge::kIrOutputRequired, ""},
{"grad_offsets", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"ksize",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ksize, ksize + ksize_num))
},
{
"dilations",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"deformable_groups",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(deformable_groups))
},
{
"modulated",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(modulated))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offsets->GetAnchor(), node->GetInDataAnchor(2)));
return EsDeformableOffsetsGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsDeformableRoiPool(EsbTensor *x, EsbTensor *rois, EsbTensor *offset, const int64_t *output_size, int64_t output_size_num, float spatial_scale, int64_t sampling_ratio, float gamma) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(rois);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DeformableRoiPool")
.Name(("DeformableRoiPool_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"rois", ge::kIrInputRequired, ""},
{"offset", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"output_size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(output_size, output_size + output_size_num))
},
{
"spatial_scale",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(spatial_scale))
},
{
"sampling_ratio",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(sampling_ratio))
},
{
"gamma",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(gamma))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rois->GetAnchor(), node->GetInDataAnchor(1)));
if (offset != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset->GetAnchor(), node->GetInDataAnchor(2)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsDeformableRoiPoolGradOutput EsDeformableRoiPoolGrad(EsbTensor *grad, EsbTensor *x, EsbTensor *rois, EsbTensor *offset, const int64_t *output_size, int64_t output_size_num, float spatial_scale, int64_t sampling_ratio, float gamma) {
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(rois);
auto &graph = grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DeformableRoiPoolGrad")
.Name(("DeformableRoiPoolGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grad", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"rois", ge::kIrInputRequired, ""},
{"offset", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"grad_x", ge::kIrOutputRequired, ""},
{"grad_offset", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"output_size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(output_size, output_size + output_size_num))
},
{
"spatial_scale",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(spatial_scale))
},
{
"sampling_ratio",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(sampling_ratio))
},
{
"gamma",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(gamma))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rois->GetAnchor(), node->GetInDataAnchor(2)));
if (offset != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset->GetAnchor(), node->GetInDataAnchor(3)));
}
return EsDeformableRoiPoolGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsDeinitEmbeddingHashmapV2(EsbTensor *table_id) {
GE_ASSERT_NOTNULL(table_id);
auto &graph = table_id->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DeinitEmbeddingHashmapV2")
.Name(("DeinitEmbeddingHashmapV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"table_id", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(table_id->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsDeleteSeedGenerator(EsbTensor *handle, EsbTensor *deleter) {
GE_ASSERT_NOTNULL(handle);
GE_ASSERT_NOTNULL(deleter);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DeleteSeedGenerator")
.Name(("DeleteSeedGenerator_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
{"deleter", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(deleter->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsDenseBincount(EsbTensor *input, EsbTensor *size, EsbTensor *weights, bool binary_output) {
GE_ASSERT_NOTNULL(input);
GE_ASSERT_NOTNULL(size);
GE_ASSERT_NOTNULL(weights);
auto &graph = input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DenseBincount")
.Name(("DenseBincount_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input", ge::kIrInputRequired, ""},
{"size", ge::kIrInputRequired, ""},
{"weights", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"binary_output",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(binary_output))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(size->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weights->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsDenseCountSparseOutputOutput EsDenseCountSparseOutput(EsbTensor *values, EsbTensor *weights, bool binary_output, int64_t minlength, int64_t maxlength) {
GE_ASSERT_NOTNULL(values);
GE_ASSERT_NOTNULL(weights);
auto &graph = values->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DenseCountSparseOutput")
.Name(("DenseCountSparseOutput_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"values", ge::kIrInputRequired, ""},
{"weights", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_indices", ge::kIrOutputRequired, ""},
{"output_values", ge::kIrOutputRequired, ""},
{"output_dense_shape", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"binary_output",
ge::kAttrRequired,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(binary_output))
},
{
"minlength",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(minlength))
},
{
"maxlength",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(maxlength))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(values->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weights->GetAnchor(), node->GetInDataAnchor(1)));
return EsDenseCountSparseOutputOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsDenseImageWarp(EsbTensor *image, EsbTensor *flow) {
GE_ASSERT_NOTNULL(image);
GE_ASSERT_NOTNULL(flow);
auto &graph = image->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DenseImageWarp")
.Name(("DenseImageWarp_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"image", ge::kIrInputRequired, ""},
{"flow", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(image->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(flow->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsDenseImageWarpGradOutput EsDenseImageWarpGrad(EsbTensor *grad, EsbTensor *image, EsbTensor *flow) {
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(image);
GE_ASSERT_NOTNULL(flow);
auto &graph = grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DenseImageWarpGrad")
.Name(("DenseImageWarpGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grad", ge::kIrInputRequired, ""},
{"image", ge::kIrInputRequired, ""},
{"flow", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"grad_image", ge::kIrOutputRequired, ""},
{"grad_flow", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(image->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(flow->GetAnchor(), node->GetInDataAnchor(2)));
return EsDenseImageWarpGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsDenseToDenseSetOperationOutput EsDenseToDenseSetOperation(EsbTensor *x1, EsbTensor *x2, const char *set_operation, bool validate_indices) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DenseToDenseSetOperation")
.Name(("DenseToDenseSetOperation_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y_indices", ge::kIrOutputRequired, ""},
{"y_values", ge::kIrOutputRequired, ""},
{"y_shape", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"set_operation",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(set_operation))
},
{
"validate_indices",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(validate_indices))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return EsDenseToDenseSetOperationOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsDenseToSparseSetOperationOutput EsDenseToSparseSetOperation(EsbTensor *x1, EsbTensor *x2_indices, EsbTensor *x2_values, EsbTensor *x2_shape, const char *set_operation, bool validate_indices) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2_indices);
GE_ASSERT_NOTNULL(x2_values);
GE_ASSERT_NOTNULL(x2_shape);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DenseToSparseSetOperation")
.Name(("DenseToSparseSetOperation_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2_indices", ge::kIrInputRequired, ""},
{"x2_values", ge::kIrInputRequired, ""},
{"x2_shape", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y_indices", ge::kIrOutputRequired, ""},
{"y_values", ge::kIrOutputRequired, ""},
{"y_shape", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"set_operation",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(set_operation))
},
{
"validate_indices",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(validate_indices))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2_indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2_values->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2_shape->GetAnchor(), node->GetInDataAnchor(3)));
return EsDenseToSparseSetOperationOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsDepthToSpace(EsbTensor *x, int64_t block_size, const char *mode, const char *data_format) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DepthToSpace")
.Name(("DepthToSpace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"block_size",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(block_size))
},
{
"mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(mode))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDepthwiseConv2D(EsbTensor *x, EsbTensor *filter, EsbTensor *bias, EsbTensor *offset_w, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const int64_t *dilations, int64_t dilations_num, const char *data_format, int64_t offset_x) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(filter);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DepthwiseConv2D")
.Name(("DepthwiseConv2D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"filter", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
{"offset_w", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dilations",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"offset_x",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(offset_x))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(filter->GetAnchor(), node->GetInDataAnchor(1)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(2)));
}
if (offset_w != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset_w->GetAnchor(), node->GetInDataAnchor(3)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDepthwiseConv2DBackpropFilter(EsbTensor *input, EsbTensor *filter_size, EsbTensor *out_backprop, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const int64_t *dilations, int64_t dilations_num, const char *data_format) {
GE_ASSERT_NOTNULL(input);
GE_ASSERT_NOTNULL(filter_size);
GE_ASSERT_NOTNULL(out_backprop);
auto &graph = input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DepthwiseConv2DBackpropFilter")
.Name(("DepthwiseConv2DBackpropFilter_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input", ge::kIrInputRequired, ""},
{"filter_size", ge::kIrInputRequired, ""},
{"out_backprop", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"filter_grad", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dilations",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(filter_size->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(out_backprop->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDepthwiseConv2DBackpropFilterD(EsbTensor *input, EsbTensor *out_backprop, const int64_t *filter_size, int64_t filter_size_num, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const int64_t *dilations, int64_t dilations_num, const char *data_format) {
GE_ASSERT_NOTNULL(input);
GE_ASSERT_NOTNULL(out_backprop);
auto &graph = input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DepthwiseConv2DBackpropFilterD")
.Name(("DepthwiseConv2DBackpropFilterD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input", ge::kIrInputRequired, ""},
{"out_backprop", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"filter_grad", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"filter_size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(filter_size, filter_size + filter_size_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dilations",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(out_backprop->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDepthwiseConv2DBackpropInput(EsbTensor *input_size, EsbTensor *filter, EsbTensor *out_backprop, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const int64_t *dilations, int64_t dilations_num, const char *data_format) {
GE_ASSERT_NOTNULL(input_size);
GE_ASSERT_NOTNULL(filter);
GE_ASSERT_NOTNULL(out_backprop);
auto &graph = input_size->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DepthwiseConv2DBackpropInput")
.Name(("DepthwiseConv2DBackpropInput_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_size", ge::kIrInputRequired, ""},
{"filter", ge::kIrInputRequired, ""},
{"out_backprop", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"input_grad", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dilations",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_size->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(filter->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(out_backprop->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDepthwiseConv2DBackpropInputD(EsbTensor *filter, EsbTensor *out_backprop, const int64_t *input_size, int64_t input_size_num, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const int64_t *dilations, int64_t dilations_num, const char *data_format) {
GE_ASSERT_NOTNULL(filter);
GE_ASSERT_NOTNULL(out_backprop);
auto &graph = filter->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DepthwiseConv2DBackpropInputD")
.Name(("DepthwiseConv2DBackpropInputD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"filter", ge::kIrInputRequired, ""},
{"out_backprop", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"input_grad", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"input_size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(input_size, input_size + input_size_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dilations",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(filter->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(out_backprop->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDepthwiseWeight4DTo6D(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DepthwiseWeight4DTo6D")
.Name(("DepthwiseWeight4DTo6D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDepthwiseWeight6DTo4D(EsbTensor *x, int64_t channel_size) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DepthwiseWeight6DTo4D")
.Name(("DepthwiseWeight6DTo4D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"channel_size",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(channel_size))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDequantize(EsbTensor *x, EsbTensor *min_range, EsbTensor *max_range, const char *mode) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(min_range);
GE_ASSERT_NOTNULL(max_range);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Dequantize")
.Name(("Dequantize_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"min_range", ge::kIrInputRequired, ""},
{"max_range", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(min_range->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(max_range->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDequeue(EsbTensor *queue_id, ge::DataType output_type, const int64_t *output_shape, int64_t output_shape_num, const char *queue_name) {
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
non_null_in = queue_id;
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Dequeue")
.Name(("Dequeue_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"queue_id", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"data", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"output_type",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(output_type))
},
{
"output_shape",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(output_shape, output_shape + output_shape_num))
},
{
"queue_name",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(queue_name))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if (queue_id != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(queue_id->GetAnchor(), node->GetInDataAnchor(0)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsDeserializeManySparseOutput EsDeserializeManySparse(EsbTensor *serialized_sparse, ge::DataType dtype) {
GE_ASSERT_NOTNULL(serialized_sparse);
auto &graph = serialized_sparse->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DeserializeManySparse")
.Name(("DeserializeManySparse_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"serialized_sparse", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"indices", ge::kIrOutputRequired, ""},
{"values", ge::kIrOutputRequired, ""},
{"shape", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(serialized_sparse->GetAnchor(), node->GetInDataAnchor(0)));
return EsDeserializeManySparseOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsDeserializeSparseOutput EsDeserializeSparse(EsbTensor *serialized_sparse, ge::DataType dtype) {
GE_ASSERT_NOTNULL(serialized_sparse);
auto &graph = serialized_sparse->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DeserializeSparse")
.Name(("DeserializeSparse_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"serialized_sparse", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"indices", ge::kIrOutputRequired, ""},
{"values", ge::kIrOutputRequired, ""},
{"shape", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(serialized_sparse->GetAnchor(), node->GetInDataAnchor(0)));
return EsDeserializeSparseOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsDestroyTemporaryVariable(EsbTensor *x, const char *var_name) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DestroyTemporaryVariable")
.Name(("DestroyTemporaryVariable_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"var_name",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(var_name))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsDetectFlashAttentionScoreOutput EsDetectFlashAttentionScore(EsbTensor *query, EsbTensor *key, EsbTensor *value, EsbTensor *real_shift, EsbTensor *drop_mask, EsbTensor *padding_mask, EsbTensor *atten_mask, EsbTensor *prefix, EsbTensor *actual_seq_qlen, EsbTensor *actual_seq_kvlen, EsbTensor *q_start_idx, EsbTensor *kv_start_idx, int64_t head_num, const char *input_layout, float scale_value, float keep_prob, int64_t pre_tockens, int64_t next_tockens, int64_t inner_precise, int64_t sparse_mode, int64_t pse_type) {
GE_ASSERT_NOTNULL(query);
GE_ASSERT_NOTNULL(key);
GE_ASSERT_NOTNULL(value);
auto &graph = query->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DetectFlashAttentionScore")
.Name(("DetectFlashAttentionScore_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"query", ge::kIrInputRequired, ""},
{"key", ge::kIrInputRequired, ""},
{"value", ge::kIrInputRequired, ""},
{"real_shift", ge::kIrInputOptional, ""},
{"drop_mask", ge::kIrInputOptional, ""},
{"padding_mask", ge::kIrInputOptional, ""},
{"atten_mask", ge::kIrInputOptional, ""},
{"prefix", ge::kIrInputOptional, ""},
{"actual_seq_qlen", ge::kIrInputOptional, ""},
{"actual_seq_kvlen", ge::kIrInputOptional, ""},
{"q_start_idx", ge::kIrInputOptional, ""},
{"kv_start_idx", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"softmax_max", ge::kIrOutputRequired, ""},
{"softmax_sum", ge::kIrOutputRequired, ""},
{"softmax_out", ge::kIrOutputRequired, ""},
{"attention_out", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"head_num",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(head_num))
},
{
"input_layout",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(input_layout))
},
{
"scale_value",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(scale_value))
},
{
"keep_prob",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(keep_prob))
},
{
"pre_tockens",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pre_tockens))
},
{
"next_tockens",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(next_tockens))
},
{
"inner_precise",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(inner_precise))
},
{
"sparse_mode",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(sparse_mode))
},
{
"pse_type",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pse_type))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(query->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(key->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(2)));
if (real_shift != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(real_shift->GetAnchor(), node->GetInDataAnchor(3)));
}
if (drop_mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(drop_mask->GetAnchor(), node->GetInDataAnchor(4)));
}
if (padding_mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(padding_mask->GetAnchor(), node->GetInDataAnchor(5)));
}
if (atten_mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(atten_mask->GetAnchor(), node->GetInDataAnchor(6)));
}
if (prefix != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(prefix->GetAnchor(), node->GetInDataAnchor(7)));
}
if (actual_seq_qlen != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(actual_seq_qlen->GetAnchor(), node->GetInDataAnchor(8)));
}
if (actual_seq_kvlen != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(actual_seq_kvlen->GetAnchor(), node->GetInDataAnchor(9)));
}
if (q_start_idx != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(q_start_idx->GetAnchor(), node->GetInDataAnchor(10)));
}
if (kv_start_idx != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(kv_start_idx->GetAnchor(), node->GetInDataAnchor(11)));
}
return EsDetectFlashAttentionScoreOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsDetectFlashAttentionScoreGradOutput EsDetectFlashAttentionScoreGrad(EsbTensor *query, EsbTensor *key, EsbTensor *value, EsbTensor *dy, EsbTensor *pse_shift, EsbTensor *drop_mask, EsbTensor *padding_mask, EsbTensor *atten_mask, EsbTensor *softmax_max, EsbTensor *softmax_sum, EsbTensor *softmax_in, EsbTensor *attention_in, EsbTensor *prefix, EsbTensor *actual_seq_qlen, EsbTensor *actual_seq_kvlen, EsbTensor *q_start_idx, EsbTensor *kv_start_idx, int64_t head_num, const char *input_layout, float scale_value, float keep_prob, int64_t pre_tockens, int64_t next_tockens, int64_t inner_precise, int64_t sparse_mode, int64_t pse_type) {
GE_ASSERT_NOTNULL(query);
GE_ASSERT_NOTNULL(key);
GE_ASSERT_NOTNULL(value);
GE_ASSERT_NOTNULL(dy);
auto &graph = query->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DetectFlashAttentionScoreGrad")
.Name(("DetectFlashAttentionScoreGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"query", ge::kIrInputRequired, ""},
{"key", ge::kIrInputRequired, ""},
{"value", ge::kIrInputRequired, ""},
{"dy", ge::kIrInputRequired, ""},
{"pse_shift", ge::kIrInputOptional, ""},
{"drop_mask", ge::kIrInputOptional, ""},
{"padding_mask", ge::kIrInputOptional, ""},
{"atten_mask", ge::kIrInputOptional, ""},
{"softmax_max", ge::kIrInputOptional, ""},
{"softmax_sum", ge::kIrInputOptional, ""},
{"softmax_in", ge::kIrInputOptional, ""},
{"attention_in", ge::kIrInputOptional, ""},
{"prefix", ge::kIrInputOptional, ""},
{"actual_seq_qlen", ge::kIrInputOptional, ""},
{"actual_seq_kvlen", ge::kIrInputOptional, ""},
{"q_start_idx", ge::kIrInputOptional, ""},
{"kv_start_idx", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"dq", ge::kIrOutputRequired, ""},
{"dk", ge::kIrOutputRequired, ""},
{"dv", ge::kIrOutputRequired, ""},
{"dpse", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"head_num",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(head_num))
},
{
"input_layout",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(input_layout))
},
{
"scale_value",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(scale_value))
},
{
"keep_prob",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(keep_prob))
},
{
"pre_tockens",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pre_tockens))
},
{
"next_tockens",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(next_tockens))
},
{
"inner_precise",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(inner_precise))
},
{
"sparse_mode",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(sparse_mode))
},
{
"pse_type",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pse_type))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(query->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(key->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(3)));
if (pse_shift != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(pse_shift->GetAnchor(), node->GetInDataAnchor(4)));
}
if (drop_mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(drop_mask->GetAnchor(), node->GetInDataAnchor(5)));
}
if (padding_mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(padding_mask->GetAnchor(), node->GetInDataAnchor(6)));
}
if (atten_mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(atten_mask->GetAnchor(), node->GetInDataAnchor(7)));
}
if (softmax_max != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(softmax_max->GetAnchor(), node->GetInDataAnchor(8)));
}
if (softmax_sum != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(softmax_sum->GetAnchor(), node->GetInDataAnchor(9)));
}
if (softmax_in != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(softmax_in->GetAnchor(), node->GetInDataAnchor(10)));
}
if (attention_in != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(attention_in->GetAnchor(), node->GetInDataAnchor(11)));
}
if (prefix != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(prefix->GetAnchor(), node->GetInDataAnchor(12)));
}
if (actual_seq_qlen != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(actual_seq_qlen->GetAnchor(), node->GetInDataAnchor(13)));
}
if (actual_seq_kvlen != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(actual_seq_kvlen->GetAnchor(), node->GetInDataAnchor(14)));
}
if (q_start_idx != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(q_start_idx->GetAnchor(), node->GetInDataAnchor(15)));
}
if (kv_start_idx != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(kv_start_idx->GetAnchor(), node->GetInDataAnchor(16)));
}
return EsDetectFlashAttentionScoreGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsbTensor *EsDiag(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Diag")
.Name(("Diag_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDiagD(EsbTensor *x, EsbTensor *assist) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(assist);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DiagD")
.Name(("DiagD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"assist", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(assist->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDiagFlat(EsbTensor *x, int64_t diagonal) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DiagFlat")
.Name(("DiagFlat_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"diagonal",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(diagonal))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDiagPart(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DiagPart")
.Name(("DiagPart_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDiagPartD(EsbTensor *x, EsbTensor *assist) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(assist);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DiagPartD")
.Name(("DiagPartD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"assist", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(assist->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDiagV2(EsbTensor *x, int64_t diagonal) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DiagV2")
.Name(("DiagV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"diagonal",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(diagonal))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDigamma(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Digamma")
.Name(("Digamma_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDilation(EsbTensor *x, const int64_t *dilations, int64_t dilations_num, const int64_t *pads, int64_t pads_num, float padding_value) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Dilation")
.Name(("Dilation_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dilations",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"pads",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"padding_value",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(padding_value))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDilation2D(EsbTensor *x, EsbTensor *filter, const int64_t *strides, int64_t strides_num, const int64_t *rates, int64_t rates_num, const char *padding_mode, const int64_t *pads, int64_t pads_num, bool ceil_mode, const char *data_format) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(filter);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Dilation2D")
.Name(("Dilation2D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"filter", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"rates",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(rates, rates + rates_num))
},
{
"padding_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(padding_mode))
},
{
"pads",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"ceil_mode",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(ceil_mode))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(filter->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDilation2DBackpropFilter(EsbTensor *x, EsbTensor *filter, EsbTensor *out_backprop, const int64_t *strides, int64_t strides_num, const int64_t *rates, int64_t rates_num, const char *padding_mode, const int64_t *pads, int64_t pads_num, bool ceil_mode, const char *data_format) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(filter);
GE_ASSERT_NOTNULL(out_backprop);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Dilation2DBackpropFilter")
.Name(("Dilation2DBackpropFilter_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"filter", ge::kIrInputRequired, ""},
{"out_backprop", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"rates",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(rates, rates + rates_num))
},
{
"padding_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(padding_mode))
},
{
"pads",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"ceil_mode",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(ceil_mode))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(filter->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(out_backprop->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDilation2DBackpropInput(EsbTensor *x, EsbTensor *filter, EsbTensor *out_backprop, const int64_t *strides, int64_t strides_num, const int64_t *rates, int64_t rates_num, const char *padding_mode, const int64_t *pads, int64_t pads_num, bool ceil_mode, const char *data_format) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(filter);
GE_ASSERT_NOTNULL(out_backprop);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Dilation2DBackpropInput")
.Name(("Dilation2DBackpropInput_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"filter", ge::kIrInputRequired, ""},
{"out_backprop", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"rates",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(rates, rates + rates_num))
},
{
"padding_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(padding_mode))
},
{
"pads",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"ceil_mode",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(ceil_mode))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(filter->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(out_backprop->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDiv(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Div")
.Name(("Div_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDivNoNan(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DivNoNan")
.Name(("DivNoNan_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDot(EsbTensor *input_x, EsbTensor *input_y) {
GE_ASSERT_NOTNULL(input_x);
GE_ASSERT_NOTNULL(input_y);
auto &graph = input_x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Dot")
.Name(("Dot_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_x", ge::kIrInputRequired, ""},
{"input_y", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_y->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDrawBoundingBoxes(EsbTensor *images, EsbTensor *boxes) {
GE_ASSERT_NOTNULL(images);
GE_ASSERT_NOTNULL(boxes);
auto &graph = images->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DrawBoundingBoxes")
.Name(("DrawBoundingBoxes_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"images", ge::kIrInputRequired, ""},
{"boxes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(images->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(boxes->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDrawBoundingBoxesV2(EsbTensor *images, EsbTensor *boxes, EsbTensor *colors) {
GE_ASSERT_NOTNULL(images);
GE_ASSERT_NOTNULL(boxes);
GE_ASSERT_NOTNULL(colors);
auto &graph = images->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DrawBoundingBoxesV2")
.Name(("DrawBoundingBoxesV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"images", ge::kIrInputRequired, ""},
{"boxes", ge::kIrInputRequired, ""},
{"colors", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(images->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(boxes->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(colors->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDropOutDoMask(EsbTensor *x, EsbTensor *mask, EsbTensor *keep_prob) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(mask);
GE_ASSERT_NOTNULL(keep_prob);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DropOutDoMask")
.Name(("DropOutDoMask_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"mask", ge::kIrInputRequired, ""},
{"keep_prob", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mask->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(keep_prob->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDropOutDoMaskV3(EsbTensor *x, EsbTensor *mask, EsbTensor *keep_prob) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(mask);
GE_ASSERT_NOTNULL(keep_prob);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DropOutDoMaskV3")
.Name(("DropOutDoMaskV3_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"mask", ge::kIrInputRequired, ""},
{"keep_prob", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mask->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(keep_prob->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDropOutDoMaskV3D(EsbTensor *x, EsbTensor *mask, float keep_prob) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(mask);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DropOutDoMaskV3D")
.Name(("DropOutDoMaskV3D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"mask", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"keep_prob",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(keep_prob))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mask->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDropOutGenMask(EsbTensor *shape, EsbTensor *prob, int64_t seed, int64_t seed2) {
GE_ASSERT_NOTNULL(shape);
GE_ASSERT_NOTNULL(prob);
auto &graph = shape->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DropOutGenMask")
.Name(("DropOutGenMask_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"shape", ge::kIrInputRequired, ""},
{"prob", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"seed",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed))
},
{
"seed2",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed2))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(prob->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDropOutGenMaskV3(EsbTensor *shape, EsbTensor *prob, int64_t seed, int64_t seed2) {
GE_ASSERT_NOTNULL(shape);
GE_ASSERT_NOTNULL(prob);
auto &graph = shape->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DropOutGenMaskV3")
.Name(("DropOutGenMaskV3_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"shape", ge::kIrInputRequired, ""},
{"prob", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"seed",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed))
},
{
"seed2",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed2))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(prob->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDropOutGenMaskV4(EsbTensor *shape, EsbTensor *prob, int64_t seed, int64_t seed2, ge::DataType dtype) {
GE_ASSERT_NOTNULL(shape);
GE_ASSERT_NOTNULL(prob);
auto &graph = shape->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DropOutGenMaskV4")
.Name(("DropOutGenMaskV4_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"shape", ge::kIrInputRequired, ""},
{"prob", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"seed",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed))
},
{
"seed2",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed2))
},
{
"dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(prob->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDropout(EsbTensor *x, float dropout_ratio, bool scale_train, float alpha, float beta) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Dropout")
.Name(("Dropout_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dropout_ratio",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(dropout_ratio))
},
{
"scale_train",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(scale_train))
},
{
"alpha",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(alpha))
},
{
"beta",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(beta))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsDropoutV2Output EsDropoutV2(EsbTensor *x, EsbTensor *seed, float p) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(seed);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DropoutV2")
.Name(("DropoutV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"seed", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"mask", ge::kIrOutputRequired, ""},
{"seed", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"p",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(p))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seed->GetAnchor(), node->GetInDataAnchor(1)));
return EsDropoutV2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsDropoutWithMulsAndSoftmaxGrad(EsbTensor *y_grad, EsbTensor *mask, EsbTensor *softmax_output, float input_keep_prob, float alpha, const int64_t *axes, int64_t axes_num) {
GE_ASSERT_NOTNULL(y_grad);
GE_ASSERT_NOTNULL(mask);
GE_ASSERT_NOTNULL(softmax_output);
auto &graph = y_grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DropoutWithMulsAndSoftmaxGrad")
.Name(("DropoutWithMulsAndSoftmaxGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"y_grad", ge::kIrInputRequired, ""},
{"mask", ge::kIrInputRequired, ""},
{"softmax_output", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"x_grad", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"input_keep_prob",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(input_keep_prob))
},
{
"alpha",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(alpha))
},
{
"axes",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(axes, axes + axes_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y_grad->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mask->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(softmax_output->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsDuaQuantizeAddLayerNormOutput EsDuaQuantizeAddLayerNorm(EsbTensor *x1, EsbTensor *x2, EsbTensor *gamma, EsbTensor *beta, EsbTensor *bias, EsbTensor *scales1, EsbTensor *scales2, EsbTensor *zero_points1, EsbTensor *zero_points2, int64_t dtype, int64_t axis, float epsilon, bool additional_output) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
GE_ASSERT_NOTNULL(gamma);
GE_ASSERT_NOTNULL(beta);
GE_ASSERT_NOTNULL(bias);
GE_ASSERT_NOTNULL(scales1);
GE_ASSERT_NOTNULL(scales2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DuaQuantizeAddLayerNorm")
.Name(("DuaQuantizeAddLayerNorm_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
{"beta", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputRequired, ""},
{"scales1", ge::kIrInputRequired, ""},
{"scales2", ge::kIrInputRequired, ""},
{"zero_points1", ge::kIrInputOptional, ""},
{"zero_points2", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y1", ge::kIrOutputRequired, ""},
{"y2", ge::kIrOutputRequired, ""},
{"x", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dtype))
},
{
"axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
{
"additional_output",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(additional_output))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scales1->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scales2->GetAnchor(), node->GetInDataAnchor(6)));
if (zero_points1 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(zero_points1->GetAnchor(), node->GetInDataAnchor(7)));
}
if (zero_points2 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(zero_points2->GetAnchor(), node->GetInDataAnchor(8)));
}
return EsDuaQuantizeAddLayerNormOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsDummySeedGenerator(EsbGraph *owner_graph) {
GE_ASSERT_NOTNULL(owner_graph);
EsbGraph &graph = *owner_graph;

auto desc = ge::CompliantOpDescBuilder().OpType("DummySeedGenerator")
.Name(("DummySeedGenerator_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
})
.IrDefOutputs({
{"handle", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsDynSeqOuter(EsbTensor *x1, EsbTensor *x2, EsbTensor *seq_len1, EsbTensor *seq_len2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
GE_ASSERT_NOTNULL(seq_len1);
GE_ASSERT_NOTNULL(seq_len2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DynSeqOuter")
.Name(("DynSeqOuter_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"seq_len1", ge::kIrInputRequired, ""},
{"seq_len2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seq_len1->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seq_len2->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsDynamicAUGRUOutput EsDynamicAUGRU(EsbTensor *x, EsbTensor *weight_input, EsbTensor *weight_hidden, EsbTensor *weight_att, EsbTensor *bias_input, EsbTensor *bias_hidden, EsbTensor *seq_length, EsbTensor *init_h, const char *direction, int64_t cell_depth, float keep_prob, float cell_clip, int64_t num_proj, bool time_major, const char *activation, const char *gate_order, bool reset_after, bool is_training) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(weight_input);
GE_ASSERT_NOTNULL(weight_hidden);
GE_ASSERT_NOTNULL(weight_att);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DynamicAUGRU")
.Name(("DynamicAUGRU_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"weight_input", ge::kIrInputRequired, ""},
{"weight_hidden", ge::kIrInputRequired, ""},
{"weight_att", ge::kIrInputRequired, ""},
{"bias_input", ge::kIrInputOptional, ""},
{"bias_hidden", ge::kIrInputOptional, ""},
{"seq_length", ge::kIrInputOptional, ""},
{"init_h", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"output_h", ge::kIrOutputRequired, ""},
{"update", ge::kIrOutputRequired, ""},
{"update_att", ge::kIrOutputRequired, ""},
{"reset", ge::kIrOutputRequired, ""},
{"new", ge::kIrOutputRequired, ""},
{"hidden_new", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"direction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(direction))
},
{
"cell_depth",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(cell_depth))
},
{
"keep_prob",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(keep_prob))
},
{
"cell_clip",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(cell_clip))
},
{
"num_proj",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_proj))
},
{
"time_major",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(time_major))
},
{
"activation",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(activation))
},
{
"gate_order",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(gate_order))
},
{
"reset_after",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(reset_after))
},
{
"is_training",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_training))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight_input->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight_hidden->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight_att->GetAnchor(), node->GetInDataAnchor(3)));
if (bias_input != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias_input->GetAnchor(), node->GetInDataAnchor(4)));
}
if (bias_hidden != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias_hidden->GetAnchor(), node->GetInDataAnchor(5)));
}
if (seq_length != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seq_length->GetAnchor(), node->GetInDataAnchor(6)));
}
if (init_h != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(init_h->GetAnchor(), node->GetInDataAnchor(7)));
}
return EsDynamicAUGRUOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
graph.GetEsbTensorFromNode(node, 5),
graph.GetEsbTensorFromNode(node, 6),
};
}
EsDynamicAUGRUGradOutput EsDynamicAUGRUGrad(EsbTensor *x, EsbTensor *weight_input, EsbTensor *weight_hidden, EsbTensor *weight_att, EsbTensor *y, EsbTensor *init_h, EsbTensor *h, EsbTensor *dy, EsbTensor *dh, EsbTensor *update, EsbTensor *update_att, EsbTensor *reset, EsbTensor *in_new, EsbTensor *hidden_new, EsbTensor *seq_length, EsbTensor *mask, const char *direction, int64_t cell_depth, float keep_prob, float cell_clip, int64_t num_proj, bool time_major, const char *gate_order, bool reset_after) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(weight_input);
GE_ASSERT_NOTNULL(weight_hidden);
GE_ASSERT_NOTNULL(weight_att);
GE_ASSERT_NOTNULL(y);
GE_ASSERT_NOTNULL(init_h);
GE_ASSERT_NOTNULL(h);
GE_ASSERT_NOTNULL(dy);
GE_ASSERT_NOTNULL(dh);
GE_ASSERT_NOTNULL(update);
GE_ASSERT_NOTNULL(update_att);
GE_ASSERT_NOTNULL(reset);
GE_ASSERT_NOTNULL(in_new);
GE_ASSERT_NOTNULL(hidden_new);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DynamicAUGRUGrad")
.Name(("DynamicAUGRUGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"weight_input", ge::kIrInputRequired, ""},
{"weight_hidden", ge::kIrInputRequired, ""},
{"weight_att", ge::kIrInputRequired, ""},
{"y", ge::kIrInputRequired, ""},
{"init_h", ge::kIrInputRequired, ""},
{"h", ge::kIrInputRequired, ""},
{"dy", ge::kIrInputRequired, ""},
{"dh", ge::kIrInputRequired, ""},
{"update", ge::kIrInputRequired, ""},
{"update_att", ge::kIrInputRequired, ""},
{"reset", ge::kIrInputRequired, ""},
{"new", ge::kIrInputRequired, ""},
{"hidden_new", ge::kIrInputRequired, ""},
{"seq_length", ge::kIrInputOptional, ""},
{"mask", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"dw_input", ge::kIrOutputRequired, ""},
{"dw_hidden", ge::kIrOutputRequired, ""},
{"db_input", ge::kIrOutputRequired, ""},
{"db_hidden", ge::kIrOutputRequired, ""},
{"dx", ge::kIrOutputRequired, ""},
{"dh_prev", ge::kIrOutputRequired, ""},
{"dw_att", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"direction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(direction))
},
{
"cell_depth",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(cell_depth))
},
{
"keep_prob",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(keep_prob))
},
{
"cell_clip",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(cell_clip))
},
{
"num_proj",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_proj))
},
{
"time_major",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(time_major))
},
{
"gate_order",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(gate_order))
},
{
"reset_after",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(reset_after))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight_input->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight_hidden->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight_att->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(init_h->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(h->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(7)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dh->GetAnchor(), node->GetInDataAnchor(8)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(update->GetAnchor(), node->GetInDataAnchor(9)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(update_att->GetAnchor(), node->GetInDataAnchor(10)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(reset->GetAnchor(), node->GetInDataAnchor(11)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(in_new->GetAnchor(), node->GetInDataAnchor(12)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(hidden_new->GetAnchor(), node->GetInDataAnchor(13)));
if (seq_length != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seq_length->GetAnchor(), node->GetInDataAnchor(14)));
}
if (mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mask->GetAnchor(), node->GetInDataAnchor(15)));
}
return EsDynamicAUGRUGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
graph.GetEsbTensorFromNode(node, 5),
graph.GetEsbTensorFromNode(node, 6),
};
}
EsbTensor *EsDynamicAtomicAddrClean(EsbGraph *owner_graph, const int64_t *automic_add_mem_size, int64_t automic_add_mem_size_num) {
GE_ASSERT_NOTNULL(owner_graph);
EsbGraph &graph = *owner_graph;

auto desc = ge::CompliantOpDescBuilder().OpType("DynamicAtomicAddrClean")
.Name(("DynamicAtomicAddrClean_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
})
.IrDefOutputs({
})
.IrDefAttrs({
{
"automic_add_mem_size",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(automic_add_mem_size, automic_add_mem_size + automic_add_mem_size_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsDynamicGRUOutput EsDynamicGRU(EsbTensor *x, EsbTensor *w, EsbTensor *b, EsbTensor *cw, EsbTensor *cb, EsbTensor *seq_length, EsbTensor *init_h, const char *direction, int64_t cell_depth, float keep_prob, float cell_clip, int64_t num_proj, bool time_major, const char *activation, bool is_training) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(w);
GE_ASSERT_NOTNULL(b);
GE_ASSERT_NOTNULL(cw);
GE_ASSERT_NOTNULL(cb);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DynamicGRU")
.Name(("DynamicGRU_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"w", ge::kIrInputRequired, ""},
{"b", ge::kIrInputRequired, ""},
{"cw", ge::kIrInputRequired, ""},
{"cb", ge::kIrInputRequired, ""},
{"seq_length", ge::kIrInputOptional, ""},
{"init_h", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"output_h", ge::kIrOutputRequired, ""},
{"r", ge::kIrOutputRequired, ""},
{"i", ge::kIrOutputRequired, ""},
{"n", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"direction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(direction))
},
{
"cell_depth",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(cell_depth))
},
{
"keep_prob",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(keep_prob))
},
{
"cell_clip",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(cell_clip))
},
{
"num_proj",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_proj))
},
{
"time_major",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(time_major))
},
{
"activation",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(activation))
},
{
"is_training",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_training))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(w->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(b->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(cw->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(cb->GetAnchor(), node->GetInDataAnchor(4)));
if (seq_length != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seq_length->GetAnchor(), node->GetInDataAnchor(5)));
}
if (init_h != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(init_h->GetAnchor(), node->GetInDataAnchor(6)));
}
return EsDynamicGRUOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
};
}
EsDynamicGRUCellGradOutput EsDynamicGRUCellGrad(EsbTensor *dh_pre_t, EsbTensor *h, EsbTensor *dy, EsbTensor *dh, EsbTensor *update, EsbTensor *reset, EsbTensor *in_new, EsbTensor *hidden_new, EsbTensor *init_h, EsbTensor *t_state, EsbTensor *seq_length, const char *gate_order) {
GE_ASSERT_NOTNULL(dh_pre_t);
GE_ASSERT_NOTNULL(h);
GE_ASSERT_NOTNULL(dy);
GE_ASSERT_NOTNULL(dh);
GE_ASSERT_NOTNULL(update);
GE_ASSERT_NOTNULL(reset);
GE_ASSERT_NOTNULL(in_new);
GE_ASSERT_NOTNULL(hidden_new);
GE_ASSERT_NOTNULL(init_h);
GE_ASSERT_NOTNULL(t_state);
auto &graph = dh_pre_t->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DynamicGRUCellGrad")
.Name(("DynamicGRUCellGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"dh_pre_t", ge::kIrInputRequired, ""},
{"h", ge::kIrInputRequired, ""},
{"dy", ge::kIrInputRequired, ""},
{"dh", ge::kIrInputRequired, ""},
{"update", ge::kIrInputRequired, ""},
{"reset", ge::kIrInputRequired, ""},
{"new", ge::kIrInputRequired, ""},
{"hidden_new", ge::kIrInputRequired, ""},
{"init_h", ge::kIrInputRequired, ""},
{"t_state", ge::kIrInputRequired, ""},
{"seq_length", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"dh_prev", ge::kIrOutputRequired, ""},
{"dgate_h", ge::kIrOutputRequired, ""},
{"dnt_x", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"gate_order",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(gate_order))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dh_pre_t->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(h->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dh->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(update->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(reset->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(in_new->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(hidden_new->GetAnchor(), node->GetInDataAnchor(7)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(init_h->GetAnchor(), node->GetInDataAnchor(8)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(t_state->GetAnchor(), node->GetInDataAnchor(9)));
if (seq_length != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seq_length->GetAnchor(), node->GetInDataAnchor(10)));
}
return EsDynamicGRUCellGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsDynamicGRUV2Output EsDynamicGRUV2(EsbTensor *x, EsbTensor *weight_input, EsbTensor *weight_hidden, EsbTensor *bias_input, EsbTensor *bias_hidden, EsbTensor *seq_length, EsbTensor *init_h, const char *direction, int64_t cell_depth, float keep_prob, float cell_clip, int64_t num_proj, bool time_major, const char *activation, const char *gate_order, bool reset_after, bool is_training) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(weight_input);
GE_ASSERT_NOTNULL(weight_hidden);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DynamicGRUV2")
.Name(("DynamicGRUV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"weight_input", ge::kIrInputRequired, ""},
{"weight_hidden", ge::kIrInputRequired, ""},
{"bias_input", ge::kIrInputOptional, ""},
{"bias_hidden", ge::kIrInputOptional, ""},
{"seq_length", ge::kIrInputOptional, ""},
{"init_h", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"output_h", ge::kIrOutputRequired, ""},
{"update", ge::kIrOutputRequired, ""},
{"reset", ge::kIrOutputRequired, ""},
{"new", ge::kIrOutputRequired, ""},
{"hidden_new", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"direction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(direction))
},
{
"cell_depth",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(cell_depth))
},
{
"keep_prob",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(keep_prob))
},
{
"cell_clip",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(cell_clip))
},
{
"num_proj",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_proj))
},
{
"time_major",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(time_major))
},
{
"activation",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(activation))
},
{
"gate_order",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(gate_order))
},
{
"reset_after",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(reset_after))
},
{
"is_training",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_training))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight_input->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight_hidden->GetAnchor(), node->GetInDataAnchor(2)));
if (bias_input != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias_input->GetAnchor(), node->GetInDataAnchor(3)));
}
if (bias_hidden != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias_hidden->GetAnchor(), node->GetInDataAnchor(4)));
}
if (seq_length != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seq_length->GetAnchor(), node->GetInDataAnchor(5)));
}
if (init_h != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(init_h->GetAnchor(), node->GetInDataAnchor(6)));
}
return EsDynamicGRUV2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
graph.GetEsbTensorFromNode(node, 5),
};
}
EsDynamicGRUV2GradOutput EsDynamicGRUV2Grad(EsbTensor *x, EsbTensor *weight_input, EsbTensor *weight_hidden, EsbTensor *y, EsbTensor *init_h, EsbTensor *h, EsbTensor *dy, EsbTensor *dh, EsbTensor *update, EsbTensor *reset, EsbTensor *in_new, EsbTensor *hidden_new, EsbTensor *seq_length, EsbTensor *mask, const char *direction, int64_t cell_depth, float keep_prob, float cell_clip, int64_t num_proj, bool time_major, const char *gate_order, bool reset_after) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(weight_input);
GE_ASSERT_NOTNULL(weight_hidden);
GE_ASSERT_NOTNULL(y);
GE_ASSERT_NOTNULL(init_h);
GE_ASSERT_NOTNULL(h);
GE_ASSERT_NOTNULL(dy);
GE_ASSERT_NOTNULL(dh);
GE_ASSERT_NOTNULL(update);
GE_ASSERT_NOTNULL(reset);
GE_ASSERT_NOTNULL(in_new);
GE_ASSERT_NOTNULL(hidden_new);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DynamicGRUV2Grad")
.Name(("DynamicGRUV2Grad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"weight_input", ge::kIrInputRequired, ""},
{"weight_hidden", ge::kIrInputRequired, ""},
{"y", ge::kIrInputRequired, ""},
{"init_h", ge::kIrInputRequired, ""},
{"h", ge::kIrInputRequired, ""},
{"dy", ge::kIrInputRequired, ""},
{"dh", ge::kIrInputRequired, ""},
{"update", ge::kIrInputRequired, ""},
{"reset", ge::kIrInputRequired, ""},
{"new", ge::kIrInputRequired, ""},
{"hidden_new", ge::kIrInputRequired, ""},
{"seq_length", ge::kIrInputOptional, ""},
{"mask", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"dw_input", ge::kIrOutputRequired, ""},
{"dw_hidden", ge::kIrOutputRequired, ""},
{"db_input", ge::kIrOutputRequired, ""},
{"db_hidden", ge::kIrOutputRequired, ""},
{"dx", ge::kIrOutputRequired, ""},
{"dh_prev", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"direction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(direction))
},
{
"cell_depth",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(cell_depth))
},
{
"keep_prob",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(keep_prob))
},
{
"cell_clip",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(cell_clip))
},
{
"num_proj",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_proj))
},
{
"time_major",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(time_major))
},
{
"gate_order",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(gate_order))
},
{
"reset_after",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(reset_after))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight_input->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight_hidden->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(init_h->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(h->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dh->GetAnchor(), node->GetInDataAnchor(7)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(update->GetAnchor(), node->GetInDataAnchor(8)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(reset->GetAnchor(), node->GetInDataAnchor(9)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(in_new->GetAnchor(), node->GetInDataAnchor(10)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(hidden_new->GetAnchor(), node->GetInDataAnchor(11)));
if (seq_length != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seq_length->GetAnchor(), node->GetInDataAnchor(12)));
}
if (mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mask->GetAnchor(), node->GetInDataAnchor(13)));
}
return EsDynamicGRUV2GradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
graph.GetEsbTensorFromNode(node, 5),
};
}
EsDynamicGRUV2HiddenOutput EsDynamicGRUV2Hidden(EsbTensor *x_weight_input, EsbTensor *weight_hidden, EsbTensor *bias_hidden, EsbTensor *seq_length, EsbTensor *init_h, const char *direction, int64_t cell_depth, float keep_prob, float cell_clip, int64_t num_proj, bool time_major, const char *activation, const char *gate_order, bool reset_after, bool is_training) {
GE_ASSERT_NOTNULL(x_weight_input);
GE_ASSERT_NOTNULL(weight_hidden);
auto &graph = x_weight_input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DynamicGRUV2Hidden")
.Name(("DynamicGRUV2Hidden_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x_weight_input", ge::kIrInputRequired, ""},
{"weight_hidden", ge::kIrInputRequired, ""},
{"bias_hidden", ge::kIrInputOptional, ""},
{"seq_length", ge::kIrInputOptional, ""},
{"init_h", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"output_h", ge::kIrOutputRequired, ""},
{"update", ge::kIrOutputRequired, ""},
{"reset", ge::kIrOutputRequired, ""},
{"new", ge::kIrOutputRequired, ""},
{"hidden_new", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"direction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(direction))
},
{
"cell_depth",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(cell_depth))
},
{
"keep_prob",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(keep_prob))
},
{
"cell_clip",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(cell_clip))
},
{
"num_proj",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_proj))
},
{
"time_major",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(time_major))
},
{
"activation",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(activation))
},
{
"gate_order",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(gate_order))
},
{
"reset_after",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(reset_after))
},
{
"is_training",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_training))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x_weight_input->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight_hidden->GetAnchor(), node->GetInDataAnchor(1)));
if (bias_hidden != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias_hidden->GetAnchor(), node->GetInDataAnchor(2)));
}
if (seq_length != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seq_length->GetAnchor(), node->GetInDataAnchor(3)));
}
if (init_h != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(init_h->GetAnchor(), node->GetInDataAnchor(4)));
}
return EsDynamicGRUV2HiddenOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
graph.GetEsbTensorFromNode(node, 5),
};
}
EsbTensor *EsDynamicLSTM(EsbTensor *x, EsbTensor *w, EsbTensor *b) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(w);
GE_ASSERT_NOTNULL(b);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DynamicLSTM")
.Name(("DynamicLSTM_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"w", ge::kIrInputRequired, ""},
{"b", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_h", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(w->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(b->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsDynamicLSTMV2Output EsDynamicLSTMV2(EsbTensor *x, EsbTensor *w, EsbTensor *b, EsbTensor *cont, EsbTensor *w_xc_x_static, EsbTensor *h0, EsbTensor *c0, EsbTensor *wci, EsbTensor *wcf, EsbTensor *wco, EsbTensor *mask, int64_t num_output, bool expose_hidden, bool need_output_last, float forget_bias) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(w);
GE_ASSERT_NOTNULL(b);
GE_ASSERT_NOTNULL(cont);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DynamicLSTMV2")
.Name(("DynamicLSTMV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"w", ge::kIrInputRequired, ""},
{"b", ge::kIrInputRequired, ""},
{"cont", ge::kIrInputRequired, ""},
{"w_xc_x_static", ge::kIrInputOptional, ""},
{"h0", ge::kIrInputOptional, ""},
{"c0", ge::kIrInputOptional, ""},
{"wci", ge::kIrInputOptional, ""},
{"wcf", ge::kIrInputOptional, ""},
{"wco", ge::kIrInputOptional, ""},
{"mask", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"output_h", ge::kIrOutputRequired, ""},
{"output_c", ge::kIrOutputRequired, ""},
{"last_output_h", ge::kIrOutputRequired, ""},
{"last_output_c", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_output",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_output))
},
{
"expose_hidden",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(expose_hidden))
},
{
"need_output_last",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(need_output_last))
},
{
"forget_bias",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(forget_bias))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(w->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(b->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(cont->GetAnchor(), node->GetInDataAnchor(3)));
if (w_xc_x_static != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(w_xc_x_static->GetAnchor(), node->GetInDataAnchor(4)));
}
if (h0 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(h0->GetAnchor(), node->GetInDataAnchor(5)));
}
if (c0 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(c0->GetAnchor(), node->GetInDataAnchor(6)));
}
if (wci != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(wci->GetAnchor(), node->GetInDataAnchor(7)));
}
if (wcf != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(wcf->GetAnchor(), node->GetInDataAnchor(8)));
}
if (wco != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(wco->GetAnchor(), node->GetInDataAnchor(9)));
}
if (mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mask->GetAnchor(), node->GetInDataAnchor(10)));
}
return EsDynamicLSTMV2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
};
}
EsDynamicQuantOutput EsDynamicQuant(EsbTensor *x, EsbTensor *smooth_scales, EsbTensor *group_index, int64_t dst_type) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DynamicQuant")
.Name(("DynamicQuant_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"smooth_scales", ge::kIrInputOptional, ""},
{"group_index", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"scale", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dst_type",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dst_type))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
if (smooth_scales != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(smooth_scales->GetAnchor(), node->GetInDataAnchor(1)));
}
if (group_index != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(group_index->GetAnchor(), node->GetInDataAnchor(2)));
}
return EsDynamicQuantOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsDynamicQuantUpdateScatterOutput EsDynamicQuantUpdateScatter(EsbTensor *var, EsbTensor *var_scale, EsbTensor *indices, EsbTensor *updates, EsbTensor *smooth_scales, const char *reduce, int64_t axis) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(var_scale);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(updates);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DynamicQuantUpdateScatter")
.Name(("DynamicQuantUpdateScatter_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"var_scale", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"updates", ge::kIrInputRequired, ""},
{"smooth_scales", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"var_scale", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"reduce",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduce))
},
{
"axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var_scale->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(updates->GetAnchor(), node->GetInDataAnchor(3)));
if (smooth_scales != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(smooth_scales->GetAnchor(), node->GetInDataAnchor(4)));
}
return EsDynamicQuantUpdateScatterOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsDynamicQuantV2Output EsDynamicQuantV2(EsbTensor *x, EsbTensor *smooth_scales, EsbTensor *group_index, int64_t dst_type) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DynamicQuantV2")
.Name(("DynamicQuantV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"smooth_scales", ge::kIrInputOptional, ""},
{"group_index", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"scale", ge::kIrOutputRequired, ""},
{"offset", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dst_type",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dst_type))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
if (smooth_scales != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(smooth_scales->GetAnchor(), node->GetInDataAnchor(1)));
}
if (group_index != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(group_index->GetAnchor(), node->GetInDataAnchor(2)));
}
return EsDynamicQuantV2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsDynamicRNNOutput EsDynamicRNN(EsbTensor *x, EsbTensor *w, EsbTensor *b, EsbTensor *seq_length, EsbTensor *init_h, EsbTensor *init_c, EsbTensor *wci, EsbTensor *wcf, EsbTensor *wco, EsbTensor *mask, const char *cell_type, const char *direction, int64_t cell_depth, bool use_peephole, float keep_prob, float cell_clip, int64_t num_proj, bool time_major, const char *activation, float forget_bias, const char *gate_order, bool is_training) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(w);
GE_ASSERT_NOTNULL(b);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DynamicRNN")
.Name(("DynamicRNN_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"w", ge::kIrInputRequired, ""},
{"b", ge::kIrInputRequired, ""},
{"seq_length", ge::kIrInputOptional, ""},
{"init_h", ge::kIrInputOptional, ""},
{"init_c", ge::kIrInputOptional, ""},
{"wci", ge::kIrInputOptional, ""},
{"wcf", ge::kIrInputOptional, ""},
{"wco", ge::kIrInputOptional, ""},
{"mask", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"output_h", ge::kIrOutputRequired, ""},
{"output_c", ge::kIrOutputRequired, ""},
{"i", ge::kIrOutputRequired, ""},
{"j", ge::kIrOutputRequired, ""},
{"f", ge::kIrOutputRequired, ""},
{"o", ge::kIrOutputRequired, ""},
{"tanhc", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"cell_type",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(cell_type))
},
{
"direction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(direction))
},
{
"cell_depth",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(cell_depth))
},
{
"use_peephole",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_peephole))
},
{
"keep_prob",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(keep_prob))
},
{
"cell_clip",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(cell_clip))
},
{
"num_proj",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_proj))
},
{
"time_major",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(time_major))
},
{
"activation",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(activation))
},
{
"forget_bias",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(forget_bias))
},
{
"gate_order",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(gate_order))
},
{
"is_training",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_training))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(w->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(b->GetAnchor(), node->GetInDataAnchor(2)));
if (seq_length != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seq_length->GetAnchor(), node->GetInDataAnchor(3)));
}
if (init_h != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(init_h->GetAnchor(), node->GetInDataAnchor(4)));
}
if (init_c != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(init_c->GetAnchor(), node->GetInDataAnchor(5)));
}
if (wci != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(wci->GetAnchor(), node->GetInDataAnchor(6)));
}
if (wcf != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(wcf->GetAnchor(), node->GetInDataAnchor(7)));
}
if (wco != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(wco->GetAnchor(), node->GetInDataAnchor(8)));
}
if (mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mask->GetAnchor(), node->GetInDataAnchor(9)));
}
return EsDynamicRNNOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
graph.GetEsbTensorFromNode(node, 5),
graph.GetEsbTensorFromNode(node, 6),
graph.GetEsbTensorFromNode(node, 7),
};
}
EsDynamicRNNV2Output EsDynamicRNNV2(EsbTensor *x, EsbTensor *weight_input, EsbTensor *weight_hidden, EsbTensor *b, EsbTensor *seq_length, EsbTensor *init_h, EsbTensor *init_c, EsbTensor *wci, EsbTensor *wcf, EsbTensor *wco, EsbTensor *mask, const char *cell_type, const char *direction, int64_t cell_depth, bool use_peephole, float keep_prob, float cell_clip, int64_t num_proj, bool time_major, const char *activation, const char *recurrent_activation, float forget_bias, const char *gate_order, bool stateful, const char *merge_mode, bool is_training) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(weight_input);
GE_ASSERT_NOTNULL(weight_hidden);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DynamicRNNV2")
.Name(("DynamicRNNV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"weight_input", ge::kIrInputRequired, ""},
{"weight_hidden", ge::kIrInputRequired, ""},
{"b", ge::kIrInputOptional, ""},
{"seq_length", ge::kIrInputOptional, ""},
{"init_h", ge::kIrInputOptional, ""},
{"init_c", ge::kIrInputOptional, ""},
{"wci", ge::kIrInputOptional, ""},
{"wcf", ge::kIrInputOptional, ""},
{"wco", ge::kIrInputOptional, ""},
{"mask", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"output_h", ge::kIrOutputRequired, ""},
{"output_c", ge::kIrOutputRequired, ""},
{"i", ge::kIrOutputRequired, ""},
{"j", ge::kIrOutputRequired, ""},
{"f", ge::kIrOutputRequired, ""},
{"o", ge::kIrOutputRequired, ""},
{"tanhc", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"cell_type",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(cell_type))
},
{
"direction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(direction))
},
{
"cell_depth",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(cell_depth))
},
{
"use_peephole",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_peephole))
},
{
"keep_prob",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(keep_prob))
},
{
"cell_clip",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(cell_clip))
},
{
"num_proj",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_proj))
},
{
"time_major",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(time_major))
},
{
"activation",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(activation))
},
{
"recurrent_activation",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(recurrent_activation))
},
{
"forget_bias",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(forget_bias))
},
{
"gate_order",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(gate_order))
},
{
"stateful",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(stateful))
},
{
"merge_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(merge_mode))
},
{
"is_training",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_training))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight_input->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight_hidden->GetAnchor(), node->GetInDataAnchor(2)));
if (b != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(b->GetAnchor(), node->GetInDataAnchor(3)));
}
if (seq_length != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seq_length->GetAnchor(), node->GetInDataAnchor(4)));
}
if (init_h != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(init_h->GetAnchor(), node->GetInDataAnchor(5)));
}
if (init_c != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(init_c->GetAnchor(), node->GetInDataAnchor(6)));
}
if (wci != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(wci->GetAnchor(), node->GetInDataAnchor(7)));
}
if (wcf != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(wcf->GetAnchor(), node->GetInDataAnchor(8)));
}
if (wco != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(wco->GetAnchor(), node->GetInDataAnchor(9)));
}
if (mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mask->GetAnchor(), node->GetInDataAnchor(10)));
}
return EsDynamicRNNV2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
graph.GetEsbTensorFromNode(node, 5),
graph.GetEsbTensorFromNode(node, 6),
graph.GetEsbTensorFromNode(node, 7),
};
}
EsDynamicRNNV3Output EsDynamicRNNV3(EsbTensor *x, EsbTensor *w, EsbTensor *b, EsbTensor *seq_length, EsbTensor *init_h, EsbTensor *init_c, EsbTensor *wci, EsbTensor *wcf, EsbTensor *wco, EsbTensor *mask, EsbTensor *real_mask, EsbTensor *project, const char *cell_type, const char *direction, int64_t cell_depth, bool use_peephole, float keep_prob, float cell_clip, int64_t num_proj, bool time_major, const char *activation, float forget_bias, bool is_training) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(w);
GE_ASSERT_NOTNULL(b);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DynamicRNNV3")
.Name(("DynamicRNNV3_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"w", ge::kIrInputRequired, ""},
{"b", ge::kIrInputRequired, ""},
{"seq_length", ge::kIrInputOptional, ""},
{"init_h", ge::kIrInputOptional, ""},
{"init_c", ge::kIrInputOptional, ""},
{"wci", ge::kIrInputOptional, ""},
{"wcf", ge::kIrInputOptional, ""},
{"wco", ge::kIrInputOptional, ""},
{"mask", ge::kIrInputOptional, ""},
{"real_mask", ge::kIrInputOptional, ""},
{"project", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"output_h", ge::kIrOutputRequired, ""},
{"output_c", ge::kIrOutputRequired, ""},
{"i", ge::kIrOutputRequired, ""},
{"j", ge::kIrOutputRequired, ""},
{"f", ge::kIrOutputRequired, ""},
{"o", ge::kIrOutputRequired, ""},
{"tanhc", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"cell_type",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(cell_type))
},
{
"direction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(direction))
},
{
"cell_depth",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(cell_depth))
},
{
"use_peephole",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_peephole))
},
{
"keep_prob",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(keep_prob))
},
{
"cell_clip",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(cell_clip))
},
{
"num_proj",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_proj))
},
{
"time_major",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(time_major))
},
{
"activation",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(activation))
},
{
"forget_bias",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(forget_bias))
},
{
"is_training",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_training))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(w->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(b->GetAnchor(), node->GetInDataAnchor(2)));
if (seq_length != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seq_length->GetAnchor(), node->GetInDataAnchor(3)));
}
if (init_h != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(init_h->GetAnchor(), node->GetInDataAnchor(4)));
}
if (init_c != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(init_c->GetAnchor(), node->GetInDataAnchor(5)));
}
if (wci != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(wci->GetAnchor(), node->GetInDataAnchor(6)));
}
if (wcf != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(wcf->GetAnchor(), node->GetInDataAnchor(7)));
}
if (wco != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(wco->GetAnchor(), node->GetInDataAnchor(8)));
}
if (mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mask->GetAnchor(), node->GetInDataAnchor(9)));
}
if (real_mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(real_mask->GetAnchor(), node->GetInDataAnchor(10)));
}
if (project != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(project->GetAnchor(), node->GetInDataAnchor(11)));
}
return EsDynamicRNNV3Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
graph.GetEsbTensorFromNode(node, 5),
graph.GetEsbTensorFromNode(node, 6),
graph.GetEsbTensorFromNode(node, 7),
};
}
EsbTensor *EsDynamicStitch(EsbTensor **indices, int64_t indices_num, EsbTensor **x, int64_t x_num, int64_t N) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(indices_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < indices_num; ++i) {
if (indices[i] != nullptr) {
non_null_in = indices[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("DynamicStitch")
.Name(("DynamicStitch_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"indices", ge::kIrInputDynamic, ""},
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"N",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(N))
},
})
.InstanceDynamicInputNum("indices", static_cast<int32_t>(indices_num))
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((indices != nullptr) && (indices_num > 0)) {
for (int64_t i = 0; i < indices_num; ++i) {
auto one_indices = indices[i];
GE_ASSERT_NOTNULL(one_indices);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_indices->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + indices_num + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsEditDistance(EsbTensor *hypothesis_indices, EsbTensor *hypothesis_values, EsbTensor *hypothesis_shape, EsbTensor *truth_indices, EsbTensor *truth_values, EsbTensor *truth_shape, bool normalize) {
GE_ASSERT_NOTNULL(hypothesis_indices);
GE_ASSERT_NOTNULL(hypothesis_values);
GE_ASSERT_NOTNULL(hypothesis_shape);
GE_ASSERT_NOTNULL(truth_indices);
GE_ASSERT_NOTNULL(truth_values);
GE_ASSERT_NOTNULL(truth_shape);
auto &graph = hypothesis_indices->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("EditDistance")
.Name(("EditDistance_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"hypothesis_indices", ge::kIrInputRequired, ""},
{"hypothesis_values", ge::kIrInputRequired, ""},
{"hypothesis_shape", ge::kIrInputRequired, ""},
{"truth_indices", ge::kIrInputRequired, ""},
{"truth_values", ge::kIrInputRequired, ""},
{"truth_shape", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"normalize",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(normalize))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(hypothesis_indices->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(hypothesis_values->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(hypothesis_shape->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(truth_indices->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(truth_values->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(truth_shape->GetAnchor(), node->GetInDataAnchor(5)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsEinsum(EsbTensor **x, int64_t x_num, const char *equation, int64_t N) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Einsum")
.Name(("Einsum_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"equation",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(equation))
},
{
"N",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(N))
},
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsEltwise(EsbTensor **x, int64_t x_num, int64_t N, int64_t mode, const float *coeff, int64_t coeff_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Eltwise")
.Name(("Eltwise_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"N",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(N))
},
{
"mode",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(mode))
},
{
"coeff",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(coeff, coeff + coeff_num))
},
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsElu(EsbTensor *x, float alpha, float scale, float input_scale) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Elu")
.Name(("Elu_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"alpha",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(alpha))
},
{
"scale",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(scale))
},
{
"input_scale",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(input_scale))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsEluGrad(EsbTensor *grads, EsbTensor *activations) {
GE_ASSERT_NOTNULL(grads);
GE_ASSERT_NOTNULL(activations);
auto &graph = grads->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("EluGrad")
.Name(("EluGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grads", ge::kIrInputRequired, ""},
{"activations", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grads->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(activations->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsEluGradV2(EsbTensor *grads, EsbTensor *activations, float alpha, float scale, float input_scale, bool is_result) {
GE_ASSERT_NOTNULL(grads);
GE_ASSERT_NOTNULL(activations);
auto &graph = grads->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("EluGradV2")
.Name(("EluGradV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grads", ge::kIrInputRequired, ""},
{"activations", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"alpha",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(alpha))
},
{
"scale",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(scale))
},
{
"input_scale",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(input_scale))
},
{
"is_result",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_result))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grads->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(activations->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsEmbeddingApplyAdaGrad(EsbTensor *var_handle, EsbTensor *lr, EsbTensor *grad, EsbTensor *keys, EsbTensor *global_step, const int64_t *embedding_dim, int64_t embedding_dim_num, const int64_t *mask_zero, int64_t mask_zero_num, const int64_t *padding_key, int64_t padding_key_num, const int64_t *padding_key_mask, int64_t padding_key_mask_num, const int64_t *completion_key, int64_t completion_key_num, const int64_t *completion_key_mask, int64_t completion_key_mask_num) {
GE_ASSERT_NOTNULL(var_handle);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(keys);
GE_ASSERT_NOTNULL(global_step);
auto &graph = var_handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("EmbeddingApplyAdaGrad")
.Name(("EmbeddingApplyAdaGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var_handle", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"keys", ge::kIrInputRequired, ""},
{"global_step", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var_handle", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"embedding_dim",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(embedding_dim, embedding_dim + embedding_dim_num))
},
{
"mask_zero",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(mask_zero, mask_zero + mask_zero_num))
},
{
"padding_key",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(padding_key, padding_key + padding_key_num))
},
{
"padding_key_mask",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(padding_key_mask, padding_key_mask + padding_key_mask_num))
},
{
"completion_key",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(completion_key, completion_key + completion_key_num))
},
{
"completion_key_mask",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(completion_key_mask, completion_key_mask + completion_key_mask_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var_handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(keys->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(global_step->GetAnchor(), node->GetInDataAnchor(4)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsEmbeddingApplyAdam(EsbTensor *var_handle, EsbTensor *beta1_power, EsbTensor *beta2_power, EsbTensor *lr, EsbTensor *beta1, EsbTensor *beta2, EsbTensor *epsilon, EsbTensor *grad, EsbTensor *keys, EsbTensor *global_step, const int64_t *embedding_dim, int64_t embedding_dim_num, const int64_t *mask_zero, int64_t mask_zero_num, const int64_t *padding_key, int64_t padding_key_num, const int64_t *padding_key_mask, int64_t padding_key_mask_num, const int64_t *completion_key, int64_t completion_key_num, const int64_t *completion_key_mask, int64_t completion_key_mask_num) {
GE_ASSERT_NOTNULL(var_handle);
GE_ASSERT_NOTNULL(beta1_power);
GE_ASSERT_NOTNULL(beta2_power);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(beta1);
GE_ASSERT_NOTNULL(beta2);
GE_ASSERT_NOTNULL(epsilon);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(keys);
GE_ASSERT_NOTNULL(global_step);
auto &graph = var_handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("EmbeddingApplyAdam")
.Name(("EmbeddingApplyAdam_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var_handle", ge::kIrInputRequired, ""},
{"beta1_power", ge::kIrInputRequired, ""},
{"beta2_power", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"beta1", ge::kIrInputRequired, ""},
{"beta2", ge::kIrInputRequired, ""},
{"epsilon", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"keys", ge::kIrInputRequired, ""},
{"global_step", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var_handle", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"embedding_dim",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(embedding_dim, embedding_dim + embedding_dim_num))
},
{
"mask_zero",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(mask_zero, mask_zero + mask_zero_num))
},
{
"padding_key",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(padding_key, padding_key + padding_key_num))
},
{
"padding_key_mask",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(padding_key_mask, padding_key_mask + padding_key_mask_num))
},
{
"completion_key",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(completion_key, completion_key + completion_key_num))
},
{
"completion_key_mask",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(completion_key_mask, completion_key_mask + completion_key_mask_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var_handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta1_power->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta2_power->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta1->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta2->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(epsilon->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(7)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(keys->GetAnchor(), node->GetInDataAnchor(8)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(global_step->GetAnchor(), node->GetInDataAnchor(9)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsEmbeddingApplyAdamW(EsbTensor *var_handle, EsbTensor *beta1_power, EsbTensor *beta2_power, EsbTensor *lr, EsbTensor *weight_decay, EsbTensor *beta1, EsbTensor *beta2, EsbTensor *epsilon, EsbTensor *grad, EsbTensor *keys, EsbTensor *max_grad_norm, EsbTensor *global_step, const int64_t *embedding_dim, int64_t embedding_dim_num, const int64_t *amsgrad, int64_t amsgrad_num, const int64_t *maximize, int64_t maximize_num, const int64_t *mask_zero, int64_t mask_zero_num, const int64_t *padding_key, int64_t padding_key_num, const int64_t *padding_key_mask, int64_t padding_key_mask_num, const int64_t *completion_key, int64_t completion_key_num, const int64_t *completion_key_mask, int64_t completion_key_mask_num) {
GE_ASSERT_NOTNULL(var_handle);
GE_ASSERT_NOTNULL(beta1_power);
GE_ASSERT_NOTNULL(beta2_power);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(weight_decay);
GE_ASSERT_NOTNULL(beta1);
GE_ASSERT_NOTNULL(beta2);
GE_ASSERT_NOTNULL(epsilon);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(keys);
auto &graph = var_handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("EmbeddingApplyAdamW")
.Name(("EmbeddingApplyAdamW_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var_handle", ge::kIrInputRequired, ""},
{"beta1_power", ge::kIrInputRequired, ""},
{"beta2_power", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"weight_decay", ge::kIrInputRequired, ""},
{"beta1", ge::kIrInputRequired, ""},
{"beta2", ge::kIrInputRequired, ""},
{"epsilon", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"keys", ge::kIrInputRequired, ""},
{"max_grad_norm", ge::kIrInputOptional, ""},
{"global_step", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"var_handle", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"embedding_dim",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(embedding_dim, embedding_dim + embedding_dim_num))
},
{
"amsgrad",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(amsgrad, amsgrad + amsgrad_num))
},
{
"maximize",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(maximize, maximize + maximize_num))
},
{
"mask_zero",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(mask_zero, mask_zero + mask_zero_num))
},
{
"padding_key",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(padding_key, padding_key + padding_key_num))
},
{
"padding_key_mask",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(padding_key_mask, padding_key_mask + padding_key_mask_num))
},
{
"completion_key",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(completion_key, completion_key + completion_key_num))
},
{
"completion_key_mask",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(completion_key_mask, completion_key_mask + completion_key_mask_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var_handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta1_power->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta2_power->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight_decay->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta1->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta2->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(epsilon->GetAnchor(), node->GetInDataAnchor(7)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(8)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(keys->GetAnchor(), node->GetInDataAnchor(9)));
if (max_grad_norm != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(max_grad_norm->GetAnchor(), node->GetInDataAnchor(10)));
}
if (global_step != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(global_step->GetAnchor(), node->GetInDataAnchor(11)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsEmbeddingApplyFtrl(EsbTensor *var_handle, EsbTensor *lr, EsbTensor *lr_power, EsbTensor *lambda1, EsbTensor *lambda2, EsbTensor *grad, EsbTensor *keys, EsbTensor *global_step, const int64_t *embedding_dim, int64_t embedding_dim_num, const int64_t *mask_zero, int64_t mask_zero_num, const int64_t *padding_key, int64_t padding_key_num, const int64_t *padding_key_mask, int64_t padding_key_mask_num, const int64_t *completion_key, int64_t completion_key_num, const int64_t *completion_key_mask, int64_t completion_key_mask_num) {
GE_ASSERT_NOTNULL(var_handle);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(lr_power);
GE_ASSERT_NOTNULL(lambda1);
GE_ASSERT_NOTNULL(lambda2);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(keys);
auto &graph = var_handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("EmbeddingApplyFtrl")
.Name(("EmbeddingApplyFtrl_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var_handle", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"lr_power", ge::kIrInputRequired, ""},
{"lambda1", ge::kIrInputRequired, ""},
{"lambda2", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"keys", ge::kIrInputRequired, ""},
{"global_step", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"var_handle", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"embedding_dim",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(embedding_dim, embedding_dim + embedding_dim_num))
},
{
"mask_zero",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(mask_zero, mask_zero + mask_zero_num))
},
{
"padding_key",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(padding_key, padding_key + padding_key_num))
},
{
"padding_key_mask",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(padding_key_mask, padding_key_mask + padding_key_mask_num))
},
{
"completion_key",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(completion_key, completion_key + completion_key_num))
},
{
"completion_key_mask",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(completion_key_mask, completion_key_mask + completion_key_mask_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var_handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr_power->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lambda1->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lambda2->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(keys->GetAnchor(), node->GetInDataAnchor(6)));
if (global_step != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(global_step->GetAnchor(), node->GetInDataAnchor(7)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsEmbeddingApplyRmsprop(EsbTensor *var_handle, EsbTensor *lr, EsbTensor *rho, EsbTensor *momentum, EsbTensor *epsilon, EsbTensor *grad, EsbTensor *keys, EsbTensor *global_step, const int64_t *embedding_dim, int64_t embedding_dim_num, const int64_t *mask_zero, int64_t mask_zero_num, const int64_t *padding_key, int64_t padding_key_num, const int64_t *padding_key_mask, int64_t padding_key_mask_num, const int64_t *completion_key, int64_t completion_key_num, const int64_t *completion_key_mask, int64_t completion_key_mask_num) {
GE_ASSERT_NOTNULL(var_handle);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(rho);
GE_ASSERT_NOTNULL(momentum);
GE_ASSERT_NOTNULL(epsilon);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(keys);
auto &graph = var_handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("EmbeddingApplyRmsprop")
.Name(("EmbeddingApplyRmsprop_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var_handle", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"rho", ge::kIrInputRequired, ""},
{"momentum", ge::kIrInputRequired, ""},
{"epsilon", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"keys", ge::kIrInputRequired, ""},
{"global_step", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"var_handle", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"embedding_dim",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(embedding_dim, embedding_dim + embedding_dim_num))
},
{
"mask_zero",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(mask_zero, mask_zero + mask_zero_num))
},
{
"padding_key",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(padding_key, padding_key + padding_key_num))
},
{
"padding_key_mask",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(padding_key_mask, padding_key_mask + padding_key_mask_num))
},
{
"completion_key",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(completion_key, completion_key + completion_key_num))
},
{
"completion_key_mask",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(completion_key_mask, completion_key_mask + completion_key_mask_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var_handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rho->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(momentum->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(epsilon->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(keys->GetAnchor(), node->GetInDataAnchor(6)));
if (global_step != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(global_step->GetAnchor(), node->GetInDataAnchor(7)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsEmbeddingApplySgd(EsbTensor *var_handle, EsbTensor *lr, EsbTensor *grad, EsbTensor *keys, EsbTensor *global_step, const int64_t *embedding_dim, int64_t embedding_dim_num, const int64_t *mask_zero, int64_t mask_zero_num, const int64_t *padding_key, int64_t padding_key_num, const int64_t *padding_key_mask, int64_t padding_key_mask_num, const int64_t *completion_key, int64_t completion_key_num, const int64_t *completion_key_mask, int64_t completion_key_mask_num) {
GE_ASSERT_NOTNULL(var_handle);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(keys);
auto &graph = var_handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("EmbeddingApplySgd")
.Name(("EmbeddingApplySgd_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var_handle", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"keys", ge::kIrInputRequired, ""},
{"global_step", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"var_handle", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"embedding_dim",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(embedding_dim, embedding_dim + embedding_dim_num))
},
{
"mask_zero",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(mask_zero, mask_zero + mask_zero_num))
},
{
"padding_key",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(padding_key, padding_key + padding_key_num))
},
{
"padding_key_mask",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(padding_key_mask, padding_key_mask + padding_key_mask_num))
},
{
"completion_key",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(completion_key, completion_key + completion_key_num))
},
{
"completion_key_mask",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(completion_key_mask, completion_key_mask + completion_key_mask_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var_handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(keys->GetAnchor(), node->GetInDataAnchor(3)));
if (global_step != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(global_step->GetAnchor(), node->GetInDataAnchor(4)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsEmbeddingBagOutput EsEmbeddingBag(EsbTensor *weight, EsbTensor *indices, EsbTensor *offsets, EsbTensor *per_sample_weights, const char *mode, bool scale_grad_by_freq, bool sparse, bool include_last_offset, int64_t padding_idx) {
GE_ASSERT_NOTNULL(weight);
GE_ASSERT_NOTNULL(indices);
auto &graph = weight->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("EmbeddingBag")
.Name(("EmbeddingBag_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"weight", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"offsets", ge::kIrInputOptional, ""},
{"per_sample_weights", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"offset2bag", ge::kIrOutputRequired, ""},
{"bag_size", ge::kIrOutputRequired, ""},
{"max_indices", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(mode))
},
{
"scale_grad_by_freq",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(scale_grad_by_freq))
},
{
"sparse",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(sparse))
},
{
"include_last_offset",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(include_last_offset))
},
{
"padding_idx",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(padding_idx))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
if (offsets != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offsets->GetAnchor(), node->GetInDataAnchor(2)));
}
if (per_sample_weights != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(per_sample_weights->GetAnchor(), node->GetInDataAnchor(3)));
}
return EsEmbeddingBagOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsbTensor *EsEmbeddingDenseGrad(EsbTensor *grad, EsbTensor *indices, int64_t num_weights, int64_t padding_idx, bool scale_grad_by_freq) {
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(indices);
auto &graph = grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("EmbeddingDenseGrad")
.Name(("EmbeddingDenseGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grad", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_weights",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_weights))
},
{
"padding_idx",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(padding_idx))
},
{
"scale_grad_by_freq",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(scale_grad_by_freq))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsEmbeddingDenseGradV2(EsbTensor *grad, EsbTensor *sort_indices, EsbTensor *pos_idx, int64_t num_weights, int64_t padding_idx, bool scale_grad_by_freq) {
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(sort_indices);
GE_ASSERT_NOTNULL(pos_idx);
auto &graph = grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("EmbeddingDenseGradV2")
.Name(("EmbeddingDenseGradV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grad", ge::kIrInputRequired, ""},
{"sort_indices", ge::kIrInputRequired, ""},
{"pos_idx", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_weights",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_weights))
},
{
"padding_idx",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(padding_idx))
},
{
"scale_grad_by_freq",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(scale_grad_by_freq))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sort_indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(pos_idx->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsEmbeddingFeatureMapping(EsbTensor *feature_id) {
GE_ASSERT_NOTNULL(feature_id);
auto &graph = feature_id->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("EmbeddingFeatureMapping")
.Name(("EmbeddingFeatureMapping_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"feature_id", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"offset_id", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(feature_id->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsEmbeddingFeatureMappingExport(EsbTensor *file_path, EsbTensor *table_name, EsbTensor *global_step, EsbTensor *values, EsbTensor **feature_id, int64_t feature_id_num, EsbTensor **offset_id, int64_t offset_id_num, const int64_t *embedding_dim, int64_t embedding_dim_num) {
GE_ASSERT_NOTNULL(file_path);
GE_ASSERT_NOTNULL(table_name);
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(feature_id_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(offset_id_num));
auto &graph = file_path->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("EmbeddingFeatureMappingExport")
.Name(("EmbeddingFeatureMappingExport_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"file_path", ge::kIrInputRequired, ""},
{"table_name", ge::kIrInputRequired, ""},
{"global_step", ge::kIrInputOptional, ""},
{"values", ge::kIrInputOptional, ""},
{"feature_id", ge::kIrInputDynamic, ""},
{"offset_id", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
{
"embedding_dim",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(embedding_dim, embedding_dim + embedding_dim_num))
},
})
.InstanceDynamicInputNum("feature_id", static_cast<int32_t>(feature_id_num))
.InstanceDynamicInputNum("offset_id", static_cast<int32_t>(offset_id_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(file_path->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(table_name->GetAnchor(), node->GetInDataAnchor(1)));
if (global_step != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(global_step->GetAnchor(), node->GetInDataAnchor(2)));
}
if (values != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(values->GetAnchor(), node->GetInDataAnchor(3)));
}
if ((feature_id != nullptr) && (feature_id_num > 0)) {
for (int64_t i = 0; i < feature_id_num; ++i) {
auto one_feature_id = feature_id[i];
GE_ASSERT_NOTNULL(one_feature_id);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_feature_id->GetAnchor(), node->GetInDataAnchor(4 + i)));
}
}
if ((offset_id != nullptr) && (offset_id_num > 0)) {
for (int64_t i = 0; i < offset_id_num; ++i) {
auto one_offset_id = offset_id[i];
GE_ASSERT_NOTNULL(one_offset_id);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_offset_id->GetAnchor(), node->GetInDataAnchor(4 + feature_id_num + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsEmbeddingFeatureMappingFileSize(EsbTensor *file_path, EsbTensor *table_name, EsbTensor *global_step, const int64_t *embedding_dim, int64_t embedding_dim_num, bool only_offset_flag) {
GE_ASSERT_NOTNULL(file_path);
GE_ASSERT_NOTNULL(table_name);
auto &graph = file_path->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("EmbeddingFeatureMappingFileSize")
.Name(("EmbeddingFeatureMappingFileSize_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"file_path", ge::kIrInputRequired, ""},
{"table_name", ge::kIrInputRequired, ""},
{"global_step", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"feature_size", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"embedding_dim",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(embedding_dim, embedding_dim + embedding_dim_num))
},
{
"only_offset_flag",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(only_offset_flag))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(file_path->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(table_name->GetAnchor(), node->GetInDataAnchor(1)));
if (global_step != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(global_step->GetAnchor(), node->GetInDataAnchor(2)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsEmbeddingFeatureMappingInsert(EsbTensor *table_name, EsbTensor **feature_id, int64_t feature_id_num, EsbTensor **offset_id, int64_t offset_id_num) {
GE_ASSERT_NOTNULL(table_name);
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(feature_id_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(offset_id_num));
auto &graph = table_name->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("EmbeddingFeatureMappingInsert")
.Name(("EmbeddingFeatureMappingInsert_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"table_name", ge::kIrInputRequired, ""},
{"feature_id", ge::kIrInputDynamic, ""},
{"offset_id", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("feature_id", static_cast<int32_t>(feature_id_num))
.InstanceDynamicInputNum("offset_id", static_cast<int32_t>(offset_id_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(table_name->GetAnchor(), node->GetInDataAnchor(0)));
if ((feature_id != nullptr) && (feature_id_num > 0)) {
for (int64_t i = 0; i < feature_id_num; ++i) {
auto one_feature_id = feature_id[i];
GE_ASSERT_NOTNULL(one_feature_id);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_feature_id->GetAnchor(), node->GetInDataAnchor(1 + i)));
}
}
if ((offset_id != nullptr) && (offset_id_num > 0)) {
for (int64_t i = 0; i < offset_id_num; ++i) {
auto one_offset_id = offset_id[i];
GE_ASSERT_NOTNULL(one_offset_id);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_offset_id->GetAnchor(), node->GetInDataAnchor(1 + feature_id_num + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsEmbeddingFeatureMappingTableSize(EsbTensor *table_name) {
GE_ASSERT_NOTNULL(table_name);
auto &graph = table_name->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("EmbeddingFeatureMappingTableSize")
.Name(("EmbeddingFeatureMappingTableSize_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"table_name", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"feature_size", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(table_name->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsEmbeddingFeatureMappingV2(EsbTensor *table_name, EsbTensor *feature_id, const int64_t *table_total_size, int64_t table_total_size_num, const int64_t *table_actual_size, int64_t table_actual_size_num) {
GE_ASSERT_NOTNULL(table_name);
GE_ASSERT_NOTNULL(feature_id);
auto &graph = table_name->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("EmbeddingFeatureMappingV2")
.Name(("EmbeddingFeatureMappingV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"table_name", ge::kIrInputRequired, ""},
{"feature_id", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"offset_id", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"table_total_size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(table_total_size, table_total_size + table_total_size_num))
},
{
"table_actual_size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(table_actual_size, table_actual_size + table_actual_size_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(table_name->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(feature_id->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsEmbeddingHashmapExport(EsbTensor *file_path, EsbTensor *table_ids, EsbTensor *table_names, EsbTensor *global_step, EsbTensor **keys, int64_t keys_num, EsbTensor **counters, int64_t counters_num, EsbTensor **filter_flags, int64_t filter_flags_num, EsbTensor **values, int64_t values_num) {
GE_ASSERT_NOTNULL(file_path);
GE_ASSERT_NOTNULL(table_ids);
GE_ASSERT_NOTNULL(table_names);
GE_ASSERT_NOTNULL(global_step);
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(keys_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(counters_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(filter_flags_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(values_num));
auto &graph = file_path->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("EmbeddingHashmapExport")
.Name(("EmbeddingHashmapExport_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"file_path", ge::kIrInputRequired, ""},
{"table_ids", ge::kIrInputRequired, ""},
{"table_names", ge::kIrInputRequired, ""},
{"global_step", ge::kIrInputRequired, ""},
{"keys", ge::kIrInputDynamic, ""},
{"counters", ge::kIrInputDynamic, ""},
{"filter_flags", ge::kIrInputDynamic, ""},
{"values", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("keys", static_cast<int32_t>(keys_num))
.InstanceDynamicInputNum("counters", static_cast<int32_t>(counters_num))
.InstanceDynamicInputNum("filter_flags", static_cast<int32_t>(filter_flags_num))
.InstanceDynamicInputNum("values", static_cast<int32_t>(values_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(file_path->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(table_ids->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(table_names->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(global_step->GetAnchor(), node->GetInDataAnchor(3)));
if ((keys != nullptr) && (keys_num > 0)) {
for (int64_t i = 0; i < keys_num; ++i) {
auto one_keys = keys[i];
GE_ASSERT_NOTNULL(one_keys);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_keys->GetAnchor(), node->GetInDataAnchor(4 + i)));
}
}
if ((counters != nullptr) && (counters_num > 0)) {
for (int64_t i = 0; i < counters_num; ++i) {
auto one_counters = counters[i];
GE_ASSERT_NOTNULL(one_counters);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_counters->GetAnchor(), node->GetInDataAnchor(4 + keys_num + i)));
}
}
if ((filter_flags != nullptr) && (filter_flags_num > 0)) {
for (int64_t i = 0; i < filter_flags_num; ++i) {
auto one_filter_flags = filter_flags[i];
GE_ASSERT_NOTNULL(one_filter_flags);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_filter_flags->GetAnchor(), node->GetInDataAnchor(4 + keys_num + counters_num + i)));
}
}
if ((values != nullptr) && (values_num > 0)) {
for (int64_t i = 0; i < values_num; ++i) {
auto one_values = values[i];
GE_ASSERT_NOTNULL(one_values);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_values->GetAnchor(), node->GetInDataAnchor(4 + keys_num + counters_num + filter_flags_num + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsEmbeddingHashmapFileSize(EsbTensor *file_path, EsbTensor *table_ids, EsbTensor *table_names, EsbTensor *global_step, const int64_t *embedding_dims, int64_t embedding_dims_num) {
GE_ASSERT_NOTNULL(file_path);
GE_ASSERT_NOTNULL(table_ids);
GE_ASSERT_NOTNULL(table_names);
GE_ASSERT_NOTNULL(global_step);
auto &graph = file_path->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("EmbeddingHashmapFileSize")
.Name(("EmbeddingHashmapFileSize_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"file_path", ge::kIrInputRequired, ""},
{"table_ids", ge::kIrInputRequired, ""},
{"table_names", ge::kIrInputRequired, ""},
{"global_step", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"table_sizes", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"embedding_dims",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(embedding_dims, embedding_dims + embedding_dims_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(file_path->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(table_ids->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(table_names->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(global_step->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsEmbeddingHashmapSize(EsbTensor *table_ids, bool filter_export_flag, const char *export_mode) {
GE_ASSERT_NOTNULL(table_ids);
auto &graph = table_ids->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("EmbeddingHashmapSize")
.Name(("EmbeddingHashmapSize_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"table_ids", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"table_sizes", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"filter_export_flag",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(filter_export_flag))
},
{
"export_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(export_mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(table_ids->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsEmbeddingLocalIndexOutput EsEmbeddingLocalIndex(EsbTensor *addr_table, EsbTensor *index, int64_t row_memory, const char *mode) {
GE_ASSERT_NOTNULL(addr_table);
GE_ASSERT_NOTNULL(index);
auto &graph = addr_table->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("EmbeddingLocalIndex")
.Name(("EmbeddingLocalIndex_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"addr_table", ge::kIrInputRequired, ""},
{"index", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"local_idx", ge::kIrOutputRequired, ""},
{"nums", ge::kIrOutputRequired, ""},
{"recover_idx", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"row_memory",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(row_memory))
},
{
"mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(addr_table->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(index->GetAnchor(), node->GetInDataAnchor(1)));
return EsEmbeddingLocalIndexOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsEmbeddingRankId(EsbTensor *addr_table, EsbTensor *index, int64_t row_memory, const char *mode) {
GE_ASSERT_NOTNULL(addr_table);
GE_ASSERT_NOTNULL(index);
auto &graph = addr_table->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("EmbeddingRankId")
.Name(("EmbeddingRankId_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"addr_table", ge::kIrInputRequired, ""},
{"index", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"rank_id", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"row_memory",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(row_memory))
},
{
"mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(addr_table->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(index->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsEmbeddingTableEvict(EsbTensor *var_handle, EsbTensor *global_step, int64_t steps_to_live) {
GE_ASSERT_NOTNULL(var_handle);
auto &graph = var_handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("EmbeddingTableEvict")
.Name(("EmbeddingTableEvict_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var_handle", ge::kIrInputRequired, ""},
{"global_step", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
{
"steps_to_live",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(steps_to_live))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var_handle->GetAnchor(), node->GetInDataAnchor(0)));
if (global_step != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(global_step->GetAnchor(), node->GetInDataAnchor(1)));
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsEmbeddingTableFind(EsbTensor *table_id, EsbTensor *keys, const int64_t *embedding_dim, int64_t embedding_dim_num, const float *default_value, int64_t default_value_num) {
GE_ASSERT_NOTNULL(table_id);
GE_ASSERT_NOTNULL(keys);
auto &graph = table_id->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("EmbeddingTableFind")
.Name(("EmbeddingTableFind_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"table_id", ge::kIrInputRequired, ""},
{"keys", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"values", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"embedding_dim",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(embedding_dim, embedding_dim + embedding_dim_num))
},
{
"default_value",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(default_value, default_value + default_value_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(table_id->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(keys->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsEmpty(EsbTensor *shape, int64_t dtype, bool init) {
GE_ASSERT_NOTNULL(shape);
auto &graph = shape->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Empty")
.Name(("Empty_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"shape", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dtype))
},
{
"init",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(init))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsEmptyTensorList(EsbTensor *element_shape, EsbTensor *max_num_elements, ge::DataType element_dtype) {
GE_ASSERT_NOTNULL(element_shape);
GE_ASSERT_NOTNULL(max_num_elements);
auto &graph = element_shape->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("EmptyTensorList")
.Name(("EmptyTensorList_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"element_shape", ge::kIrInputRequired, ""},
{"max_num_elements", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"handle", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"element_dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(element_dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(element_shape->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(max_num_elements->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsEmptyTensorMap(EsbGraph *owner_graph) {
GE_ASSERT_NOTNULL(owner_graph);
EsbGraph &graph = *owner_graph;

auto desc = ge::CompliantOpDescBuilder().OpType("EmptyTensorMap")
.Name(("EmptyTensorMap_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
})
.IrDefOutputs({
{"handle", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsEncodeBase64(EsbTensor *x, bool pad) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("EncodeBase64")
.Name(("EncodeBase64_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"pad",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(pad))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsEncodeJpeg(EsbTensor *image, const char *format, int64_t quality, bool progressive, bool optimize_size, bool chroma_downsampling, const char *density_unit, int64_t x_density, int64_t y_density, const char *xmp_metadata) {
GE_ASSERT_NOTNULL(image);
auto &graph = image->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("EncodeJpeg")
.Name(("EncodeJpeg_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"image", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"contents", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(format))
},
{
"quality",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(quality))
},
{
"progressive",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(progressive))
},
{
"optimize_size",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(optimize_size))
},
{
"chroma_downsampling",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(chroma_downsampling))
},
{
"density_unit",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(density_unit))
},
{
"x_density",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(x_density))
},
{
"y_density",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(y_density))
},
{
"xmp_metadata",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(xmp_metadata))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(image->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsEncodeJpegVariableQuality(EsbTensor *images, EsbTensor *quality) {
GE_ASSERT_NOTNULL(images);
GE_ASSERT_NOTNULL(quality);
auto &graph = images->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("EncodeJpegVariableQuality")
.Name(("EncodeJpegVariableQuality_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"images", ge::kIrInputRequired, ""},
{"quality", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"contents", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(images->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(quality->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsEncodePng(EsbTensor *image, int64_t compression) {
GE_ASSERT_NOTNULL(image);
auto &graph = image->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("EncodePng")
.Name(("EncodePng_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"image", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"contents", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"compression",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(compression))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(image->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsEncodeWav(EsbTensor *audio, EsbTensor *sample_rate) {
GE_ASSERT_NOTNULL(audio);
GE_ASSERT_NOTNULL(sample_rate);
auto &graph = audio->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("EncodeWav")
.Name(("EncodeWav_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"audio", ge::kIrInputRequired, ""},
{"sample_rate", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"contents", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(audio->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sample_rate->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsEnd(EsbTensor *x, int64_t peerIndex, const char *parentOpType) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("End")
.Name(("End_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"peerIndex",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(peerIndex))
},
{
"parentOpType",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(parentOpType))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsEndOfSequence(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("EndOfSequence")
.Name(("EndOfSequence_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsEnsureShape(EsbTensor *input, const int64_t *shape, int64_t shape_num) {
GE_ASSERT_NOTNULL(input);
auto &graph = input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("EnsureShape")
.Name(("EnsureShape_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"shape",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(shape, shape + shape_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsEnter(EsbTensor *x, const char *frame_name, bool is_constant) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Enter")
.Name(("Enter_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"frame_name",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(frame_name))
},
{
"is_constant",
ge::kAttrRequired,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_constant))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsEqual(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Equal")
.Name(("Equal_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsErf(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Erf")
.Name(("Erf_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsErfc(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Erfc")
.Name(("Erfc_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsErfinv(EsbTensor *input_x) {
GE_ASSERT_NOTNULL(input_x);
auto &graph = input_x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Erfinv")
.Name(("Erfinv_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsEuclideanNorm(EsbTensor *x, EsbTensor *axes, bool keep_dims) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(axes);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("EuclideanNorm")
.Name(("EuclideanNorm_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"axes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"keep_dims",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keep_dims))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(axes->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsEuclideanNormD(EsbTensor *x, const int64_t *axes, int64_t axes_num, bool keep_dims) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("EuclideanNormD")
.Name(("EuclideanNormD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axes",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(axes, axes + axes_num))
},
{
"keep_dims",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keep_dims))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsExit(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Exit")
.Name(("Exit_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsExp(EsbTensor *x, float base, float scale, float shift) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Exp")
.Name(("Exp_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"base",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(base))
},
{
"scale",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(scale))
},
{
"shift",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(shift))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsExpand(EsbTensor *x, EsbTensor *shape) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(shape);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Expand")
.Name(("Expand_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"shape", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsExpandD(EsbTensor *x, const int64_t *shape, int64_t shape_num) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ExpandD")
.Name(("ExpandD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"shape",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(shape, shape + shape_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsExpandDims(EsbTensor *x, EsbTensor *axis) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(axis);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ExpandDims")
.Name(("ExpandDims_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"axis", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(axis->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsExpint(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Expint")
.Name(("Expint_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsExpm1(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Expm1")
.Name(("Expm1_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsExponential(EsbTensor *x, float lambda, int64_t seed) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Exponential")
.Name(("Exponential_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"lambda",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(lambda))
},
{
"seed",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsExponentialDecayLR(EsbTensor *var_handle, EsbTensor *initial_learning_rate, EsbTensor *decay_rate, EsbTensor *decay_steps, EsbTensor *global_step, bool staircase) {
GE_ASSERT_NOTNULL(var_handle);
GE_ASSERT_NOTNULL(initial_learning_rate);
GE_ASSERT_NOTNULL(decay_rate);
GE_ASSERT_NOTNULL(decay_steps);
auto &graph = var_handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ExponentialDecayLR")
.Name(("ExponentialDecayLR_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var_handle", ge::kIrInputRequired, ""},
{"initial_learning_rate", ge::kIrInputRequired, ""},
{"decay_rate", ge::kIrInputRequired, ""},
{"decay_steps", ge::kIrInputRequired, ""},
{"global_step", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"decayed_lr", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"staircase",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(staircase))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var_handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(initial_learning_rate->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(decay_rate->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(decay_steps->GetAnchor(), node->GetInDataAnchor(3)));
if (global_step != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(global_step->GetAnchor(), node->GetInDataAnchor(4)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsExtractGlimpse(EsbTensor *x, EsbTensor *size, EsbTensor *offsets, bool centered, bool normalized, bool uniform_noise, const char *noise) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(size);
GE_ASSERT_NOTNULL(offsets);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ExtractGlimpse")
.Name(("ExtractGlimpse_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"size", ge::kIrInputRequired, ""},
{"offsets", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"centered",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(centered))
},
{
"normalized",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(normalized))
},
{
"uniform_noise",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(uniform_noise))
},
{
"noise",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(noise))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(size->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offsets->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsExtractGlimpseV2(EsbTensor *input, EsbTensor *size, EsbTensor *offsets, bool centered, bool normalized, bool uniform_noise, const char *noise) {
GE_ASSERT_NOTNULL(input);
GE_ASSERT_NOTNULL(size);
GE_ASSERT_NOTNULL(offsets);
auto &graph = input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ExtractGlimpseV2")
.Name(("ExtractGlimpseV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input", ge::kIrInputRequired, ""},
{"size", ge::kIrInputRequired, ""},
{"offsets", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"glimpse", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"centered",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(centered))
},
{
"normalized",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(normalized))
},
{
"uniform_noise",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(uniform_noise))
},
{
"noise",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(noise))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(size->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offsets->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsExtractImagePatches(EsbTensor *x, const int64_t *ksizes, int64_t ksizes_num, const int64_t *strides, int64_t strides_num, const int64_t *rates, int64_t rates_num, const char *padding) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ExtractImagePatches")
.Name(("ExtractImagePatches_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ksizes",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ksizes, ksizes + ksizes_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"rates",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(rates, rates + rates_num))
},
{
"padding",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(padding))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsExtractJpegShape(EsbTensor *contents, ge::DataType output_type) {
GE_ASSERT_NOTNULL(contents);
auto &graph = contents->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ExtractJpegShape")
.Name(("ExtractJpegShape_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"contents", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"image_shape", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"output_type",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(output_type))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(contents->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsExtractVolumePatches(EsbTensor *x, const int64_t *ksizes, int64_t ksizes_num, const int64_t *strides, int64_t strides_num, const char *padding) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ExtractVolumePatches")
.Name(("ExtractVolumePatches_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ksizes",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ksizes, ksizes + ksizes_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"padding",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(padding))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsEye(EsbGraph *owner_graph, int64_t num_rows, int64_t num_columns, const int64_t *batch_shape, int64_t batch_shape_num, int64_t dtype) {
GE_ASSERT_NOTNULL(owner_graph);
EsbGraph &graph = *owner_graph;

auto desc = ge::CompliantOpDescBuilder().OpType("Eye")
.Name(("Eye_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_rows",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_rows))
},
{
"num_columns",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_columns))
},
{
"batch_shape",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(batch_shape, batch_shape + batch_shape_num))
},
{
"dtype",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsFFN(EsbTensor *x, EsbTensor *weight1, EsbTensor *weight2, EsbTensor *expert_tokens, EsbTensor *bias1, EsbTensor *bias2, EsbTensor *scale, EsbTensor *offset, EsbTensor *deq_scale1, EsbTensor *deq_scale2, EsbTensor *antiquant_scale1, EsbTensor *antiquant_scale2, EsbTensor *antiquant_offset1, EsbTensor *antiquant_offset2, const char *activation, int64_t inner_precise, int64_t output_dtype, bool tokens_index_flag) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(weight1);
GE_ASSERT_NOTNULL(weight2);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FFN")
.Name(("FFN_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"weight1", ge::kIrInputRequired, ""},
{"weight2", ge::kIrInputRequired, ""},
{"expert_tokens", ge::kIrInputOptional, ""},
{"bias1", ge::kIrInputOptional, ""},
{"bias2", ge::kIrInputOptional, ""},
{"scale", ge::kIrInputOptional, ""},
{"offset", ge::kIrInputOptional, ""},
{"deq_scale1", ge::kIrInputOptional, ""},
{"deq_scale2", ge::kIrInputOptional, ""},
{"antiquant_scale1", ge::kIrInputOptional, ""},
{"antiquant_scale2", ge::kIrInputOptional, ""},
{"antiquant_offset1", ge::kIrInputOptional, ""},
{"antiquant_offset2", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"activation",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(activation))
},
{
"inner_precise",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(inner_precise))
},
{
"output_dtype",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(output_dtype))
},
{
"tokens_index_flag",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(tokens_index_flag))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight1->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight2->GetAnchor(), node->GetInDataAnchor(2)));
if (expert_tokens != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(expert_tokens->GetAnchor(), node->GetInDataAnchor(3)));
}
if (bias1 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias1->GetAnchor(), node->GetInDataAnchor(4)));
}
if (bias2 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias2->GetAnchor(), node->GetInDataAnchor(5)));
}
if (scale != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(6)));
}
if (offset != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset->GetAnchor(), node->GetInDataAnchor(7)));
}
if (deq_scale1 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(deq_scale1->GetAnchor(), node->GetInDataAnchor(8)));
}
if (deq_scale2 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(deq_scale2->GetAnchor(), node->GetInDataAnchor(9)));
}
if (antiquant_scale1 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(antiquant_scale1->GetAnchor(), node->GetInDataAnchor(10)));
}
if (antiquant_scale2 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(antiquant_scale2->GetAnchor(), node->GetInDataAnchor(11)));
}
if (antiquant_offset1 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(antiquant_offset1->GetAnchor(), node->GetInDataAnchor(12)));
}
if (antiquant_offset2 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(antiquant_offset2->GetAnchor(), node->GetInDataAnchor(13)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsFFT(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FFT")
.Name(("FFT_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsFFT2D(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FFT2D")
.Name(("FFT2D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsFSRDetectionOutputOutput EsFSRDetectionOutput(EsbTensor *rois, EsbTensor *bbox_delta, EsbTensor *score, EsbTensor *im_info, EsbTensor *actual_rois_num, int64_t num_classes, float score_threshold, float iou_threshold, int64_t batch_rois) {
GE_ASSERT_NOTNULL(rois);
GE_ASSERT_NOTNULL(bbox_delta);
GE_ASSERT_NOTNULL(score);
GE_ASSERT_NOTNULL(im_info);
auto &graph = rois->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FSRDetectionOutput")
.Name(("FSRDetectionOutput_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"rois", ge::kIrInputRequired, ""},
{"bbox_delta", ge::kIrInputRequired, ""},
{"score", ge::kIrInputRequired, ""},
{"im_info", ge::kIrInputRequired, ""},
{"actual_rois_num", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"actual_bbox_num", ge::kIrOutputRequired, ""},
{"box", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_classes",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_classes))
},
{
"score_threshold",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(score_threshold))
},
{
"iou_threshold",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(iou_threshold))
},
{
"batch_rois",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(batch_rois))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rois->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bbox_delta->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(score->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(im_info->GetAnchor(), node->GetInDataAnchor(3)));
if (actual_rois_num != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(actual_rois_num->GetAnchor(), node->GetInDataAnchor(4)));
}
return EsFSRDetectionOutputOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsFakeQuantAffineCachemaskOutput EsFakeQuantAffineCachemask(EsbTensor *x, EsbTensor *scale, EsbTensor *zero_point, int64_t axis, int64_t quant_min, int64_t quant_max) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(scale);
GE_ASSERT_NOTNULL(zero_point);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FakeQuantAffineCachemask")
.Name(("FakeQuantAffineCachemask_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"scale", ge::kIrInputRequired, ""},
{"zero_point", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"mask", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
{
"quant_min",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(quant_min))
},
{
"quant_max",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(quant_max))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(zero_point->GetAnchor(), node->GetInDataAnchor(2)));
return EsFakeQuantAffineCachemaskOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsFakeQuantWithMinMaxArgs(EsbTensor *x, float min, float max, int64_t num_bits, bool narrow_range) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FakeQuantWithMinMaxArgs")
.Name(("FakeQuantWithMinMaxArgs_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"min",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(min))
},
{
"max",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(max))
},
{
"num_bits",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_bits))
},
{
"narrow_range",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(narrow_range))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsFakeQuantWithMinMaxArgsGradient(EsbTensor *gradients, EsbTensor *x, float min, float max, int64_t num_bits, bool narrow_range) {
GE_ASSERT_NOTNULL(gradients);
GE_ASSERT_NOTNULL(x);
auto &graph = gradients->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FakeQuantWithMinMaxArgsGradient")
.Name(("FakeQuantWithMinMaxArgsGradient_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"gradients", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"min",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(min))
},
{
"max",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(max))
},
{
"num_bits",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_bits))
},
{
"narrow_range",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(narrow_range))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gradients->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsFakeQuantWithMinMaxVars(EsbTensor *x, EsbTensor *min, EsbTensor *max, int64_t num_bits, bool narrow_range) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(min);
GE_ASSERT_NOTNULL(max);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FakeQuantWithMinMaxVars")
.Name(("FakeQuantWithMinMaxVars_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"min", ge::kIrInputRequired, ""},
{"max", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_bits",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_bits))
},
{
"narrow_range",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(narrow_range))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(min->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(max->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsFakeQuantWithMinMaxVarsGradientOutput EsFakeQuantWithMinMaxVarsGradient(EsbTensor *gradients, EsbTensor *x, EsbTensor *min, EsbTensor *max, int64_t num_bits, bool narrow_range) {
GE_ASSERT_NOTNULL(gradients);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(min);
GE_ASSERT_NOTNULL(max);
auto &graph = gradients->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FakeQuantWithMinMaxVarsGradient")
.Name(("FakeQuantWithMinMaxVarsGradient_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"gradients", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"min", ge::kIrInputRequired, ""},
{"max", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"backprops_wrt_x", ge::kIrOutputRequired, ""},
{"backprops_wrt_min", ge::kIrOutputRequired, ""},
{"backprops_wrt_max", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_bits",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_bits))
},
{
"narrow_range",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(narrow_range))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gradients->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(min->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(max->GetAnchor(), node->GetInDataAnchor(3)));
return EsFakeQuantWithMinMaxVarsGradientOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsFakeQuantWithMinMaxVarsPerChannel(EsbTensor *x, EsbTensor *min, EsbTensor *max, int64_t num_bits, bool narrow_range) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(min);
GE_ASSERT_NOTNULL(max);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FakeQuantWithMinMaxVarsPerChannel")
.Name(("FakeQuantWithMinMaxVarsPerChannel_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"min", ge::kIrInputRequired, ""},
{"max", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_bits",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_bits))
},
{
"narrow_range",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(narrow_range))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(min->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(max->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsFakeQuantWithMinMaxVarsPerChannelGradientOutput EsFakeQuantWithMinMaxVarsPerChannelGradient(EsbTensor *gradients, EsbTensor *x, EsbTensor *min, EsbTensor *max, int64_t num_bits, bool narrow_range) {
GE_ASSERT_NOTNULL(gradients);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(min);
GE_ASSERT_NOTNULL(max);
auto &graph = gradients->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FakeQuantWithMinMaxVarsPerChannelGradient")
.Name(("FakeQuantWithMinMaxVarsPerChannelGradient_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"gradients", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"min", ge::kIrInputRequired, ""},
{"max", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"backprops_wrt_x", ge::kIrOutputRequired, ""},
{"backprops_wrt_min", ge::kIrOutputRequired, ""},
{"backprops_wrt_max", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_bits",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_bits))
},
{
"narrow_range",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(narrow_range))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gradients->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(min->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(max->GetAnchor(), node->GetInDataAnchor(3)));
return EsFakeQuantWithMinMaxVarsPerChannelGradientOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsFakeQueue(EsbTensor *resource) {
GE_ASSERT_NOTNULL(resource);
auto &graph = resource->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FakeQueue")
.Name(("FakeQueue_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"resource", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"handle", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(resource->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsFastGelu(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FastGelu")
.Name(("FastGelu_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsFastGeluGrad(EsbTensor *dy, EsbTensor *x) {
GE_ASSERT_NOTNULL(dy);
GE_ASSERT_NOTNULL(x);
auto &graph = dy->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FastGeluGrad")
.Name(("FastGeluGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"dy", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"z", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsFastGeluV2(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FastGeluV2")
.Name(("FastGeluV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsFastrcnnPredictionsOutput EsFastrcnnPredictions(EsbTensor *rois, EsbTensor *score, float nms_threshold, float score_threshold, int64_t k) {
GE_ASSERT_NOTNULL(rois);
GE_ASSERT_NOTNULL(score);
auto &graph = rois->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FastrcnnPredictions")
.Name(("FastrcnnPredictions_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"rois", ge::kIrInputRequired, ""},
{"score", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"sorted_rois", ge::kIrOutputRequired, ""},
{"sorted_scores", ge::kIrOutputRequired, ""},
{"sorted_classes", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"nms_threshold",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(nms_threshold))
},
{
"score_threshold",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(score_threshold))
},
{
"k",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(k))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rois->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(score->GetAnchor(), node->GetInDataAnchor(1)));
return EsFastrcnnPredictionsOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsFeedsRepeat(EsbTensor *feeds, EsbTensor *feeds_repeat_times, int64_t output_feeds_size) {
GE_ASSERT_NOTNULL(feeds);
GE_ASSERT_NOTNULL(feeds_repeat_times);
auto &graph = feeds->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FeedsRepeat")
.Name(("FeedsRepeat_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"feeds", ge::kIrInputRequired, ""},
{"feeds_repeat_times", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"output_feeds_size",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(output_feeds_size))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(feeds->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(feeds_repeat_times->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsFileConstant(EsbGraph *owner_graph, const int64_t *shape, int64_t shape_num, ge::DataType dtype, const char *file_path, const char *file_id) {
GE_ASSERT_NOTNULL(owner_graph);
EsbGraph &graph = *owner_graph;

auto desc = ge::CompliantOpDescBuilder().OpType("FileConstant")
.Name(("FileConstant_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"shape",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(shape, shape + shape_num))
},
{
"dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
{
"file_path",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(file_path))
},
{
"file_id",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(file_id))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsFill(EsbTensor *dims, EsbTensor *value) {
GE_ASSERT_NOTNULL(dims);
GE_ASSERT_NOTNULL(value);
auto &graph = dims->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Fill")
.Name(("Fill_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"dims", ge::kIrInputRequired, ""},
{"value", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dims->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsFillD(EsbTensor *value, const int64_t *dims, int64_t dims_num) {
GE_ASSERT_NOTNULL(value);
auto &graph = value->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FillD")
.Name(("FillD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"value", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dims",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dims, dims + dims_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsFillDiagonal(EsbTensor *x, float fill_value, bool wrap) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FillDiagonal")
.Name(("FillDiagonal_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"fill_value",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(fill_value))
},
{
"wrap",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(wrap))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsFillV2(EsbTensor *dims, float value) {
GE_ASSERT_NOTNULL(dims);
auto &graph = dims->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FillV2")
.Name(("FillV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"dims", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"value",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(value))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dims->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsFillV2D(EsbGraph *owner_graph, const int64_t *dims, int64_t dims_num, float value) {
GE_ASSERT_NOTNULL(owner_graph);
EsbGraph &graph = *owner_graph;

auto desc = ge::CompliantOpDescBuilder().OpType("FillV2D")
.Name(("FillV2D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dims",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dims, dims + dims_num))
},
{
"value",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(value))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsFillWindowCache(EsbTensor *x, EsbTensor *clean_cache, int64_t axis, int64_t cache_depth) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(clean_cache);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FillWindowCache")
.Name(("FillWindowCache_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"clean_cache", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
{
"cache_depth",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(cache_depth))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(clean_cache->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsFills(EsbTensor *x, float value) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Fills")
.Name(("Fills_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"value",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(value))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsFingerprint(EsbTensor *data, EsbTensor *method) {
GE_ASSERT_NOTNULL(data);
GE_ASSERT_NOTNULL(method);
auto &graph = data->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Fingerprint")
.Name(("Fingerprint_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"data", ge::kIrInputRequired, ""},
{"method", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(data->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(method->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsFixedUnigramCandidateSamplerOutput EsFixedUnigramCandidateSampler(EsbTensor *true_classes, const float *unigrams, int64_t unigrams_num, int64_t num_true, int64_t num_sampled, bool unique, int64_t range_max, const char *vocab_file, float distortion, int64_t num_reserved_ids, int64_t num_shards, int64_t shard, int64_t seed, int64_t seed2) {
GE_ASSERT_NOTNULL(true_classes);
auto &graph = true_classes->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FixedUnigramCandidateSampler")
.Name(("FixedUnigramCandidateSampler_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"true_classes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"sampled_candidates", ge::kIrOutputRequired, ""},
{"true_expected_count", ge::kIrOutputRequired, ""},
{"sampled_expected_count", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"unigrams",
ge::kAttrRequired,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(unigrams, unigrams + unigrams_num))
},
{
"num_true",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_true))
},
{
"num_sampled",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_sampled))
},
{
"unique",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(unique))
},
{
"range_max",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(range_max))
},
{
"vocab_file",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(vocab_file))
},
{
"distortion",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(distortion))
},
{
"num_reserved_ids",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_reserved_ids))
},
{
"num_shards",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_shards))
},
{
"shard",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(shard))
},
{
"seed",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed))
},
{
"seed2",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed2))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(true_classes->GetAnchor(), node->GetInDataAnchor(0)));
return EsFixedUnigramCandidateSamplerOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsFlashAttentionScoreOutput EsFlashAttentionScore(EsbTensor *query, EsbTensor *key, EsbTensor *value, EsbTensor *real_shift, EsbTensor *drop_mask, EsbTensor *padding_mask, EsbTensor *atten_mask, EsbTensor *prefix, EsbTensor *actual_seq_qlen, EsbTensor *actual_seq_kvlen, EsbTensor *q_start_idx, EsbTensor *kv_start_idx, int64_t head_num, const char *input_layout, float scale_value, float keep_prob, int64_t pre_tockens, int64_t next_tockens, int64_t inner_precise, int64_t sparse_mode, int64_t pse_type) {
GE_ASSERT_NOTNULL(query);
GE_ASSERT_NOTNULL(key);
GE_ASSERT_NOTNULL(value);
auto &graph = query->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FlashAttentionScore")
.Name(("FlashAttentionScore_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"query", ge::kIrInputRequired, ""},
{"key", ge::kIrInputRequired, ""},
{"value", ge::kIrInputRequired, ""},
{"real_shift", ge::kIrInputOptional, ""},
{"drop_mask", ge::kIrInputOptional, ""},
{"padding_mask", ge::kIrInputOptional, ""},
{"atten_mask", ge::kIrInputOptional, ""},
{"prefix", ge::kIrInputOptional, ""},
{"actual_seq_qlen", ge::kIrInputOptional, ""},
{"actual_seq_kvlen", ge::kIrInputOptional, ""},
{"q_start_idx", ge::kIrInputOptional, ""},
{"kv_start_idx", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"softmax_max", ge::kIrOutputRequired, ""},
{"softmax_sum", ge::kIrOutputRequired, ""},
{"softmax_out", ge::kIrOutputRequired, ""},
{"attention_out", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"head_num",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(head_num))
},
{
"input_layout",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(input_layout))
},
{
"scale_value",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(scale_value))
},
{
"keep_prob",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(keep_prob))
},
{
"pre_tockens",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pre_tockens))
},
{
"next_tockens",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(next_tockens))
},
{
"inner_precise",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(inner_precise))
},
{
"sparse_mode",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(sparse_mode))
},
{
"pse_type",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pse_type))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(query->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(key->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(2)));
if (real_shift != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(real_shift->GetAnchor(), node->GetInDataAnchor(3)));
}
if (drop_mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(drop_mask->GetAnchor(), node->GetInDataAnchor(4)));
}
if (padding_mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(padding_mask->GetAnchor(), node->GetInDataAnchor(5)));
}
if (atten_mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(atten_mask->GetAnchor(), node->GetInDataAnchor(6)));
}
if (prefix != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(prefix->GetAnchor(), node->GetInDataAnchor(7)));
}
if (actual_seq_qlen != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(actual_seq_qlen->GetAnchor(), node->GetInDataAnchor(8)));
}
if (actual_seq_kvlen != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(actual_seq_kvlen->GetAnchor(), node->GetInDataAnchor(9)));
}
if (q_start_idx != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(q_start_idx->GetAnchor(), node->GetInDataAnchor(10)));
}
if (kv_start_idx != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(kv_start_idx->GetAnchor(), node->GetInDataAnchor(11)));
}
return EsFlashAttentionScoreOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsFlashAttentionScoreGradOutput EsFlashAttentionScoreGrad(EsbTensor *query, EsbTensor *key, EsbTensor *value, EsbTensor *dy, EsbTensor *pse_shift, EsbTensor *drop_mask, EsbTensor *padding_mask, EsbTensor *atten_mask, EsbTensor *softmax_max, EsbTensor *softmax_sum, EsbTensor *softmax_in, EsbTensor *attention_in, EsbTensor *prefix, EsbTensor *actual_seq_qlen, EsbTensor *actual_seq_kvlen, EsbTensor *q_start_idx, EsbTensor *kv_start_idx, int64_t head_num, const char *input_layout, float scale_value, float keep_prob, int64_t pre_tockens, int64_t next_tockens, int64_t inner_precise, int64_t sparse_mode, int64_t pse_type) {
GE_ASSERT_NOTNULL(query);
GE_ASSERT_NOTNULL(key);
GE_ASSERT_NOTNULL(value);
GE_ASSERT_NOTNULL(dy);
auto &graph = query->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FlashAttentionScoreGrad")
.Name(("FlashAttentionScoreGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"query", ge::kIrInputRequired, ""},
{"key", ge::kIrInputRequired, ""},
{"value", ge::kIrInputRequired, ""},
{"dy", ge::kIrInputRequired, ""},
{"pse_shift", ge::kIrInputOptional, ""},
{"drop_mask", ge::kIrInputOptional, ""},
{"padding_mask", ge::kIrInputOptional, ""},
{"atten_mask", ge::kIrInputOptional, ""},
{"softmax_max", ge::kIrInputOptional, ""},
{"softmax_sum", ge::kIrInputOptional, ""},
{"softmax_in", ge::kIrInputOptional, ""},
{"attention_in", ge::kIrInputOptional, ""},
{"prefix", ge::kIrInputOptional, ""},
{"actual_seq_qlen", ge::kIrInputOptional, ""},
{"actual_seq_kvlen", ge::kIrInputOptional, ""},
{"q_start_idx", ge::kIrInputOptional, ""},
{"kv_start_idx", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"dq", ge::kIrOutputRequired, ""},
{"dk", ge::kIrOutputRequired, ""},
{"dv", ge::kIrOutputRequired, ""},
{"dpse", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"head_num",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(head_num))
},
{
"input_layout",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(input_layout))
},
{
"scale_value",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(scale_value))
},
{
"keep_prob",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(keep_prob))
},
{
"pre_tockens",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pre_tockens))
},
{
"next_tockens",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(next_tockens))
},
{
"inner_precise",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(inner_precise))
},
{
"sparse_mode",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(sparse_mode))
},
{
"pse_type",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pse_type))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(query->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(key->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(3)));
if (pse_shift != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(pse_shift->GetAnchor(), node->GetInDataAnchor(4)));
}
if (drop_mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(drop_mask->GetAnchor(), node->GetInDataAnchor(5)));
}
if (padding_mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(padding_mask->GetAnchor(), node->GetInDataAnchor(6)));
}
if (atten_mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(atten_mask->GetAnchor(), node->GetInDataAnchor(7)));
}
if (softmax_max != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(softmax_max->GetAnchor(), node->GetInDataAnchor(8)));
}
if (softmax_sum != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(softmax_sum->GetAnchor(), node->GetInDataAnchor(9)));
}
if (softmax_in != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(softmax_in->GetAnchor(), node->GetInDataAnchor(10)));
}
if (attention_in != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(attention_in->GetAnchor(), node->GetInDataAnchor(11)));
}
if (prefix != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(prefix->GetAnchor(), node->GetInDataAnchor(12)));
}
if (actual_seq_qlen != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(actual_seq_qlen->GetAnchor(), node->GetInDataAnchor(13)));
}
if (actual_seq_kvlen != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(actual_seq_kvlen->GetAnchor(), node->GetInDataAnchor(14)));
}
if (q_start_idx != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(q_start_idx->GetAnchor(), node->GetInDataAnchor(15)));
}
if (kv_start_idx != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(kv_start_idx->GetAnchor(), node->GetInDataAnchor(16)));
}
return EsFlashAttentionScoreGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsbTensor *EsFlatten(EsbTensor *x, int64_t axis) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Flatten")
.Name(("Flatten_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsFlattenV2(EsbTensor *x, int64_t axis, int64_t end_axis) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FlattenV2")
.Name(("FlattenV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
{
"end_axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(end_axis))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsFloor(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Floor")
.Name(("Floor_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsFloorDiv(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FloorDiv")
.Name(("FloorDiv_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsFloorMod(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FloorMod")
.Name(("FloorMod_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsForeachACosInplace(EsbTensor **x, int64_t x_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachACosInplace")
.Name(("ForeachACosInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachASinInplace(EsbTensor **x, int64_t x_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachASinInplace")
.Name(("ForeachASinInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachATanInplace(EsbTensor **x, int64_t x_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachATanInplace")
.Name(("ForeachATanInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachAbsInplace(EsbTensor **x, int64_t x_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachAbsInplace")
.Name(("ForeachAbsInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachAddListInplace(EsbTensor **x1, int64_t x1_num, EsbTensor **x2, int64_t x2_num, EsbTensor *alpha) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x1_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x2_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x1_num; ++i) {
if (x1[i] != nullptr) {
non_null_in = x1[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x2_num; ++i) {
if (x2[i] != nullptr) {
non_null_in = x2[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
if (non_null_in == nullptr) {
non_null_in = alpha;
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachAddListInplace")
.Name(("ForeachAddListInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputDynamic, ""},
{"x2", ge::kIrInputDynamic, ""},
{"alpha", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x1", static_cast<int32_t>(x1_num))
.InstanceDynamicInputNum("x2", static_cast<int32_t>(x2_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x1 != nullptr) && (x1_num > 0)) {
for (int64_t i = 0; i < x1_num; ++i) {
auto one_x1 = x1[i];
GE_ASSERT_NOTNULL(one_x1);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x1->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
if ((x2 != nullptr) && (x2_num > 0)) {
for (int64_t i = 0; i < x2_num; ++i) {
auto one_x2 = x2[i];
GE_ASSERT_NOTNULL(one_x2);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x2->GetAnchor(), node->GetInDataAnchor(0 + x1_num + i)));
}
}
if (alpha != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(alpha->GetAnchor(), node->GetInDataAnchor(0 + x1_num + x2_num)));
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachAddScalarInplace(EsbTensor **x, int64_t x_num, EsbTensor *scalar) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
GE_ASSERT_NOTNULL(scalar);
auto &graph = scalar->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachAddScalarInplace")
.Name(("ForeachAddScalarInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
{"scalar", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scalar->GetAnchor(), node->GetInDataAnchor(0 + x_num)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachAddScalarListInplace(EsbTensor **x, int64_t x_num, EsbTensor *scalars) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
GE_ASSERT_NOTNULL(scalars);
auto &graph = scalars->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachAddScalarListInplace")
.Name(("ForeachAddScalarListInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
{"scalars", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scalars->GetAnchor(), node->GetInDataAnchor(0 + x_num)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachAddcdivListInplace(EsbTensor **x1, int64_t x1_num, EsbTensor **x2, int64_t x2_num, EsbTensor **x3, int64_t x3_num, EsbTensor *scalars) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x1_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x2_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x3_num));
GE_ASSERT_NOTNULL(scalars);
auto &graph = scalars->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachAddcdivListInplace")
.Name(("ForeachAddcdivListInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputDynamic, ""},
{"x2", ge::kIrInputDynamic, ""},
{"x3", ge::kIrInputDynamic, ""},
{"scalars", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x1", static_cast<int32_t>(x1_num))
.InstanceDynamicInputNum("x2", static_cast<int32_t>(x2_num))
.InstanceDynamicInputNum("x3", static_cast<int32_t>(x3_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x1 != nullptr) && (x1_num > 0)) {
for (int64_t i = 0; i < x1_num; ++i) {
auto one_x1 = x1[i];
GE_ASSERT_NOTNULL(one_x1);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x1->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
if ((x2 != nullptr) && (x2_num > 0)) {
for (int64_t i = 0; i < x2_num; ++i) {
auto one_x2 = x2[i];
GE_ASSERT_NOTNULL(one_x2);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x2->GetAnchor(), node->GetInDataAnchor(0 + x1_num + i)));
}
}
if ((x3 != nullptr) && (x3_num > 0)) {
for (int64_t i = 0; i < x3_num; ++i) {
auto one_x3 = x3[i];
GE_ASSERT_NOTNULL(one_x3);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x3->GetAnchor(), node->GetInDataAnchor(0 + x1_num + x2_num + i)));
}
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scalars->GetAnchor(), node->GetInDataAnchor(0 + x1_num + x2_num + x3_num)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachAddcdivScalarInplace(EsbTensor **x1, int64_t x1_num, EsbTensor **x2, int64_t x2_num, EsbTensor **x3, int64_t x3_num, EsbTensor *scalars) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x1_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x2_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x3_num));
GE_ASSERT_NOTNULL(scalars);
auto &graph = scalars->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachAddcdivScalarInplace")
.Name(("ForeachAddcdivScalarInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputDynamic, ""},
{"x2", ge::kIrInputDynamic, ""},
{"x3", ge::kIrInputDynamic, ""},
{"scalars", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x1", static_cast<int32_t>(x1_num))
.InstanceDynamicInputNum("x2", static_cast<int32_t>(x2_num))
.InstanceDynamicInputNum("x3", static_cast<int32_t>(x3_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x1 != nullptr) && (x1_num > 0)) {
for (int64_t i = 0; i < x1_num; ++i) {
auto one_x1 = x1[i];
GE_ASSERT_NOTNULL(one_x1);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x1->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
if ((x2 != nullptr) && (x2_num > 0)) {
for (int64_t i = 0; i < x2_num; ++i) {
auto one_x2 = x2[i];
GE_ASSERT_NOTNULL(one_x2);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x2->GetAnchor(), node->GetInDataAnchor(0 + x1_num + i)));
}
}
if ((x3 != nullptr) && (x3_num > 0)) {
for (int64_t i = 0; i < x3_num; ++i) {
auto one_x3 = x3[i];
GE_ASSERT_NOTNULL(one_x3);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x3->GetAnchor(), node->GetInDataAnchor(0 + x1_num + x2_num + i)));
}
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scalars->GetAnchor(), node->GetInDataAnchor(0 + x1_num + x2_num + x3_num)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachAddcmulListInplace(EsbTensor **x1, int64_t x1_num, EsbTensor **x2, int64_t x2_num, EsbTensor **x3, int64_t x3_num, EsbTensor *scalars) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x1_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x2_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x3_num));
GE_ASSERT_NOTNULL(scalars);
auto &graph = scalars->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachAddcmulListInplace")
.Name(("ForeachAddcmulListInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputDynamic, ""},
{"x2", ge::kIrInputDynamic, ""},
{"x3", ge::kIrInputDynamic, ""},
{"scalars", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x1", static_cast<int32_t>(x1_num))
.InstanceDynamicInputNum("x2", static_cast<int32_t>(x2_num))
.InstanceDynamicInputNum("x3", static_cast<int32_t>(x3_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x1 != nullptr) && (x1_num > 0)) {
for (int64_t i = 0; i < x1_num; ++i) {
auto one_x1 = x1[i];
GE_ASSERT_NOTNULL(one_x1);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x1->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
if ((x2 != nullptr) && (x2_num > 0)) {
for (int64_t i = 0; i < x2_num; ++i) {
auto one_x2 = x2[i];
GE_ASSERT_NOTNULL(one_x2);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x2->GetAnchor(), node->GetInDataAnchor(0 + x1_num + i)));
}
}
if ((x3 != nullptr) && (x3_num > 0)) {
for (int64_t i = 0; i < x3_num; ++i) {
auto one_x3 = x3[i];
GE_ASSERT_NOTNULL(one_x3);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x3->GetAnchor(), node->GetInDataAnchor(0 + x1_num + x2_num + i)));
}
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scalars->GetAnchor(), node->GetInDataAnchor(0 + x1_num + x2_num + x3_num)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachAddcmulScalarInplace(EsbTensor **x1, int64_t x1_num, EsbTensor **x2, int64_t x2_num, EsbTensor **x3, int64_t x3_num, EsbTensor *scalar) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x1_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x2_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x3_num));
GE_ASSERT_NOTNULL(scalar);
auto &graph = scalar->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachAddcmulScalarInplace")
.Name(("ForeachAddcmulScalarInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputDynamic, ""},
{"x2", ge::kIrInputDynamic, ""},
{"x3", ge::kIrInputDynamic, ""},
{"scalar", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x1", static_cast<int32_t>(x1_num))
.InstanceDynamicInputNum("x2", static_cast<int32_t>(x2_num))
.InstanceDynamicInputNum("x3", static_cast<int32_t>(x3_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x1 != nullptr) && (x1_num > 0)) {
for (int64_t i = 0; i < x1_num; ++i) {
auto one_x1 = x1[i];
GE_ASSERT_NOTNULL(one_x1);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x1->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
if ((x2 != nullptr) && (x2_num > 0)) {
for (int64_t i = 0; i < x2_num; ++i) {
auto one_x2 = x2[i];
GE_ASSERT_NOTNULL(one_x2);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x2->GetAnchor(), node->GetInDataAnchor(0 + x1_num + i)));
}
}
if ((x3 != nullptr) && (x3_num > 0)) {
for (int64_t i = 0; i < x3_num; ++i) {
auto one_x3 = x3[i];
GE_ASSERT_NOTNULL(one_x3);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x3->GetAnchor(), node->GetInDataAnchor(0 + x1_num + x2_num + i)));
}
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scalar->GetAnchor(), node->GetInDataAnchor(0 + x1_num + x2_num + x3_num)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachCosInplace(EsbTensor **x, int64_t x_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachCosInplace")
.Name(("ForeachCosInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachCoshInplace(EsbTensor **x, int64_t x_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachCoshInplace")
.Name(("ForeachCoshInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachDivListInplace(EsbTensor **x1, int64_t x1_num, EsbTensor **x2, int64_t x2_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x1_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x2_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x1_num; ++i) {
if (x1[i] != nullptr) {
non_null_in = x1[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x2_num; ++i) {
if (x2[i] != nullptr) {
non_null_in = x2[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachDivListInplace")
.Name(("ForeachDivListInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputDynamic, ""},
{"x2", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x1", static_cast<int32_t>(x1_num))
.InstanceDynamicInputNum("x2", static_cast<int32_t>(x2_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x1 != nullptr) && (x1_num > 0)) {
for (int64_t i = 0; i < x1_num; ++i) {
auto one_x1 = x1[i];
GE_ASSERT_NOTNULL(one_x1);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x1->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
if ((x2 != nullptr) && (x2_num > 0)) {
for (int64_t i = 0; i < x2_num; ++i) {
auto one_x2 = x2[i];
GE_ASSERT_NOTNULL(one_x2);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x2->GetAnchor(), node->GetInDataAnchor(0 + x1_num + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachDivScalarInplace(EsbTensor **x, int64_t x_num, EsbTensor *scalar) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
GE_ASSERT_NOTNULL(scalar);
auto &graph = scalar->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachDivScalarInplace")
.Name(("ForeachDivScalarInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
{"scalar", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scalar->GetAnchor(), node->GetInDataAnchor(0 + x_num)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachDivScalarListInplace(EsbTensor **x, int64_t x_num, EsbTensor *scalars) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
GE_ASSERT_NOTNULL(scalars);
auto &graph = scalars->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachDivScalarListInplace")
.Name(("ForeachDivScalarListInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
{"scalars", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scalars->GetAnchor(), node->GetInDataAnchor(0 + x_num)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachExpInplace(EsbTensor **x, int64_t x_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachExpInplace")
.Name(("ForeachExpInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachExpm1Inplace(EsbTensor **x, int64_t x_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachExpm1Inplace")
.Name(("ForeachExpm1Inplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachLerpListInplace(EsbTensor **x1, int64_t x1_num, EsbTensor **x2, int64_t x2_num, EsbTensor *weights) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x1_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x2_num));
GE_ASSERT_NOTNULL(weights);
auto &graph = weights->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachLerpListInplace")
.Name(("ForeachLerpListInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputDynamic, ""},
{"x2", ge::kIrInputDynamic, ""},
{"weights", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x1", static_cast<int32_t>(x1_num))
.InstanceDynamicInputNum("x2", static_cast<int32_t>(x2_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x1 != nullptr) && (x1_num > 0)) {
for (int64_t i = 0; i < x1_num; ++i) {
auto one_x1 = x1[i];
GE_ASSERT_NOTNULL(one_x1);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x1->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
if ((x2 != nullptr) && (x2_num > 0)) {
for (int64_t i = 0; i < x2_num; ++i) {
auto one_x2 = x2[i];
GE_ASSERT_NOTNULL(one_x2);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x2->GetAnchor(), node->GetInDataAnchor(0 + x1_num + i)));
}
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weights->GetAnchor(), node->GetInDataAnchor(0 + x1_num + x2_num)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachLerpScalarInplace(EsbTensor **x1, int64_t x1_num, EsbTensor **x2, int64_t x2_num, EsbTensor *weight) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x1_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x2_num));
GE_ASSERT_NOTNULL(weight);
auto &graph = weight->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachLerpScalarInplace")
.Name(("ForeachLerpScalarInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputDynamic, ""},
{"x2", ge::kIrInputDynamic, ""},
{"weight", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x1", static_cast<int32_t>(x1_num))
.InstanceDynamicInputNum("x2", static_cast<int32_t>(x2_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x1 != nullptr) && (x1_num > 0)) {
for (int64_t i = 0; i < x1_num; ++i) {
auto one_x1 = x1[i];
GE_ASSERT_NOTNULL(one_x1);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x1->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
if ((x2 != nullptr) && (x2_num > 0)) {
for (int64_t i = 0; i < x2_num; ++i) {
auto one_x2 = x2[i];
GE_ASSERT_NOTNULL(one_x2);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x2->GetAnchor(), node->GetInDataAnchor(0 + x1_num + i)));
}
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight->GetAnchor(), node->GetInDataAnchor(0 + x1_num + x2_num)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachLog10Inplace(EsbTensor **x, int64_t x_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachLog10Inplace")
.Name(("ForeachLog10Inplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachLog1pInplace(EsbTensor **x, int64_t x_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachLog1pInplace")
.Name(("ForeachLog1pInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachLog2Inplace(EsbTensor **x, int64_t x_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachLog2Inplace")
.Name(("ForeachLog2Inplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachLogInplace(EsbTensor **x, int64_t x_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachLogInplace")
.Name(("ForeachLogInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachMaximumListInplace(EsbTensor **x1, int64_t x1_num, EsbTensor **x2, int64_t x2_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x1_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x2_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x1_num; ++i) {
if (x1[i] != nullptr) {
non_null_in = x1[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x2_num; ++i) {
if (x2[i] != nullptr) {
non_null_in = x2[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachMaximumListInplace")
.Name(("ForeachMaximumListInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputDynamic, ""},
{"x2", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x1", static_cast<int32_t>(x1_num))
.InstanceDynamicInputNum("x2", static_cast<int32_t>(x2_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x1 != nullptr) && (x1_num > 0)) {
for (int64_t i = 0; i < x1_num; ++i) {
auto one_x1 = x1[i];
GE_ASSERT_NOTNULL(one_x1);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x1->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
if ((x2 != nullptr) && (x2_num > 0)) {
for (int64_t i = 0; i < x2_num; ++i) {
auto one_x2 = x2[i];
GE_ASSERT_NOTNULL(one_x2);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x2->GetAnchor(), node->GetInDataAnchor(0 + x1_num + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachMaximumScalarInplace(EsbTensor **x, int64_t x_num, EsbTensor *scalar) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
GE_ASSERT_NOTNULL(scalar);
auto &graph = scalar->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachMaximumScalarInplace")
.Name(("ForeachMaximumScalarInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
{"scalar", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scalar->GetAnchor(), node->GetInDataAnchor(0 + x_num)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachMaximumScalarListInplace(EsbTensor **x, int64_t x_num, EsbTensor *scalars) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
GE_ASSERT_NOTNULL(scalars);
auto &graph = scalars->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachMaximumScalarListInplace")
.Name(("ForeachMaximumScalarListInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
{"scalars", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scalars->GetAnchor(), node->GetInDataAnchor(0 + x_num)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachMinimumListInplace(EsbTensor **x1, int64_t x1_num, EsbTensor **x2, int64_t x2_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x1_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x2_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x1_num; ++i) {
if (x1[i] != nullptr) {
non_null_in = x1[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x2_num; ++i) {
if (x2[i] != nullptr) {
non_null_in = x2[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachMinimumListInplace")
.Name(("ForeachMinimumListInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputDynamic, ""},
{"x2", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x1", static_cast<int32_t>(x1_num))
.InstanceDynamicInputNum("x2", static_cast<int32_t>(x2_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x1 != nullptr) && (x1_num > 0)) {
for (int64_t i = 0; i < x1_num; ++i) {
auto one_x1 = x1[i];
GE_ASSERT_NOTNULL(one_x1);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x1->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
if ((x2 != nullptr) && (x2_num > 0)) {
for (int64_t i = 0; i < x2_num; ++i) {
auto one_x2 = x2[i];
GE_ASSERT_NOTNULL(one_x2);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x2->GetAnchor(), node->GetInDataAnchor(0 + x1_num + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachMinimumScalarInplace(EsbTensor **x, int64_t x_num, EsbTensor *scalar) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
GE_ASSERT_NOTNULL(scalar);
auto &graph = scalar->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachMinimumScalarInplace")
.Name(("ForeachMinimumScalarInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
{"scalar", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scalar->GetAnchor(), node->GetInDataAnchor(0 + x_num)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachMinimumScalarListInplace(EsbTensor **x, int64_t x_num, EsbTensor *scalars) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
GE_ASSERT_NOTNULL(scalars);
auto &graph = scalars->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachMinimumScalarListInplace")
.Name(("ForeachMinimumScalarListInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
{"scalars", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scalars->GetAnchor(), node->GetInDataAnchor(0 + x_num)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachMulListInplace(EsbTensor **x1, int64_t x1_num, EsbTensor **x2, int64_t x2_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x1_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x2_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x1_num; ++i) {
if (x1[i] != nullptr) {
non_null_in = x1[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x2_num; ++i) {
if (x2[i] != nullptr) {
non_null_in = x2[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachMulListInplace")
.Name(("ForeachMulListInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputDynamic, ""},
{"x2", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x1", static_cast<int32_t>(x1_num))
.InstanceDynamicInputNum("x2", static_cast<int32_t>(x2_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x1 != nullptr) && (x1_num > 0)) {
for (int64_t i = 0; i < x1_num; ++i) {
auto one_x1 = x1[i];
GE_ASSERT_NOTNULL(one_x1);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x1->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
if ((x2 != nullptr) && (x2_num > 0)) {
for (int64_t i = 0; i < x2_num; ++i) {
auto one_x2 = x2[i];
GE_ASSERT_NOTNULL(one_x2);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x2->GetAnchor(), node->GetInDataAnchor(0 + x1_num + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachMulScalarInplace(EsbTensor **x, int64_t x_num, EsbTensor *scalar) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
GE_ASSERT_NOTNULL(scalar);
auto &graph = scalar->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachMulScalarInplace")
.Name(("ForeachMulScalarInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
{"scalar", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scalar->GetAnchor(), node->GetInDataAnchor(0 + x_num)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachMulScalarListInplace(EsbTensor **x, int64_t x_num, EsbTensor *scalars) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
GE_ASSERT_NOTNULL(scalars);
auto &graph = scalars->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachMulScalarListInplace")
.Name(("ForeachMulScalarListInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
{"scalars", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scalars->GetAnchor(), node->GetInDataAnchor(0 + x_num)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachNegInplace(EsbTensor **x, int64_t x_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachNegInplace")
.Name(("ForeachNegInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachNonFiniteCheckAndUnscale(EsbTensor **scaled_grads, int64_t scaled_grads_num, EsbTensor *found_inf, EsbTensor *inv_scale) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(scaled_grads_num));
GE_ASSERT_NOTNULL(found_inf);
GE_ASSERT_NOTNULL(inv_scale);
auto &graph = found_inf->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachNonFiniteCheckAndUnscale")
.Name(("ForeachNonFiniteCheckAndUnscale_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"scaled_grads", ge::kIrInputDynamic, ""},
{"found_inf", ge::kIrInputRequired, ""},
{"inv_scale", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("scaled_grads", static_cast<int32_t>(scaled_grads_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((scaled_grads != nullptr) && (scaled_grads_num > 0)) {
for (int64_t i = 0; i < scaled_grads_num; ++i) {
auto one_scaled_grads = scaled_grads[i];
GE_ASSERT_NOTNULL(one_scaled_grads);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_scaled_grads->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(found_inf->GetAnchor(), node->GetInDataAnchor(0 + scaled_grads_num)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(inv_scale->GetAnchor(), node->GetInDataAnchor(1 + scaled_grads_num)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachPowListInplace(EsbTensor **x1, int64_t x1_num, EsbTensor **x2, int64_t x2_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x1_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x2_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x1_num; ++i) {
if (x1[i] != nullptr) {
non_null_in = x1[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x2_num; ++i) {
if (x2[i] != nullptr) {
non_null_in = x2[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachPowListInplace")
.Name(("ForeachPowListInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputDynamic, ""},
{"x2", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x1", static_cast<int32_t>(x1_num))
.InstanceDynamicInputNum("x2", static_cast<int32_t>(x2_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x1 != nullptr) && (x1_num > 0)) {
for (int64_t i = 0; i < x1_num; ++i) {
auto one_x1 = x1[i];
GE_ASSERT_NOTNULL(one_x1);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x1->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
if ((x2 != nullptr) && (x2_num > 0)) {
for (int64_t i = 0; i < x2_num; ++i) {
auto one_x2 = x2[i];
GE_ASSERT_NOTNULL(one_x2);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x2->GetAnchor(), node->GetInDataAnchor(0 + x1_num + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachPowScalarInplace(EsbTensor **x, int64_t x_num, EsbTensor *scalar) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
GE_ASSERT_NOTNULL(scalar);
auto &graph = scalar->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachPowScalarInplace")
.Name(("ForeachPowScalarInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
{"scalar", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scalar->GetAnchor(), node->GetInDataAnchor(0 + x_num)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachPowScalarListInplace(EsbTensor **x, int64_t x_num, EsbTensor *scalars) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
GE_ASSERT_NOTNULL(scalars);
auto &graph = scalars->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachPowScalarListInplace")
.Name(("ForeachPowScalarListInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
{"scalars", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scalars->GetAnchor(), node->GetInDataAnchor(0 + x_num)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachReciprocalInplace(EsbTensor **x, int64_t x_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachReciprocalInplace")
.Name(("ForeachReciprocalInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachRoundOffNumberInplace(EsbTensor **x, int64_t x_num, EsbTensor *roundMode) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
GE_ASSERT_NOTNULL(roundMode);
auto &graph = roundMode->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachRoundOffNumberInplace")
.Name(("ForeachRoundOffNumberInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
{"roundMode", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(roundMode->GetAnchor(), node->GetInDataAnchor(0 + x_num)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachSigmoidInplace(EsbTensor **x, int64_t x_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachSigmoidInplace")
.Name(("ForeachSigmoidInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachSignInplace(EsbTensor **x, int64_t x_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachSignInplace")
.Name(("ForeachSignInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachSinInplace(EsbTensor **x, int64_t x_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachSinInplace")
.Name(("ForeachSinInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachSinhInplace(EsbTensor **x, int64_t x_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachSinhInplace")
.Name(("ForeachSinhInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachSqrtInplace(EsbTensor **x, int64_t x_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachSqrtInplace")
.Name(("ForeachSqrtInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachSubListInplace(EsbTensor **x1, int64_t x1_num, EsbTensor **x2, int64_t x2_num, EsbTensor *alpha) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x1_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x2_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x1_num; ++i) {
if (x1[i] != nullptr) {
non_null_in = x1[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x2_num; ++i) {
if (x2[i] != nullptr) {
non_null_in = x2[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
if (non_null_in == nullptr) {
non_null_in = alpha;
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachSubListInplace")
.Name(("ForeachSubListInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputDynamic, ""},
{"x2", ge::kIrInputDynamic, ""},
{"alpha", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x1", static_cast<int32_t>(x1_num))
.InstanceDynamicInputNum("x2", static_cast<int32_t>(x2_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x1 != nullptr) && (x1_num > 0)) {
for (int64_t i = 0; i < x1_num; ++i) {
auto one_x1 = x1[i];
GE_ASSERT_NOTNULL(one_x1);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x1->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
if ((x2 != nullptr) && (x2_num > 0)) {
for (int64_t i = 0; i < x2_num; ++i) {
auto one_x2 = x2[i];
GE_ASSERT_NOTNULL(one_x2);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x2->GetAnchor(), node->GetInDataAnchor(0 + x1_num + i)));
}
}
if (alpha != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(alpha->GetAnchor(), node->GetInDataAnchor(0 + x1_num + x2_num)));
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachSubScalarInplace(EsbTensor **x, int64_t x_num, EsbTensor *scalar) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
GE_ASSERT_NOTNULL(scalar);
auto &graph = scalar->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachSubScalarInplace")
.Name(("ForeachSubScalarInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
{"scalar", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scalar->GetAnchor(), node->GetInDataAnchor(0 + x_num)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachSubScalarListInplace(EsbTensor **x, int64_t x_num, EsbTensor *scalars) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
GE_ASSERT_NOTNULL(scalars);
auto &graph = scalars->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachSubScalarListInplace")
.Name(("ForeachSubScalarListInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
{"scalars", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scalars->GetAnchor(), node->GetInDataAnchor(0 + x_num)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachTanInplace(EsbTensor **x, int64_t x_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachTanInplace")
.Name(("ForeachTanInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachTanhInplace(EsbTensor **x, int64_t x_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachTanhInplace")
.Name(("ForeachTanhInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsForeachZeroInplace(EsbTensor **x, int64_t x_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ForeachZeroInplace")
.Name(("ForeachZeroInplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsFractionalAvgPoolOutput EsFractionalAvgPool(EsbTensor *x, const float *pooling_ratio, int64_t pooling_ratio_num, bool pseudo_random, bool overlapping, bool deterministic, int64_t seed, int64_t seed2) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FractionalAvgPool")
.Name(("FractionalAvgPool_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"row_pooling_sequence", ge::kIrOutputRequired, ""},
{"col_pooling_sequence", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"pooling_ratio",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(pooling_ratio, pooling_ratio + pooling_ratio_num))
},
{
"pseudo_random",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(pseudo_random))
},
{
"overlapping",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(overlapping))
},
{
"deterministic",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(deterministic))
},
{
"seed",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed))
},
{
"seed2",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed2))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return EsFractionalAvgPoolOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsFractionalAvgPoolGrad(EsbTensor *orig_input_tensor_shape, EsbTensor *out_backprop, EsbTensor *row_pooling_sequence, EsbTensor *col_pooling_sequence, bool overlapping) {
GE_ASSERT_NOTNULL(orig_input_tensor_shape);
GE_ASSERT_NOTNULL(out_backprop);
GE_ASSERT_NOTNULL(row_pooling_sequence);
GE_ASSERT_NOTNULL(col_pooling_sequence);
auto &graph = orig_input_tensor_shape->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FractionalAvgPoolGrad")
.Name(("FractionalAvgPoolGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"orig_input_tensor_shape", ge::kIrInputRequired, ""},
{"out_backprop", ge::kIrInputRequired, ""},
{"row_pooling_sequence", ge::kIrInputRequired, ""},
{"col_pooling_sequence", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"overlapping",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(overlapping))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(orig_input_tensor_shape->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(out_backprop->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(row_pooling_sequence->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(col_pooling_sequence->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsFractionalMaxPoolOutput EsFractionalMaxPool(EsbTensor *x, const float *pooling_ratio, int64_t pooling_ratio_num, bool pseudo_random, bool overlapping, bool deterministic, int64_t seed, int64_t seed2) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FractionalMaxPool")
.Name(("FractionalMaxPool_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"row_pooling_sequence", ge::kIrOutputRequired, ""},
{"col_pooling_sequence", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"pooling_ratio",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(pooling_ratio, pooling_ratio + pooling_ratio_num))
},
{
"pseudo_random",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(pseudo_random))
},
{
"overlapping",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(overlapping))
},
{
"deterministic",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(deterministic))
},
{
"seed",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed))
},
{
"seed2",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed2))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return EsFractionalMaxPoolOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsFractionalMaxPoolGrad(EsbTensor *orig_input, EsbTensor *orig_output, EsbTensor *out_backprop, EsbTensor *row_pooling_sequence, EsbTensor *col_pooling_sequence, bool overlapping) {
GE_ASSERT_NOTNULL(orig_input);
GE_ASSERT_NOTNULL(orig_output);
GE_ASSERT_NOTNULL(out_backprop);
GE_ASSERT_NOTNULL(row_pooling_sequence);
GE_ASSERT_NOTNULL(col_pooling_sequence);
auto &graph = orig_input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FractionalMaxPoolGrad")
.Name(("FractionalMaxPoolGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"orig_input", ge::kIrInputRequired, ""},
{"orig_output", ge::kIrInputRequired, ""},
{"out_backprop", ge::kIrInputRequired, ""},
{"row_pooling_sequence", ge::kIrInputRequired, ""},
{"col_pooling_sequence", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"overlapping",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(overlapping))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(orig_input->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(orig_output->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(out_backprop->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(row_pooling_sequence->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(col_pooling_sequence->GetAnchor(), node->GetInDataAnchor(4)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsFresnelCos(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FresnelCos")
.Name(("FresnelCos_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsFresnelSin(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FresnelSin")
.Name(("FresnelSin_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsFullyConnection(EsbTensor *x, EsbTensor *w, EsbTensor *b, EsbTensor *offset_w, int64_t num_output, bool transpose, int64_t axis, int64_t offset_x) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(w);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FullyConnection")
.Name(("FullyConnection_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"w", ge::kIrInputRequired, ""},
{"b", ge::kIrInputOptional, ""},
{"offset_w", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_output",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_output))
},
{
"transpose",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(transpose))
},
{
"axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
{
"offset_x",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(offset_x))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(w->GetAnchor(), node->GetInDataAnchor(1)));
if (b != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(b->GetAnchor(), node->GetInDataAnchor(2)));
}
if (offset_w != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset_w->GetAnchor(), node->GetInDataAnchor(3)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsFullyConnectionCompress(EsbTensor *x, EsbTensor *w, EsbTensor *comress_index, EsbTensor *b, EsbTensor *offset_w, int64_t num_output, bool transpose, int64_t axis, int64_t offset_x) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(w);
GE_ASSERT_NOTNULL(comress_index);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FullyConnectionCompress")
.Name(("FullyConnectionCompress_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"w", ge::kIrInputRequired, ""},
{"comress_index", ge::kIrInputRequired, ""},
{"b", ge::kIrInputOptional, ""},
{"offset_w", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_output",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_output))
},
{
"transpose",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(transpose))
},
{
"axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
{
"offset_x",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(offset_x))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(w->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(comress_index->GetAnchor(), node->GetInDataAnchor(2)));
if (b != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(b->GetAnchor(), node->GetInDataAnchor(3)));
}
if (offset_w != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset_w->GetAnchor(), node->GetInDataAnchor(4)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsFusedBatchNormV2Output EsFusedBatchNormV2(EsbTensor *x, EsbTensor *scale, EsbTensor *offset, EsbTensor *mean, EsbTensor *variance, float epsilon, const char *data_format, bool is_training, float exponential_avg_factor) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(scale);
GE_ASSERT_NOTNULL(offset);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FusedBatchNormV2")
.Name(("FusedBatchNormV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"scale", ge::kIrInputRequired, ""},
{"offset", ge::kIrInputRequired, ""},
{"mean", ge::kIrInputOptional, ""},
{"variance", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"batch_mean", ge::kIrOutputRequired, ""},
{"batch_variance", ge::kIrOutputRequired, ""},
{"reserve_space_1", ge::kIrOutputRequired, ""},
{"reserve_space_2", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"is_training",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_training))
},
{
"exponential_avg_factor",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(exponential_avg_factor))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset->GetAnchor(), node->GetInDataAnchor(2)));
if (mean != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(3)));
}
if (variance != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(variance->GetAnchor(), node->GetInDataAnchor(4)));
}
return EsFusedBatchNormV2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
};
}
EsbTensor *EsFusedBiasLeakyRelu(EsbTensor *x, EsbTensor *bias, float negative_slope, float scale) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(bias);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FusedBiasLeakyRelu")
.Name(("FusedBiasLeakyRelu_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"negative_slope",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(negative_slope))
},
{
"scale",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(scale))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsFusedBiasLeakyReluGrad(EsbTensor *y_grad, EsbTensor *features, float negative_slope, float scale) {
GE_ASSERT_NOTNULL(y_grad);
GE_ASSERT_NOTNULL(features);
auto &graph = y_grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FusedBiasLeakyReluGrad")
.Name(("FusedBiasLeakyReluGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"y_grad", ge::kIrInputRequired, ""},
{"features", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"x_grad", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"negative_slope",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(negative_slope))
},
{
"scale",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(scale))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y_grad->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(features->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsFusedInferAttentionScoreOutput EsFusedInferAttentionScore(EsbTensor *query, EsbTensor **key, int64_t key_num, EsbTensor **value, int64_t value_num, EsbTensor *pse_shift, EsbTensor *atten_mask, EsbTensor *actual_seq_lengths, EsbTensor *actual_seq_lengths_kv, EsbTensor *dequant_scale1, EsbTensor *quant_scale1, EsbTensor *dequant_scale2, EsbTensor *quant_scale2, EsbTensor *quant_offset2, EsbTensor *antiquant_scale, EsbTensor *antiquant_offset, EsbTensor *block_table, EsbTensor *query_padding_size, EsbTensor *kv_padding_size, EsbTensor *key_antiquant_scale, EsbTensor *key_antiquant_offset, EsbTensor *value_antiquant_scale, EsbTensor *value_antiquant_offset, EsbTensor *key_shared_prefix, EsbTensor *value_shared_prefix, EsbTensor *actual_shared_prefix_len, int64_t num_heads, float scale, int64_t pre_tokens, int64_t next_tokens, const char *input_layout, int64_t num_key_value_heads, int64_t sparse_mode, int64_t inner_precise, int64_t block_size, int64_t antiquant_mode, bool softmax_lse_flag, int64_t key_antiquant_mode, int64_t value_antiquant_mode) {
GE_ASSERT_NOTNULL(query);
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(key_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(value_num));
auto &graph = query->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FusedInferAttentionScore")
.Name(("FusedInferAttentionScore_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"query", ge::kIrInputRequired, ""},
{"key", ge::kIrInputDynamic, ""},
{"value", ge::kIrInputDynamic, ""},
{"pse_shift", ge::kIrInputOptional, ""},
{"atten_mask", ge::kIrInputOptional, ""},
{"actual_seq_lengths", ge::kIrInputOptional, ""},
{"actual_seq_lengths_kv", ge::kIrInputOptional, ""},
{"dequant_scale1", ge::kIrInputOptional, ""},
{"quant_scale1", ge::kIrInputOptional, ""},
{"dequant_scale2", ge::kIrInputOptional, ""},
{"quant_scale2", ge::kIrInputOptional, ""},
{"quant_offset2", ge::kIrInputOptional, ""},
{"antiquant_scale", ge::kIrInputOptional, ""},
{"antiquant_offset", ge::kIrInputOptional, ""},
{"block_table", ge::kIrInputOptional, ""},
{"query_padding_size", ge::kIrInputOptional, ""},
{"kv_padding_size", ge::kIrInputOptional, ""},
{"key_antiquant_scale", ge::kIrInputOptional, ""},
{"key_antiquant_offset", ge::kIrInputOptional, ""},
{"value_antiquant_scale", ge::kIrInputOptional, ""},
{"value_antiquant_offset", ge::kIrInputOptional, ""},
{"key_shared_prefix", ge::kIrInputOptional, ""},
{"value_shared_prefix", ge::kIrInputOptional, ""},
{"actual_shared_prefix_len", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"attention_out", ge::kIrOutputRequired, ""},
{"softmax_lse", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_heads",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_heads))
},
{
"scale",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(scale))
},
{
"pre_tokens",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pre_tokens))
},
{
"next_tokens",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(next_tokens))
},
{
"input_layout",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(input_layout))
},
{
"num_key_value_heads",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_key_value_heads))
},
{
"sparse_mode",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(sparse_mode))
},
{
"inner_precise",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(inner_precise))
},
{
"block_size",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(block_size))
},
{
"antiquant_mode",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(antiquant_mode))
},
{
"softmax_lse_flag",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(softmax_lse_flag))
},
{
"key_antiquant_mode",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(key_antiquant_mode))
},
{
"value_antiquant_mode",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(value_antiquant_mode))
},
})
.InstanceDynamicInputNum("key", static_cast<int32_t>(key_num))
.InstanceDynamicInputNum("value", static_cast<int32_t>(value_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(query->GetAnchor(), node->GetInDataAnchor(0)));
if ((key != nullptr) && (key_num > 0)) {
for (int64_t i = 0; i < key_num; ++i) {
auto one_key = key[i];
GE_ASSERT_NOTNULL(one_key);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_key->GetAnchor(), node->GetInDataAnchor(1 + i)));
}
}
if ((value != nullptr) && (value_num > 0)) {
for (int64_t i = 0; i < value_num; ++i) {
auto one_value = value[i];
GE_ASSERT_NOTNULL(one_value);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_value->GetAnchor(), node->GetInDataAnchor(1 + key_num + i)));
}
}
if (pse_shift != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(pse_shift->GetAnchor(), node->GetInDataAnchor(1 + key_num + value_num)));
}
if (atten_mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(atten_mask->GetAnchor(), node->GetInDataAnchor(2 + key_num + value_num)));
}
if (actual_seq_lengths != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(actual_seq_lengths->GetAnchor(), node->GetInDataAnchor(3 + key_num + value_num)));
}
if (actual_seq_lengths_kv != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(actual_seq_lengths_kv->GetAnchor(), node->GetInDataAnchor(4 + key_num + value_num)));
}
if (dequant_scale1 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dequant_scale1->GetAnchor(), node->GetInDataAnchor(5 + key_num + value_num)));
}
if (quant_scale1 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(quant_scale1->GetAnchor(), node->GetInDataAnchor(6 + key_num + value_num)));
}
if (dequant_scale2 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dequant_scale2->GetAnchor(), node->GetInDataAnchor(7 + key_num + value_num)));
}
if (quant_scale2 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(quant_scale2->GetAnchor(), node->GetInDataAnchor(8 + key_num + value_num)));
}
if (quant_offset2 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(quant_offset2->GetAnchor(), node->GetInDataAnchor(9 + key_num + value_num)));
}
if (antiquant_scale != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(antiquant_scale->GetAnchor(), node->GetInDataAnchor(10 + key_num + value_num)));
}
if (antiquant_offset != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(antiquant_offset->GetAnchor(), node->GetInDataAnchor(11 + key_num + value_num)));
}
if (block_table != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(block_table->GetAnchor(), node->GetInDataAnchor(12 + key_num + value_num)));
}
if (query_padding_size != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(query_padding_size->GetAnchor(), node->GetInDataAnchor(13 + key_num + value_num)));
}
if (kv_padding_size != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(kv_padding_size->GetAnchor(), node->GetInDataAnchor(14 + key_num + value_num)));
}
if (key_antiquant_scale != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(key_antiquant_scale->GetAnchor(), node->GetInDataAnchor(15 + key_num + value_num)));
}
if (key_antiquant_offset != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(key_antiquant_offset->GetAnchor(), node->GetInDataAnchor(16 + key_num + value_num)));
}
if (value_antiquant_scale != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value_antiquant_scale->GetAnchor(), node->GetInDataAnchor(17 + key_num + value_num)));
}
if (value_antiquant_offset != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value_antiquant_offset->GetAnchor(), node->GetInDataAnchor(18 + key_num + value_num)));
}
if (key_shared_prefix != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(key_shared_prefix->GetAnchor(), node->GetInDataAnchor(19 + key_num + value_num)));
}
if (value_shared_prefix != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value_shared_prefix->GetAnchor(), node->GetInDataAnchor(20 + key_num + value_num)));
}
if (actual_shared_prefix_len != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(actual_shared_prefix_len->GetAnchor(), node->GetInDataAnchor(21 + key_num + value_num)));
}
return EsFusedInferAttentionScoreOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsFusedMulAdd(EsbTensor *x1, EsbTensor *x2, EsbTensor *x3) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
GE_ASSERT_NOTNULL(x3);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FusedMulAdd")
.Name(("FusedMulAdd_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"x3", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x3->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsFusedMulAddAdd(EsbTensor *x1, EsbTensor *x2, EsbTensor *x3, EsbTensor *x4) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
GE_ASSERT_NOTNULL(x3);
GE_ASSERT_NOTNULL(x4);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FusedMulAddAdd")
.Name(("FusedMulAddAdd_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"x3", ge::kIrInputRequired, ""},
{"x4", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x3->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x4->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsFusedMulAddN(EsbTensor *x1, EsbTensor *x2, EsbTensor *x3) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
GE_ASSERT_NOTNULL(x3);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FusedMulAddN")
.Name(("FusedMulAddN_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"x3", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x3->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsFusedMulAddNL2lossOutput EsFusedMulAddNL2loss(EsbTensor *x1, EsbTensor *x2, EsbTensor *x3) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
GE_ASSERT_NOTNULL(x3);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FusedMulAddNL2loss")
.Name(("FusedMulAddNL2loss_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"x3", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y1", ge::kIrOutputRequired, ""},
{"y2", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x3->GetAnchor(), node->GetInDataAnchor(2)));
return EsFusedMulAddNL2lossOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsFusedMulApplyKerasMomentumOutput EsFusedMulApplyKerasMomentum(EsbTensor *var, EsbTensor *accum, EsbTensor *lr, EsbTensor *x1, EsbTensor *momentum, EsbTensor *x2, bool use_locking, bool use_nesterov) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(accum);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(momentum);
GE_ASSERT_NOTNULL(x2);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FusedMulApplyKerasMomentum")
.Name(("FusedMulApplyKerasMomentum_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"accum", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"x1", ge::kIrInputRequired, ""},
{"momentum", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"accum", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
{
"use_nesterov",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_nesterov))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(momentum->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(5)));
return EsFusedMulApplyKerasMomentumOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsFusedMulApplyMomentumOutput EsFusedMulApplyMomentum(EsbTensor *var, EsbTensor *accum, EsbTensor *lr, EsbTensor *x1, EsbTensor *momentum, EsbTensor *x2, bool use_nesterov, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(accum);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(momentum);
GE_ASSERT_NOTNULL(x2);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FusedMulApplyMomentum")
.Name(("FusedMulApplyMomentum_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"accum", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"x1", ge::kIrInputRequired, ""},
{"momentum", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"accum", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_nesterov",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_nesterov))
},
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(momentum->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(5)));
return EsFusedMulApplyMomentumOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsFusedMulApplyMomentumExternOutput EsFusedMulApplyMomentumExtern(EsbTensor *var, EsbTensor *accum, EsbTensor *lr, EsbTensor *x1, EsbTensor *momentum, EsbTensor *x2, EsbTensor *var_copy, bool use_nesterov, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(accum);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(momentum);
GE_ASSERT_NOTNULL(x2);
GE_ASSERT_NOTNULL(var_copy);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("FusedMulApplyMomentumExtern")
.Name(("FusedMulApplyMomentumExtern_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"accum", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"x1", ge::kIrInputRequired, ""},
{"momentum", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"var_copy", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"var_copy", ge::kIrOutputRequired, ""},
{"accum", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_nesterov",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_nesterov))
},
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(momentum->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var_copy->GetAnchor(), node->GetInDataAnchor(6)));
return EsFusedMulApplyMomentumExternOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsGEMM(EsbTensor *a, EsbTensor *b, EsbTensor *c, EsbTensor *alpha, EsbTensor *beta, bool transpose_a, bool transpose_b) {
GE_ASSERT_NOTNULL(a);
GE_ASSERT_NOTNULL(b);
GE_ASSERT_NOTNULL(c);
GE_ASSERT_NOTNULL(alpha);
GE_ASSERT_NOTNULL(beta);
auto &graph = a->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GEMM")
.Name(("GEMM_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"a", ge::kIrInputRequired, ""},
{"b", ge::kIrInputRequired, ""},
{"c", ge::kIrInputRequired, ""},
{"alpha", ge::kIrInputRequired, ""},
{"beta", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"transpose_a",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(transpose_a))
},
{
"transpose_b",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(transpose_b))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(a->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(b->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(c->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(alpha->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta->GetAnchor(), node->GetInDataAnchor(4)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsGIoU(EsbTensor *bboxes, EsbTensor *gtboxes, bool trans, bool is_cross, const char *mode) {
GE_ASSERT_NOTNULL(bboxes);
GE_ASSERT_NOTNULL(gtboxes);
auto &graph = bboxes->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GIoU")
.Name(("GIoU_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"bboxes", ge::kIrInputRequired, ""},
{"gtboxes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"overlap", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"trans",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(trans))
},
{
"is_cross",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_cross))
},
{
"mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bboxes->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gtboxes->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsGIoUGradOutput EsGIoUGrad(EsbTensor *dy, EsbTensor *bboxes, EsbTensor *gtboxes, bool trans, bool is_cross, const char *mode) {
GE_ASSERT_NOTNULL(dy);
GE_ASSERT_NOTNULL(bboxes);
GE_ASSERT_NOTNULL(gtboxes);
auto &graph = dy->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GIoUGrad")
.Name(("GIoUGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"dy", ge::kIrInputRequired, ""},
{"bboxes", ge::kIrInputRequired, ""},
{"gtboxes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"dbboxes", ge::kIrOutputRequired, ""},
{"dgtboxes", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"trans",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(trans))
},
{
"is_cross",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_cross))
},
{
"mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bboxes->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gtboxes->GetAnchor(), node->GetInDataAnchor(2)));
return EsGIoUGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsGLU(EsbTensor *x, int64_t dim) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GLU")
.Name(("GLU_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dim",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dim))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsGLUGrad(EsbTensor *y_grad, EsbTensor *x, int64_t dim) {
GE_ASSERT_NOTNULL(y_grad);
GE_ASSERT_NOTNULL(x);
auto &graph = y_grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GLUGrad")
.Name(("GLUGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"y_grad", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"x_grad", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dim",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dim))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y_grad->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsGNTrainingReduceOutput EsGNTrainingReduce(EsbTensor *x, int64_t num_groups) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GNTrainingReduce")
.Name(("GNTrainingReduce_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"sum", ge::kIrOutputRequired, ""},
{"square_sum", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_groups",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_groups))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return EsGNTrainingReduceOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsGNTrainingUpdateOutput EsGNTrainingUpdate(EsbTensor *x, EsbTensor *sum, EsbTensor *square_sum, EsbTensor *scale, EsbTensor *offset, EsbTensor *mean, EsbTensor *variance, int64_t num_groups, float epsilon) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(sum);
GE_ASSERT_NOTNULL(square_sum);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GNTrainingUpdate")
.Name(("GNTrainingUpdate_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"sum", ge::kIrInputRequired, ""},
{"square_sum", ge::kIrInputRequired, ""},
{"scale", ge::kIrInputOptional, ""},
{"offset", ge::kIrInputOptional, ""},
{"mean", ge::kIrInputOptional, ""},
{"variance", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"batch_mean", ge::kIrOutputRequired, ""},
{"batch_variance", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_groups",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_groups))
},
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(square_sum->GetAnchor(), node->GetInDataAnchor(2)));
if (scale != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(3)));
}
if (offset != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset->GetAnchor(), node->GetInDataAnchor(4)));
}
if (mean != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(5)));
}
if (variance != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(variance->GetAnchor(), node->GetInDataAnchor(6)));
}
return EsGNTrainingUpdateOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsGRUV2HiddenGradCellOutput EsGRUV2HiddenGradCell(EsbTensor *dh_pre_t, EsbTensor *h, EsbTensor *dy, EsbTensor *dh, EsbTensor *update, EsbTensor *reset, EsbTensor *in_new, EsbTensor *hidden_new, EsbTensor *seq_length, int64_t t_state, const char *gate_order) {
GE_ASSERT_NOTNULL(dh_pre_t);
GE_ASSERT_NOTNULL(h);
GE_ASSERT_NOTNULL(dy);
GE_ASSERT_NOTNULL(dh);
GE_ASSERT_NOTNULL(update);
GE_ASSERT_NOTNULL(reset);
GE_ASSERT_NOTNULL(in_new);
GE_ASSERT_NOTNULL(hidden_new);
auto &graph = dh_pre_t->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GRUV2HiddenGradCell")
.Name(("GRUV2HiddenGradCell_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"dh_pre_t", ge::kIrInputRequired, ""},
{"h", ge::kIrInputRequired, ""},
{"dy", ge::kIrInputRequired, ""},
{"dh", ge::kIrInputRequired, ""},
{"update", ge::kIrInputRequired, ""},
{"reset", ge::kIrInputRequired, ""},
{"new", ge::kIrInputRequired, ""},
{"hidden_new", ge::kIrInputRequired, ""},
{"seq_length", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"dh_prev", ge::kIrOutputRequired, ""},
{"dgate_h", ge::kIrOutputRequired, ""},
{"dnt_x", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"t_state",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(t_state))
},
{
"gate_order",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(gate_order))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dh_pre_t->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(h->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dh->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(update->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(reset->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(in_new->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(hidden_new->GetAnchor(), node->GetInDataAnchor(7)));
if (seq_length != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seq_length->GetAnchor(), node->GetInDataAnchor(8)));
}
return EsGRUV2HiddenGradCellOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsGather(EsbTensor *x, EsbTensor *indices, bool validate_indices, int64_t batch_dims, bool is_preprocessed, bool negative_index_support) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(indices);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Gather")
.Name(("Gather_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"validate_indices",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(validate_indices))
},
{
"batch_dims",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(batch_dims))
},
{
"is_preprocessed",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_preprocessed))
},
{
"negative_index_support",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(negative_index_support))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsGatherElements(EsbTensor *x, EsbTensor *index, int64_t dim) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(index);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GatherElements")
.Name(("GatherElements_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"index", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dim",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dim))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(index->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsGatherNd(EsbTensor *x, EsbTensor *indices, bool negative_index_support) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(indices);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GatherNd")
.Name(("GatherNd_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"negative_index_support",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(negative_index_support))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsGatherV2(EsbTensor *x, EsbTensor *indices, EsbTensor *axis, int64_t batch_dims, bool is_preprocessed, bool negative_index_support) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(axis);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GatherV2")
.Name(("GatherV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"axis", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"batch_dims",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(batch_dims))
},
{
"is_preprocessed",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_preprocessed))
},
{
"negative_index_support",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(negative_index_support))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(axis->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsGatherV2D(EsbTensor *x, EsbTensor *indices, int64_t axis) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(indices);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GatherV2D")
.Name(("GatherV2D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsGaussianBlur(EsbTensor *x, const int64_t *kernel_size, int64_t kernel_size_num, const float *sigma, int64_t sigma_num, const char *padding_mode) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GaussianBlur")
.Name(("GaussianBlur_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"kernel_size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(kernel_size, kernel_size + kernel_size_num))
},
{
"sigma",
ge::kAttrRequired,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(sigma, sigma + sigma_num))
},
{
"padding_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(padding_mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsGcd(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Gcd")
.Name(("Gcd_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsGeGluGradV2(EsbTensor *dy, EsbTensor *x, EsbTensor *gelu, int64_t dim, int64_t approximate, bool activate_left) {
GE_ASSERT_NOTNULL(dy);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(gelu);
auto &graph = dy->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GeGluGradV2")
.Name(("GeGluGradV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"dy", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"gelu", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"dx", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dim",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dim))
},
{
"approximate",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(approximate))
},
{
"activate_left",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(activate_left))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gelu->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsGeGluV2Output EsGeGluV2(EsbTensor *x, int64_t dim, int64_t approximate, bool activate_left) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GeGluV2")
.Name(("GeGluV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"gelu", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dim",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dim))
},
{
"approximate",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(approximate))
},
{
"activate_left",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(activate_left))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return EsGeGluV2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsGelu(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Gelu")
.Name(("Gelu_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsGeluGrad(EsbTensor *dy, EsbTensor *x, EsbTensor *y) {
GE_ASSERT_NOTNULL(dy);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(y);
auto &graph = dy->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GeluGrad")
.Name(("GeluGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"dy", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"y", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"z", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsGeluGradV2(EsbTensor *dy, EsbTensor *x, const char *approximate) {
GE_ASSERT_NOTNULL(dy);
GE_ASSERT_NOTNULL(x);
auto &graph = dy->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GeluGradV2")
.Name(("GeluGradV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"dy", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"z", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"approximate",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(approximate))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsGeluQuantOutput EsGeluQuant(EsbTensor *x, EsbTensor *input_scale, EsbTensor *input_offset, const char *approximate, const char *quant_mode) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GeluQuant")
.Name(("GeluQuant_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"input_scale", ge::kIrInputOptional, ""},
{"input_offset", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"out_scale", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"approximate",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(approximate))
},
{
"quant_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(quant_mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
if (input_scale != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_scale->GetAnchor(), node->GetInDataAnchor(1)));
}
if (input_offset != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_offset->GetAnchor(), node->GetInDataAnchor(2)));
}
return EsGeluQuantOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsGeluV2(EsbTensor *x, const char *approximate) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GeluV2")
.Name(("GeluV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"approximate",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(approximate))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsGemmV2(EsbTensor *a, EsbTensor *b, EsbTensor *alpha, EsbTensor *beta, EsbTensor *c, bool transpose_a, bool transpose_b) {
GE_ASSERT_NOTNULL(a);
GE_ASSERT_NOTNULL(b);
GE_ASSERT_NOTNULL(alpha);
GE_ASSERT_NOTNULL(beta);
GE_ASSERT_NOTNULL(c);
auto &graph = a->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GemmV2")
.Name(("GemmV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"a", ge::kIrInputRequired, ""},
{"b", ge::kIrInputRequired, ""},
{"alpha", ge::kIrInputRequired, ""},
{"beta", ge::kIrInputRequired, ""},
{"c", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"c", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"transpose_a",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(transpose_a))
},
{
"transpose_b",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(transpose_b))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(a->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(b->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(alpha->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(c->GetAnchor(), node->GetInDataAnchor(4)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsGenADC(EsbTensor *query, EsbTensor *code_book, EsbTensor *centroids, EsbTensor *bucket_list, const char *distance_type) {
GE_ASSERT_NOTNULL(query);
GE_ASSERT_NOTNULL(code_book);
GE_ASSERT_NOTNULL(centroids);
GE_ASSERT_NOTNULL(bucket_list);
auto &graph = query->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GenADC")
.Name(("GenADC_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"query", ge::kIrInputRequired, ""},
{"code_book", ge::kIrInputRequired, ""},
{"centroids", ge::kIrInputRequired, ""},
{"bucket_list", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"adc_tables", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"distance_type",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(distance_type))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(query->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(code_book->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(centroids->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bucket_list->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsGenerateBoundingBoxProposalsOutput EsGenerateBoundingBoxProposals(EsbTensor *scores, EsbTensor *bbox_deltas, EsbTensor *image_info, EsbTensor *anchors, EsbTensor *nms_threshold, EsbTensor *pre_nms_topn, EsbTensor *min_size, int64_t post_nms_topn) {
GE_ASSERT_NOTNULL(scores);
GE_ASSERT_NOTNULL(bbox_deltas);
GE_ASSERT_NOTNULL(image_info);
GE_ASSERT_NOTNULL(anchors);
GE_ASSERT_NOTNULL(nms_threshold);
GE_ASSERT_NOTNULL(pre_nms_topn);
GE_ASSERT_NOTNULL(min_size);
auto &graph = scores->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GenerateBoundingBoxProposals")
.Name(("GenerateBoundingBoxProposals_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"scores", ge::kIrInputRequired, ""},
{"bbox_deltas", ge::kIrInputRequired, ""},
{"image_info", ge::kIrInputRequired, ""},
{"anchors", ge::kIrInputRequired, ""},
{"nms_threshold", ge::kIrInputRequired, ""},
{"pre_nms_topn", ge::kIrInputRequired, ""},
{"min_size", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"rois", ge::kIrOutputRequired, ""},
{"rois_probabilities", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"post_nms_topn",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(post_nms_topn))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scores->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bbox_deltas->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(image_info->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(anchors->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(nms_threshold->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(pre_nms_topn->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(min_size->GetAnchor(), node->GetInDataAnchor(6)));
return EsGenerateBoundingBoxProposalsOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsGeometric(EsbTensor *x, float p, int64_t seed) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Geometric")
.Name(("Geometric_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"p",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(p))
},
{
"seed",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsGer(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Ger")
.Name(("Ger_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsGetDynamicDims(EsbTensor **input, int64_t input_num, const int64_t *shape_info, int64_t shape_info_num, int64_t N) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(input_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < input_num; ++i) {
if (input[i] != nullptr) {
non_null_in = input[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GetDynamicDims")
.Name(("GetDynamicDims_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
{"dims", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"shape_info",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(shape_info, shape_info + shape_info_num))
},
{
"N",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(N))
},
})
.InstanceDynamicInputNum("input", static_cast<int32_t>(input_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((input != nullptr) && (input_num > 0)) {
for (int64_t i = 0; i < input_num; ++i) {
auto one_input = input[i];
GE_ASSERT_NOTNULL(one_input);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_input->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsGetShape(EsbTensor **x, int64_t x_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GetShape")
.Name(("GetShape_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsGlobalAveragePool(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GlobalAveragePool")
.Name(("GlobalAveragePool_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsGlobalLpPool(EsbTensor *x, float p) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GlobalLpPool")
.Name(("GlobalLpPool_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"p",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(p))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsGreater(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Greater")
.Name(("Greater_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsGreaterEqual(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GreaterEqual")
.Name(("GreaterEqual_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsGridAssignPositive(EsbTensor *assigned_gt_inds, EsbTensor *overlaps, EsbTensor *box_responsible_flags, EsbTensor *max_overlaps, EsbTensor *argmax_overlaps, EsbTensor *gt_max_overlaps, EsbTensor *gt_argmax_overlaps, EsbTensor *num_gts, float pos_iou_thr, float min_pos_iou, bool gt_max_assign_all) {
GE_ASSERT_NOTNULL(assigned_gt_inds);
GE_ASSERT_NOTNULL(overlaps);
GE_ASSERT_NOTNULL(box_responsible_flags);
GE_ASSERT_NOTNULL(max_overlaps);
GE_ASSERT_NOTNULL(argmax_overlaps);
GE_ASSERT_NOTNULL(gt_max_overlaps);
GE_ASSERT_NOTNULL(gt_argmax_overlaps);
GE_ASSERT_NOTNULL(num_gts);
auto &graph = assigned_gt_inds->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GridAssignPositive")
.Name(("GridAssignPositive_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"assigned_gt_inds", ge::kIrInputRequired, ""},
{"overlaps", ge::kIrInputRequired, ""},
{"box_responsible_flags", ge::kIrInputRequired, ""},
{"max_overlaps", ge::kIrInputRequired, ""},
{"argmax_overlaps", ge::kIrInputRequired, ""},
{"gt_max_overlaps", ge::kIrInputRequired, ""},
{"gt_argmax_overlaps", ge::kIrInputRequired, ""},
{"num_gts", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"assigned_gt_inds_pos", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"pos_iou_thr",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(pos_iou_thr))
},
{
"min_pos_iou",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(min_pos_iou))
},
{
"gt_max_assign_all",
ge::kAttrRequired,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(gt_max_assign_all))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(assigned_gt_inds->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(overlaps->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(box_responsible_flags->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(max_overlaps->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(argmax_overlaps->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gt_max_overlaps->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gt_argmax_overlaps->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(num_gts->GetAnchor(), node->GetInDataAnchor(7)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsGridSample(EsbTensor *x, EsbTensor *grid, const char *interpolation_mode, const char *padding_mode, bool align_corners, bool channel_last, int64_t scheduler_mode) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(grid);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GridSample")
.Name(("GridSample_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"grid", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"interpolation_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(interpolation_mode))
},
{
"padding_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(padding_mode))
},
{
"align_corners",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(align_corners))
},
{
"channel_last",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(channel_last))
},
{
"scheduler_mode",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(scheduler_mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grid->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsGridSampler2D(EsbTensor *x, EsbTensor *grid, const char *interpolation_mode, const char *padding_mode, bool align_corners) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(grid);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GridSampler2D")
.Name(("GridSampler2D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"grid", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"interpolation_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(interpolation_mode))
},
{
"padding_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(padding_mode))
},
{
"align_corners",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(align_corners))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grid->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsGridSampler2DGradOutput EsGridSampler2DGrad(EsbTensor *grad, EsbTensor *x, EsbTensor *grid, const char *interpolation_mode, const char *padding_mode, bool align_corners) {
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(grid);
auto &graph = grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GridSampler2DGrad")
.Name(("GridSampler2DGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grad", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"grid", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"dx", ge::kIrOutputRequired, ""},
{"dgrid", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"interpolation_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(interpolation_mode))
},
{
"padding_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(padding_mode))
},
{
"align_corners",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(align_corners))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grid->GetAnchor(), node->GetInDataAnchor(2)));
return EsGridSampler2DGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsGridSampler3D(EsbTensor *x, EsbTensor *grid, const char *interpolation_mode, const char *padding_mode, const char *data_format, bool align_corners) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(grid);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GridSampler3D")
.Name(("GridSampler3D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"grid", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"interpolation_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(interpolation_mode))
},
{
"padding_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(padding_mode))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"align_corners",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(align_corners))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grid->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsGridSampler3DGradOutput EsGridSampler3DGrad(EsbTensor *grad, EsbTensor *x, EsbTensor *grid, const char *interpolation_mode, const char *padding_mode, bool align_corners) {
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(grid);
auto &graph = grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GridSampler3DGrad")
.Name(("GridSampler3DGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grad", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"grid", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"dx", ge::kIrOutputRequired, ""},
{"dgrid", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"interpolation_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(interpolation_mode))
},
{
"padding_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(padding_mode))
},
{
"align_corners",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(align_corners))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grid->GetAnchor(), node->GetInDataAnchor(2)));
return EsGridSampler3DGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsGridUnnormalOutput EsGridUnnormal(EsbTensor *grid, EsbTensor *assist, bool align_corners) {
GE_ASSERT_NOTNULL(grid);
GE_ASSERT_NOTNULL(assist);
auto &graph = grid->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GridUnnormal")
.Name(("GridUnnormal_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grid", ge::kIrInputRequired, ""},
{"assist", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"diff", ge::kIrOutputRequired, ""},
{"position", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"align_corners",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(align_corners))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grid->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(assist->GetAnchor(), node->GetInDataAnchor(1)));
return EsGridUnnormalOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsGroupNormOutput EsGroupNorm(EsbTensor *x, EsbTensor *gamma, EsbTensor *beta, int64_t num_groups, const char *data_format, float eps, bool is_training) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(gamma);
GE_ASSERT_NOTNULL(beta);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GroupNorm")
.Name(("GroupNorm_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
{"beta", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"mean", ge::kIrOutputRequired, ""},
{"variance", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_groups",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_groups))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"eps",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(eps))
},
{
"is_training",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_training))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta->GetAnchor(), node->GetInDataAnchor(2)));
return EsGroupNormOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsGroupNormGradOutput EsGroupNormGrad(EsbTensor *dy, EsbTensor *mean, EsbTensor *rstd, EsbTensor *x, EsbTensor *gamma, int64_t num_groups, const char *data_format, bool dx_is_require, bool dgamma_is_require, bool dbeta_is_require) {
GE_ASSERT_NOTNULL(dy);
GE_ASSERT_NOTNULL(mean);
GE_ASSERT_NOTNULL(rstd);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(gamma);
auto &graph = dy->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GroupNormGrad")
.Name(("GroupNormGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"dy", ge::kIrInputRequired, ""},
{"mean", ge::kIrInputRequired, ""},
{"rstd", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"dx", ge::kIrOutputRequired, ""},
{"dgamma", ge::kIrOutputRequired, ""},
{"dbeta", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_groups",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_groups))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"dx_is_require",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(dx_is_require))
},
{
"dgamma_is_require",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(dgamma_is_require))
},
{
"dbeta_is_require",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(dbeta_is_require))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rstd->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(4)));
return EsGroupNormGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsGroupNormRelu(EsbTensor *x, EsbTensor *gamma, EsbTensor *beta, int64_t num_groups, float eps) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(gamma);
GE_ASSERT_NOTNULL(beta);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GroupNormRelu")
.Name(("GroupNormRelu_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
{"beta", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_groups",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_groups))
},
{
"eps",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(eps))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsGroupNormSiluOutput EsGroupNormSilu(EsbTensor *x, EsbTensor *gamma, EsbTensor *beta, int64_t num_groups, float eps, bool activate_silu) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GroupNormSilu")
.Name(("GroupNormSilu_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputOptional, ""},
{"beta", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"mean", ge::kIrOutputRequired, ""},
{"rstd", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_groups",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_groups))
},
{
"eps",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(eps))
},
{
"activate_silu",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(activate_silu))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
if (gamma != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(1)));
}
if (beta != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta->GetAnchor(), node->GetInDataAnchor(2)));
}
return EsGroupNormSiluOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsGroupNormSwishOutput EsGroupNormSwish(EsbTensor *x, EsbTensor *gamma, EsbTensor *beta, int64_t num_groups, const char *data_format, float eps, bool activate_swish, float swish_scale) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(gamma);
GE_ASSERT_NOTNULL(beta);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GroupNormSwish")
.Name(("GroupNormSwish_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
{"beta", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"mean", ge::kIrOutputRequired, ""},
{"rstd", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_groups",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_groups))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"eps",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(eps))
},
{
"activate_swish",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(activate_swish))
},
{
"swish_scale",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(swish_scale))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta->GetAnchor(), node->GetInDataAnchor(2)));
return EsGroupNormSwishOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsGroupNormSwishGradOutput EsGroupNormSwishGrad(EsbTensor *dy, EsbTensor *mean, EsbTensor *rstd, EsbTensor *x, EsbTensor *gamma, EsbTensor *beta, int64_t num_groups, const char *data_format, float swish_scale, bool dgamma_is_require, bool dbeta_is_require) {
GE_ASSERT_NOTNULL(dy);
GE_ASSERT_NOTNULL(mean);
GE_ASSERT_NOTNULL(rstd);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(gamma);
GE_ASSERT_NOTNULL(beta);
auto &graph = dy->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GroupNormSwishGrad")
.Name(("GroupNormSwishGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"dy", ge::kIrInputRequired, ""},
{"mean", ge::kIrInputRequired, ""},
{"rstd", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
{"beta", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"dx", ge::kIrOutputRequired, ""},
{"dgamma", ge::kIrOutputRequired, ""},
{"dbeta", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_groups",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_groups))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"swish_scale",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(swish_scale))
},
{
"dgamma_is_require",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(dgamma_is_require))
},
{
"dbeta_is_require",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(dbeta_is_require))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rstd->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta->GetAnchor(), node->GetInDataAnchor(5)));
return EsGroupNormSwishGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsGroupNormV2Output EsGroupNormV2(EsbTensor *x, EsbTensor *gamma, EsbTensor *beta, int64_t num_groups, const char *data_format, float eps, bool is_training) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(gamma);
GE_ASSERT_NOTNULL(beta);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GroupNormV2")
.Name(("GroupNormV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
{"beta", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"mean", ge::kIrOutputRequired, ""},
{"rstd", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_groups",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_groups))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"eps",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(eps))
},
{
"is_training",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_training))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta->GetAnchor(), node->GetInDataAnchor(2)));
return EsGroupNormV2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsGroupQuant(EsbTensor *x, EsbTensor *scale, EsbTensor *group_index, EsbTensor *offset, int64_t dst_type) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(scale);
GE_ASSERT_NOTNULL(group_index);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GroupQuant")
.Name(("GroupQuant_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"scale", ge::kIrInputRequired, ""},
{"group_index", ge::kIrInputRequired, ""},
{"offset", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dst_type",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dst_type))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(group_index->GetAnchor(), node->GetInDataAnchor(2)));
if (offset != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset->GetAnchor(), node->GetInDataAnchor(3)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsGroupedBiasAddGrad(EsbTensor *grad_y, EsbTensor *group_idx, int64_t group_idx_type) {
GE_ASSERT_NOTNULL(grad_y);
auto &graph = grad_y->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GroupedBiasAddGrad")
.Name(("GroupedBiasAddGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grad_y", ge::kIrInputRequired, ""},
{"group_idx", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"grad_bias", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"group_idx_type",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(group_idx_type))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad_y->GetAnchor(), node->GetInDataAnchor(0)));
if (group_idx != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(group_idx->GetAnchor(), node->GetInDataAnchor(1)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsGuaranteeConst(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("GuaranteeConst")
.Name(("GuaranteeConst_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsHSVToRGB(EsbTensor *images) {
GE_ASSERT_NOTNULL(images);
auto &graph = images->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("HSVToRGB")
.Name(("HSVToRGB_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"images", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(images->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsHardMax(EsbTensor *x, int64_t axis) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("HardMax")
.Name(("HardMax_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsHardShrink(EsbTensor *input_x, float lambd) {
GE_ASSERT_NOTNULL(input_x);
auto &graph = input_x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("HardShrink")
.Name(("HardShrink_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"lambd",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(lambd))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsHardShrinkGrad(EsbTensor *gradients, EsbTensor *features, float lambd) {
GE_ASSERT_NOTNULL(gradients);
GE_ASSERT_NOTNULL(features);
auto &graph = gradients->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("HardShrinkGrad")
.Name(("HardShrinkGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"gradients", ge::kIrInputRequired, ""},
{"features", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"backprops", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"lambd",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(lambd))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gradients->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(features->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsHardSigmoid(EsbTensor *input_x, float alpha, float beta) {
GE_ASSERT_NOTNULL(input_x);
auto &graph = input_x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("HardSigmoid")
.Name(("HardSigmoid_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"alpha",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(alpha))
},
{
"beta",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(beta))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsHardSigmoidGrad(EsbTensor *grads, EsbTensor *input_x, float alpha, float beta) {
GE_ASSERT_NOTNULL(grads);
GE_ASSERT_NOTNULL(input_x);
auto &graph = grads->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("HardSigmoidGrad")
.Name(("HardSigmoidGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grads", ge::kIrInputRequired, ""},
{"input_x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"alpha",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(alpha))
},
{
"beta",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(beta))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grads->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_x->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsHardSwish(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("HardSwish")
.Name(("HardSwish_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsHardSwishGrad(EsbTensor *grad, EsbTensor *x) {
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(x);
auto &graph = grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("HardSwishGrad")
.Name(("HardSwishGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grad", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsHardtanhGrad(EsbTensor *result, EsbTensor *grad, float min_val, float max_val) {
GE_ASSERT_NOTNULL(result);
GE_ASSERT_NOTNULL(grad);
auto &graph = result->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("HardtanhGrad")
.Name(("HardtanhGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"result", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"min_val",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(min_val))
},
{
"max_val",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(max_val))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(result->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsHashTable(EsbGraph *owner_graph, ge::DataType key_dtype, ge::DataType value_dtype, const char *container, const char *shared_name, bool use_node_name_sharing) {
GE_ASSERT_NOTNULL(owner_graph);
EsbGraph &graph = *owner_graph;

auto desc = ge::CompliantOpDescBuilder().OpType("HashTable")
.Name(("HashTable_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
})
.IrDefOutputs({
{"handle", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"key_dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(key_dtype))
},
{
"value_dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(value_dtype))
},
{
"container",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(container))
},
{
"shared_name",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(shared_name))
},
{
"use_node_name_sharing",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_node_name_sharing))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsHcomAllGather(EsbTensor *x, int64_t rank_size, const char *group, int64_t fusion, int64_t fusion_id) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("HcomAllGather")
.Name(("HcomAllGather_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"rank_size",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(rank_size))
},
{
"group",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(group))
},
{
"fusion",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(fusion))
},
{
"fusion_id",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(fusion_id))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsHcomAllReduce(EsbTensor *x, const char *reduction, const char *group, int64_t fusion, int64_t fusion_id) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("HcomAllReduce")
.Name(("HcomAllReduce_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"reduction",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduction))
},
{
"group",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(group))
},
{
"fusion",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(fusion))
},
{
"fusion_id",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(fusion_id))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsHcomAllToAll(EsbTensor *x, const char *group) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("HcomAllToAll")
.Name(("HcomAllToAll_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"group",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(group))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsHcomAllToAllV(EsbTensor *send_data, EsbTensor *send_counts, EsbTensor *send_displacements, EsbTensor *recv_counts, EsbTensor *recv_displacements, const char *group) {
GE_ASSERT_NOTNULL(send_data);
GE_ASSERT_NOTNULL(send_counts);
GE_ASSERT_NOTNULL(send_displacements);
GE_ASSERT_NOTNULL(recv_counts);
GE_ASSERT_NOTNULL(recv_displacements);
auto &graph = send_data->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("HcomAllToAllV")
.Name(("HcomAllToAllV_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"send_data", ge::kIrInputRequired, ""},
{"send_counts", ge::kIrInputRequired, ""},
{"send_displacements", ge::kIrInputRequired, ""},
{"recv_counts", ge::kIrInputRequired, ""},
{"recv_displacements", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"recv_data", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"group",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(group))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(send_data->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(send_counts->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(send_displacements->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(recv_counts->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(recv_displacements->GetAnchor(), node->GetInDataAnchor(4)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsHcomAllToAllVC(EsbTensor *send_data, EsbTensor *send_count_matrix, int64_t rank, const char *group, int64_t fusion, int64_t fusion_id) {
GE_ASSERT_NOTNULL(send_data);
GE_ASSERT_NOTNULL(send_count_matrix);
auto &graph = send_data->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("HcomAllToAllVC")
.Name(("HcomAllToAllVC_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"send_data", ge::kIrInputRequired, ""},
{"send_count_matrix", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"recv_data", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"rank",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(rank))
},
{
"group",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(group))
},
{
"fusion",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(fusion))
},
{
"fusion_id",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(fusion_id))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(send_data->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(send_count_matrix->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsHcomCollRemoteLookup(EsbTensor *table_id, EsbTensor *keys, int64_t tag, int64_t max_num, int64_t embedding_dim, int64_t insert_option, const char *group, int64_t flags) {
GE_ASSERT_NOTNULL(table_id);
GE_ASSERT_NOTNULL(keys);
auto &graph = table_id->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("HcomCollRemoteLookup")
.Name(("HcomCollRemoteLookup_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"table_id", ge::kIrInputRequired, ""},
{"keys", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"values", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"tag",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(tag))
},
{
"max_num",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(max_num))
},
{
"embedding_dim",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(embedding_dim))
},
{
"insert_option",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(insert_option))
},
{
"group",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(group))
},
{
"flags",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(flags))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(table_id->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(keys->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsHcomCollRemoteLookupPairedOutput EsHcomCollRemoteLookupPaired(EsbTensor *table_id, EsbTensor *keys, int64_t tag, int64_t max_num, int64_t embedding_dim, int64_t insert_option, const char *group, int64_t flags) {
GE_ASSERT_NOTNULL(table_id);
GE_ASSERT_NOTNULL(keys);
auto &graph = table_id->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("HcomCollRemoteLookupPaired")
.Name(("HcomCollRemoteLookupPaired_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"table_id", ge::kIrInputRequired, ""},
{"keys", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"values", ge::kIrOutputRequired, ""},
{"indices", ge::kIrOutputRequired, ""},
{"num_uniqued", ge::kIrOutputRequired, ""},
{"ps_segments", ge::kIrOutputRequired, ""},
{"ps_segments_num", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"tag",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(tag))
},
{
"max_num",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(max_num))
},
{
"embedding_dim",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(embedding_dim))
},
{
"insert_option",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(insert_option))
},
{
"group",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(group))
},
{
"flags",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(flags))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(table_id->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(keys->GetAnchor(), node->GetInDataAnchor(1)));
return EsHcomCollRemoteLookupPairedOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
};
}
EsHcomCollRemoteLookupUniquedAndPairedOutput EsHcomCollRemoteLookupUniquedAndPaired(EsbTensor *table_id, EsbTensor *keys, EsbTensor *key_num_input, EsbTensor *unique_indices, EsbTensor *key_count, int64_t tag, int64_t max_num, int64_t embedding_dim, int64_t flags, int64_t insert_option, const char *group) {
GE_ASSERT_NOTNULL(table_id);
GE_ASSERT_NOTNULL(keys);
GE_ASSERT_NOTNULL(key_num_input);
GE_ASSERT_NOTNULL(unique_indices);
auto &graph = table_id->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("HcomCollRemoteLookupUniquedAndPaired")
.Name(("HcomCollRemoteLookupUniquedAndPaired_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"table_id", ge::kIrInputRequired, ""},
{"keys", ge::kIrInputRequired, ""},
{"key_num_input", ge::kIrInputRequired, ""},
{"unique_indices", ge::kIrInputRequired, ""},
{"key_count", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"values", ge::kIrOutputRequired, ""},
{"indices", ge::kIrOutputRequired, ""},
{"num_uniqued", ge::kIrOutputRequired, ""},
{"ps_segments", ge::kIrOutputRequired, ""},
{"ps_segments_num", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"tag",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(tag))
},
{
"max_num",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(max_num))
},
{
"embedding_dim",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(embedding_dim))
},
{
"flags",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(flags))
},
{
"insert_option",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(insert_option))
},
{
"group",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(group))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(table_id->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(keys->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(key_num_input->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(unique_indices->GetAnchor(), node->GetInDataAnchor(3)));
if (key_count != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(key_count->GetAnchor(), node->GetInDataAnchor(4)));
}
return EsHcomCollRemoteLookupUniquedAndPairedOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
};
}
EsbTensor *EsHcomCollRemoteUpdate(EsbTensor *table_id, EsbTensor *keys, EsbTensor *values, int64_t tag, int64_t max_num, int64_t embedding_dim, const char *group) {
GE_ASSERT_NOTNULL(table_id);
GE_ASSERT_NOTNULL(keys);
GE_ASSERT_NOTNULL(values);
auto &graph = table_id->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("HcomCollRemoteUpdate")
.Name(("HcomCollRemoteUpdate_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"table_id", ge::kIrInputRequired, ""},
{"keys", ge::kIrInputRequired, ""},
{"values", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
{
"tag",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(tag))
},
{
"max_num",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(max_num))
},
{
"embedding_dim",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(embedding_dim))
},
{
"group",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(group))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(table_id->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(keys->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(values->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsHcomCollRemoteUpdatePaired(EsbTensor *table_id, EsbTensor *keys, EsbTensor *values, EsbTensor *indices, EsbTensor *num_uniqued, EsbTensor *ps_segments, EsbTensor *ps_segments_num, EsbTensor *global_step, int64_t tag, int64_t max_num, int64_t embedding_dim, const char *group, int64_t padding_key, int64_t flags) {
GE_ASSERT_NOTNULL(table_id);
GE_ASSERT_NOTNULL(keys);
GE_ASSERT_NOTNULL(values);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(num_uniqued);
GE_ASSERT_NOTNULL(ps_segments);
GE_ASSERT_NOTNULL(ps_segments_num);
auto &graph = table_id->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("HcomCollRemoteUpdatePaired")
.Name(("HcomCollRemoteUpdatePaired_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"table_id", ge::kIrInputRequired, ""},
{"keys", ge::kIrInputRequired, ""},
{"values", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"num_uniqued", ge::kIrInputRequired, ""},
{"ps_segments", ge::kIrInputRequired, ""},
{"ps_segments_num", ge::kIrInputRequired, ""},
{"global_step", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
{
"tag",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(tag))
},
{
"max_num",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(max_num))
},
{
"embedding_dim",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(embedding_dim))
},
{
"group",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(group))
},
{
"padding_key",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(padding_key))
},
{
"flags",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(flags))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(table_id->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(keys->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(values->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(num_uniqued->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(ps_segments->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(ps_segments_num->GetAnchor(), node->GetInDataAnchor(6)));
if (global_step != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(global_step->GetAnchor(), node->GetInDataAnchor(7)));
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsHcomGather(EsbTensor *x, int64_t root_rank, const char *group, int64_t rank_size) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("HcomGather")
.Name(("HcomGather_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"root_rank",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(root_rank))
},
{
"group",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(group))
},
{
"rank_size",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(rank_size))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsHcomGatherAllToAllVOutput EsHcomGatherAllToAllV(EsbTensor *addrinfo, EsbTensor *addrinfo_count_per_rank, EsbTensor *recv_counts, EsbTensor *recv_displacements, const char *group, ge::DataType dtype, int64_t addr_length) {
GE_ASSERT_NOTNULL(addrinfo);
GE_ASSERT_NOTNULL(addrinfo_count_per_rank);
GE_ASSERT_NOTNULL(recv_counts);
GE_ASSERT_NOTNULL(recv_displacements);
auto &graph = addrinfo->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("HcomGatherAllToAllV")
.Name(("HcomGatherAllToAllV_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"addrinfo", ge::kIrInputRequired, ""},
{"addrinfo_count_per_rank", ge::kIrInputRequired, ""},
{"recv_counts", ge::kIrInputRequired, ""},
{"recv_displacements", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"recv_data", ge::kIrOutputRequired, ""},
{"gathered", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"group",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(group))
},
{
"dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
{
"addr_length",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(addr_length))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(addrinfo->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(addrinfo_count_per_rank->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(recv_counts->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(recv_displacements->GetAnchor(), node->GetInDataAnchor(3)));
return EsHcomGatherAllToAllVOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsHcomReceive(EsbGraph *owner_graph, const char *group, int64_t sr_tag, int64_t src_rank, const int64_t *shape, int64_t shape_num, ge::DataType dtype) {
GE_ASSERT_NOTNULL(owner_graph);
EsbGraph &graph = *owner_graph;

auto desc = ge::CompliantOpDescBuilder().OpType("HcomReceive")
.Name(("HcomReceive_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"group",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(group))
},
{
"sr_tag",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(sr_tag))
},
{
"src_rank",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(src_rank))
},
{
"shape",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(shape, shape + shape_num))
},
{
"dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsHcomReduce(EsbTensor *x, int64_t root_rank, const char *reduction, const char *group, int64_t fusion, int64_t fusion_id) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("HcomReduce")
.Name(("HcomReduce_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"root_rank",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(root_rank))
},
{
"reduction",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduction))
},
{
"group",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(group))
},
{
"fusion",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(fusion))
},
{
"fusion_id",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(fusion_id))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsHcomReduceScatter(EsbTensor *x, const char *reduction, const char *group, int64_t rank_size, int64_t fusion, int64_t fusion_id) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("HcomReduceScatter")
.Name(("HcomReduceScatter_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"reduction",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduction))
},
{
"group",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(group))
},
{
"rank_size",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(rank_size))
},
{
"fusion",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(fusion))
},
{
"fusion_id",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(fusion_id))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsHcomRemoteLookup(EsbTensor *keys, EsbTensor *table_id, int64_t tag, int64_t max_num, int64_t embedding_dim, int64_t insert_option) {
GE_ASSERT_NOTNULL(keys);
GE_ASSERT_NOTNULL(table_id);
auto &graph = keys->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("HcomRemoteLookup")
.Name(("HcomRemoteLookup_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"keys", ge::kIrInputRequired, ""},
{"table_id", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"values", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"tag",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(tag))
},
{
"max_num",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(max_num))
},
{
"embedding_dim",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(embedding_dim))
},
{
"insert_option",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(insert_option))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(keys->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(table_id->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsHcomRemoteRead(EsbTensor *remote, ge::DataType dtype) {
GE_ASSERT_NOTNULL(remote);
auto &graph = remote->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("HcomRemoteRead")
.Name(("HcomRemoteRead_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"remote", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"local", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(remote->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsHcomRemoteRefRead(EsbTensor *remote, EsbTensor *cache_var, EsbTensor *local_offset, ge::DataType dtype) {
GE_ASSERT_NOTNULL(remote);
GE_ASSERT_NOTNULL(cache_var);
GE_ASSERT_NOTNULL(local_offset);
auto &graph = remote->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("HcomRemoteRefRead")
.Name(("HcomRemoteRefRead_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"remote", ge::kIrInputRequired, ""},
{"cache_var", ge::kIrInputRequired, ""},
{"local_offset", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"cache_var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(remote->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(cache_var->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(local_offset->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsHcomRemoteScatterWrite(EsbTensor *remote, EsbTensor *local, EsbTensor *local_offset) {
GE_ASSERT_NOTNULL(remote);
GE_ASSERT_NOTNULL(local);
auto &graph = remote->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("HcomRemoteScatterWrite")
.Name(("HcomRemoteScatterWrite_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"remote", ge::kIrInputRequired, ""},
{"local", ge::kIrInputRequired, ""},
{"local_offset", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(remote->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(local->GetAnchor(), node->GetInDataAnchor(1)));
if (local_offset != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(local_offset->GetAnchor(), node->GetInDataAnchor(2)));
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsHcomRemoteWrite(EsbTensor *remote, EsbTensor *local) {
GE_ASSERT_NOTNULL(remote);
GE_ASSERT_NOTNULL(local);
auto &graph = remote->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("HcomRemoteWrite")
.Name(("HcomRemoteWrite_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"remote", ge::kIrInputRequired, ""},
{"local", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(remote->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(local->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsHcomSend(EsbTensor *x, const char *group, int64_t sr_tag, int64_t dest_rank) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("HcomSend")
.Name(("HcomSend_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
{
"group",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(group))
},
{
"sr_tag",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(sr_tag))
},
{
"dest_rank",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dest_rank))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsHistogram(EsbTensor *x, int64_t bins, float min, float max) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Histogram")
.Name(("Histogram_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"bins",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(bins))
},
{
"min",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(min))
},
{
"max",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(max))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsHistogramFixedWidth(EsbTensor *x, EsbTensor *range, EsbTensor *nbins, int64_t dtype) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(range);
GE_ASSERT_NOTNULL(nbins);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("HistogramFixedWidth")
.Name(("HistogramFixedWidth_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"range", ge::kIrInputRequired, ""},
{"nbins", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(range->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(nbins->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsHistogramFixedWidthD(EsbTensor *x, EsbTensor *range, int64_t nbins, int64_t dtype) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(range);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("HistogramFixedWidthD")
.Name(("HistogramFixedWidthD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"range", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"nbins",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(nbins))
},
{
"dtype",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(range->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsHistogramV2(EsbTensor *x, EsbTensor *min, EsbTensor *max, int64_t bins) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(min);
GE_ASSERT_NOTNULL(max);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("HistogramV2")
.Name(("HistogramV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"min", ge::kIrInputRequired, ""},
{"max", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"bins",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(bins))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(min->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(max->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsHorovodAllgather(EsbTensor *x, int64_t rank_size) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("HorovodAllgather")
.Name(("HorovodAllgather_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"rank_size",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(rank_size))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsHorovodAllreduce(EsbTensor *x, int64_t reduce_op) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("HorovodAllreduce")
.Name(("HorovodAllreduce_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"reduce_op",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(reduce_op))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsHorovodBroadcast(EsbTensor *x, int64_t root_rank) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("HorovodBroadcast")
.Name(("HorovodBroadcast_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"root_rank",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(root_rank))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsIFFT(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("IFFT")
.Name(("IFFT_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsIFFT2D(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("IFFT2D")
.Name(("IFFT2D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsIFMROutput EsIFMR(EsbTensor *data, EsbTensor *data_min, EsbTensor *data_max, EsbTensor *cumsum, float min_percentile, float max_percentile, const float *search_range, int64_t search_range_num, float search_step, bool with_offset, int64_t quant_bits) {
GE_ASSERT_NOTNULL(data);
GE_ASSERT_NOTNULL(data_min);
GE_ASSERT_NOTNULL(data_max);
GE_ASSERT_NOTNULL(cumsum);
auto &graph = data->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("IFMR")
.Name(("IFMR_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"data", ge::kIrInputRequired, ""},
{"data_min", ge::kIrInputRequired, ""},
{"data_max", ge::kIrInputRequired, ""},
{"cumsum", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"scale", ge::kIrOutputRequired, ""},
{"offset", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"min_percentile",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(min_percentile))
},
{
"max_percentile",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(max_percentile))
},
{
"search_range",
ge::kAttrRequired,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(search_range, search_range + search_range_num))
},
{
"search_step",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(search_step))
},
{
"with_offset",
ge::kAttrRequired,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(with_offset))
},
{
"quant_bits",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(quant_bits))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(data->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(data_min->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(data_max->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(cumsum->GetAnchor(), node->GetInDataAnchor(3)));
return EsIFMROutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsIMGWarp(EsbTensor *img, EsbTensor *warp_offset) {
GE_ASSERT_NOTNULL(img);
GE_ASSERT_NOTNULL(warp_offset);
auto &graph = img->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("IMGWarp")
.Name(("IMGWarp_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"img", ge::kIrInputRequired, ""},
{"warp_offset", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"warp_img", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(img->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(warp_offset->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsIMGWarpOffsets(EsbTensor *images, EsbTensor *offsets) {
GE_ASSERT_NOTNULL(images);
GE_ASSERT_NOTNULL(offsets);
auto &graph = images->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("IMGWarpOffsets")
.Name(("IMGWarpOffsets_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"images", ge::kIrInputRequired, ""},
{"offsets", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"warp_images", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(images->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offsets->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsIMGWarpResize(EsbTensor *img, EsbTensor *warp_index) {
GE_ASSERT_NOTNULL(img);
GE_ASSERT_NOTNULL(warp_index);
auto &graph = img->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("IMGWarpResize")
.Name(("IMGWarpResize_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"img", ge::kIrInputRequired, ""},
{"warp_index", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"warp_img", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(img->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(warp_index->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsINInferV2Output EsINInferV2(EsbTensor *x, EsbTensor *gamma, EsbTensor *beta, EsbTensor *mean, EsbTensor *variance, float epsilon) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("INInferV2")
.Name(("INInferV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputOptional, ""},
{"beta", ge::kIrInputOptional, ""},
{"mean", ge::kIrInputOptional, ""},
{"variance", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"batch_mean", ge::kIrOutputRequired, ""},
{"batch_variance", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
if (gamma != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(1)));
}
if (beta != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta->GetAnchor(), node->GetInDataAnchor(2)));
}
if (mean != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(3)));
}
if (variance != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(variance->GetAnchor(), node->GetInDataAnchor(4)));
}
return EsINInferV2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsINInferV2DOutput EsINInferV2D(EsbTensor *x, EsbTensor *gamma, EsbTensor *beta, EsbTensor *mean, EsbTensor *variance, EsbTensor *variance_sqrt) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("INInferV2D")
.Name(("INInferV2D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputOptional, ""},
{"beta", ge::kIrInputOptional, ""},
{"mean", ge::kIrInputOptional, ""},
{"variance", ge::kIrInputOptional, ""},
{"variance_sqrt", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"batch_mean", ge::kIrOutputRequired, ""},
{"batch_variance", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
if (gamma != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(1)));
}
if (beta != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta->GetAnchor(), node->GetInDataAnchor(2)));
}
if (mean != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(3)));
}
if (variance != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(variance->GetAnchor(), node->GetInDataAnchor(4)));
}
if (variance_sqrt != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(variance_sqrt->GetAnchor(), node->GetInDataAnchor(5)));
}
return EsINInferV2DOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsINTrainingReduceGrad(EsbTensor *dy, EsbTensor *x, EsbTensor *variance, EsbTensor *mean, EsbTensor *res_gamma, EsbTensor *res_beta, EsbTensor *gamma) {
GE_ASSERT_NOTNULL(dy);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(variance);
GE_ASSERT_NOTNULL(mean);
GE_ASSERT_NOTNULL(res_gamma);
GE_ASSERT_NOTNULL(res_beta);
GE_ASSERT_NOTNULL(gamma);
auto &graph = dy->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("INTrainingReduceGrad")
.Name(("INTrainingReduceGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"dy", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"variance", ge::kIrInputRequired, ""},
{"mean", ge::kIrInputRequired, ""},
{"res_gamma", ge::kIrInputRequired, ""},
{"res_beta", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"pd_x", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(variance->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(res_gamma->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(res_beta->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(6)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsINTrainingReduceV2Output EsINTrainingReduceV2(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("INTrainingReduceV2")
.Name(("INTrainingReduceV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"sum", ge::kIrOutputRequired, ""},
{"square_sum", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return EsINTrainingReduceV2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsINTrainingUpdateGradOutput EsINTrainingUpdateGrad(EsbTensor *dy, EsbTensor *x, EsbTensor *variance, EsbTensor *mean) {
GE_ASSERT_NOTNULL(dy);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(variance);
GE_ASSERT_NOTNULL(mean);
auto &graph = dy->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("INTrainingUpdateGrad")
.Name(("INTrainingUpdateGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"dy", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"variance", ge::kIrInputRequired, ""},
{"mean", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"res_gamma", ge::kIrOutputRequired, ""},
{"res_beta", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(variance->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(3)));
return EsINTrainingUpdateGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsINTrainingUpdateGradGammaBetaOutput EsINTrainingUpdateGradGammaBeta(EsbTensor *res_gamma, EsbTensor *res_beta) {
GE_ASSERT_NOTNULL(res_gamma);
GE_ASSERT_NOTNULL(res_beta);
auto &graph = res_gamma->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("INTrainingUpdateGradGammaBeta")
.Name(("INTrainingUpdateGradGammaBeta_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"res_gamma", ge::kIrInputRequired, ""},
{"res_beta", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"pd_gamma", ge::kIrOutputRequired, ""},
{"pd_beta", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(res_gamma->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(res_beta->GetAnchor(), node->GetInDataAnchor(1)));
return EsINTrainingUpdateGradGammaBetaOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsINTrainingUpdateV2Output EsINTrainingUpdateV2(EsbTensor *x, EsbTensor *sum, EsbTensor *square_sum, EsbTensor *gamma, EsbTensor *beta, EsbTensor *mean, EsbTensor *variance, float momentum, float epsilon) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(sum);
GE_ASSERT_NOTNULL(square_sum);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("INTrainingUpdateV2")
.Name(("INTrainingUpdateV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"sum", ge::kIrInputRequired, ""},
{"square_sum", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputOptional, ""},
{"beta", ge::kIrInputOptional, ""},
{"mean", ge::kIrInputOptional, ""},
{"variance", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"batch_mean", ge::kIrOutputRequired, ""},
{"batch_variance", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"momentum",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(momentum))
},
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(square_sum->GetAnchor(), node->GetInDataAnchor(2)));
if (gamma != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(3)));
}
if (beta != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta->GetAnchor(), node->GetInDataAnchor(4)));
}
if (mean != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(5)));
}
if (variance != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(variance->GetAnchor(), node->GetInDataAnchor(6)));
}
return EsINTrainingUpdateV2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsIRFFT(EsbTensor *x, EsbTensor *fft_length) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(fft_length);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("IRFFT")
.Name(("IRFFT_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"fft_length", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(fft_length->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsIdentity(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Identity")
.Name(("Identity_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsIgamma(EsbTensor *a, EsbTensor *x) {
GE_ASSERT_NOTNULL(a);
GE_ASSERT_NOTNULL(x);
auto &graph = a->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Igamma")
.Name(("Igamma_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"a", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"z", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(a->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsIgammaGradA(EsbTensor *a, EsbTensor *x) {
GE_ASSERT_NOTNULL(a);
GE_ASSERT_NOTNULL(x);
auto &graph = a->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("IgammaGradA")
.Name(("IgammaGradA_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"a", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"z", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(a->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsIgammac(EsbTensor *a, EsbTensor *x) {
GE_ASSERT_NOTNULL(a);
GE_ASSERT_NOTNULL(x);
auto &graph = a->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Igammac")
.Name(("Igammac_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"a", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"z", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(a->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsIm2col(EsbTensor *x, const int64_t *ksizes, int64_t ksizes_num, const int64_t *strides, int64_t strides_num, const int64_t *dilations, int64_t dilations_num, const char *padding_mode, const int64_t *pads, int64_t pads_num) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Im2col")
.Name(("Im2col_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ksizes",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ksizes, ksizes + ksizes_num))
},
{
"strides",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"dilations",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"padding_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(padding_mode))
},
{
"pads",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsImag(EsbTensor *input, ge::DataType Tout) {
GE_ASSERT_NOTNULL(input);
auto &graph = input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Imag")
.Name(("Imag_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"Tout",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(Tout))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsImageProjectiveTransform(EsbTensor *images, EsbTensor *transforms, EsbTensor *output_shape, const char *interpolation, const char *fill_mode) {
GE_ASSERT_NOTNULL(images);
GE_ASSERT_NOTNULL(transforms);
GE_ASSERT_NOTNULL(output_shape);
auto &graph = images->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ImageProjectiveTransform")
.Name(("ImageProjectiveTransform_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"images", ge::kIrInputRequired, ""},
{"transforms", ge::kIrInputRequired, ""},
{"output_shape", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"transformed_images", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"interpolation",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(interpolation))
},
{
"fill_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(fill_mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(images->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(transforms->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(output_shape->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsImageProjectiveTransformV2(EsbTensor *images, EsbTensor *transforms, EsbTensor *output_shape, EsbTensor *fill_value, const char *interpolation, const char *fill_mode) {
GE_ASSERT_NOTNULL(images);
GE_ASSERT_NOTNULL(transforms);
GE_ASSERT_NOTNULL(output_shape);
auto &graph = images->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ImageProjectiveTransformV2")
.Name(("ImageProjectiveTransformV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"images", ge::kIrInputRequired, ""},
{"transforms", ge::kIrInputRequired, ""},
{"output_shape", ge::kIrInputRequired, ""},
{"fill_value", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"transformed_images", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"interpolation",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(interpolation))
},
{
"fill_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(fill_mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(images->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(transforms->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(output_shape->GetAnchor(), node->GetInDataAnchor(2)));
if (fill_value != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(fill_value->GetAnchor(), node->GetInDataAnchor(3)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsImageUnfold(EsbTensor *x, EsbTensor *position, const char *padding_mode) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(position);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ImageUnfold")
.Name(("ImageUnfold_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"position", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"padding_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(padding_mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(position->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsImgCrop(EsbTensor *x, EsbTensor *boxes, EsbTensor *box_index, const char *data_format) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(boxes);
GE_ASSERT_NOTNULL(box_index);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ImgCrop")
.Name(("ImgCrop_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"boxes", ge::kIrInputRequired, ""},
{"box_index", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(boxes->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(box_index->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsImgRawDecodePostHandle(EsbTensor *img_channel_0, EsbTensor *img_channel_1, EsbTensor *img_channel_2, EsbTensor *img_channel_3, EsbTensor *img_size, EsbTensor *gamma, const char *bayer_pattern) {
GE_ASSERT_NOTNULL(img_channel_0);
GE_ASSERT_NOTNULL(img_channel_1);
GE_ASSERT_NOTNULL(img_channel_2);
GE_ASSERT_NOTNULL(img_channel_3);
GE_ASSERT_NOTNULL(img_size);
GE_ASSERT_NOTNULL(gamma);
auto &graph = img_channel_0->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ImgRawDecodePostHandle")
.Name(("ImgRawDecodePostHandle_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"img_channel_0", ge::kIrInputRequired, ""},
{"img_channel_1", ge::kIrInputRequired, ""},
{"img_channel_2", ge::kIrInputRequired, ""},
{"img_channel_3", ge::kIrInputRequired, ""},
{"img_size", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"raw_img", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"bayer_pattern",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(bayer_pattern))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(img_channel_0->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(img_channel_1->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(img_channel_2->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(img_channel_3->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(img_size->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(5)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsImgRawDecodePostHandleV2(EsbTensor *img_channel_0, EsbTensor *img_channel_1, EsbTensor *img_channel_2, EsbTensor *img_channel_3, EsbTensor *gamma, EsbTensor *bayer_coordinate, EsbTensor *bayer_params, EsbTensor *bayer_ptn) {
GE_ASSERT_NOTNULL(img_channel_0);
GE_ASSERT_NOTNULL(img_channel_1);
GE_ASSERT_NOTNULL(img_channel_2);
GE_ASSERT_NOTNULL(img_channel_3);
GE_ASSERT_NOTNULL(gamma);
GE_ASSERT_NOTNULL(bayer_coordinate);
GE_ASSERT_NOTNULL(bayer_params);
GE_ASSERT_NOTNULL(bayer_ptn);
auto &graph = img_channel_0->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ImgRawDecodePostHandleV2")
.Name(("ImgRawDecodePostHandleV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"img_channel_0", ge::kIrInputRequired, ""},
{"img_channel_1", ge::kIrInputRequired, ""},
{"img_channel_2", ge::kIrInputRequired, ""},
{"img_channel_3", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
{"bayer_coordinate", ge::kIrInputRequired, ""},
{"bayer_params", ge::kIrInputRequired, ""},
{"bayer_ptn", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"raw_img", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(img_channel_0->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(img_channel_1->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(img_channel_2->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(img_channel_3->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bayer_coordinate->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bayer_params->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bayer_ptn->GetAnchor(), node->GetInDataAnchor(7)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsImgToTensor(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ImgToTensor")
.Name(("ImgToTensor_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsInTopK(EsbTensor *x1, EsbTensor *x2, EsbTensor *k) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
GE_ASSERT_NOTNULL(k);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("InTopK")
.Name(("InTopK_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"k", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(k->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsInTopKD(EsbTensor *x1, EsbTensor *x2, int64_t k) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("InTopKD")
.Name(("InTopKD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"k",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(k))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsInTopKV2(EsbTensor *predictions, EsbTensor *targets, EsbTensor *k) {
GE_ASSERT_NOTNULL(predictions);
GE_ASSERT_NOTNULL(targets);
GE_ASSERT_NOTNULL(k);
auto &graph = predictions->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("InTopKV2")
.Name(("InTopKV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"predictions", ge::kIrInputRequired, ""},
{"targets", ge::kIrInputRequired, ""},
{"k", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"precision", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(predictions->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(targets->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(k->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsIncreFlashAttention(EsbTensor *query, EsbTensor **key, int64_t key_num, EsbTensor **value, int64_t value_num, EsbTensor *pse_shift, EsbTensor *atten_mask, EsbTensor *actual_seq_lengths, EsbTensor *dequant_scale1, EsbTensor *quant_scale1, EsbTensor *dequant_scale2, EsbTensor *quant_scale2, EsbTensor *quant_offset2, EsbTensor *antiquant_scale, EsbTensor *antiquant_offset, EsbTensor *block_table, EsbTensor *kv_padding_size, int64_t num_heads, float scale_value, const char *input_layout, int64_t num_key_value_heads, int64_t block_size, int64_t inner_precise) {
GE_ASSERT_NOTNULL(query);
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(key_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(value_num));
auto &graph = query->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("IncreFlashAttention")
.Name(("IncreFlashAttention_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"query", ge::kIrInputRequired, ""},
{"key", ge::kIrInputDynamic, ""},
{"value", ge::kIrInputDynamic, ""},
{"pse_shift", ge::kIrInputOptional, ""},
{"atten_mask", ge::kIrInputOptional, ""},
{"actual_seq_lengths", ge::kIrInputOptional, ""},
{"dequant_scale1", ge::kIrInputOptional, ""},
{"quant_scale1", ge::kIrInputOptional, ""},
{"dequant_scale2", ge::kIrInputOptional, ""},
{"quant_scale2", ge::kIrInputOptional, ""},
{"quant_offset2", ge::kIrInputOptional, ""},
{"antiquant_scale", ge::kIrInputOptional, ""},
{"antiquant_offset", ge::kIrInputOptional, ""},
{"block_table", ge::kIrInputOptional, ""},
{"kv_padding_size", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"attention_out", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_heads",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_heads))
},
{
"scale_value",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(scale_value))
},
{
"input_layout",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(input_layout))
},
{
"num_key_value_heads",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_key_value_heads))
},
{
"block_size",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(block_size))
},
{
"inner_precise",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(inner_precise))
},
})
.InstanceDynamicInputNum("key", static_cast<int32_t>(key_num))
.InstanceDynamicInputNum("value", static_cast<int32_t>(value_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(query->GetAnchor(), node->GetInDataAnchor(0)));
if ((key != nullptr) && (key_num > 0)) {
for (int64_t i = 0; i < key_num; ++i) {
auto one_key = key[i];
GE_ASSERT_NOTNULL(one_key);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_key->GetAnchor(), node->GetInDataAnchor(1 + i)));
}
}
if ((value != nullptr) && (value_num > 0)) {
for (int64_t i = 0; i < value_num; ++i) {
auto one_value = value[i];
GE_ASSERT_NOTNULL(one_value);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_value->GetAnchor(), node->GetInDataAnchor(1 + key_num + i)));
}
}
if (pse_shift != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(pse_shift->GetAnchor(), node->GetInDataAnchor(1 + key_num + value_num)));
}
if (atten_mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(atten_mask->GetAnchor(), node->GetInDataAnchor(2 + key_num + value_num)));
}
if (actual_seq_lengths != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(actual_seq_lengths->GetAnchor(), node->GetInDataAnchor(3 + key_num + value_num)));
}
if (dequant_scale1 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dequant_scale1->GetAnchor(), node->GetInDataAnchor(4 + key_num + value_num)));
}
if (quant_scale1 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(quant_scale1->GetAnchor(), node->GetInDataAnchor(5 + key_num + value_num)));
}
if (dequant_scale2 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dequant_scale2->GetAnchor(), node->GetInDataAnchor(6 + key_num + value_num)));
}
if (quant_scale2 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(quant_scale2->GetAnchor(), node->GetInDataAnchor(7 + key_num + value_num)));
}
if (quant_offset2 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(quant_offset2->GetAnchor(), node->GetInDataAnchor(8 + key_num + value_num)));
}
if (antiquant_scale != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(antiquant_scale->GetAnchor(), node->GetInDataAnchor(9 + key_num + value_num)));
}
if (antiquant_offset != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(antiquant_offset->GetAnchor(), node->GetInDataAnchor(10 + key_num + value_num)));
}
if (block_table != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(block_table->GetAnchor(), node->GetInDataAnchor(11 + key_num + value_num)));
}
if (kv_padding_size != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(kv_padding_size->GetAnchor(), node->GetInDataAnchor(12 + key_num + value_num)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsIndex(EsbTensor *x, EsbTensor *indexed_sizes, EsbTensor *indexed_strides, EsbTensor **indices, int64_t indices_num) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(indexed_sizes);
GE_ASSERT_NOTNULL(indexed_strides);
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(indices_num));
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Index")
.Name(("Index_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"indexed_sizes", ge::kIrInputRequired, ""},
{"indexed_strides", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("indices", static_cast<int32_t>(indices_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indexed_sizes->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indexed_strides->GetAnchor(), node->GetInDataAnchor(2)));
if ((indices != nullptr) && (indices_num > 0)) {
for (int64_t i = 0; i < indices_num; ++i) {
auto one_indices = indices[i];
GE_ASSERT_NOTNULL(one_indices);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_indices->GetAnchor(), node->GetInDataAnchor(3 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsIndexAdd(EsbTensor *var, EsbTensor *indices, EsbTensor *updates, int64_t axis) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(updates);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("IndexAdd")
.Name(("IndexAdd_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"updates", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var_out", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(updates->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsIndexFillD(EsbTensor *x, EsbTensor *assist1, EsbTensor *assist2, int64_t dim) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(assist1);
GE_ASSERT_NOTNULL(assist2);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("IndexFillD")
.Name(("IndexFillD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"assist1", ge::kIrInputRequired, ""},
{"assist2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dim",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dim))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(assist1->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(assist2->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsIndexPut(EsbTensor *x1, EsbTensor *x2, const int64_t *indices, int64_t indices_num, int64_t accumulate) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("IndexPut")
.Name(("IndexPut_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"indices",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(indices, indices + indices_num))
},
{
"accumulate",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(accumulate))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsIndexPutV2(EsbTensor *x, EsbTensor *value, EsbTensor *indexed_sizes, EsbTensor *indexed_strides, EsbTensor **indices, int64_t indices_num, bool accumulate) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(value);
GE_ASSERT_NOTNULL(indexed_sizes);
GE_ASSERT_NOTNULL(indexed_strides);
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(indices_num));
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("IndexPutV2")
.Name(("IndexPutV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"value", ge::kIrInputRequired, ""},
{"indexed_sizes", ge::kIrInputRequired, ""},
{"indexed_strides", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
{"x", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"accumulate",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(accumulate))
},
})
.InstanceDynamicInputNum("indices", static_cast<int32_t>(indices_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indexed_sizes->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indexed_strides->GetAnchor(), node->GetInDataAnchor(3)));
if ((indices != nullptr) && (indices_num > 0)) {
for (int64_t i = 0; i < indices_num; ++i) {
auto one_indices = indices[i];
GE_ASSERT_NOTNULL(one_indices);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_indices->GetAnchor(), node->GetInDataAnchor(4 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsIndexToAddr(EsbTensor *base_addr, EsbTensor *x, const int64_t *ori_shape, int64_t ori_shape_num, const int64_t *block_size, int64_t block_size_num, const char *ori_storage_mode, const char *block_storage_mode, int64_t rank_id, ge::DataType dtype) {
GE_ASSERT_NOTNULL(base_addr);
GE_ASSERT_NOTNULL(x);
auto &graph = base_addr->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("IndexToAddr")
.Name(("IndexToAddr_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"base_addr", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"addrs_table", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ori_shape",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ori_shape, ori_shape + ori_shape_num))
},
{
"block_size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(block_size, block_size + block_size_num))
},
{
"ori_storage_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(ori_storage_mode))
},
{
"block_storage_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(block_storage_mode))
},
{
"rank_id",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(rank_id))
},
{
"dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(base_addr->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsInitData(EsbGraph *owner_graph, const char *channel_name) {
GE_ASSERT_NOTNULL(owner_graph);
EsbGraph &graph = *owner_graph;

auto desc = ge::CompliantOpDescBuilder().OpType("InitData")
.Name(("InitData_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
})
.IrDefOutputs({
})
.IrDefAttrs({
{
"channel_name",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(channel_name))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsInitEmbeddingHashmap(EsbTensor *table_id, int64_t value_total_len, int64_t embedding_dim, int64_t bucket_size, ge::DataType dtype, const char *initializer_mode, float constant_value, float min, float max, float mu, float sigma, int64_t seed, int64_t seed2, const char *filter_mode, const char *optimizer_mode, const float *optimizer_params, int64_t optimizer_params_num) {
GE_ASSERT_NOTNULL(table_id);
auto &graph = table_id->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("InitEmbeddingHashmap")
.Name(("InitEmbeddingHashmap_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"table_id", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
{
"value_total_len",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(value_total_len))
},
{
"embedding_dim",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(embedding_dim))
},
{
"bucket_size",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(bucket_size))
},
{
"dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
{
"initializer_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(initializer_mode))
},
{
"constant_value",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(constant_value))
},
{
"min",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(min))
},
{
"max",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(max))
},
{
"mu",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(mu))
},
{
"sigma",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(sigma))
},
{
"seed",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed))
},
{
"seed2",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed2))
},
{
"filter_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(filter_mode))
},
{
"optimizer_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(optimizer_mode))
},
{
"optimizer_params",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(optimizer_params, optimizer_params + optimizer_params_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(table_id->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsInitEmbeddingHashmapV2(EsbTensor *table_id, int64_t bucket_size, int64_t load_factor, int64_t embedding_dim, ge::DataType dtype) {
GE_ASSERT_NOTNULL(table_id);
auto &graph = table_id->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("InitEmbeddingHashmapV2")
.Name(("InitEmbeddingHashmapV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"table_id", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"table_handle", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"bucket_size",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(bucket_size))
},
{
"load_factor",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(load_factor))
},
{
"embedding_dim",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(embedding_dim))
},
{
"dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(table_id->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsInitPartitionMap(EsbTensor *ps_num, EsbTensor *ps_ids, int64_t partition_num) {
GE_ASSERT_NOTNULL(ps_num);
GE_ASSERT_NOTNULL(ps_ids);
auto &graph = ps_num->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("InitPartitionMap")
.Name(("InitPartitionMap_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"ps_num", ge::kIrInputRequired, ""},
{"ps_ids", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
{
"partition_num",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(partition_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(ps_num->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(ps_ids->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsInitializeTable(EsbTensor *handle, EsbTensor *keys, EsbTensor *values) {
GE_ASSERT_NOTNULL(handle);
GE_ASSERT_NOTNULL(keys);
GE_ASSERT_NOTNULL(values);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("InitializeTable")
.Name(("InitializeTable_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
{"keys", ge::kIrInputRequired, ""},
{"values", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(keys->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(values->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsInplaceAdd(EsbTensor *x, EsbTensor *indices, EsbTensor *v) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(v);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("InplaceAdd")
.Name(("InplaceAdd_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"v", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(v->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsInplaceAddD(EsbTensor *x, EsbTensor *v, const int64_t *indices, int64_t indices_num) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(v);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("InplaceAddD")
.Name(("InplaceAddD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"v", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"indices",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(indices, indices + indices_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(v->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsInplaceAddLayerNormOutput EsInplaceAddLayerNorm(EsbTensor *x1, EsbTensor *x2, EsbTensor *gamma, EsbTensor *beta, EsbTensor *bias, float epsilon, bool additional_output) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
GE_ASSERT_NOTNULL(gamma);
GE_ASSERT_NOTNULL(beta);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("InplaceAddLayerNorm")
.Name(("InplaceAddLayerNorm_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
{"beta", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"x1", ge::kIrOutputRequired, ""},
{"mean", ge::kIrOutputRequired, ""},
{"rstd", ge::kIrOutputRequired, ""},
{"x2", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
{
"additional_output",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(additional_output))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta->GetAnchor(), node->GetInDataAnchor(3)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(4)));
}
return EsInplaceAddLayerNormOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsInplaceAddRmsNormOutput EsInplaceAddRmsNorm(EsbTensor *x1, EsbTensor *x2, EsbTensor *gamma, float epsilon) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
GE_ASSERT_NOTNULL(gamma);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("InplaceAddRmsNorm")
.Name(("InplaceAddRmsNorm_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"x1", ge::kIrOutputRequired, ""},
{"rstd", ge::kIrOutputRequired, ""},
{"x2", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(2)));
return EsInplaceAddRmsNormOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsInplaceIndexAdd(EsbTensor *var, EsbTensor *indices, EsbTensor *updates, EsbTensor *alpha, int64_t axis) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(updates);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("InplaceIndexAdd")
.Name(("InplaceIndexAdd_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"updates", ge::kIrInputRequired, ""},
{"alpha", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(updates->GetAnchor(), node->GetInDataAnchor(2)));
if (alpha != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(alpha->GetAnchor(), node->GetInDataAnchor(3)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsInplaceMatmulAllReduceAddRmsNormOutput EsInplaceMatmulAllReduceAddRmsNorm(EsbTensor *x1, EsbTensor *x2, EsbTensor *bias, EsbTensor *residual, EsbTensor *gamma, EsbTensor *antiquant_scale, EsbTensor *antiquant_offset, EsbTensor *dequant_scale, const char *group, const char *reduce_op, bool is_trans_a, bool is_trans_b, int64_t comm_turn, int64_t antiquant_group_size, float epsilon) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
GE_ASSERT_NOTNULL(residual);
GE_ASSERT_NOTNULL(gamma);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("InplaceMatmulAllReduceAddRmsNorm")
.Name(("InplaceMatmulAllReduceAddRmsNorm_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
{"residual", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
{"antiquant_scale", ge::kIrInputOptional, ""},
{"antiquant_offset", ge::kIrInputOptional, ""},
{"dequant_scale", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"residual", ge::kIrOutputRequired, ""},
{"norm_out", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"group",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(group))
},
{
"reduce_op",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduce_op))
},
{
"is_trans_a",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_trans_a))
},
{
"is_trans_b",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_trans_b))
},
{
"comm_turn",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(comm_turn))
},
{
"antiquant_group_size",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(antiquant_group_size))
},
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(2)));
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(residual->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(4)));
if (antiquant_scale != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(antiquant_scale->GetAnchor(), node->GetInDataAnchor(5)));
}
if (antiquant_offset != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(antiquant_offset->GetAnchor(), node->GetInDataAnchor(6)));
}
if (dequant_scale != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dequant_scale->GetAnchor(), node->GetInDataAnchor(7)));
}
return EsInplaceMatmulAllReduceAddRmsNormOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsInplaceSub(EsbTensor *x, EsbTensor *indices, EsbTensor *v) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(v);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("InplaceSub")
.Name(("InplaceSub_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"v", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(v->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsInplaceSubD(EsbTensor *x, EsbTensor *v, const int64_t *indices, int64_t indices_num) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(v);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("InplaceSubD")
.Name(("InplaceSubD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"v", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"indices",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(indices, indices + indices_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(v->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsInplaceTopKDistance(EsbTensor *topk_pq_distance, EsbTensor *topk_pq_index, EsbTensor *topk_pq_ivf, EsbTensor *pq_distance, EsbTensor *pq_index, EsbTensor *pq_ivf, const char *order) {
GE_ASSERT_NOTNULL(topk_pq_distance);
GE_ASSERT_NOTNULL(topk_pq_index);
GE_ASSERT_NOTNULL(topk_pq_ivf);
GE_ASSERT_NOTNULL(pq_distance);
GE_ASSERT_NOTNULL(pq_index);
GE_ASSERT_NOTNULL(pq_ivf);
auto &graph = topk_pq_distance->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("InplaceTopKDistance")
.Name(("InplaceTopKDistance_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"topk_pq_distance", ge::kIrInputRequired, ""},
{"topk_pq_index", ge::kIrInputRequired, ""},
{"topk_pq_ivf", ge::kIrInputRequired, ""},
{"pq_distance", ge::kIrInputRequired, ""},
{"pq_index", ge::kIrInputRequired, ""},
{"pq_ivf", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
{
"order",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(order))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(topk_pq_distance->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(topk_pq_index->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(topk_pq_ivf->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(pq_distance->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(pq_index->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(pq_ivf->GetAnchor(), node->GetInDataAnchor(5)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsInplaceUpdate(EsbTensor *x, EsbTensor *indices, EsbTensor *v) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(v);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("InplaceUpdate")
.Name(("InplaceUpdate_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"v", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(v->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsInplaceUpdateD(EsbTensor *x, EsbTensor *v, const int64_t *indices, int64_t indices_num) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(v);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("InplaceUpdateD")
.Name(("InplaceUpdateD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"v", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"indices",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(indices, indices + indices_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(v->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsInstanceNormOutput EsInstanceNorm(EsbTensor *x, EsbTensor *gamma, EsbTensor *beta, const char *data_format, float epsilon) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(gamma);
GE_ASSERT_NOTNULL(beta);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("InstanceNorm")
.Name(("InstanceNorm_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
{"beta", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"mean", ge::kIrOutputRequired, ""},
{"variance", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta->GetAnchor(), node->GetInDataAnchor(2)));
return EsInstanceNormOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsInstanceNormGradOutput EsInstanceNormGrad(EsbTensor *dy, EsbTensor *x, EsbTensor *variance, EsbTensor *mean, EsbTensor *gamma) {
GE_ASSERT_NOTNULL(dy);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(variance);
GE_ASSERT_NOTNULL(mean);
GE_ASSERT_NOTNULL(gamma);
auto &graph = dy->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("InstanceNormGrad")
.Name(("InstanceNormGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"dy", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"variance", ge::kIrInputRequired, ""},
{"mean", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"pd_x", ge::kIrOutputRequired, ""},
{"pd_gamma", ge::kIrOutputRequired, ""},
{"pd_beta", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(variance->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(4)));
return EsInstanceNormGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsInstanceNormV2Output EsInstanceNormV2(EsbTensor *x, EsbTensor *gamma, EsbTensor *beta, EsbTensor *mean, EsbTensor *variance, bool is_training, float momentum, float epsilon) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("InstanceNormV2")
.Name(("InstanceNormV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputOptional, ""},
{"beta", ge::kIrInputOptional, ""},
{"mean", ge::kIrInputOptional, ""},
{"variance", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"batch_mean", ge::kIrOutputRequired, ""},
{"batch_variance", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"is_training",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_training))
},
{
"momentum",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(momentum))
},
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
if (gamma != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(1)));
}
if (beta != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta->GetAnchor(), node->GetInDataAnchor(2)));
}
if (mean != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(3)));
}
if (variance != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(variance->GetAnchor(), node->GetInDataAnchor(4)));
}
return EsInstanceNormV2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsInternalDataMove(EsbTensor *x, const char *src_buf, const char *dst_buf) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("InternalDataMove")
.Name(("InternalDataMove_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"src_buf",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(src_buf))
},
{
"dst_buf",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(dst_buf))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsInv(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Inv")
.Name(("Inv_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsInvGrad(EsbTensor *x, EsbTensor *grad) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(grad);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("InvGrad")
.Name(("InvGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsInvert(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Invert")
.Name(("Invert_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsInvertPermutation(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("InvertPermutation")
.Name(("InvertPermutation_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsIou(EsbTensor *bboxes, EsbTensor *gtboxes, const char *mode, float eps, bool aligned) {
GE_ASSERT_NOTNULL(bboxes);
GE_ASSERT_NOTNULL(gtboxes);
auto &graph = bboxes->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Iou")
.Name(("Iou_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"bboxes", ge::kIrInputRequired, ""},
{"gtboxes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"overlap", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(mode))
},
{
"eps",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(eps))
},
{
"aligned",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(aligned))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bboxes->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gtboxes->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsIou3D(EsbTensor *bboxes, EsbTensor *gtboxes) {
GE_ASSERT_NOTNULL(bboxes);
GE_ASSERT_NOTNULL(gtboxes);
auto &graph = bboxes->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Iou3D")
.Name(("Iou3D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"bboxes", ge::kIrInputRequired, ""},
{"gtboxes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"iou", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bboxes->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gtboxes->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsIsClose(EsbTensor *x1, EsbTensor *x2, float rtol, float atol, bool equal_nan) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("IsClose")
.Name(("IsClose_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"rtol",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(rtol))
},
{
"atol",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(atol))
},
{
"equal_nan",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(equal_nan))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsIsFinite(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("IsFinite")
.Name(("IsFinite_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsIsInf(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("IsInf")
.Name(("IsInf_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsIsNan(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("IsNan")
.Name(("IsNan_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsIsNegInf(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("IsNegInf")
.Name(("IsNegInf_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsIsPosInf(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("IsPosInf")
.Name(("IsPosInf_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsIsVariableInitialized(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("IsVariableInitialized")
.Name(("IsVariableInitialized_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsIsotonicRegressionOutput EsIsotonicRegression(EsbTensor *input, ge::DataType output_dtype) {
GE_ASSERT_NOTNULL(input);
auto &graph = input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("IsotonicRegression")
.Name(("IsotonicRegression_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
{"segments", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"output_dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(output_dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input->GetAnchor(), node->GetInDataAnchor(0)));
return EsIsotonicRegressionOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsKLDiv(EsbTensor *x, EsbTensor *target, const char *reduction) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(target);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("KLDiv")
.Name(("KLDiv_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"target", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"reduction",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduction))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(target->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsKLDivV2(EsbTensor *x, EsbTensor *target, const char *reduction, bool log_target) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(target);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("KLDivV2")
.Name(("KLDivV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"target", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"reduction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduction))
},
{
"log_target",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(log_target))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(target->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsKMeansCentroidsOutput EsKMeansCentroids(EsbTensor *x, EsbTensor *y, EsbTensor *sum_square_y, EsbTensor *sum_square_x, bool use_actual_distance) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(y);
GE_ASSERT_NOTNULL(sum_square_y);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("KMeansCentroids")
.Name(("KMeansCentroids_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"y", ge::kIrInputRequired, ""},
{"sum_square_y", ge::kIrInputRequired, ""},
{"sum_square_x", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"segment_sum", ge::kIrOutputRequired, ""},
{"segment_count", ge::kIrOutputRequired, ""},
{"kmean_total_sum", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_actual_distance",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_actual_distance))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sum_square_y->GetAnchor(), node->GetInDataAnchor(2)));
if (sum_square_x != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sum_square_x->GetAnchor(), node->GetInDataAnchor(3)));
}
return EsKMeansCentroidsOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsKeepRatioResizeBilinear(EsbTensor *images, int64_t min_dimension, int64_t max_dimension, bool align_corners, bool half_pixel_centers) {
GE_ASSERT_NOTNULL(images);
auto &graph = images->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("KeepRatioResizeBilinear")
.Name(("KeepRatioResizeBilinear_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"images", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"min_dimension",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(min_dimension))
},
{
"max_dimension",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(max_dimension))
},
{
"align_corners",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(align_corners))
},
{
"half_pixel_centers",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(half_pixel_centers))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(images->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsKlDivLossGrad(EsbTensor *grad, EsbTensor *input, EsbTensor *target, const char *reduction, bool log_target) {
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(input);
GE_ASSERT_NOTNULL(target);
auto &graph = grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("KlDivLossGrad")
.Name(("KlDivLossGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grad", ge::kIrInputRequired, ""},
{"input", ge::kIrInputRequired, ""},
{"target", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"reduction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduction))
},
{
"log_target",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(log_target))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(target->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsL1LossGrad(EsbTensor *grads, EsbTensor *predict, EsbTensor *label, const char *reduction) {
GE_ASSERT_NOTNULL(grads);
GE_ASSERT_NOTNULL(predict);
GE_ASSERT_NOTNULL(label);
auto &graph = grads->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("L1LossGrad")
.Name(("L1LossGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grads", ge::kIrInputRequired, ""},
{"predict", ge::kIrInputRequired, ""},
{"label", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"reduction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduction))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grads->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(predict->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(label->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsL2Loss(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("L2Loss")
.Name(("L2Loss_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsL2Normalize(EsbTensor *x, const int64_t *axis, int64_t axis_num, float eps) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("L2Normalize")
.Name(("L2Normalize_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(axis, axis + axis_num))
},
{
"eps",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(eps))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsL2NormalizeGrad(EsbTensor *x, EsbTensor *y, EsbTensor *dy, const int64_t *dim, int64_t dim_num, float eps) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(y);
GE_ASSERT_NOTNULL(dy);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("L2NormalizeGrad")
.Name(("L2NormalizeGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"y", ge::kIrInputRequired, ""},
{"dy", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"dx", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dim",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dim, dim + dim_num))
},
{
"eps",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(eps))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsLDPCDecode(EsbTensor *valid_num, EsbTensor *matrix_info) {
GE_ASSERT_NOTNULL(valid_num);
GE_ASSERT_NOTNULL(matrix_info);
auto &graph = valid_num->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LDPCDecode")
.Name(("LDPCDecode_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"valid_num", ge::kIrInputRequired, ""},
{"matrix_info", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"indices", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(valid_num->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(matrix_info->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsLNDropoutGradOutput EsLNDropoutGrad(EsbTensor *dy, EsbTensor *x, EsbTensor *variance, EsbTensor *mean, EsbTensor *gamma, EsbTensor *mask, float keep_prob) {
GE_ASSERT_NOTNULL(dy);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(variance);
GE_ASSERT_NOTNULL(mean);
GE_ASSERT_NOTNULL(gamma);
GE_ASSERT_NOTNULL(mask);
auto &graph = dy->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LNDropoutGrad")
.Name(("LNDropoutGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"dy", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"variance", ge::kIrInputRequired, ""},
{"mean", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
{"mask", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"pd_x", ge::kIrOutputRequired, ""},
{"pd_x_dropout", ge::kIrOutputRequired, ""},
{"pd_gamma", ge::kIrOutputRequired, ""},
{"pd_beta", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"keep_prob",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(keep_prob))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(variance->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mask->GetAnchor(), node->GetInDataAnchor(5)));
return EsLNDropoutGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsbTensor *EsLRN(EsbTensor *x, int64_t depth_radius, float bias, float alpha, float beta, const char *norm_region) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LRN")
.Name(("LRN_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"depth_radius",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(depth_radius))
},
{
"bias",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(bias))
},
{
"alpha",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(alpha))
},
{
"beta",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(beta))
},
{
"norm_region",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(norm_region))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsLRNGrad(EsbTensor *grads, EsbTensor *x, EsbTensor *y, int64_t depth_radius, float bias, float alpha, float beta) {
GE_ASSERT_NOTNULL(grads);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(y);
auto &graph = grads->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LRNGrad")
.Name(("LRNGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grads", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"y", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"z", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"depth_radius",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(depth_radius))
},
{
"bias",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(bias))
},
{
"alpha",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(alpha))
},
{
"beta",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(beta))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grads->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsLRUCacheV2Output EsLRUCacheV2(EsbTensor *index_list, EsbTensor *data, EsbTensor *cache, EsbTensor *tag, EsbTensor *is_last_call, int64_t pre_route_count) {
GE_ASSERT_NOTNULL(index_list);
GE_ASSERT_NOTNULL(data);
GE_ASSERT_NOTNULL(cache);
GE_ASSERT_NOTNULL(tag);
GE_ASSERT_NOTNULL(is_last_call);
auto &graph = index_list->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LRUCacheV2")
.Name(("LRUCacheV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"index_list", ge::kIrInputRequired, ""},
{"data", ge::kIrInputRequired, ""},
{"cache", ge::kIrInputRequired, ""},
{"tag", ge::kIrInputRequired, ""},
{"is_last_call", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"data", ge::kIrOutputRequired, ""},
{"cache", ge::kIrOutputRequired, ""},
{"tag", ge::kIrOutputRequired, ""},
{"index_offset_list", ge::kIrOutputRequired, ""},
{"not_in_cache_index_list", ge::kIrOutputRequired, ""},
{"not_in_cache_number", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"pre_route_count",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pre_route_count))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(index_list->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(data->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(cache->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(tag->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(is_last_call->GetAnchor(), node->GetInDataAnchor(4)));
return EsLRUCacheV2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
graph.GetEsbTensorFromNode(node, 5),
};
}
EsLSTMOutput EsLSTM(EsbTensor *x, EsbTensor *cont, EsbTensor *w_x, EsbTensor *bias, EsbTensor *w_h, EsbTensor *x_static, EsbTensor *h_0, EsbTensor *c_0, EsbTensor *w_x_static, int64_t num_output, bool expose_hidden) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(cont);
GE_ASSERT_NOTNULL(w_x);
GE_ASSERT_NOTNULL(bias);
GE_ASSERT_NOTNULL(w_h);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LSTM")
.Name(("LSTM_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"cont", ge::kIrInputRequired, ""},
{"w_x", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputRequired, ""},
{"w_h", ge::kIrInputRequired, ""},
{"x_static", ge::kIrInputOptional, ""},
{"h_0", ge::kIrInputOptional, ""},
{"c_0", ge::kIrInputOptional, ""},
{"w_x_static", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"h", ge::kIrOutputRequired, ""},
{"h_t", ge::kIrOutputRequired, ""},
{"c_t", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_output",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_output))
},
{
"expose_hidden",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(expose_hidden))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(cont->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(w_x->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(w_h->GetAnchor(), node->GetInDataAnchor(4)));
if (x_static != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x_static->GetAnchor(), node->GetInDataAnchor(5)));
}
if (h_0 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(h_0->GetAnchor(), node->GetInDataAnchor(6)));
}
if (c_0 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(c_0->GetAnchor(), node->GetInDataAnchor(7)));
}
if (w_x_static != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(w_x_static->GetAnchor(), node->GetInDataAnchor(8)));
}
return EsLSTMOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsLSTMInputGradOutput EsLSTMInputGrad(EsbTensor *w, EsbTensor *init_c, EsbTensor *c, EsbTensor *dy, EsbTensor *dh, EsbTensor *dc, EsbTensor *i, EsbTensor *j, EsbTensor *f, EsbTensor *o, EsbTensor *tanhct) {
GE_ASSERT_NOTNULL(w);
GE_ASSERT_NOTNULL(init_c);
GE_ASSERT_NOTNULL(c);
GE_ASSERT_NOTNULL(dy);
GE_ASSERT_NOTNULL(dh);
GE_ASSERT_NOTNULL(dc);
GE_ASSERT_NOTNULL(i);
GE_ASSERT_NOTNULL(j);
GE_ASSERT_NOTNULL(f);
GE_ASSERT_NOTNULL(o);
auto &graph = w->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LSTMInputGrad")
.Name(("LSTMInputGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"w", ge::kIrInputRequired, ""},
{"init_c", ge::kIrInputRequired, ""},
{"c", ge::kIrInputRequired, ""},
{"dy", ge::kIrInputRequired, ""},
{"dh", ge::kIrInputRequired, ""},
{"dc", ge::kIrInputRequired, ""},
{"i", ge::kIrInputRequired, ""},
{"j", ge::kIrInputRequired, ""},
{"f", ge::kIrInputRequired, ""},
{"o", ge::kIrInputRequired, ""},
{"tanhct", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"dx", ge::kIrOutputRequired, ""},
{"dh_prev", ge::kIrOutputRequired, ""},
{"dc_prev", ge::kIrOutputRequired, ""},
{"dgate", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(w->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(init_c->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(c->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dh->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dc->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(i->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(j->GetAnchor(), node->GetInDataAnchor(7)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(f->GetAnchor(), node->GetInDataAnchor(8)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(o->GetAnchor(), node->GetInDataAnchor(9)));
if (tanhct != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(tanhct->GetAnchor(), node->GetInDataAnchor(10)));
}
return EsLSTMInputGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsLSTMPOutput EsLSTMP(EsbTensor *x, EsbTensor *wx, EsbTensor *bias, EsbTensor *wr, EsbTensor *project, EsbTensor *real_mask, EsbTensor *init_h, EsbTensor *init_c, bool time_major) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(wx);
GE_ASSERT_NOTNULL(bias);
GE_ASSERT_NOTNULL(wr);
GE_ASSERT_NOTNULL(project);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LSTMP")
.Name(("LSTMP_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"wx", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputRequired, ""},
{"wr", ge::kIrInputRequired, ""},
{"project", ge::kIrInputRequired, ""},
{"real_mask", ge::kIrInputOptional, ""},
{"init_h", ge::kIrInputOptional, ""},
{"init_c", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"output_h", ge::kIrOutputRequired, ""},
{"output_c", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"time_major",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(time_major))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(wx->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(wr->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(project->GetAnchor(), node->GetInDataAnchor(4)));
if (real_mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(real_mask->GetAnchor(), node->GetInDataAnchor(5)));
}
if (init_h != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(init_h->GetAnchor(), node->GetInDataAnchor(6)));
}
if (init_c != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(init_c->GetAnchor(), node->GetInDataAnchor(7)));
}
return EsLSTMPOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsLUT3D(EsbTensor *img, EsbTensor *lut_table) {
GE_ASSERT_NOTNULL(img);
GE_ASSERT_NOTNULL(lut_table);
auto &graph = img->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LUT3D")
.Name(("LUT3D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"img", ge::kIrInputRequired, ""},
{"lut_table", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"lut_img", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(img->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lut_table->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsLambApplyOptimizerAssignOutput EsLambApplyOptimizerAssign(EsbTensor *grad, EsbTensor *inputv, EsbTensor *inputm, EsbTensor *input3, EsbTensor *mul0_x, EsbTensor *mul1_x, EsbTensor *mul2_x, EsbTensor *mul3_x, EsbTensor *add2_y, EsbTensor *steps, EsbTensor *do_use_weight, EsbTensor *weight_decay_rate) {
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(inputv);
GE_ASSERT_NOTNULL(inputm);
GE_ASSERT_NOTNULL(input3);
GE_ASSERT_NOTNULL(mul0_x);
GE_ASSERT_NOTNULL(mul1_x);
GE_ASSERT_NOTNULL(mul2_x);
GE_ASSERT_NOTNULL(mul3_x);
GE_ASSERT_NOTNULL(add2_y);
GE_ASSERT_NOTNULL(steps);
GE_ASSERT_NOTNULL(do_use_weight);
GE_ASSERT_NOTNULL(weight_decay_rate);
auto &graph = grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LambApplyOptimizerAssign")
.Name(("LambApplyOptimizerAssign_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grad", ge::kIrInputRequired, ""},
{"inputv", ge::kIrInputRequired, ""},
{"inputm", ge::kIrInputRequired, ""},
{"input3", ge::kIrInputRequired, ""},
{"mul0_x", ge::kIrInputRequired, ""},
{"mul1_x", ge::kIrInputRequired, ""},
{"mul2_x", ge::kIrInputRequired, ""},
{"mul3_x", ge::kIrInputRequired, ""},
{"add2_y", ge::kIrInputRequired, ""},
{"steps", ge::kIrInputRequired, ""},
{"do_use_weight", ge::kIrInputRequired, ""},
{"weight_decay_rate", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output0", ge::kIrOutputRequired, ""},
{"inputv", ge::kIrOutputRequired, ""},
{"inputm", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(inputv->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(inputm->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input3->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mul0_x->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mul1_x->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mul2_x->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mul3_x->GetAnchor(), node->GetInDataAnchor(7)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(add2_y->GetAnchor(), node->GetInDataAnchor(8)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(steps->GetAnchor(), node->GetInDataAnchor(9)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(do_use_weight->GetAnchor(), node->GetInDataAnchor(10)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight_decay_rate->GetAnchor(), node->GetInDataAnchor(11)));
return EsLambApplyOptimizerAssignOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsLambApplyWeightAssign(EsbTensor *input0, EsbTensor *input1, EsbTensor *input2, EsbTensor *input3, EsbTensor *input_param) {
GE_ASSERT_NOTNULL(input0);
GE_ASSERT_NOTNULL(input1);
GE_ASSERT_NOTNULL(input2);
GE_ASSERT_NOTNULL(input3);
GE_ASSERT_NOTNULL(input_param);
auto &graph = input0->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LambApplyWeightAssign")
.Name(("LambApplyWeightAssign_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input0", ge::kIrInputRequired, ""},
{"input1", ge::kIrInputRequired, ""},
{"input2", ge::kIrInputRequired, ""},
{"input3", ge::kIrInputRequired, ""},
{"input_param", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"input_param", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input0->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input1->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input2->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input3->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_param->GetAnchor(), node->GetInDataAnchor(4)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsLambNextMVOutput EsLambNextMV(EsbTensor *input_mul3, EsbTensor *input_mul2, EsbTensor *input_realdiv1, EsbTensor *input_mul1, EsbTensor *input_mul0, EsbTensor *input_realdiv0, EsbTensor *input_mul4, EsbTensor *mul0_x, EsbTensor *mul1_sub, EsbTensor *mul2_x, EsbTensor *mul3_sub1, EsbTensor *mul4_x, EsbTensor *add2_y) {
GE_ASSERT_NOTNULL(input_mul3);
GE_ASSERT_NOTNULL(input_mul2);
GE_ASSERT_NOTNULL(input_realdiv1);
GE_ASSERT_NOTNULL(input_mul1);
GE_ASSERT_NOTNULL(input_mul0);
GE_ASSERT_NOTNULL(input_realdiv0);
GE_ASSERT_NOTNULL(input_mul4);
GE_ASSERT_NOTNULL(mul0_x);
GE_ASSERT_NOTNULL(mul1_sub);
GE_ASSERT_NOTNULL(mul2_x);
GE_ASSERT_NOTNULL(mul3_sub1);
GE_ASSERT_NOTNULL(mul4_x);
GE_ASSERT_NOTNULL(add2_y);
auto &graph = input_mul3->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LambNextMV")
.Name(("LambNextMV_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_mul3", ge::kIrInputRequired, ""},
{"input_mul2", ge::kIrInputRequired, ""},
{"input_realdiv1", ge::kIrInputRequired, ""},
{"input_mul1", ge::kIrInputRequired, ""},
{"input_mul0", ge::kIrInputRequired, ""},
{"input_realdiv0", ge::kIrInputRequired, ""},
{"input_mul4", ge::kIrInputRequired, ""},
{"mul0_x", ge::kIrInputRequired, ""},
{"mul1_sub", ge::kIrInputRequired, ""},
{"mul2_x", ge::kIrInputRequired, ""},
{"mul3_sub1", ge::kIrInputRequired, ""},
{"mul4_x", ge::kIrInputRequired, ""},
{"add2_y", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y1", ge::kIrOutputRequired, ""},
{"y2", ge::kIrOutputRequired, ""},
{"y3", ge::kIrOutputRequired, ""},
{"y4", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_mul3->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_mul2->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_realdiv1->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_mul1->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_mul0->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_realdiv0->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_mul4->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mul0_x->GetAnchor(), node->GetInDataAnchor(7)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mul1_sub->GetAnchor(), node->GetInDataAnchor(8)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mul2_x->GetAnchor(), node->GetInDataAnchor(9)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mul3_sub1->GetAnchor(), node->GetInDataAnchor(10)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mul4_x->GetAnchor(), node->GetInDataAnchor(11)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(add2_y->GetAnchor(), node->GetInDataAnchor(12)));
return EsLambNextMVOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsLambNextMVWithDecayOutput EsLambNextMVWithDecay(EsbTensor *input_mul3, EsbTensor *input_mul2, EsbTensor *input_realdiv1, EsbTensor *input_mul1, EsbTensor *input_mul0, EsbTensor *input_realdiv0, EsbTensor *input_mul4, EsbTensor *mul0_x, EsbTensor *mul1_sub, EsbTensor *mul2_x, EsbTensor *mul3_sub1, EsbTensor *mul4_x, EsbTensor *add2_y) {
GE_ASSERT_NOTNULL(input_mul3);
GE_ASSERT_NOTNULL(input_mul2);
GE_ASSERT_NOTNULL(input_realdiv1);
GE_ASSERT_NOTNULL(input_mul1);
GE_ASSERT_NOTNULL(input_mul0);
GE_ASSERT_NOTNULL(input_realdiv0);
GE_ASSERT_NOTNULL(input_mul4);
GE_ASSERT_NOTNULL(mul0_x);
GE_ASSERT_NOTNULL(mul1_sub);
GE_ASSERT_NOTNULL(mul2_x);
GE_ASSERT_NOTNULL(mul3_sub1);
GE_ASSERT_NOTNULL(mul4_x);
GE_ASSERT_NOTNULL(add2_y);
auto &graph = input_mul3->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LambNextMVWithDecay")
.Name(("LambNextMVWithDecay_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_mul3", ge::kIrInputRequired, ""},
{"input_mul2", ge::kIrInputRequired, ""},
{"input_realdiv1", ge::kIrInputRequired, ""},
{"input_mul1", ge::kIrInputRequired, ""},
{"input_mul0", ge::kIrInputRequired, ""},
{"input_realdiv0", ge::kIrInputRequired, ""},
{"input_mul4", ge::kIrInputRequired, ""},
{"mul0_x", ge::kIrInputRequired, ""},
{"mul1_sub", ge::kIrInputRequired, ""},
{"mul2_x", ge::kIrInputRequired, ""},
{"mul3_sub1", ge::kIrInputRequired, ""},
{"mul4_x", ge::kIrInputRequired, ""},
{"add2_y", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y1", ge::kIrOutputRequired, ""},
{"y2", ge::kIrOutputRequired, ""},
{"y3", ge::kIrOutputRequired, ""},
{"y4", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_mul3->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_mul2->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_realdiv1->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_mul1->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_mul0->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_realdiv0->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_mul4->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mul0_x->GetAnchor(), node->GetInDataAnchor(7)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mul1_sub->GetAnchor(), node->GetInDataAnchor(8)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mul2_x->GetAnchor(), node->GetInDataAnchor(9)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mul3_sub1->GetAnchor(), node->GetInDataAnchor(10)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mul4_x->GetAnchor(), node->GetInDataAnchor(11)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(add2_y->GetAnchor(), node->GetInDataAnchor(12)));
return EsLambNextMVWithDecayOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsLambNextRightOutput EsLambNextRight(EsbTensor *input_square, EsbTensor *input_mul2, EsbTensor *mul2_x, EsbTensor *mul3_x, EsbTensor *truediv1_recip, EsbTensor *add2_y) {
GE_ASSERT_NOTNULL(input_square);
GE_ASSERT_NOTNULL(input_mul2);
GE_ASSERT_NOTNULL(mul2_x);
GE_ASSERT_NOTNULL(mul3_x);
GE_ASSERT_NOTNULL(truediv1_recip);
GE_ASSERT_NOTNULL(add2_y);
auto &graph = input_square->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LambNextRight")
.Name(("LambNextRight_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_square", ge::kIrInputRequired, ""},
{"input_mul2", ge::kIrInputRequired, ""},
{"mul2_x", ge::kIrInputRequired, ""},
{"mul3_x", ge::kIrInputRequired, ""},
{"truediv1_recip", ge::kIrInputRequired, ""},
{"add2_y", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y1", ge::kIrOutputRequired, ""},
{"y2", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_square->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_mul2->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mul2_x->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mul3_x->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(truediv1_recip->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(add2_y->GetAnchor(), node->GetInDataAnchor(5)));
return EsLambNextRightOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsLambUpdateWithLr(EsbTensor *input_greater1, EsbTensor *input_greater_realdiv, EsbTensor *input_realdiv, EsbTensor *input_mul0, EsbTensor *input_mul1, EsbTensor *input_sub, EsbTensor *greater_y, EsbTensor *select_e, EsbTensor *minimum_y) {
GE_ASSERT_NOTNULL(input_greater1);
GE_ASSERT_NOTNULL(input_greater_realdiv);
GE_ASSERT_NOTNULL(input_realdiv);
GE_ASSERT_NOTNULL(input_mul0);
GE_ASSERT_NOTNULL(input_mul1);
GE_ASSERT_NOTNULL(input_sub);
GE_ASSERT_NOTNULL(greater_y);
GE_ASSERT_NOTNULL(select_e);
GE_ASSERT_NOTNULL(minimum_y);
auto &graph = input_greater1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LambUpdateWithLr")
.Name(("LambUpdateWithLr_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_greater1", ge::kIrInputRequired, ""},
{"input_greater_realdiv", ge::kIrInputRequired, ""},
{"input_realdiv", ge::kIrInputRequired, ""},
{"input_mul0", ge::kIrInputRequired, ""},
{"input_mul1", ge::kIrInputRequired, ""},
{"input_sub", ge::kIrInputRequired, ""},
{"greater_y", ge::kIrInputRequired, ""},
{"select_e", ge::kIrInputRequired, ""},
{"minimum_y", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_greater1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_greater_realdiv->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_realdiv->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_mul0->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_mul1->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_sub->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(greater_y->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(select_e->GetAnchor(), node->GetInDataAnchor(7)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(minimum_y->GetAnchor(), node->GetInDataAnchor(8)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsLambUpdateWithLrV2(EsbTensor *x1, EsbTensor *x2, EsbTensor *x3, EsbTensor *x4, EsbTensor *x5, EsbTensor *greater_y, EsbTensor *select_e) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
GE_ASSERT_NOTNULL(x3);
GE_ASSERT_NOTNULL(x4);
GE_ASSERT_NOTNULL(x5);
GE_ASSERT_NOTNULL(greater_y);
GE_ASSERT_NOTNULL(select_e);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LambUpdateWithLrV2")
.Name(("LambUpdateWithLrV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"x3", ge::kIrInputRequired, ""},
{"x4", ge::kIrInputRequired, ""},
{"x5", ge::kIrInputRequired, ""},
{"greater_y", ge::kIrInputRequired, ""},
{"select_e", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x3->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x4->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x5->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(greater_y->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(select_e->GetAnchor(), node->GetInDataAnchor(6)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsLarsV2(EsbTensor *w, EsbTensor *g, EsbTensor *weight_decay, EsbTensor *learning_rate, float hyperpara, float epsilon, bool use_clip) {
GE_ASSERT_NOTNULL(w);
GE_ASSERT_NOTNULL(g);
GE_ASSERT_NOTNULL(weight_decay);
GE_ASSERT_NOTNULL(learning_rate);
auto &graph = w->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LarsV2")
.Name(("LarsV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"w", ge::kIrInputRequired, ""},
{"g", ge::kIrInputRequired, ""},
{"weight_decay", ge::kIrInputRequired, ""},
{"learning_rate", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"g_new", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"hyperpara",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(hyperpara))
},
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
{
"use_clip",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_clip))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(w->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(g->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight_decay->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(learning_rate->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsLarsV2Update(EsbTensor *w, EsbTensor *g, EsbTensor *w_square_sum, EsbTensor *g_square_sum, EsbTensor *weight_decay, EsbTensor *learning_rate, float hyperpara, float epsilon, bool use_clip) {
GE_ASSERT_NOTNULL(w);
GE_ASSERT_NOTNULL(g);
GE_ASSERT_NOTNULL(w_square_sum);
GE_ASSERT_NOTNULL(g_square_sum);
GE_ASSERT_NOTNULL(weight_decay);
GE_ASSERT_NOTNULL(learning_rate);
auto &graph = w->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LarsV2Update")
.Name(("LarsV2Update_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"w", ge::kIrInputRequired, ""},
{"g", ge::kIrInputRequired, ""},
{"w_square_sum", ge::kIrInputRequired, ""},
{"g_square_sum", ge::kIrInputRequired, ""},
{"weight_decay", ge::kIrInputRequired, ""},
{"learning_rate", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"g_new", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"hyperpara",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(hyperpara))
},
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
{
"use_clip",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_clip))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(w->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(g->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(w_square_sum->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(g_square_sum->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight_decay->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(learning_rate->GetAnchor(), node->GetInDataAnchor(5)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsLayerNormOutput EsLayerNorm(EsbTensor *x, EsbTensor *gamma, EsbTensor *beta, int64_t begin_norm_axis, int64_t begin_params_axis, float epsilon) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(gamma);
GE_ASSERT_NOTNULL(beta);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LayerNorm")
.Name(("LayerNorm_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
{"beta", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"mean", ge::kIrOutputRequired, ""},
{"variance", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"begin_norm_axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(begin_norm_axis))
},
{
"begin_params_axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(begin_params_axis))
},
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta->GetAnchor(), node->GetInDataAnchor(2)));
return EsLayerNormOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsLayerNormBetaGammaBackpropOutput EsLayerNormBetaGammaBackprop(EsbTensor *dy, EsbTensor *x, EsbTensor *variance, EsbTensor *mean, const int64_t *shape_gamma, int64_t shape_gamma_num) {
GE_ASSERT_NOTNULL(dy);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(variance);
GE_ASSERT_NOTNULL(mean);
auto &graph = dy->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LayerNormBetaGammaBackprop")
.Name(("LayerNormBetaGammaBackprop_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"dy", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"variance", ge::kIrInputRequired, ""},
{"mean", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"pd_gamma", ge::kIrOutputRequired, ""},
{"pd_beta", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"shape_gamma",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(shape_gamma, shape_gamma + shape_gamma_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(variance->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(3)));
return EsLayerNormBetaGammaBackpropOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsLayerNormBetaGammaBackpropV2Output EsLayerNormBetaGammaBackpropV2(EsbTensor *dy, EsbTensor *res_for_gamma, const int64_t *shape_gamma, int64_t shape_gamma_num) {
GE_ASSERT_NOTNULL(dy);
GE_ASSERT_NOTNULL(res_for_gamma);
auto &graph = dy->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LayerNormBetaGammaBackpropV2")
.Name(("LayerNormBetaGammaBackpropV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"dy", ge::kIrInputRequired, ""},
{"res_for_gamma", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"pd_gamma", ge::kIrOutputRequired, ""},
{"pd_beta", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"shape_gamma",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(shape_gamma, shape_gamma + shape_gamma_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(res_for_gamma->GetAnchor(), node->GetInDataAnchor(1)));
return EsLayerNormBetaGammaBackpropV2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsLayerNormGradOutput EsLayerNormGrad(EsbTensor *dy, EsbTensor *x, EsbTensor *variance, EsbTensor *mean, EsbTensor *gamma) {
GE_ASSERT_NOTNULL(dy);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(variance);
GE_ASSERT_NOTNULL(mean);
GE_ASSERT_NOTNULL(gamma);
auto &graph = dy->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LayerNormGrad")
.Name(("LayerNormGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"dy", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"variance", ge::kIrInputRequired, ""},
{"mean", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"pd_x", ge::kIrOutputRequired, ""},
{"pd_gamma", ge::kIrOutputRequired, ""},
{"pd_beta", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(variance->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(4)));
return EsLayerNormGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsLayerNormGradV3Output EsLayerNormGradV3(EsbTensor *dy, EsbTensor *x, EsbTensor *rstd, EsbTensor *mean, EsbTensor *gamma) {
GE_ASSERT_NOTNULL(dy);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(rstd);
GE_ASSERT_NOTNULL(mean);
GE_ASSERT_NOTNULL(gamma);
auto &graph = dy->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LayerNormGradV3")
.Name(("LayerNormGradV3_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"dy", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"rstd", ge::kIrInputRequired, ""},
{"mean", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"pd_x", ge::kIrOutputRequired, ""},
{"pd_gamma", ge::kIrOutputRequired, ""},
{"pd_beta", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rstd->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(4)));
return EsLayerNormGradV3Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsLayerNormUpdate(EsbTensor *x1, EsbTensor *beta, EsbTensor *gamma, EsbTensor *sum, EsbTensor *square_sum, float epsilon) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(beta);
GE_ASSERT_NOTNULL(gamma);
GE_ASSERT_NOTNULL(sum);
GE_ASSERT_NOTNULL(square_sum);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LayerNormUpdate")
.Name(("LayerNormUpdate_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"beta", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
{"sum", ge::kIrInputRequired, ""},
{"square_sum", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sum->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(square_sum->GetAnchor(), node->GetInDataAnchor(4)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsLayerNormV3Output EsLayerNormV3(EsbTensor *x, EsbTensor *gamma, EsbTensor *beta, int64_t begin_norm_axis, int64_t begin_params_axis, float epsilon) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(gamma);
GE_ASSERT_NOTNULL(beta);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LayerNormV3")
.Name(("LayerNormV3_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
{"beta", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"mean", ge::kIrOutputRequired, ""},
{"rstd", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"begin_norm_axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(begin_norm_axis))
},
{
"begin_params_axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(begin_params_axis))
},
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta->GetAnchor(), node->GetInDataAnchor(2)));
return EsLayerNormV3Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsLayerNormV4Output EsLayerNormV4(EsbTensor *x, EsbTensor *normalized_shape, EsbTensor *gamma, EsbTensor *beta, float epsilon) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(normalized_shape);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LayerNormV4")
.Name(("LayerNormV4_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"normalized_shape", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputOptional, ""},
{"beta", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"mean", ge::kIrOutputRequired, ""},
{"rstd", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(normalized_shape->GetAnchor(), node->GetInDataAnchor(1)));
if (gamma != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(2)));
}
if (beta != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta->GetAnchor(), node->GetInDataAnchor(3)));
}
return EsLayerNormV4Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsLayerNormXBackprop(EsbTensor *dy, EsbTensor *x, EsbTensor *variance, EsbTensor *mean, EsbTensor *gamma) {
GE_ASSERT_NOTNULL(dy);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(variance);
GE_ASSERT_NOTNULL(mean);
GE_ASSERT_NOTNULL(gamma);
auto &graph = dy->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LayerNormXBackprop")
.Name(("LayerNormXBackprop_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"dy", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"variance", ge::kIrInputRequired, ""},
{"mean", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"pd_x", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(variance->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(4)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsLayerNormXBackpropV2Output EsLayerNormXBackpropV2(EsbTensor *dy, EsbTensor *x, EsbTensor *variance, EsbTensor *mean, EsbTensor *gamma) {
GE_ASSERT_NOTNULL(dy);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(variance);
GE_ASSERT_NOTNULL(mean);
GE_ASSERT_NOTNULL(gamma);
auto &graph = dy->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LayerNormXBackpropV2")
.Name(("LayerNormXBackpropV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"dy", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"variance", ge::kIrInputRequired, ""},
{"mean", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"pd_x", ge::kIrOutputRequired, ""},
{"res_for_gamma", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(variance->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(4)));
return EsLayerNormXBackpropV2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsLayerNormXBackpropV3Output EsLayerNormXBackpropV3(EsbTensor *dy, EsbTensor *x, EsbTensor *rstd, EsbTensor *mean, EsbTensor *gamma) {
GE_ASSERT_NOTNULL(dy);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(rstd);
GE_ASSERT_NOTNULL(mean);
GE_ASSERT_NOTNULL(gamma);
auto &graph = dy->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LayerNormXBackpropV3")
.Name(("LayerNormXBackpropV3_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"dy", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"rstd", ge::kIrInputRequired, ""},
{"mean", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"pd_x", ge::kIrOutputRequired, ""},
{"res_for_gamma", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rstd->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(4)));
return EsLayerNormXBackpropV3Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsLeakyRelu(EsbTensor *x, float negative_slope) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LeakyRelu")
.Name(("LeakyRelu_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"negative_slope",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(negative_slope))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsLeakyReluGrad(EsbTensor *gradients, EsbTensor *features, float negative_slope) {
GE_ASSERT_NOTNULL(gradients);
GE_ASSERT_NOTNULL(features);
auto &graph = gradients->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LeakyReluGrad")
.Name(("LeakyReluGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"gradients", ge::kIrInputRequired, ""},
{"features", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"backprops", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"negative_slope",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(negative_slope))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gradients->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(features->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsLearnedUnigramCandidateSamplerOutput EsLearnedUnigramCandidateSampler(EsbTensor *true_classes, int64_t num_true, int64_t num_sampled, bool unique, int64_t range_max, int64_t seed, int64_t seed2) {
GE_ASSERT_NOTNULL(true_classes);
auto &graph = true_classes->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LearnedUnigramCandidateSampler")
.Name(("LearnedUnigramCandidateSampler_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"true_classes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"sampled_candidates", ge::kIrOutputRequired, ""},
{"true_expected_count", ge::kIrOutputRequired, ""},
{"sampled_expected_count", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_true",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_true))
},
{
"num_sampled",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_sampled))
},
{
"unique",
ge::kAttrRequired,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(unique))
},
{
"range_max",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(range_max))
},
{
"seed",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed))
},
{
"seed2",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed2))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(true_classes->GetAnchor(), node->GetInDataAnchor(0)));
return EsLearnedUnigramCandidateSamplerOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsLeftShift(EsbTensor *x, EsbTensor *y) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(y);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LeftShift")
.Name(("LeftShift_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"y", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"z", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsLerp(EsbTensor *start, EsbTensor *end, EsbTensor *weight) {
GE_ASSERT_NOTNULL(start);
GE_ASSERT_NOTNULL(end);
GE_ASSERT_NOTNULL(weight);
auto &graph = start->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Lerp")
.Name(("Lerp_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"start", ge::kIrInputRequired, ""},
{"end", ge::kIrInputRequired, ""},
{"weight", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(start->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(end->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsLess(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Less")
.Name(("Less_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsLessEqual(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LessEqual")
.Name(("LessEqual_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsLgamma(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Lgamma")
.Name(("Lgamma_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsLinSpace(EsbTensor *start, EsbTensor *stop, EsbTensor *num) {
GE_ASSERT_NOTNULL(start);
GE_ASSERT_NOTNULL(stop);
GE_ASSERT_NOTNULL(num);
auto &graph = start->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LinSpace")
.Name(("LinSpace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"start", ge::kIrInputRequired, ""},
{"stop", ge::kIrInputRequired, ""},
{"num", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(start->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(stop->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(num->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsLinSpaceD(EsbTensor *assist, EsbTensor *start, EsbTensor *stop, EsbTensor *num) {
GE_ASSERT_NOTNULL(assist);
GE_ASSERT_NOTNULL(start);
GE_ASSERT_NOTNULL(stop);
GE_ASSERT_NOTNULL(num);
auto &graph = assist->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LinSpaceD")
.Name(("LinSpaceD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"assist", ge::kIrInputRequired, ""},
{"start", ge::kIrInputRequired, ""},
{"stop", ge::kIrInputRequired, ""},
{"num", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(assist->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(start->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(stop->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(num->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsListDiffOutput EsListDiff(EsbTensor *x, EsbTensor *y, ge::DataType out_idx) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(y);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ListDiff")
.Name(("ListDiff_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"y", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"out", ge::kIrOutputRequired, ""},
{"idx", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"out_idx",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(out_idx))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y->GetAnchor(), node->GetInDataAnchor(1)));
return EsListDiffOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsLog(EsbTensor *x, float base, float scale, float shift) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Log")
.Name(("Log_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"base",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(base))
},
{
"scale",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(scale))
},
{
"shift",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(shift))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsLog1p(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Log1p")
.Name(("Log1p_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsLogAddExp(EsbTensor *x1, EsbTensor *x2, float base, float scale, float shift) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LogAddExp")
.Name(("LogAddExp_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"base",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(base))
},
{
"scale",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(scale))
},
{
"shift",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(shift))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsLogMatrixDeterminantOutput EsLogMatrixDeterminant(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LogMatrixDeterminant")
.Name(("LogMatrixDeterminant_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"sign", ge::kIrOutputRequired, ""},
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return EsLogMatrixDeterminantOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsLogSigmoid(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LogSigmoid")
.Name(("LogSigmoid_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsLogSigmoidGrad(EsbTensor *grads, EsbTensor *features) {
GE_ASSERT_NOTNULL(grads);
GE_ASSERT_NOTNULL(features);
auto &graph = grads->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LogSigmoidGrad")
.Name(("LogSigmoidGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grads", ge::kIrInputRequired, ""},
{"features", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"backprops", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grads->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(features->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsLogSoftmaxGrad(EsbTensor *grad, EsbTensor *x, const int64_t *axis, int64_t axis_num) {
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(x);
auto &graph = grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LogSoftmaxGrad")
.Name(("LogSoftmaxGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grad", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(axis, axis + axis_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsLogSoftmaxV2(EsbTensor *logits, const int64_t *axes, int64_t axes_num) {
GE_ASSERT_NOTNULL(logits);
auto &graph = logits->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LogSoftmaxV2")
.Name(("LogSoftmaxV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"logits", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"logsoftmax", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axes",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(axes, axes + axes_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(logits->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsLogSpaceD(EsbTensor *assist, float start, float end, int64_t steps, float base, int64_t dtype) {
GE_ASSERT_NOTNULL(assist);
auto &graph = assist->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LogSpaceD")
.Name(("LogSpaceD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"assist", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"start",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(start))
},
{
"end",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(end))
},
{
"steps",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(steps))
},
{
"base",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(base))
},
{
"dtype",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(assist->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsLogUniformCandidateSamplerOutput EsLogUniformCandidateSampler(EsbTensor *true_classes, int64_t num_true, int64_t num_sampled, bool unique, int64_t range_max, int64_t seed, int64_t seed2) {
GE_ASSERT_NOTNULL(true_classes);
auto &graph = true_classes->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LogUniformCandidateSampler")
.Name(("LogUniformCandidateSampler_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"true_classes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"sampled_candidates", ge::kIrOutputRequired, ""},
{"true_expected_count", ge::kIrOutputRequired, ""},
{"sampled_expected_count", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_true",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_true))
},
{
"num_sampled",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_sampled))
},
{
"unique",
ge::kAttrRequired,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(unique))
},
{
"range_max",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(range_max))
},
{
"seed",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed))
},
{
"seed2",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed2))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(true_classes->GetAnchor(), node->GetInDataAnchor(0)));
return EsLogUniformCandidateSamplerOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsLogicalAnd(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LogicalAnd")
.Name(("LogicalAnd_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsLogicalNot(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LogicalNot")
.Name(("LogicalNot_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsLogicalOr(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LogicalOr")
.Name(("LogicalOr_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsLookupTableExportOutput EsLookupTableExport(EsbTensor *handle, ge::DataType Tkeys, ge::DataType Tvalues) {
GE_ASSERT_NOTNULL(handle);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LookupTableExport")
.Name(("LookupTableExport_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"keys", ge::kIrOutputRequired, ""},
{"values", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"Tkeys",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(Tkeys))
},
{
"Tvalues",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(Tvalues))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
return EsLookupTableExportOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsLookupTableFind(EsbTensor *handle, EsbTensor *keys, EsbTensor *default_value, ge::DataType Tout) {
GE_ASSERT_NOTNULL(handle);
GE_ASSERT_NOTNULL(keys);
GE_ASSERT_NOTNULL(default_value);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LookupTableFind")
.Name(("LookupTableFind_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
{"keys", ge::kIrInputRequired, ""},
{"default_value", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"values", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"Tout",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(Tout))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(keys->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(default_value->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsLookupTableImport(EsbTensor *handle, EsbTensor *keys, EsbTensor *values) {
GE_ASSERT_NOTNULL(handle);
GE_ASSERT_NOTNULL(keys);
GE_ASSERT_NOTNULL(values);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LookupTableImport")
.Name(("LookupTableImport_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
{"keys", ge::kIrInputRequired, ""},
{"values", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(keys->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(values->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsLookupTableInsert(EsbTensor *handle, EsbTensor *keys, EsbTensor *values) {
GE_ASSERT_NOTNULL(handle);
GE_ASSERT_NOTNULL(keys);
GE_ASSERT_NOTNULL(values);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LookupTableInsert")
.Name(("LookupTableInsert_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
{"keys", ge::kIrInputRequired, ""},
{"values", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(keys->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(values->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsLookupTableRemove(EsbTensor *table_handle, EsbTensor *keys) {
GE_ASSERT_NOTNULL(table_handle);
GE_ASSERT_NOTNULL(keys);
auto &graph = table_handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LookupTableRemove")
.Name(("LookupTableRemove_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"table_handle", ge::kIrInputRequired, ""},
{"keys", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(table_handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(keys->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsLookupTableSize(EsbTensor *handle) {
GE_ASSERT_NOTNULL(handle);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LookupTableSize")
.Name(("LookupTableSize_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"size", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsLoopCond(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LoopCond")
.Name(("LoopCond_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsLowerBound(EsbTensor *sorted_x, EsbTensor *values, ge::DataType out_type) {
GE_ASSERT_NOTNULL(sorted_x);
GE_ASSERT_NOTNULL(values);
auto &graph = sorted_x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LowerBound")
.Name(("LowerBound_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"sorted_x", ge::kIrInputRequired, ""},
{"values", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"out_type",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(out_type))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sorted_x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(values->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsLpLoss(EsbTensor *predict, EsbTensor *label, int64_t p, const char *reduction) {
GE_ASSERT_NOTNULL(predict);
GE_ASSERT_NOTNULL(label);
auto &graph = predict->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LpLoss")
.Name(("LpLoss_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"predict", ge::kIrInputRequired, ""},
{"label", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"p",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(p))
},
{
"reduction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduction))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(predict->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(label->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsLpNorm(EsbTensor *x, int64_t p, const int64_t *axes, int64_t axes_num, bool keepdim, float epsilon) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LpNorm")
.Name(("LpNorm_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"p",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(p))
},
{
"axes",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(axes, axes + axes_num))
},
{
"keepdim",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keepdim))
},
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsLpNormReduce(EsbTensor *x, int64_t p, const int64_t *axes, int64_t axes_num, bool keepdim, float epsilon) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LpNormReduce")
.Name(("LpNormReduce_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"p",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(p))
},
{
"axes",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(axes, axes + axes_num))
},
{
"keepdim",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keepdim))
},
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsLpNormReduceV2(EsbTensor *x, float p, const int64_t *axes, int64_t axes_num, bool keepdim, float epsilon) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LpNormReduceV2")
.Name(("LpNormReduceV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"p",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(p))
},
{
"axes",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(axes, axes + axes_num))
},
{
"keepdim",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keepdim))
},
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsLpNormUpdate(EsbTensor *x, int64_t p, float epsilon) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LpNormUpdate")
.Name(("LpNormUpdate_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"p",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(p))
},
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsLpNormUpdateV2(EsbTensor *x, float p, float epsilon) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LpNormUpdateV2")
.Name(("LpNormUpdateV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"p",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(p))
},
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsLpNormV2(EsbTensor *x, float p, const int64_t *axes, int64_t axes_num, bool keepdim, float epsilon) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("LpNormV2")
.Name(("LpNormV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"p",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(p))
},
{
"axes",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(axes, axes + axes_num))
},
{
"keepdim",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keepdim))
},
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsLruCache(EsbGraph *owner_graph, ge::DataType dtype, const char *container, const char *shared_name, int64_t cache_size, float load_factor) {
GE_ASSERT_NOTNULL(owner_graph);
EsbGraph &graph = *owner_graph;

auto desc = ge::CompliantOpDescBuilder().OpType("LruCache")
.Name(("LruCache_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
})
.IrDefOutputs({
{"cache", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
{
"container",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(container))
},
{
"shared_name",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(shared_name))
},
{
"cache_size",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(cache_size))
},
{
"load_factor",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(load_factor))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsLuOutput EsLu(EsbTensor *input, ge::DataType output_idx_type) {
GE_ASSERT_NOTNULL(input);
auto &graph = input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Lu")
.Name(("Lu_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"lu", ge::kIrOutputRequired, ""},
{"p", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"output_idx_type",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(output_idx_type))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input->GetAnchor(), node->GetInDataAnchor(0)));
return EsLuOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsMVN(EsbTensor *x, bool normalize_variance, bool across_channels, float eps) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MVN")
.Name(("MVN_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"normalize_variance",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(normalize_variance))
},
{
"across_channels",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(across_channels))
},
{
"eps",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(eps))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMVNV2(EsbTensor *x, float eps, const int64_t *axes, int64_t axes_num) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MVNV2")
.Name(("MVNV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"eps",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(eps))
},
{
"axes",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(axes, axes + axes_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMapIndex(EsbTensor *x, EsbTensor *data_seq, EsbTensor *level_index) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(data_seq);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MapIndex")
.Name(("MapIndex_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"data_seq", ge::kIrInputRequired, ""},
{"level_index", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(data_seq->GetAnchor(), node->GetInDataAnchor(1)));
if (level_index != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(level_index->GetAnchor(), node->GetInDataAnchor(2)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMask2Argmax(EsbTensor *x, EsbTensor *mask, const int64_t *ksize, int64_t ksize_num, const int64_t *strides, int64_t strides_num, const char *padding, const int64_t *originshape, int64_t originshape_num) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(mask);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Mask2Argmax")
.Name(("Mask2Argmax_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"mask", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"argmax", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ksize",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ksize, ksize + ksize_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"padding",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(padding))
},
{
"originshape",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(originshape, originshape + originshape_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mask->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMaskedFill(EsbTensor *x, EsbTensor *mask, EsbTensor *value) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(mask);
GE_ASSERT_NOTNULL(value);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MaskedFill")
.Name(("MaskedFill_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"mask", ge::kIrInputRequired, ""},
{"value", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mask->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMaskedFillRange(EsbTensor *x, EsbTensor *start, EsbTensor *end, EsbTensor *value, int64_t axis) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(start);
GE_ASSERT_NOTNULL(end);
GE_ASSERT_NOTNULL(value);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MaskedFillRange")
.Name(("MaskedFillRange_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"start", ge::kIrInputRequired, ""},
{"end", ge::kIrInputRequired, ""},
{"value", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(start->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(end->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMaskedScale(EsbTensor *x, EsbTensor *mask, float value) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(mask);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MaskedScale")
.Name(("MaskedScale_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"mask", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"value",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(value))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mask->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMaskedScatter(EsbTensor *x, EsbTensor *mask, EsbTensor *updates) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(mask);
GE_ASSERT_NOTNULL(updates);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MaskedScatter")
.Name(("MaskedScatter_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"mask", ge::kIrInputRequired, ""},
{"updates", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mask->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(updates->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMaskedSelect(EsbTensor *x, EsbTensor *mask) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(mask);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MaskedSelect")
.Name(("MaskedSelect_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"mask", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mask->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMaskedSelectV2(EsbTensor *x, EsbTensor *mask) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(mask);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MaskedSelectV2")
.Name(("MaskedSelectV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"mask", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mask->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMaskedSoftmaxWithRelPosBias(EsbTensor *x, EsbTensor *atten_mask, EsbTensor *relative_pos_bias, float scale_value, int64_t inner_precision_mode) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(relative_pos_bias);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MaskedSoftmaxWithRelPosBias")
.Name(("MaskedSoftmaxWithRelPosBias_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"atten_mask", ge::kIrInputOptional, ""},
{"relative_pos_bias", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"scale_value",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(scale_value))
},
{
"inner_precision_mode",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(inner_precision_mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
if (atten_mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(atten_mask->GetAnchor(), node->GetInDataAnchor(1)));
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(relative_pos_bias->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMatMul(EsbTensor *x1, EsbTensor *x2, EsbTensor *bias, bool transpose_x1, bool transpose_x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MatMul")
.Name(("MatMul_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"transpose_x1",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(transpose_x1))
},
{
"transpose_x2",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(transpose_x2))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(2)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMatMulV2(EsbTensor *x1, EsbTensor *x2, EsbTensor *bias, EsbTensor *offset_w, bool transpose_x1, bool transpose_x2, int64_t offset_x) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MatMulV2")
.Name(("MatMulV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
{"offset_w", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"transpose_x1",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(transpose_x1))
},
{
"transpose_x2",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(transpose_x2))
},
{
"offset_x",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(offset_x))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(2)));
}
if (offset_w != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset_w->GetAnchor(), node->GetInDataAnchor(3)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMatMulV2Compress(EsbTensor *x1, EsbTensor *x2, EsbTensor *compress_index, EsbTensor *bias, EsbTensor *offset_w, bool transpose_x1, bool transpose_x2, int64_t offset_x, const char *alg) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
GE_ASSERT_NOTNULL(compress_index);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MatMulV2Compress")
.Name(("MatMulV2Compress_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"compress_index", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
{"offset_w", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"transpose_x1",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(transpose_x1))
},
{
"transpose_x2",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(transpose_x2))
},
{
"offset_x",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(offset_x))
},
{
"alg",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(alg))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(compress_index->GetAnchor(), node->GetInDataAnchor(2)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(3)));
}
if (offset_w != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset_w->GetAnchor(), node->GetInDataAnchor(4)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMatMulV2CompressDequant(EsbTensor *x1, EsbTensor *x2, EsbTensor *compress_index, EsbTensor *deq_scale, EsbTensor *bias, EsbTensor *offset_w, bool transpose_x1, bool transpose_x2, const int64_t *compress_info, int64_t compress_info_num, int64_t offset_x, const char *alg) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
GE_ASSERT_NOTNULL(compress_index);
GE_ASSERT_NOTNULL(deq_scale);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MatMulV2CompressDequant")
.Name(("MatMulV2CompressDequant_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"compress_index", ge::kIrInputRequired, ""},
{"deq_scale", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
{"offset_w", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"transpose_x1",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(transpose_x1))
},
{
"transpose_x2",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(transpose_x2))
},
{
"compress_info",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(compress_info, compress_info + compress_info_num))
},
{
"offset_x",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(offset_x))
},
{
"alg",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(alg))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(compress_index->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(deq_scale->GetAnchor(), node->GetInDataAnchor(3)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(4)));
}
if (offset_w != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset_w->GetAnchor(), node->GetInDataAnchor(5)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMatMulV3(EsbTensor *x1, EsbTensor *x2, EsbTensor *bias, EsbTensor *offset_w, bool transpose_x1, bool transpose_x2, int64_t offset_x, bool enable_hf32) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MatMulV3")
.Name(("MatMulV3_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
{"offset_w", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"transpose_x1",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(transpose_x1))
},
{
"transpose_x2",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(transpose_x2))
},
{
"offset_x",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(offset_x))
},
{
"enable_hf32",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(enable_hf32))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(2)));
}
if (offset_w != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset_w->GetAnchor(), node->GetInDataAnchor(3)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMatmulAllReduce(EsbTensor *x1, EsbTensor *x2, EsbTensor *bias, EsbTensor *x3, EsbTensor *antiquant_scale, EsbTensor *antiquant_offset, EsbTensor *dequant_scale, EsbTensor *pertoken_scale, EsbTensor *comm_quant_scale_1, EsbTensor *comm_quant_scale_2, const char *group, const char *reduce_op, bool is_trans_a, bool is_trans_b, int64_t comm_turn, int64_t antiquant_group_size) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MatmulAllReduce")
.Name(("MatmulAllReduce_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
{"x3", ge::kIrInputOptional, ""},
{"antiquant_scale", ge::kIrInputOptional, ""},
{"antiquant_offset", ge::kIrInputOptional, ""},
{"dequant_scale", ge::kIrInputOptional, ""},
{"pertoken_scale", ge::kIrInputOptional, ""},
{"comm_quant_scale_1", ge::kIrInputOptional, ""},
{"comm_quant_scale_2", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"group",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(group))
},
{
"reduce_op",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduce_op))
},
{
"is_trans_a",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_trans_a))
},
{
"is_trans_b",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_trans_b))
},
{
"comm_turn",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(comm_turn))
},
{
"antiquant_group_size",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(antiquant_group_size))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(2)));
}
if (x3 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x3->GetAnchor(), node->GetInDataAnchor(3)));
}
if (antiquant_scale != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(antiquant_scale->GetAnchor(), node->GetInDataAnchor(4)));
}
if (antiquant_offset != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(antiquant_offset->GetAnchor(), node->GetInDataAnchor(5)));
}
if (dequant_scale != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dequant_scale->GetAnchor(), node->GetInDataAnchor(6)));
}
if (pertoken_scale != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(pertoken_scale->GetAnchor(), node->GetInDataAnchor(7)));
}
if (comm_quant_scale_1 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(comm_quant_scale_1->GetAnchor(), node->GetInDataAnchor(8)));
}
if (comm_quant_scale_2 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(comm_quant_scale_2->GetAnchor(), node->GetInDataAnchor(9)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsMatmulAllReduceAddRmsNormOutput EsMatmulAllReduceAddRmsNorm(EsbTensor *x1, EsbTensor *x2, EsbTensor *bias, EsbTensor *residual, EsbTensor *gamma, EsbTensor *antiquant_scale, EsbTensor *antiquant_offset, EsbTensor *dequant_scale, const char *group, const char *reduce_op, bool is_trans_a, bool is_trans_b, int64_t comm_turn, int64_t antiquant_group_size, float epsilon) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
GE_ASSERT_NOTNULL(residual);
GE_ASSERT_NOTNULL(gamma);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MatmulAllReduceAddRmsNorm")
.Name(("MatmulAllReduceAddRmsNorm_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
{"residual", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
{"antiquant_scale", ge::kIrInputOptional, ""},
{"antiquant_offset", ge::kIrInputOptional, ""},
{"dequant_scale", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"norm_out", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"group",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(group))
},
{
"reduce_op",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduce_op))
},
{
"is_trans_a",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_trans_a))
},
{
"is_trans_b",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_trans_b))
},
{
"comm_turn",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(comm_turn))
},
{
"antiquant_group_size",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(antiquant_group_size))
},
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(2)));
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(residual->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(4)));
if (antiquant_scale != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(antiquant_scale->GetAnchor(), node->GetInDataAnchor(5)));
}
if (antiquant_offset != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(antiquant_offset->GetAnchor(), node->GetInDataAnchor(6)));
}
if (dequant_scale != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dequant_scale->GetAnchor(), node->GetInDataAnchor(7)));
}
return EsMatmulAllReduceAddRmsNormOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsMatmulLayerNormReduceOutput EsMatmulLayerNormReduce(EsbTensor *x1, EsbTensor *weight, EsbTensor *bias, EsbTensor *x2, EsbTensor *x3) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(weight);
GE_ASSERT_NOTNULL(bias);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MatmulLayerNormReduce")
.Name(("MatmulLayerNormReduce_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"weight", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"x3", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"x2", ge::kIrOutputRequired, ""},
{"sum", ge::kIrOutputRequired, ""},
{"square_sum", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(3)));
if (x3 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x3->GetAnchor(), node->GetInDataAnchor(4)));
}
return EsMatmulLayerNormReduceOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsMatmulReduceScatter(EsbTensor *x1, EsbTensor *x2, EsbTensor *bias, const char *group, const char *reduce_op, bool is_trans_a, bool is_trans_b, int64_t comm_turn, int64_t rank_size) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MatmulReduceScatter")
.Name(("MatmulReduceScatter_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"group",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(group))
},
{
"reduce_op",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduce_op))
},
{
"is_trans_a",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_trans_a))
},
{
"is_trans_b",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_trans_b))
},
{
"comm_turn",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(comm_turn))
},
{
"rank_size",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(rank_size))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(2)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMatrixBandPart(EsbTensor *x, EsbTensor *num_lower, EsbTensor *num_upper) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(num_lower);
GE_ASSERT_NOTNULL(num_upper);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MatrixBandPart")
.Name(("MatrixBandPart_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"num_lower", ge::kIrInputRequired, ""},
{"num_upper", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(num_lower->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(num_upper->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMatrixDeterminant(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MatrixDeterminant")
.Name(("MatrixDeterminant_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMatrixDiag(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MatrixDiag")
.Name(("MatrixDiag_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMatrixDiagD(EsbTensor *x, EsbTensor *assist) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(assist);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MatrixDiagD")
.Name(("MatrixDiagD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"assist", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(assist->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMatrixDiagPart(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MatrixDiagPart")
.Name(("MatrixDiagPart_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMatrixDiagPartD(EsbTensor *x, EsbTensor *assist) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(assist);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MatrixDiagPartD")
.Name(("MatrixDiagPartD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"assist", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(assist->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMatrixDiagPartV2(EsbTensor *input, EsbTensor *k, EsbTensor *padding_value) {
GE_ASSERT_NOTNULL(input);
GE_ASSERT_NOTNULL(k);
GE_ASSERT_NOTNULL(padding_value);
auto &graph = input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MatrixDiagPartV2")
.Name(("MatrixDiagPartV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input", ge::kIrInputRequired, ""},
{"k", ge::kIrInputRequired, ""},
{"padding_value", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"diagonal", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(k->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(padding_value->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMatrixDiagPartV3(EsbTensor *x, EsbTensor *k, EsbTensor *padding_value, const char *align) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(k);
GE_ASSERT_NOTNULL(padding_value);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MatrixDiagPartV3")
.Name(("MatrixDiagPartV3_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"k", ge::kIrInputRequired, ""},
{"padding_value", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"align",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(align))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(k->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(padding_value->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMatrixDiagV2(EsbTensor *diagonal, EsbTensor *k, EsbTensor *num_rows, EsbTensor *num_cols, EsbTensor *padding_value) {
GE_ASSERT_NOTNULL(diagonal);
GE_ASSERT_NOTNULL(k);
GE_ASSERT_NOTNULL(num_rows);
GE_ASSERT_NOTNULL(num_cols);
GE_ASSERT_NOTNULL(padding_value);
auto &graph = diagonal->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MatrixDiagV2")
.Name(("MatrixDiagV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"diagonal", ge::kIrInputRequired, ""},
{"k", ge::kIrInputRequired, ""},
{"num_rows", ge::kIrInputRequired, ""},
{"num_cols", ge::kIrInputRequired, ""},
{"padding_value", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(diagonal->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(k->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(num_rows->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(num_cols->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(padding_value->GetAnchor(), node->GetInDataAnchor(4)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMatrixDiagV3(EsbTensor *x, EsbTensor *k, EsbTensor *num_rows, EsbTensor *num_cols, EsbTensor *padding_value, const char *align) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(k);
GE_ASSERT_NOTNULL(num_rows);
GE_ASSERT_NOTNULL(num_cols);
GE_ASSERT_NOTNULL(padding_value);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MatrixDiagV3")
.Name(("MatrixDiagV3_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"k", ge::kIrInputRequired, ""},
{"num_rows", ge::kIrInputRequired, ""},
{"num_cols", ge::kIrInputRequired, ""},
{"padding_value", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"align",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(align))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(k->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(num_rows->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(num_cols->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(padding_value->GetAnchor(), node->GetInDataAnchor(4)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMatrixInverse(EsbTensor *x, bool adjoint) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MatrixInverse")
.Name(("MatrixInverse_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"adjoint",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(adjoint))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMatrixSetDiag(EsbTensor *x, EsbTensor *diagonal) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(diagonal);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MatrixSetDiag")
.Name(("MatrixSetDiag_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"diagonal", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(diagonal->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMatrixSetDiagD(EsbTensor *x, EsbTensor *diagonal, EsbTensor *assist) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(diagonal);
GE_ASSERT_NOTNULL(assist);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MatrixSetDiagD")
.Name(("MatrixSetDiagD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"diagonal", ge::kIrInputRequired, ""},
{"assist", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(diagonal->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(assist->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMatrixSetDiagV2(EsbTensor *input, EsbTensor *diagonal, EsbTensor *k) {
GE_ASSERT_NOTNULL(input);
GE_ASSERT_NOTNULL(diagonal);
GE_ASSERT_NOTNULL(k);
auto &graph = input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MatrixSetDiagV2")
.Name(("MatrixSetDiagV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input", ge::kIrInputRequired, ""},
{"diagonal", ge::kIrInputRequired, ""},
{"k", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(diagonal->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(k->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMatrixSetDiagV3(EsbTensor *input, EsbTensor *diagonal, EsbTensor *k, const char *align) {
GE_ASSERT_NOTNULL(input);
GE_ASSERT_NOTNULL(diagonal);
GE_ASSERT_NOTNULL(k);
auto &graph = input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MatrixSetDiagV3")
.Name(("MatrixSetDiagV3_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input", ge::kIrInputRequired, ""},
{"diagonal", ge::kIrInputRequired, ""},
{"k", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"align",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(align))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(diagonal->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(k->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMatrixSolve(EsbTensor *matrix, EsbTensor *rhs, bool adjoint) {
GE_ASSERT_NOTNULL(matrix);
GE_ASSERT_NOTNULL(rhs);
auto &graph = matrix->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MatrixSolve")
.Name(("MatrixSolve_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"matrix", ge::kIrInputRequired, ""},
{"rhs", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"adjoint",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(adjoint))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(matrix->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rhs->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMatrixSolveLs(EsbTensor *matrix, EsbTensor *rhs, EsbTensor *l2, bool fast) {
GE_ASSERT_NOTNULL(matrix);
GE_ASSERT_NOTNULL(rhs);
GE_ASSERT_NOTNULL(l2);
auto &graph = matrix->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MatrixSolveLs")
.Name(("MatrixSolveLs_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"matrix", ge::kIrInputRequired, ""},
{"rhs", ge::kIrInputRequired, ""},
{"l2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"fast",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(fast))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(matrix->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rhs->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(l2->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMatrixSquareRoot(EsbTensor *input) {
GE_ASSERT_NOTNULL(input);
auto &graph = input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MatrixSquareRoot")
.Name(("MatrixSquareRoot_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMatrixTriangularSolve(EsbTensor *matrix, EsbTensor *rhs, bool lower, bool adjoint) {
GE_ASSERT_NOTNULL(matrix);
GE_ASSERT_NOTNULL(rhs);
auto &graph = matrix->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MatrixTriangularSolve")
.Name(("MatrixTriangularSolve_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"matrix", ge::kIrInputRequired, ""},
{"rhs", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"lower",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(lower))
},
{
"adjoint",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(adjoint))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(matrix->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rhs->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMaxN(EsbTensor **x, int64_t x_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MaxN")
.Name(("MaxN_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMaxPool(EsbTensor *x, const int64_t *ksize, int64_t ksize_num, const int64_t *strides, int64_t strides_num, const char *padding, const char *data_format) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MaxPool")
.Name(("MaxPool_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ksize",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ksize, ksize + ksize_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"padding",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(padding))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMaxPool3D(EsbTensor *x, const int64_t *ksize, int64_t ksize_num, const int64_t *strides, int64_t strides_num, const char *padding, const int64_t *pads, int64_t pads_num, const int64_t *dilation, int64_t dilation_num, int64_t ceil_mode, const char *data_format) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MaxPool3D")
.Name(("MaxPool3D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ksize",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ksize, ksize + ksize_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"padding",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(padding))
},
{
"pads",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dilation",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilation, dilation + dilation_num))
},
{
"ceil_mode",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(ceil_mode))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMaxPool3DGrad(EsbTensor *orig_x, EsbTensor *orig_y, EsbTensor *grads, const int64_t *ksize, int64_t ksize_num, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const char *padding, const char *data_format) {
GE_ASSERT_NOTNULL(orig_x);
GE_ASSERT_NOTNULL(orig_y);
GE_ASSERT_NOTNULL(grads);
auto &graph = orig_x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MaxPool3DGrad")
.Name(("MaxPool3DGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"orig_x", ge::kIrInputRequired, ""},
{"orig_y", ge::kIrInputRequired, ""},
{"grads", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ksize",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ksize, ksize + ksize_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"padding",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(padding))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(orig_x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(orig_y->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grads->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMaxPool3DGradGrad(EsbTensor *orig_x, EsbTensor *orig_y, EsbTensor *grads, const int64_t *ksize, int64_t ksize_num, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const char *data_format) {
GE_ASSERT_NOTNULL(orig_x);
GE_ASSERT_NOTNULL(orig_y);
GE_ASSERT_NOTNULL(grads);
auto &graph = orig_x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MaxPool3DGradGrad")
.Name(("MaxPool3DGradGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"orig_x", ge::kIrInputRequired, ""},
{"orig_y", ge::kIrInputRequired, ""},
{"grads", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ksize",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ksize, ksize + ksize_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(orig_x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(orig_y->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grads->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsMaxPool3DWithArgmaxOutput EsMaxPool3DWithArgmax(EsbTensor *x, const int64_t *ksize, int64_t ksize_num, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const int64_t *dilation, int64_t dilation_num, bool ceil_mode, const char *data_format, const char *argmax_type) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MaxPool3DWithArgmax")
.Name(("MaxPool3DWithArgmax_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"argmax", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ksize",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ksize, ksize + ksize_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dilation",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilation, dilation + dilation_num))
},
{
"ceil_mode",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(ceil_mode))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"argmax_type",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(argmax_type))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return EsMaxPool3DWithArgmaxOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsMaxPoolExt2(EsbTensor *x, const int64_t *ksize, int64_t ksize_num, const int64_t *strides, int64_t strides_num, const char *padding, const char *data_format) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MaxPoolExt2")
.Name(("MaxPoolExt2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ksize",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ksize, ksize + ksize_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"padding",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(padding))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMaxPoolGrad(EsbTensor *x1, EsbTensor *x2, EsbTensor *grad, const int64_t *ksize, int64_t ksize_num, const int64_t *strides, int64_t strides_num, const char *padding, const char *data_format) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
GE_ASSERT_NOTNULL(grad);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MaxPoolGrad")
.Name(("MaxPoolGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ksize",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ksize, ksize + ksize_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"padding",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(padding))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMaxPoolGradGrad(EsbTensor *x1, EsbTensor *x2, EsbTensor *grad, const int64_t *ksize, int64_t ksize_num, const int64_t *strides, int64_t strides_num, const char *padding, const char *data_format) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
GE_ASSERT_NOTNULL(grad);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MaxPoolGradGrad")
.Name(("MaxPoolGradGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ksize",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ksize, ksize + ksize_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"padding",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(padding))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMaxPoolGradGradWithArgmax(EsbTensor *x, EsbTensor *grad, EsbTensor *argmax, const int64_t *ksize, int64_t ksize_num, const int64_t *strides, int64_t strides_num, const char *padding) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(argmax);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MaxPoolGradGradWithArgmax")
.Name(("MaxPoolGradGradWithArgmax_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"argmax", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ksize",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ksize, ksize + ksize_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"padding",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(padding))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(argmax->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMaxPoolGradWithArgmax(EsbTensor *x, EsbTensor *grad, EsbTensor *argmax, const int64_t *ksize, int64_t ksize_num, const int64_t *strides, int64_t strides_num, const char *padding) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(argmax);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MaxPoolGradWithArgmax")
.Name(("MaxPoolGradWithArgmax_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"argmax", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ksize",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ksize, ksize + ksize_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"padding",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(padding))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(argmax->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMaxPoolGradWithArgmaxV1(EsbTensor *x, EsbTensor *grad, EsbTensor *argmax, const int64_t *ksize, int64_t ksize_num, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, int64_t dtype, const int64_t *dilation, int64_t dilation_num, bool ceil_mode) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(argmax);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MaxPoolGradWithArgmaxV1")
.Name(("MaxPoolGradWithArgmaxV1_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"argmax", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ksize",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ksize, ksize + ksize_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dtype",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dtype))
},
{
"dilation",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilation, dilation + dilation_num))
},
{
"ceil_mode",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(ceil_mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(argmax->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMaxPoolGradWithArgmaxV2(EsbTensor *x, EsbTensor *grad, EsbTensor *argmax, const int64_t *ksize, int64_t ksize_num, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, int64_t dtype, const int64_t *dilation, int64_t dilation_num, bool ceil_mode) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(argmax);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MaxPoolGradWithArgmaxV2")
.Name(("MaxPoolGradWithArgmaxV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"argmax", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ksize",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ksize, ksize + ksize_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dtype",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dtype))
},
{
"dilation",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilation, dilation + dilation_num))
},
{
"ceil_mode",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(ceil_mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(argmax->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMaxPoolV2(EsbTensor *x, EsbTensor *ksize, EsbTensor *strides, const char *padding, const char *data_format) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(ksize);
GE_ASSERT_NOTNULL(strides);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MaxPoolV2")
.Name(("MaxPoolV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"ksize", ge::kIrInputRequired, ""},
{"strides", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"padding",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(padding))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(ksize->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(strides->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMaxPoolV3(EsbTensor *x, const int64_t *ksize, int64_t ksize_num, const int64_t *strides, int64_t strides_num, const char *padding_mode, const int64_t *pads, int64_t pads_num, const char *data_format, bool global_pooling, bool ceil_mode) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MaxPoolV3")
.Name(("MaxPoolV3_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ksize",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ksize, ksize + ksize_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"padding_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(padding_mode))
},
{
"pads",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"global_pooling",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(global_pooling))
},
{
"ceil_mode",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(ceil_mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMaxPoolV3Grad(EsbTensor *orig_input, EsbTensor *orig_output, EsbTensor *grad, const int64_t *ksize, int64_t ksize_num, const int64_t *strides, int64_t strides_num, const char *padding_mode, const int64_t *pads, int64_t pads_num, const char *data_format, bool global_pooling, bool ceil_mode) {
GE_ASSERT_NOTNULL(orig_input);
GE_ASSERT_NOTNULL(orig_output);
GE_ASSERT_NOTNULL(grad);
auto &graph = orig_input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MaxPoolV3Grad")
.Name(("MaxPoolV3Grad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"orig_input", ge::kIrInputRequired, ""},
{"orig_output", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"out_grad", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ksize",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ksize, ksize + ksize_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"padding_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(padding_mode))
},
{
"pads",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"global_pooling",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(global_pooling))
},
{
"ceil_mode",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(ceil_mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(orig_input->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(orig_output->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsMaxPoolWithArgmaxOutput EsMaxPoolWithArgmax(EsbTensor *x, const int64_t *ksize, int64_t ksize_num, const int64_t *strides, int64_t strides_num, const char *padding, int64_t Targmax) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MaxPoolWithArgmax")
.Name(("MaxPoolWithArgmax_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"argmax", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ksize",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ksize, ksize + ksize_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"padding",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(padding))
},
{
"Targmax",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(Targmax))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return EsMaxPoolWithArgmaxOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsMaxPoolWithArgmaxV1Output EsMaxPoolWithArgmaxV1(EsbTensor *x, const int64_t *ksize, int64_t ksize_num, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, int64_t dtype, const int64_t *dilation, int64_t dilation_num, bool ceil_mode) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MaxPoolWithArgmaxV1")
.Name(("MaxPoolWithArgmaxV1_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"argmax", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ksize",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ksize, ksize + ksize_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dtype",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dtype))
},
{
"dilation",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilation, dilation + dilation_num))
},
{
"ceil_mode",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(ceil_mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return EsMaxPoolWithArgmaxV1Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsMaxPoolWithArgmaxV2Output EsMaxPoolWithArgmaxV2(EsbTensor *x, const int64_t *ksize, int64_t ksize_num, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, int64_t dtype, const int64_t *dilation, int64_t dilation_num, bool ceil_mode) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MaxPoolWithArgmaxV2")
.Name(("MaxPoolWithArgmaxV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"argmax", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ksize",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ksize, ksize + ksize_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dtype",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dtype))
},
{
"dilation",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilation, dilation + dilation_num))
},
{
"ceil_mode",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(ceil_mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return EsMaxPoolWithArgmaxV2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsMaximum(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Maximum")
.Name(("Maximum_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsMaximumGradOutput EsMaximumGrad(EsbTensor *grads, EsbTensor *x1, EsbTensor *x2, bool grad_x, bool grad_y) {
GE_ASSERT_NOTNULL(grads);
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = grads->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MaximumGrad")
.Name(("MaximumGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grads", ge::kIrInputRequired, ""},
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y1", ge::kIrOutputRequired, ""},
{"y2", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"grad_x",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(grad_x))
},
{
"grad_y",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(grad_y))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grads->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(2)));
return EsMaximumGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsMergeOutput EsMerge(EsbTensor **x, int64_t x_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Merge")
.Name(("Merge_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"value_index", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return EsMergeOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsMfcc(EsbTensor *spectrogram, EsbTensor *sample_rate, float upper_frequency_limit, float lower_frequency_limit, int64_t filterbank_channel_count, int64_t dct_coefficient_count) {
GE_ASSERT_NOTNULL(spectrogram);
GE_ASSERT_NOTNULL(sample_rate);
auto &graph = spectrogram->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Mfcc")
.Name(("Mfcc_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"spectrogram", ge::kIrInputRequired, ""},
{"sample_rate", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"upper_frequency_limit",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(upper_frequency_limit))
},
{
"lower_frequency_limit",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(lower_frequency_limit))
},
{
"filterbank_channel_count",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(filterbank_channel_count))
},
{
"dct_coefficient_count",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dct_coefficient_count))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(spectrogram->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sample_rate->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMinAreaPolygons(EsbTensor *pointsets) {
GE_ASSERT_NOTNULL(pointsets);
auto &graph = pointsets->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MinAreaPolygons")
.Name(("MinAreaPolygons_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"pointsets", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"polygons", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(pointsets->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMinimum(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Minimum")
.Name(("Minimum_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsMinimumGradOutput EsMinimumGrad(EsbTensor *grads, EsbTensor *x1, EsbTensor *x2, bool grad_x, bool grad_y) {
GE_ASSERT_NOTNULL(grads);
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = grads->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MinimumGrad")
.Name(("MinimumGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grads", ge::kIrInputRequired, ""},
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y1", ge::kIrOutputRequired, ""},
{"y2", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"grad_x",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(grad_x))
},
{
"grad_y",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(grad_y))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grads->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(2)));
return EsMinimumGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsMirrorPad(EsbTensor *x, EsbTensor *paddings, const char *mode) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(paddings);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MirrorPad")
.Name(("MirrorPad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"paddings", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"mode",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(paddings->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMirrorPadGrad(EsbTensor *x, EsbTensor *paddings, const char *mode) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(paddings);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MirrorPadGrad")
.Name(("MirrorPadGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"paddings", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"mode",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(paddings->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMish(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Mish")
.Name(("Mish_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMishGrad(EsbTensor *grad, EsbTensor *x, EsbTensor *tanhx) {
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(x);
auto &graph = grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MishGrad")
.Name(("MishGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grad", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"tanhx", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"x_grad", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
if (tanhx != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(tanhx->GetAnchor(), node->GetInDataAnchor(2)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMod(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Mod")
.Name(("Mod_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMoeComputeExpertTokens(EsbTensor *sorted_experts, int64_t num_experts) {
GE_ASSERT_NOTNULL(sorted_experts);
auto &graph = sorted_experts->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MoeComputeExpertTokens")
.Name(("MoeComputeExpertTokens_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"sorted_experts", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"total_rows_before_expert", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_experts",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_experts))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sorted_experts->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMoeFinalizeRouting(EsbTensor *expanded_x, EsbTensor *x1, EsbTensor *x2, EsbTensor *bias, EsbTensor *scales, EsbTensor *expanded_row_idx, EsbTensor *expanded_expert_idx) {
GE_ASSERT_NOTNULL(expanded_x);
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(bias);
GE_ASSERT_NOTNULL(scales);
GE_ASSERT_NOTNULL(expanded_row_idx);
GE_ASSERT_NOTNULL(expanded_expert_idx);
auto &graph = expanded_x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MoeFinalizeRouting")
.Name(("MoeFinalizeRouting_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"expanded_x", ge::kIrInputRequired, ""},
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputOptional, ""},
{"bias", ge::kIrInputRequired, ""},
{"scales", ge::kIrInputRequired, ""},
{"expanded_row_idx", ge::kIrInputRequired, ""},
{"expanded_expert_idx", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(expanded_x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(1)));
if (x2 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(2)));
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scales->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(expanded_row_idx->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(expanded_expert_idx->GetAnchor(), node->GetInDataAnchor(6)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMoeFinalizeRoutingV2(EsbTensor *expanded_x, EsbTensor *expanded_row_idx, EsbTensor *x1, EsbTensor *x2, EsbTensor *bias, EsbTensor *scales, EsbTensor *expert_idx, int64_t drop_pad_mode) {
GE_ASSERT_NOTNULL(expanded_x);
GE_ASSERT_NOTNULL(expanded_row_idx);
auto &graph = expanded_x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MoeFinalizeRoutingV2")
.Name(("MoeFinalizeRoutingV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"expanded_x", ge::kIrInputRequired, ""},
{"expanded_row_idx", ge::kIrInputRequired, ""},
{"x1", ge::kIrInputOptional, ""},
{"x2", ge::kIrInputOptional, ""},
{"bias", ge::kIrInputOptional, ""},
{"scales", ge::kIrInputOptional, ""},
{"expert_idx", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"drop_pad_mode",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(drop_pad_mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(expanded_x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(expanded_row_idx->GetAnchor(), node->GetInDataAnchor(1)));
if (x1 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(2)));
}
if (x2 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(3)));
}
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(4)));
}
if (scales != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scales->GetAnchor(), node->GetInDataAnchor(5)));
}
if (expert_idx != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(expert_idx->GetAnchor(), node->GetInDataAnchor(6)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsMoeFinalizeRoutingV2GradOutput EsMoeFinalizeRoutingV2Grad(EsbTensor *grad_y, EsbTensor *expanded_row_idx, EsbTensor *expanded_x, EsbTensor *scales, EsbTensor *expert_idx, EsbTensor *bias, int64_t drop_pad_mode, int64_t active_num, int64_t expert_num, int64_t expert_capacity) {
GE_ASSERT_NOTNULL(grad_y);
GE_ASSERT_NOTNULL(expanded_row_idx);
auto &graph = grad_y->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MoeFinalizeRoutingV2Grad")
.Name(("MoeFinalizeRoutingV2Grad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grad_y", ge::kIrInputRequired, ""},
{"expanded_row_idx", ge::kIrInputRequired, ""},
{"expanded_x", ge::kIrInputOptional, ""},
{"scales", ge::kIrInputOptional, ""},
{"expert_idx", ge::kIrInputOptional, ""},
{"bias", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"grad_expanded_x", ge::kIrOutputRequired, ""},
{"grad_scales", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"drop_pad_mode",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(drop_pad_mode))
},
{
"active_num",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(active_num))
},
{
"expert_num",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(expert_num))
},
{
"expert_capacity",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(expert_capacity))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad_y->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(expanded_row_idx->GetAnchor(), node->GetInDataAnchor(1)));
if (expanded_x != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(expanded_x->GetAnchor(), node->GetInDataAnchor(2)));
}
if (scales != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scales->GetAnchor(), node->GetInDataAnchor(3)));
}
if (expert_idx != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(expert_idx->GetAnchor(), node->GetInDataAnchor(4)));
}
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(5)));
}
return EsMoeFinalizeRoutingV2GradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsMoeGatingTopKSoftmaxOutput EsMoeGatingTopKSoftmax(EsbTensor *x, EsbTensor *finished, int64_t k) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MoeGatingTopKSoftmax")
.Name(("MoeGatingTopKSoftmax_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"finished", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"expert_idx", ge::kIrOutputRequired, ""},
{"row_idx", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"k",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(k))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
if (finished != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(finished->GetAnchor(), node->GetInDataAnchor(1)));
}
return EsMoeGatingTopKSoftmaxOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsMoeGatingTopKSoftmaxV2Output EsMoeGatingTopKSoftmaxV2(EsbTensor *x, EsbTensor *finished, int64_t k, int64_t renorm, bool output_softmax_result_flag) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MoeGatingTopKSoftmaxV2")
.Name(("MoeGatingTopKSoftmaxV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"finished", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"expert_idx", ge::kIrOutputRequired, ""},
{"softmax_result", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"k",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(k))
},
{
"renorm",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(renorm))
},
{
"output_softmax_result_flag",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(output_softmax_result_flag))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
if (finished != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(finished->GetAnchor(), node->GetInDataAnchor(1)));
}
return EsMoeGatingTopKSoftmaxV2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsMoeInitRoutingOutput EsMoeInitRouting(EsbTensor *x, EsbTensor *row_idx, EsbTensor *expert_idx, int64_t active_num) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(row_idx);
GE_ASSERT_NOTNULL(expert_idx);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MoeInitRouting")
.Name(("MoeInitRouting_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"row_idx", ge::kIrInputRequired, ""},
{"expert_idx", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"expanded_x", ge::kIrOutputRequired, ""},
{"expanded_row_idx", ge::kIrOutputRequired, ""},
{"expanded_expert_idx", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"active_num",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(active_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(row_idx->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(expert_idx->GetAnchor(), node->GetInDataAnchor(2)));
return EsMoeInitRoutingOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsMoeInitRoutingQuantOutput EsMoeInitRoutingQuant(EsbTensor *x, EsbTensor *row_idx, EsbTensor *expert_idx, int64_t active_num, float scale, float offset) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(row_idx);
GE_ASSERT_NOTNULL(expert_idx);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MoeInitRoutingQuant")
.Name(("MoeInitRoutingQuant_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"row_idx", ge::kIrInputRequired, ""},
{"expert_idx", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"expanded_x", ge::kIrOutputRequired, ""},
{"expanded_row_idx", ge::kIrOutputRequired, ""},
{"expanded_expert_idx", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"active_num",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(active_num))
},
{
"scale",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(scale))
},
{
"offset",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(offset))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(row_idx->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(expert_idx->GetAnchor(), node->GetInDataAnchor(2)));
return EsMoeInitRoutingQuantOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsMoeInitRoutingQuantV2Output EsMoeInitRoutingQuantV2(EsbTensor *x, EsbTensor *expert_idx, EsbTensor *scale, EsbTensor *offset, int64_t active_num, int64_t expert_capacity, int64_t expert_num, int64_t drop_pad_mode, int64_t expert_tokens_count_or_cumsum_flag, bool expert_tokens_before_capacity_flag, int64_t quant_mode) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(expert_idx);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MoeInitRoutingQuantV2")
.Name(("MoeInitRoutingQuantV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"expert_idx", ge::kIrInputRequired, ""},
{"scale", ge::kIrInputOptional, ""},
{"offset", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"expanded_x", ge::kIrOutputRequired, ""},
{"expanded_row_idx", ge::kIrOutputRequired, ""},
{"expert_tokens_count_or_cumsum", ge::kIrOutputRequired, ""},
{"expert_tokens_before_capacity", ge::kIrOutputRequired, ""},
{"dynamic_quant_scale", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"active_num",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(active_num))
},
{
"expert_capacity",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(expert_capacity))
},
{
"expert_num",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(expert_num))
},
{
"drop_pad_mode",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(drop_pad_mode))
},
{
"expert_tokens_count_or_cumsum_flag",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(expert_tokens_count_or_cumsum_flag))
},
{
"expert_tokens_before_capacity_flag",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(expert_tokens_before_capacity_flag))
},
{
"quant_mode",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(quant_mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(expert_idx->GetAnchor(), node->GetInDataAnchor(1)));
if (scale != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(2)));
}
if (offset != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset->GetAnchor(), node->GetInDataAnchor(3)));
}
return EsMoeInitRoutingQuantV2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
};
}
EsbTensor *EsMoeInitRoutingV2Grad(EsbTensor *grad_expanded_x, EsbTensor *expanded_row_idx, int64_t top_k, int64_t drop_pad_mode, int64_t active_num) {
GE_ASSERT_NOTNULL(grad_expanded_x);
GE_ASSERT_NOTNULL(expanded_row_idx);
auto &graph = grad_expanded_x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MoeInitRoutingV2Grad")
.Name(("MoeInitRoutingV2Grad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grad_expanded_x", ge::kIrInputRequired, ""},
{"expanded_row_idx", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"grad_x", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"top_k",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(top_k))
},
{
"drop_pad_mode",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(drop_pad_mode))
},
{
"active_num",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(active_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad_expanded_x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(expanded_row_idx->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMovingSumWithSigmoid(EsbTensor *alpha, EsbTensor *energy, EsbTensor *offset, int64_t ksize) {
GE_ASSERT_NOTNULL(alpha);
GE_ASSERT_NOTNULL(energy);
GE_ASSERT_NOTNULL(offset);
auto &graph = alpha->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MovingSumWithSigmoid")
.Name(("MovingSumWithSigmoid_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"alpha", ge::kIrInputRequired, ""},
{"energy", ge::kIrInputRequired, ""},
{"offset", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ksize",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(ksize))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(alpha->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(energy->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMseLoss(EsbTensor *predict, EsbTensor *label, const char *reduction) {
GE_ASSERT_NOTNULL(predict);
GE_ASSERT_NOTNULL(label);
auto &graph = predict->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MseLoss")
.Name(("MseLoss_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"predict", ge::kIrInputRequired, ""},
{"label", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"reduction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduction))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(predict->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(label->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMseLossGrad(EsbTensor *predict, EsbTensor *label, EsbTensor *dout, const char *reduction) {
GE_ASSERT_NOTNULL(predict);
GE_ASSERT_NOTNULL(label);
GE_ASSERT_NOTNULL(dout);
auto &graph = predict->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MseLossGrad")
.Name(("MseLossGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"predict", ge::kIrInputRequired, ""},
{"label", ge::kIrInputRequired, ""},
{"dout", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"reduction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduction))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(predict->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(label->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dout->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMul(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Mul")
.Name(("Mul_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMulNoNan(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MulNoNan")
.Name(("MulNoNan_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMuls(EsbTensor *x, float value) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Muls")
.Name(("Muls_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"value",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(value))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsMultiHeadAttentionOutput EsMultiHeadAttention(EsbTensor *query, EsbTensor *key, EsbTensor *value, EsbTensor *query_weight, EsbTensor *key_weight, EsbTensor *value_weight, EsbTensor *attn_mask, EsbTensor *out_proj_weight, EsbTensor *query_bias, EsbTensor *key_bias, EsbTensor *value_bias, EsbTensor *out_proj_bias, EsbTensor *dropout_mask_input, int64_t attn_head_num, int64_t attn_dim_per_head, int64_t src_len, int64_t tgt_len, float keep_prob, bool softmax_use_float) {
GE_ASSERT_NOTNULL(query);
GE_ASSERT_NOTNULL(key);
GE_ASSERT_NOTNULL(value);
GE_ASSERT_NOTNULL(query_weight);
GE_ASSERT_NOTNULL(key_weight);
GE_ASSERT_NOTNULL(value_weight);
GE_ASSERT_NOTNULL(attn_mask);
GE_ASSERT_NOTNULL(out_proj_weight);
auto &graph = query->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MultiHeadAttention")
.Name(("MultiHeadAttention_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"query", ge::kIrInputRequired, ""},
{"key", ge::kIrInputRequired, ""},
{"value", ge::kIrInputRequired, ""},
{"query_weight", ge::kIrInputRequired, ""},
{"key_weight", ge::kIrInputRequired, ""},
{"value_weight", ge::kIrInputRequired, ""},
{"attn_mask", ge::kIrInputRequired, ""},
{"out_proj_weight", ge::kIrInputRequired, ""},
{"query_bias", ge::kIrInputOptional, ""},
{"key_bias", ge::kIrInputOptional, ""},
{"value_bias", ge::kIrInputOptional, ""},
{"out_proj_bias", ge::kIrInputOptional, ""},
{"dropout_mask_input", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"dropout_mask", ge::kIrOutputRequired, ""},
{"query_res", ge::kIrOutputRequired, ""},
{"key_res", ge::kIrOutputRequired, ""},
{"value_res", ge::kIrOutputRequired, ""},
{"attn_scores", ge::kIrOutputRequired, ""},
{"attn_res", ge::kIrOutputRequired, ""},
{"context", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"attn_head_num",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(attn_head_num))
},
{
"attn_dim_per_head",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(attn_dim_per_head))
},
{
"src_len",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(src_len))
},
{
"tgt_len",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(tgt_len))
},
{
"keep_prob",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(keep_prob))
},
{
"softmax_use_float",
ge::kAttrRequired,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(softmax_use_float))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(query->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(key->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(query_weight->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(key_weight->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value_weight->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(attn_mask->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(out_proj_weight->GetAnchor(), node->GetInDataAnchor(7)));
if (query_bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(query_bias->GetAnchor(), node->GetInDataAnchor(8)));
}
if (key_bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(key_bias->GetAnchor(), node->GetInDataAnchor(9)));
}
if (value_bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value_bias->GetAnchor(), node->GetInDataAnchor(10)));
}
if (out_proj_bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(out_proj_bias->GetAnchor(), node->GetInDataAnchor(11)));
}
if (dropout_mask_input != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dropout_mask_input->GetAnchor(), node->GetInDataAnchor(12)));
}
return EsMultiHeadAttentionOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
graph.GetEsbTensorFromNode(node, 5),
graph.GetEsbTensorFromNode(node, 6),
graph.GetEsbTensorFromNode(node, 7),
};
}
EsMultiHeadAttentionGradOutput EsMultiHeadAttentionGrad(EsbTensor *query, EsbTensor *key, EsbTensor *value, EsbTensor *query_weight, EsbTensor *key_weight, EsbTensor *value_weight, EsbTensor *out_proj_weight, EsbTensor *query_res, EsbTensor *key_res, EsbTensor *value_res, EsbTensor *attn_scores, EsbTensor *attn_res, EsbTensor *context, EsbTensor *y_grad, EsbTensor *dropout_mask, int64_t attn_head_num, int64_t attn_dim_per_head, int64_t src_len, int64_t tgt_len, float keep_prob, bool softmax_use_float, const bool *bias_grad_mask, int64_t bias_grad_mask_num) {
GE_ASSERT_NOTNULL(query);
GE_ASSERT_NOTNULL(key);
GE_ASSERT_NOTNULL(value);
GE_ASSERT_NOTNULL(query_weight);
GE_ASSERT_NOTNULL(key_weight);
GE_ASSERT_NOTNULL(value_weight);
GE_ASSERT_NOTNULL(out_proj_weight);
GE_ASSERT_NOTNULL(query_res);
GE_ASSERT_NOTNULL(key_res);
GE_ASSERT_NOTNULL(value_res);
GE_ASSERT_NOTNULL(attn_scores);
GE_ASSERT_NOTNULL(attn_res);
GE_ASSERT_NOTNULL(context);
GE_ASSERT_NOTNULL(y_grad);
auto &graph = query->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MultiHeadAttentionGrad")
.Name(("MultiHeadAttentionGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"query", ge::kIrInputRequired, ""},
{"key", ge::kIrInputRequired, ""},
{"value", ge::kIrInputRequired, ""},
{"query_weight", ge::kIrInputRequired, ""},
{"key_weight", ge::kIrInputRequired, ""},
{"value_weight", ge::kIrInputRequired, ""},
{"out_proj_weight", ge::kIrInputRequired, ""},
{"query_res", ge::kIrInputRequired, ""},
{"key_res", ge::kIrInputRequired, ""},
{"value_res", ge::kIrInputRequired, ""},
{"attn_scores", ge::kIrInputRequired, ""},
{"attn_res", ge::kIrInputRequired, ""},
{"context", ge::kIrInputRequired, ""},
{"y_grad", ge::kIrInputRequired, ""},
{"dropout_mask", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"query_weight_grad", ge::kIrOutputRequired, ""},
{"key_weight_grad", ge::kIrOutputRequired, ""},
{"value_weight_grad", ge::kIrOutputRequired, ""},
{"out_proj_weight_grad", ge::kIrOutputRequired, ""},
{"query_grad", ge::kIrOutputRequired, ""},
{"key_grad", ge::kIrOutputRequired, ""},
{"value_grad", ge::kIrOutputRequired, ""},
{"query_bias_grad", ge::kIrOutputRequired, ""},
{"key_bias_grad", ge::kIrOutputRequired, ""},
{"value_bias_grad", ge::kIrOutputRequired, ""},
{"out_proj_bias_grad", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"attn_head_num",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(attn_head_num))
},
{
"attn_dim_per_head",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(attn_dim_per_head))
},
{
"src_len",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(src_len))
},
{
"tgt_len",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(tgt_len))
},
{
"keep_prob",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(keep_prob))
},
{
"softmax_use_float",
ge::kAttrRequired,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(softmax_use_float))
},
{
"bias_grad_mask",
ge::kAttrRequired,
"VT_LIST_BOOL",
ge::AnyValue::CreateFrom(std::vector<bool>(bias_grad_mask, bias_grad_mask + bias_grad_mask_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(query->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(key->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(query_weight->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(key_weight->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value_weight->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(out_proj_weight->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(query_res->GetAnchor(), node->GetInDataAnchor(7)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(key_res->GetAnchor(), node->GetInDataAnchor(8)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value_res->GetAnchor(), node->GetInDataAnchor(9)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(attn_scores->GetAnchor(), node->GetInDataAnchor(10)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(attn_res->GetAnchor(), node->GetInDataAnchor(11)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(context->GetAnchor(), node->GetInDataAnchor(12)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y_grad->GetAnchor(), node->GetInDataAnchor(13)));
if (dropout_mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dropout_mask->GetAnchor(), node->GetInDataAnchor(14)));
}
return EsMultiHeadAttentionGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
graph.GetEsbTensorFromNode(node, 5),
graph.GetEsbTensorFromNode(node, 6),
graph.GetEsbTensorFromNode(node, 7),
graph.GetEsbTensorFromNode(node, 8),
graph.GetEsbTensorFromNode(node, 9),
graph.GetEsbTensorFromNode(node, 10),
};
}
EsMultiHeadAttentionScoreOutput EsMultiHeadAttentionScore(EsbTensor *query, EsbTensor *key, EsbTensor *value, EsbTensor *pse_shift, EsbTensor *drop_mask, EsbTensor *padding_mask, EsbTensor *atten_mask, int64_t head_num, const char *input_layout, float scale_value, float keep_prob, int64_t pre_tockens, int64_t next_tockens) {
GE_ASSERT_NOTNULL(query);
GE_ASSERT_NOTNULL(key);
GE_ASSERT_NOTNULL(value);
auto &graph = query->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MultiHeadAttentionScore")
.Name(("MultiHeadAttentionScore_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"query", ge::kIrInputRequired, ""},
{"key", ge::kIrInputRequired, ""},
{"value", ge::kIrInputRequired, ""},
{"pse_shift", ge::kIrInputOptional, ""},
{"drop_mask", ge::kIrInputOptional, ""},
{"padding_mask", ge::kIrInputOptional, ""},
{"atten_mask", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"softmax_out", ge::kIrOutputRequired, ""},
{"attention_out", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"head_num",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(head_num))
},
{
"input_layout",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(input_layout))
},
{
"scale_value",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(scale_value))
},
{
"keep_prob",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(keep_prob))
},
{
"pre_tockens",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pre_tockens))
},
{
"next_tockens",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(next_tockens))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(query->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(key->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(2)));
if (pse_shift != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(pse_shift->GetAnchor(), node->GetInDataAnchor(3)));
}
if (drop_mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(drop_mask->GetAnchor(), node->GetInDataAnchor(4)));
}
if (padding_mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(padding_mask->GetAnchor(), node->GetInDataAnchor(5)));
}
if (atten_mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(atten_mask->GetAnchor(), node->GetInDataAnchor(6)));
}
return EsMultiHeadAttentionScoreOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsMultiHeadAttentionScoreGradOutput EsMultiHeadAttentionScoreGrad(EsbTensor *query, EsbTensor *key, EsbTensor *value, EsbTensor *dy, EsbTensor *pse_shift, EsbTensor *drop_mask, EsbTensor *padding_mask, EsbTensor *atten_mask, EsbTensor *softmax_in, EsbTensor *attention_in, int64_t head_num, const char *input_layout, float scale_value, float keep_prob, int64_t pre_tockens, int64_t next_tockens) {
GE_ASSERT_NOTNULL(query);
GE_ASSERT_NOTNULL(key);
GE_ASSERT_NOTNULL(value);
GE_ASSERT_NOTNULL(dy);
auto &graph = query->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MultiHeadAttentionScoreGrad")
.Name(("MultiHeadAttentionScoreGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"query", ge::kIrInputRequired, ""},
{"key", ge::kIrInputRequired, ""},
{"value", ge::kIrInputRequired, ""},
{"dy", ge::kIrInputRequired, ""},
{"pse_shift", ge::kIrInputOptional, ""},
{"drop_mask", ge::kIrInputOptional, ""},
{"padding_mask", ge::kIrInputOptional, ""},
{"atten_mask", ge::kIrInputOptional, ""},
{"softmax_in", ge::kIrInputOptional, ""},
{"attention_in", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"dq", ge::kIrOutputRequired, ""},
{"dk", ge::kIrOutputRequired, ""},
{"dv", ge::kIrOutputRequired, ""},
{"dpse", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"head_num",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(head_num))
},
{
"input_layout",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(input_layout))
},
{
"scale_value",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(scale_value))
},
{
"keep_prob",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(keep_prob))
},
{
"pre_tockens",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pre_tockens))
},
{
"next_tockens",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(next_tockens))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(query->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(key->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(3)));
if (pse_shift != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(pse_shift->GetAnchor(), node->GetInDataAnchor(4)));
}
if (drop_mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(drop_mask->GetAnchor(), node->GetInDataAnchor(5)));
}
if (padding_mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(padding_mask->GetAnchor(), node->GetInDataAnchor(6)));
}
if (atten_mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(atten_mask->GetAnchor(), node->GetInDataAnchor(7)));
}
if (softmax_in != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(softmax_in->GetAnchor(), node->GetInDataAnchor(8)));
}
if (attention_in != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(attention_in->GetAnchor(), node->GetInDataAnchor(9)));
}
return EsMultiHeadAttentionScoreGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsMultiMergeOutput EsMultiMerge(EsbTensor *input_proposal, int64_t k_num, bool include_index, bool largest) {
GE_ASSERT_NOTNULL(input_proposal);
auto &graph = input_proposal->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MultiMerge")
.Name(("MultiMerge_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_proposal", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_proposal", ge::kIrOutputRequired, ""},
{"output_index", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"k_num",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(k_num))
},
{
"include_index",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(include_index))
},
{
"largest",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(largest))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_proposal->GetAnchor(), node->GetInDataAnchor(0)));
return EsMultiMergeOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsMultiScaleDeformableAttentionGradOutput EsMultiScaleDeformableAttentionGrad(EsbTensor *value, EsbTensor *value_spatial_shapes, EsbTensor *value_level_start_index, EsbTensor *sampling_locations, EsbTensor *attention_weights, EsbTensor *grad_output) {
GE_ASSERT_NOTNULL(value);
GE_ASSERT_NOTNULL(value_spatial_shapes);
GE_ASSERT_NOTNULL(value_level_start_index);
GE_ASSERT_NOTNULL(sampling_locations);
GE_ASSERT_NOTNULL(attention_weights);
GE_ASSERT_NOTNULL(grad_output);
auto &graph = value->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MultiScaleDeformableAttentionGrad")
.Name(("MultiScaleDeformableAttentionGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"value", ge::kIrInputRequired, ""},
{"value_spatial_shapes", ge::kIrInputRequired, ""},
{"value_level_start_index", ge::kIrInputRequired, ""},
{"sampling_locations", ge::kIrInputRequired, ""},
{"attention_weights", ge::kIrInputRequired, ""},
{"grad_output", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"grad_value", ge::kIrOutputRequired, ""},
{"grad_sampling_locations", ge::kIrOutputRequired, ""},
{"grad_attention_weights", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value_spatial_shapes->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value_level_start_index->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sampling_locations->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(attention_weights->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad_output->GetAnchor(), node->GetInDataAnchor(5)));
return EsMultiScaleDeformableAttentionGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsMultiScaleDeformableAttnFunction(EsbTensor *value, EsbTensor *value_spatial_shapes, EsbTensor *value_level_start_index, EsbTensor *sampling_locations, EsbTensor *attention_weights) {
GE_ASSERT_NOTNULL(value);
GE_ASSERT_NOTNULL(value_spatial_shapes);
GE_ASSERT_NOTNULL(value_level_start_index);
GE_ASSERT_NOTNULL(sampling_locations);
GE_ASSERT_NOTNULL(attention_weights);
auto &graph = value->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MultiScaleDeformableAttnFunction")
.Name(("MultiScaleDeformableAttnFunction_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"value", ge::kIrInputRequired, ""},
{"value_spatial_shapes", ge::kIrInputRequired, ""},
{"value_level_start_index", ge::kIrInputRequired, ""},
{"sampling_locations", ge::kIrInputRequired, ""},
{"attention_weights", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value_spatial_shapes->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value_level_start_index->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sampling_locations->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(attention_weights->GetAnchor(), node->GetInDataAnchor(4)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsMultilabelMarginLossOutput EsMultilabelMarginLoss(EsbTensor *x, EsbTensor *target, const char *reduction) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(target);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MultilabelMarginLoss")
.Name(("MultilabelMarginLoss_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"target", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"is_target", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"reduction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduction))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(target->GetAnchor(), node->GetInDataAnchor(1)));
return EsMultilabelMarginLossOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsMultinomial(EsbTensor *logits, EsbTensor *num_samples, ge::DataType dtype, int64_t seed, int64_t seed2) {
GE_ASSERT_NOTNULL(logits);
GE_ASSERT_NOTNULL(num_samples);
auto &graph = logits->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Multinomial")
.Name(("Multinomial_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"logits", ge::kIrInputRequired, ""},
{"num_samples", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
{
"seed",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed))
},
{
"seed2",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed2))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(logits->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(num_samples->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMultinomialAliasDraw(EsbTensor *q, EsbTensor *j, int64_t num_samples, int64_t seed) {
GE_ASSERT_NOTNULL(q);
GE_ASSERT_NOTNULL(j);
auto &graph = q->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MultinomialAliasDraw")
.Name(("MultinomialAliasDraw_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"q", ge::kIrInputRequired, ""},
{"j", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_samples",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_samples))
},
{
"seed",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(q->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(j->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsMultinomialAliasSetupOutput EsMultinomialAliasSetup(EsbTensor *probs) {
GE_ASSERT_NOTNULL(probs);
auto &graph = probs->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MultinomialAliasSetup")
.Name(("MultinomialAliasSetup_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"probs", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"j", ge::kIrOutputRequired, ""},
{"q", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(probs->GetAnchor(), node->GetInDataAnchor(0)));
return EsMultinomialAliasSetupOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsMultinomialFuss(EsbTensor *x, int64_t dtype, int64_t sample_size, float seed) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MultinomialFuss")
.Name(("MultinomialFuss_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dtype))
},
{
"sample_size",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(sample_size))
},
{
"seed",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(seed))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMultinomialWithReplacement(EsbTensor *x, EsbTensor *seed, EsbTensor *offset, int64_t numsamples, bool replacement) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(seed);
GE_ASSERT_NOTNULL(offset);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MultinomialWithReplacement")
.Name(("MultinomialWithReplacement_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"seed", ge::kIrInputRequired, ""},
{"offset", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"numsamples",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(numsamples))
},
{
"replacement",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(replacement))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seed->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMutableDenseHashTable(EsbTensor *empty_key, EsbTensor *deleted_key, ge::DataType value_dtype, const char *container, const char *shared_name, bool use_node_name_sharing, const int64_t *value_shape, int64_t value_shape_num, int64_t initial_num_buckets, float max_load_factor) {
GE_ASSERT_NOTNULL(empty_key);
GE_ASSERT_NOTNULL(deleted_key);
auto &graph = empty_key->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("MutableDenseHashTable")
.Name(("MutableDenseHashTable_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"empty_key", ge::kIrInputRequired, ""},
{"deleted_key", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"handle", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"value_dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(value_dtype))
},
{
"container",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(container))
},
{
"shared_name",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(shared_name))
},
{
"use_node_name_sharing",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_node_name_sharing))
},
{
"value_shape",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(value_shape, value_shape + value_shape_num))
},
{
"initial_num_buckets",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(initial_num_buckets))
},
{
"max_load_factor",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(max_load_factor))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(empty_key->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(deleted_key->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMutableHashTable(EsbGraph *owner_graph, ge::DataType key_dtype, ge::DataType value_dtype, const char *container, const char *shared_name, bool use_node_name_sharing) {
GE_ASSERT_NOTNULL(owner_graph);
EsbGraph &graph = *owner_graph;

auto desc = ge::CompliantOpDescBuilder().OpType("MutableHashTable")
.Name(("MutableHashTable_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
})
.IrDefOutputs({
{"handle", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"key_dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(key_dtype))
},
{
"value_dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(value_dtype))
},
{
"container",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(container))
},
{
"shared_name",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(shared_name))
},
{
"use_node_name_sharing",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_node_name_sharing))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsMutableHashTableOfTensors(EsbGraph *owner_graph, ge::DataType key_dtype, ge::DataType value_dtype, const char *container, const char *shared_name, bool use_node_name_sharing, const int64_t *value_shape, int64_t value_shape_num) {
GE_ASSERT_NOTNULL(owner_graph);
EsbGraph &graph = *owner_graph;

auto desc = ge::CompliantOpDescBuilder().OpType("MutableHashTableOfTensors")
.Name(("MutableHashTableOfTensors_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
})
.IrDefOutputs({
{"handle", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"key_dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(key_dtype))
},
{
"value_dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(value_dtype))
},
{
"container",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(container))
},
{
"shared_name",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(shared_name))
},
{
"use_node_name_sharing",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_node_name_sharing))
},
{
"value_shape",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(value_shape, value_shape + value_shape_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsNLLLossOutput EsNLLLoss(EsbTensor *x, EsbTensor *target, EsbTensor *weight, const char *reduction, int64_t ignore_index) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(target);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("NLLLoss")
.Name(("NLLLoss_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"target", ge::kIrInputRequired, ""},
{"weight", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"total_weight", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"reduction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduction))
},
{
"ignore_index",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(ignore_index))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(target->GetAnchor(), node->GetInDataAnchor(1)));
if (weight != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight->GetAnchor(), node->GetInDataAnchor(2)));
}
return EsNLLLossOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsNLLLossGrad(EsbTensor *x, EsbTensor *y_grad, EsbTensor *target, EsbTensor *weight, EsbTensor *total_weight, const char *reduction, int64_t ignore_index) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(y_grad);
GE_ASSERT_NOTNULL(target);
GE_ASSERT_NOTNULL(weight);
GE_ASSERT_NOTNULL(total_weight);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("NLLLossGrad")
.Name(("NLLLossGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"y_grad", ge::kIrInputRequired, ""},
{"target", ge::kIrInputRequired, ""},
{"weight", ge::kIrInputRequired, ""},
{"total_weight", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"x_grad", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"reduction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduction))
},
{
"ignore_index",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(ignore_index))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y_grad->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(target->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(total_weight->GetAnchor(), node->GetInDataAnchor(4)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsNMSWithMaskOutput EsNMSWithMask(EsbTensor *box_scores, float iou_threshold) {
GE_ASSERT_NOTNULL(box_scores);
auto &graph = box_scores->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("NMSWithMask")
.Name(("NMSWithMask_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"box_scores", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"selected_boxes", ge::kIrOutputRequired, ""},
{"selected_idx", ge::kIrOutputRequired, ""},
{"selected_mask", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"iou_threshold",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(iou_threshold))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(box_scores->GetAnchor(), node->GetInDataAnchor(0)));
return EsNMSWithMaskOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsNPUAllocFloatStatus(EsbGraph *owner_graph) {
GE_ASSERT_NOTNULL(owner_graph);
EsbGraph &graph = *owner_graph;

auto desc = ge::CompliantOpDescBuilder().OpType("NPUAllocFloatStatus")
.Name(("NPUAllocFloatStatus_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
})
.IrDefOutputs({
{"data", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsNPUAllocFloatStatusOperator(EsbGraph *owner_graph) {
GE_ASSERT_NOTNULL(owner_graph);
EsbGraph &graph = *owner_graph;

auto desc = ge::CompliantOpDescBuilder().OpType("NPUAllocFloatStatusOperator")
.Name(("NPUAllocFloatStatusOperator_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
})
.IrDefOutputs({
{"data", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsNPUClearFloatDebugStatus(EsbGraph *owner_graph) {
GE_ASSERT_NOTNULL(owner_graph);
EsbGraph &graph = *owner_graph;

auto desc = ge::CompliantOpDescBuilder().OpType("NPUClearFloatDebugStatus")
.Name(("NPUClearFloatDebugStatus_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsNPUClearFloatStatus(EsbTensor *addr) {
GE_ASSERT_NOTNULL(addr);
auto &graph = addr->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("NPUClearFloatStatus")
.Name(("NPUClearFloatStatus_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"addr", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"data", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(addr->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsNPUClearFloatStatusOperator(EsbTensor *addr) {
GE_ASSERT_NOTNULL(addr);
auto &graph = addr->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("NPUClearFloatStatusOperator")
.Name(("NPUClearFloatStatusOperator_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"addr", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"data", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(addr->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsNPUClearFloatStatusV2(EsbGraph *owner_graph) {
GE_ASSERT_NOTNULL(owner_graph);
EsbGraph &graph = *owner_graph;

auto desc = ge::CompliantOpDescBuilder().OpType("NPUClearFloatStatusV2")
.Name(("NPUClearFloatStatusV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsNPUGetFloatDebugStatus(EsbGraph *owner_graph) {
GE_ASSERT_NOTNULL(owner_graph);
EsbGraph &graph = *owner_graph;

auto desc = ge::CompliantOpDescBuilder().OpType("NPUGetFloatDebugStatus")
.Name(("NPUGetFloatDebugStatus_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
})
.IrDefOutputs({
{"data", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsNPUGetFloatStatus(EsbTensor *addr) {
GE_ASSERT_NOTNULL(addr);
auto &graph = addr->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("NPUGetFloatStatus")
.Name(("NPUGetFloatStatus_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"addr", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"data", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(addr->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsNPUGetFloatStatusOperator(EsbTensor *addr) {
GE_ASSERT_NOTNULL(addr);
auto &graph = addr->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("NPUGetFloatStatusOperator")
.Name(("NPUGetFloatStatusOperator_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"addr", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"data", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(addr->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsNPUGetFloatStatusV2(EsbGraph *owner_graph) {
GE_ASSERT_NOTNULL(owner_graph);
EsbGraph &graph = *owner_graph;

auto desc = ge::CompliantOpDescBuilder().OpType("NPUGetFloatStatusV2")
.Name(("NPUGetFloatStatusV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
})
.IrDefOutputs({
{"data", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsNanToNum(EsbTensor *x, float nan, float posinf, float neginf) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("NanToNum")
.Name(("NanToNum_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"nan",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(nan))
},
{
"posinf",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(posinf))
},
{
"neginf",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(neginf))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsNdtri(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Ndtri")
.Name(("Ndtri_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsNeg(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Neg")
.Name(("Neg_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsNextAfter(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("NextAfter")
.Name(("NextAfter_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsNextIteration(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("NextIteration")
.Name(("NextIteration_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsNoOp(EsbGraph *owner_graph) {
GE_ASSERT_NOTNULL(owner_graph);
EsbGraph &graph = *owner_graph;

auto desc = ge::CompliantOpDescBuilder().OpType("NoOp")
.Name(("NoOp_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsNonDeterministicInts(EsbTensor *shape, ge::DataType dtype) {
GE_ASSERT_NOTNULL(shape);
auto &graph = shape->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("NonDeterministicInts")
.Name(("NonDeterministicInts_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"shape", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsNonFiniteCheck(EsbTensor **tensor_list, int64_t tensor_list_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(tensor_list_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < tensor_list_num; ++i) {
if (tensor_list[i] != nullptr) {
non_null_in = tensor_list[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("NonFiniteCheck")
.Name(("NonFiniteCheck_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"tensor_list", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
{"found_flag", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("tensor_list", static_cast<int32_t>(tensor_list_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((tensor_list != nullptr) && (tensor_list_num > 0)) {
for (int64_t i = 0; i < tensor_list_num; ++i) {
auto one_tensor_list = tensor_list[i];
GE_ASSERT_NOTNULL(one_tensor_list);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_tensor_list->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsNonMaxSuppression(EsbTensor *boxes, EsbTensor *scores, EsbTensor *max_output_size, float iou_threshold) {
GE_ASSERT_NOTNULL(boxes);
GE_ASSERT_NOTNULL(scores);
GE_ASSERT_NOTNULL(max_output_size);
auto &graph = boxes->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("NonMaxSuppression")
.Name(("NonMaxSuppression_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"boxes", ge::kIrInputRequired, ""},
{"scores", ge::kIrInputRequired, ""},
{"max_output_size", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"selected_indices", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"iou_threshold",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(iou_threshold))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(boxes->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scores->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(max_output_size->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsNonMaxSuppressionBucketizeOutput EsNonMaxSuppressionBucketize(EsbTensor *input_nmsed_boxes, EsbTensor *input_nmsed_score, EsbTensor *input_nmsed_class, EsbTensor *input_nmsed_num) {
GE_ASSERT_NOTNULL(input_nmsed_boxes);
GE_ASSERT_NOTNULL(input_nmsed_score);
GE_ASSERT_NOTNULL(input_nmsed_class);
GE_ASSERT_NOTNULL(input_nmsed_num);
auto &graph = input_nmsed_boxes->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("NonMaxSuppressionBucketize")
.Name(("NonMaxSuppressionBucketize_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_nmsed_boxes", ge::kIrInputRequired, ""},
{"input_nmsed_score", ge::kIrInputRequired, ""},
{"input_nmsed_class", ge::kIrInputRequired, ""},
{"input_nmsed_num", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_nmsed_boxes", ge::kIrOutputRequired, ""},
{"output_nmsed_score", ge::kIrOutputRequired, ""},
{"output_nmsed_class", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_nmsed_boxes->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_nmsed_score->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_nmsed_class->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_nmsed_num->GetAnchor(), node->GetInDataAnchor(3)));
return EsNonMaxSuppressionBucketizeOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsNonMaxSuppressionV2(EsbTensor *boxes, EsbTensor *scores, EsbTensor *max_output_size, EsbTensor *iou_threshold) {
GE_ASSERT_NOTNULL(boxes);
GE_ASSERT_NOTNULL(scores);
GE_ASSERT_NOTNULL(max_output_size);
GE_ASSERT_NOTNULL(iou_threshold);
auto &graph = boxes->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("NonMaxSuppressionV2")
.Name(("NonMaxSuppressionV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"boxes", ge::kIrInputRequired, ""},
{"scores", ge::kIrInputRequired, ""},
{"max_output_size", ge::kIrInputRequired, ""},
{"iou_threshold", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"selected_indices", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(boxes->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scores->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(max_output_size->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(iou_threshold->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsNonMaxSuppressionV3(EsbTensor *boxes, EsbTensor *scores, EsbTensor *max_output_size, EsbTensor *iou_threshold, EsbTensor *score_threshold, int64_t offset) {
GE_ASSERT_NOTNULL(boxes);
GE_ASSERT_NOTNULL(scores);
GE_ASSERT_NOTNULL(max_output_size);
GE_ASSERT_NOTNULL(iou_threshold);
GE_ASSERT_NOTNULL(score_threshold);
auto &graph = boxes->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("NonMaxSuppressionV3")
.Name(("NonMaxSuppressionV3_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"boxes", ge::kIrInputRequired, ""},
{"scores", ge::kIrInputRequired, ""},
{"max_output_size", ge::kIrInputRequired, ""},
{"iou_threshold", ge::kIrInputRequired, ""},
{"score_threshold", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"selected_indices", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"offset",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(offset))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(boxes->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scores->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(max_output_size->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(iou_threshold->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(score_threshold->GetAnchor(), node->GetInDataAnchor(4)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsNonMaxSuppressionV4Output EsNonMaxSuppressionV4(EsbTensor *boxes, EsbTensor *scores, EsbTensor *max_output_size, EsbTensor *iou_threshold, EsbTensor *score_threshold, bool pad_to_max_output_size) {
GE_ASSERT_NOTNULL(boxes);
GE_ASSERT_NOTNULL(scores);
GE_ASSERT_NOTNULL(max_output_size);
GE_ASSERT_NOTNULL(iou_threshold);
GE_ASSERT_NOTNULL(score_threshold);
auto &graph = boxes->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("NonMaxSuppressionV4")
.Name(("NonMaxSuppressionV4_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"boxes", ge::kIrInputRequired, ""},
{"scores", ge::kIrInputRequired, ""},
{"max_output_size", ge::kIrInputRequired, ""},
{"iou_threshold", ge::kIrInputRequired, ""},
{"score_threshold", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"selected_indices", ge::kIrOutputRequired, ""},
{"valid_outputs", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"pad_to_max_output_size",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(pad_to_max_output_size))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(boxes->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scores->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(max_output_size->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(iou_threshold->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(score_threshold->GetAnchor(), node->GetInDataAnchor(4)));
return EsNonMaxSuppressionV4Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsNonMaxSuppressionV5Output EsNonMaxSuppressionV5(EsbTensor *boxes, EsbTensor *scores, EsbTensor *max_output_size, EsbTensor *iou_threshold, EsbTensor *score_threshold, EsbTensor *soft_nms_sigma, ge::DataType T, bool pad_to_max_output_size) {
GE_ASSERT_NOTNULL(boxes);
GE_ASSERT_NOTNULL(scores);
GE_ASSERT_NOTNULL(max_output_size);
GE_ASSERT_NOTNULL(iou_threshold);
GE_ASSERT_NOTNULL(score_threshold);
GE_ASSERT_NOTNULL(soft_nms_sigma);
auto &graph = boxes->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("NonMaxSuppressionV5")
.Name(("NonMaxSuppressionV5_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"boxes", ge::kIrInputRequired, ""},
{"scores", ge::kIrInputRequired, ""},
{"max_output_size", ge::kIrInputRequired, ""},
{"iou_threshold", ge::kIrInputRequired, ""},
{"score_threshold", ge::kIrInputRequired, ""},
{"soft_nms_sigma", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"selected_indices", ge::kIrOutputRequired, ""},
{"selected_scores", ge::kIrOutputRequired, ""},
{"valid_outputs", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"T",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(T))
},
{
"pad_to_max_output_size",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(pad_to_max_output_size))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(boxes->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scores->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(max_output_size->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(iou_threshold->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(score_threshold->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(soft_nms_sigma->GetAnchor(), node->GetInDataAnchor(5)));
return EsNonMaxSuppressionV5Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsNonMaxSuppressionV6(EsbTensor *boxes, EsbTensor *scores, EsbTensor *max_output_size, EsbTensor *iou_threshold, EsbTensor *score_threshold, int64_t center_point_box, int64_t max_boxes_size) {
GE_ASSERT_NOTNULL(boxes);
GE_ASSERT_NOTNULL(scores);
auto &graph = boxes->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("NonMaxSuppressionV6")
.Name(("NonMaxSuppressionV6_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"boxes", ge::kIrInputRequired, ""},
{"scores", ge::kIrInputRequired, ""},
{"max_output_size", ge::kIrInputOptional, ""},
{"iou_threshold", ge::kIrInputOptional, ""},
{"score_threshold", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"selected_indices", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"center_point_box",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(center_point_box))
},
{
"max_boxes_size",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(max_boxes_size))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(boxes->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scores->GetAnchor(), node->GetInDataAnchor(1)));
if (max_output_size != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(max_output_size->GetAnchor(), node->GetInDataAnchor(2)));
}
if (iou_threshold != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(iou_threshold->GetAnchor(), node->GetInDataAnchor(3)));
}
if (score_threshold != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(score_threshold->GetAnchor(), node->GetInDataAnchor(4)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsNonMaxSuppressionV7(EsbTensor *boxes, EsbTensor *scores, EsbTensor *max_output_size, EsbTensor *iou_threshold, EsbTensor *score_threshold, EsbTensor *index_id, int64_t center_point_box, int64_t max_boxes_size) {
GE_ASSERT_NOTNULL(boxes);
GE_ASSERT_NOTNULL(scores);
auto &graph = boxes->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("NonMaxSuppressionV7")
.Name(("NonMaxSuppressionV7_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"boxes", ge::kIrInputRequired, ""},
{"scores", ge::kIrInputRequired, ""},
{"max_output_size", ge::kIrInputOptional, ""},
{"iou_threshold", ge::kIrInputOptional, ""},
{"score_threshold", ge::kIrInputOptional, ""},
{"index_id", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"selected_indices", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"center_point_box",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(center_point_box))
},
{
"max_boxes_size",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(max_boxes_size))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(boxes->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scores->GetAnchor(), node->GetInDataAnchor(1)));
if (max_output_size != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(max_output_size->GetAnchor(), node->GetInDataAnchor(2)));
}
if (iou_threshold != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(iou_threshold->GetAnchor(), node->GetInDataAnchor(3)));
}
if (score_threshold != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(score_threshold->GetAnchor(), node->GetInDataAnchor(4)));
}
if (index_id != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(index_id->GetAnchor(), node->GetInDataAnchor(5)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsNonMaxSuppressionWithOverlaps(EsbTensor *overlaps, EsbTensor *scores, EsbTensor *max_output_size, EsbTensor *overlap_threshold, EsbTensor *score_threshold) {
GE_ASSERT_NOTNULL(overlaps);
GE_ASSERT_NOTNULL(scores);
GE_ASSERT_NOTNULL(max_output_size);
GE_ASSERT_NOTNULL(overlap_threshold);
GE_ASSERT_NOTNULL(score_threshold);
auto &graph = overlaps->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("NonMaxSuppressionWithOverlaps")
.Name(("NonMaxSuppressionWithOverlaps_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"overlaps", ge::kIrInputRequired, ""},
{"scores", ge::kIrInputRequired, ""},
{"max_output_size", ge::kIrInputRequired, ""},
{"overlap_threshold", ge::kIrInputRequired, ""},
{"score_threshold", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"selected_indices", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(overlaps->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scores->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(max_output_size->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(overlap_threshold->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(score_threshold->GetAnchor(), node->GetInDataAnchor(4)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsNonZero(EsbTensor *x, bool transpose, ge::DataType dtype) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("NonZero")
.Name(("NonZero_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"transpose",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(transpose))
},
{
"dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsNonZeroWithValueOutput EsNonZeroWithValue(EsbTensor *x, bool transpose, ge::DataType dtype) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("NonZeroWithValue")
.Name(("NonZeroWithValue_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"value", ge::kIrOutputRequired, ""},
{"index", ge::kIrOutputRequired, ""},
{"count", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"transpose",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(transpose))
},
{
"dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return EsNonZeroWithValueOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsNonZeroWithValueShapeOutput EsNonZeroWithValueShape(EsbTensor *value, EsbTensor *index, EsbTensor *count) {
GE_ASSERT_NOTNULL(value);
GE_ASSERT_NOTNULL(index);
GE_ASSERT_NOTNULL(count);
auto &graph = value->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("NonZeroWithValueShape")
.Name(("NonZeroWithValueShape_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"value", ge::kIrInputRequired, ""},
{"index", ge::kIrInputRequired, ""},
{"count", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"out_value", ge::kIrOutputRequired, ""},
{"out_index", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(index->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(count->GetAnchor(), node->GetInDataAnchor(2)));
return EsNonZeroWithValueShapeOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsNonZeroWithValueShapeV2Output EsNonZeroWithValueShapeV2(EsbTensor *value, EsbTensor *index, EsbTensor *count) {
GE_ASSERT_NOTNULL(value);
GE_ASSERT_NOTNULL(index);
GE_ASSERT_NOTNULL(count);
auto &graph = value->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("NonZeroWithValueShapeV2")
.Name(("NonZeroWithValueShapeV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"value", ge::kIrInputRequired, ""},
{"index", ge::kIrInputRequired, ""},
{"count", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"value", ge::kIrOutputRequired, ""},
{"index", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(index->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(count->GetAnchor(), node->GetInDataAnchor(2)));
return EsNonZeroWithValueShapeV2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsNormal(EsbTensor *mean, EsbTensor *std) {
GE_ASSERT_NOTNULL(mean);
GE_ASSERT_NOTNULL(std);
auto &graph = mean->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Normal")
.Name(("Normal_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"mean", ge::kIrInputRequired, ""},
{"std", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(std->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsNormalize(EsbTensor *x1, EsbTensor *x2, bool across_spatial, bool channel_shared, float eps) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Normalize")
.Name(("Normalize_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"across_spatial",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(across_spatial))
},
{
"channel_shared",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(channel_shared))
},
{
"eps",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(eps))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsNormalizeBBox(EsbTensor *boxes, EsbTensor *shape_hw, bool reversed_box) {
GE_ASSERT_NOTNULL(boxes);
GE_ASSERT_NOTNULL(shape_hw);
auto &graph = boxes->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("NormalizeBBox")
.Name(("NormalizeBBox_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"boxes", ge::kIrInputRequired, ""},
{"shape_hw", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"reversed_box",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(reversed_box))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(boxes->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape_hw->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsNormalizeBatch(EsbTensor *input_x, EsbTensor *seq_len, const char *normalize_type, float epsilon) {
GE_ASSERT_NOTNULL(input_x);
GE_ASSERT_NOTNULL(seq_len);
auto &graph = input_x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("NormalizeBatch")
.Name(("NormalizeBatch_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_x", ge::kIrInputRequired, ""},
{"seq_len", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"normalize_type",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(normalize_type))
},
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seq_len->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsNormalizeV2(EsbTensor *x, EsbTensor *mean, EsbTensor *variance, ge::DataType dtype) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(mean);
GE_ASSERT_NOTNULL(variance);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("NormalizeV2")
.Name(("NormalizeV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"mean", ge::kIrInputRequired, ""},
{"variance", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(variance->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsNotEqual(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("NotEqual")
.Name(("NotEqual_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsNthElement(EsbTensor *x, EsbTensor *n, bool reverse) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(n);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("NthElement")
.Name(("NthElement_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"n", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"reverse",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(reverse))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(n->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsOCRDetectionPostHandleOutput EsOCRDetectionPostHandle(EsbTensor *img, EsbTensor *polys_data, EsbTensor *polys_offset, EsbTensor *polys_size, const char *data_format) {
GE_ASSERT_NOTNULL(img);
GE_ASSERT_NOTNULL(polys_data);
GE_ASSERT_NOTNULL(polys_offset);
GE_ASSERT_NOTNULL(polys_size);
auto &graph = img->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("OCRDetectionPostHandle")
.Name(("OCRDetectionPostHandle_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"img", ge::kIrInputRequired, ""},
{"polys_data", ge::kIrInputRequired, ""},
{"polys_offset", ge::kIrInputRequired, ""},
{"polys_size", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"imgs_data", ge::kIrOutputRequired, ""},
{"imgs_offset", ge::kIrOutputRequired, ""},
{"imgs_size", ge::kIrOutputRequired, ""},
{"rect_points", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(img->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(polys_data->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(polys_offset->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(polys_size->GetAnchor(), node->GetInDataAnchor(3)));
return EsOCRDetectionPostHandleOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsOCRDetectionPreHandleOutput EsOCRDetectionPreHandle(EsbTensor *img, const char *data_format) {
GE_ASSERT_NOTNULL(img);
auto &graph = img->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("OCRDetectionPreHandle")
.Name(("OCRDetectionPreHandle_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"img", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"resized_img", ge::kIrOutputRequired, ""},
{"h_scale", ge::kIrOutputRequired, ""},
{"w_scale", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(img->GetAnchor(), node->GetInDataAnchor(0)));
return EsOCRDetectionPreHandleOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsOCRFindContoursOutput EsOCRFindContours(EsbTensor *img, int64_t value_mode) {
GE_ASSERT_NOTNULL(img);
auto &graph = img->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("OCRFindContours")
.Name(("OCRFindContours_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"img", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"polys_data", ge::kIrOutputRequired, ""},
{"polys_offset", ge::kIrOutputRequired, ""},
{"polys_size", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"value_mode",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(value_mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(img->GetAnchor(), node->GetInDataAnchor(0)));
return EsOCRFindContoursOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsOCRIdentifyPreHandle(EsbTensor *imgs_data, EsbTensor *imgs_offset, EsbTensor *imgs_size, const int64_t *size, int64_t size_num, const char *data_format) {
GE_ASSERT_NOTNULL(imgs_data);
GE_ASSERT_NOTNULL(imgs_offset);
GE_ASSERT_NOTNULL(imgs_size);
auto &graph = imgs_data->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("OCRIdentifyPreHandle")
.Name(("OCRIdentifyPreHandle_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"imgs_data", ge::kIrInputRequired, ""},
{"imgs_offset", ge::kIrInputRequired, ""},
{"imgs_size", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"resized_imgs", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(size, size + size_num))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(imgs_data->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(imgs_offset->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(imgs_size->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsOCRRecognitionPreHandleOutput EsOCRRecognitionPreHandle(EsbTensor *imgs_data, EsbTensor *imgs_offset, EsbTensor *imgs_size, EsbTensor *langs, EsbTensor *langs_score, int64_t batch_size, const char *data_format, const char *pad_mode) {
GE_ASSERT_NOTNULL(imgs_data);
GE_ASSERT_NOTNULL(imgs_offset);
GE_ASSERT_NOTNULL(imgs_size);
GE_ASSERT_NOTNULL(langs);
GE_ASSERT_NOTNULL(langs_score);
auto &graph = imgs_data->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("OCRRecognitionPreHandle")
.Name(("OCRRecognitionPreHandle_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"imgs_data", ge::kIrInputRequired, ""},
{"imgs_offset", ge::kIrInputRequired, ""},
{"imgs_size", ge::kIrInputRequired, ""},
{"langs", ge::kIrInputRequired, ""},
{"langs_score", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"imgs", ge::kIrOutputRequired, ""},
{"imgs_relation", ge::kIrOutputRequired, ""},
{"imgs_lang", ge::kIrOutputRequired, ""},
{"imgs_piece_fillers", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"batch_size",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(batch_size))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"pad_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(pad_mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(imgs_data->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(imgs_offset->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(imgs_size->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(langs->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(langs_score->GetAnchor(), node->GetInDataAnchor(4)));
return EsOCRRecognitionPreHandleOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsbTensor *EsOneHot(EsbTensor *x, EsbTensor *depth, EsbTensor *on_value, EsbTensor *off_value, int64_t axis) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(depth);
GE_ASSERT_NOTNULL(on_value);
GE_ASSERT_NOTNULL(off_value);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("OneHot")
.Name(("OneHot_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"depth", ge::kIrInputRequired, ""},
{"on_value", ge::kIrInputRequired, ""},
{"off_value", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(depth->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(on_value->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(off_value->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsOneHotD(EsbTensor *x, EsbTensor *on_value, EsbTensor *off_value, int64_t depth, int64_t axis) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(on_value);
GE_ASSERT_NOTNULL(off_value);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("OneHotD")
.Name(("OneHotD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"on_value", ge::kIrInputRequired, ""},
{"off_value", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"depth",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(depth))
},
{
"axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(on_value->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(off_value->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsOnesLike(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("OnesLike")
.Name(("OnesLike_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsOpTilingOutput EsOpTiling(EsbTensor **x, int64_t x_num, EsbTensor **output_shape, int64_t output_shape_num, const char *tiling_node, const char *op_type) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(output_shape_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
if (non_null_in == nullptr) {
for (int64_t i = 0; i < output_shape_num; ++i) {
if (output_shape[i] != nullptr) {
non_null_in = output_shape[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("OpTiling")
.Name(("OpTiling_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
{"output_shape", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
{"tiling_data", ge::kIrOutputRequired, ""},
{"tiling_key", ge::kIrOutputRequired, ""},
{"block_dim", ge::kIrOutputRequired, ""},
{"tiling_cond", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"tiling_node",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(tiling_node))
},
{
"op_type",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(op_type))
},
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.InstanceDynamicInputNum("output_shape", static_cast<int32_t>(output_shape_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
if ((output_shape != nullptr) && (output_shape_num > 0)) {
for (int64_t i = 0; i < output_shape_num; ++i) {
auto one_output_shape = output_shape[i];
GE_ASSERT_NOTNULL(one_output_shape);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_output_shape->GetAnchor(), node->GetInDataAnchor(0 + x_num + i)));
}
}
return EsOpTilingOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsbTensor *EsOutfeedEnqueueOp(EsbTensor **x, int64_t x_num, const char *channel_name) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("OutfeedEnqueueOp")
.Name(("OutfeedEnqueueOp_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
{
"channel_name",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(channel_name))
},
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsOutfeedEnqueueOpV2(EsbTensor **x, int64_t x_num, EsbTensor *tensor_name, const char *channel_name, int64_t slice_size, int64_t wait_time, bool slice_sync) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
GE_ASSERT_NOTNULL(tensor_name);
auto &graph = tensor_name->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("OutfeedEnqueueOpV2")
.Name(("OutfeedEnqueueOpV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
{"tensor_name", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
{
"channel_name",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(channel_name))
},
{
"slice_size",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(slice_size))
},
{
"wait_time",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(wait_time))
},
{
"slice_sync",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(slice_sync))
},
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(tensor_name->GetAnchor(), node->GetInDataAnchor(0 + x_num)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsPRelu(EsbTensor *x, EsbTensor *weight) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(weight);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("PRelu")
.Name(("PRelu_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"weight", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsPReluGradOutput EsPReluGrad(EsbTensor *grads, EsbTensor *features, EsbTensor *weights) {
GE_ASSERT_NOTNULL(grads);
GE_ASSERT_NOTNULL(features);
GE_ASSERT_NOTNULL(weights);
auto &graph = grads->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("PReluGrad")
.Name(("PReluGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grads", ge::kIrInputRequired, ""},
{"features", ge::kIrInputRequired, ""},
{"weights", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"dx", ge::kIrOutputRequired, ""},
{"da", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grads->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(features->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weights->GetAnchor(), node->GetInDataAnchor(2)));
return EsPReluGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsPSAMask(EsbTensor *x, int64_t psa_type, int64_t num, int64_t h_feature, int64_t w_feature, int64_t h_mask, int64_t w_mask, int64_t half_h_mask, int64_t half_w_mask) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("PSAMask")
.Name(("PSAMask_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"psa_type",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(psa_type))
},
{
"num",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num))
},
{
"h_feature",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(h_feature))
},
{
"w_feature",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(w_feature))
},
{
"h_mask",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(h_mask))
},
{
"w_mask",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(w_mask))
},
{
"half_h_mask",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(half_h_mask))
},
{
"half_w_mask",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(half_w_mask))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsPSAMaskGrad(EsbTensor *y_grad, int64_t psa_type, int64_t num, int64_t h_feature, int64_t w_feature, int64_t h_mask, int64_t w_mask, int64_t half_h_mask, int64_t half_w_mask) {
GE_ASSERT_NOTNULL(y_grad);
auto &graph = y_grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("PSAMaskGrad")
.Name(("PSAMaskGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"y_grad", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"x_grad", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"psa_type",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(psa_type))
},
{
"num",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num))
},
{
"h_feature",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(h_feature))
},
{
"w_feature",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(w_feature))
},
{
"h_mask",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(h_mask))
},
{
"w_mask",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(w_mask))
},
{
"half_h_mask",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(half_h_mask))
},
{
"half_w_mask",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(half_w_mask))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y_grad->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsPSROIPooling(EsbTensor *x, EsbTensor *rois, int64_t output_dim, int64_t group_size, float spatial_scale) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(rois);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("PSROIPooling")
.Name(("PSROIPooling_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"rois", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"output_dim",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(output_dim))
},
{
"group_size",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(group_size))
},
{
"spatial_scale",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(spatial_scale))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rois->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsPSROIPoolingGradV2D(EsbTensor *x, EsbTensor *rois, float spatial_scale, int64_t output_dim, int64_t group_size, const int64_t *input_size, int64_t input_size_num) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(rois);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("PSROIPoolingGradV2D")
.Name(("PSROIPoolingGradV2D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"rois", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"spatial_scale",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(spatial_scale))
},
{
"output_dim",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(output_dim))
},
{
"group_size",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(group_size))
},
{
"input_size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(input_size, input_size + input_size_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rois->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsPSROIPoolingV2(EsbTensor *x, EsbTensor *rois, float spatial_scale, int64_t output_dim, int64_t group_size) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(rois);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("PSROIPoolingV2")
.Name(("PSROIPoolingV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"rois", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"spatial_scale",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(spatial_scale))
},
{
"output_dim",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(output_dim))
},
{
"group_size",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(group_size))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rois->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsPack(EsbTensor **x, int64_t x_num, int64_t axis, int64_t N) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Pack")
.Name(("Pack_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
{
"N",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(N))
},
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsPad(EsbTensor *x, EsbTensor *paddings) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(paddings);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Pad")
.Name(("Pad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"paddings", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(paddings->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsPadV2(EsbTensor *x, EsbTensor *paddings, EsbTensor *constant_values) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(paddings);
GE_ASSERT_NOTNULL(constant_values);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("PadV2")
.Name(("PadV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"paddings", ge::kIrInputRequired, ""},
{"constant_values", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(paddings->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(constant_values->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsPadV3(EsbTensor *x, EsbTensor *paddings, EsbTensor *constant_values, const char *mode, bool paddings_contiguous) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(paddings);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("PadV3")
.Name(("PadV3_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"paddings", ge::kIrInputRequired, ""},
{"constant_values", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(mode))
},
{
"paddings_contiguous",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(paddings_contiguous))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(paddings->GetAnchor(), node->GetInDataAnchor(1)));
if (constant_values != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(constant_values->GetAnchor(), node->GetInDataAnchor(2)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsPadV3Grad(EsbTensor *x, EsbTensor *paddings, const char *mode, bool paddings_contiguous) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(paddings);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("PadV3Grad")
.Name(("PadV3Grad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"paddings", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(mode))
},
{
"paddings_contiguous",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(paddings_contiguous))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(paddings->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsParallelConcat(EsbTensor **values, int64_t values_num, const int64_t *shape, int64_t shape_num, int64_t N) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(values_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < values_num; ++i) {
if (values[i] != nullptr) {
non_null_in = values[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ParallelConcat")
.Name(("ParallelConcat_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"values", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
{"output_data", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"shape",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(shape, shape + shape_num))
},
{
"N",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(N))
},
})
.InstanceDynamicInputNum("values", static_cast<int32_t>(values_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((values != nullptr) && (values_num > 0)) {
for (int64_t i = 0; i < values_num; ++i) {
auto one_values = values[i];
GE_ASSERT_NOTNULL(one_values);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_values->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsParallelDynamicStitch(EsbTensor **indices, int64_t indices_num, EsbTensor **x, int64_t x_num, int64_t N) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(indices_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < indices_num; ++i) {
if (indices[i] != nullptr) {
non_null_in = indices[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ParallelDynamicStitch")
.Name(("ParallelDynamicStitch_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"indices", ge::kIrInputDynamic, ""},
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"N",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(N))
},
})
.InstanceDynamicInputNum("indices", static_cast<int32_t>(indices_num))
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((indices != nullptr) && (indices_num > 0)) {
for (int64_t i = 0; i < indices_num; ++i) {
auto one_indices = indices[i];
GE_ASSERT_NOTNULL(one_indices);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_indices->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + indices_num + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsParameterizedTruncatedNormal(EsbTensor *shape, EsbTensor *means, EsbTensor *stdevs, EsbTensor *min, EsbTensor *max, int64_t seed, int64_t seed2) {
GE_ASSERT_NOTNULL(shape);
GE_ASSERT_NOTNULL(means);
GE_ASSERT_NOTNULL(stdevs);
GE_ASSERT_NOTNULL(min);
GE_ASSERT_NOTNULL(max);
auto &graph = shape->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ParameterizedTruncatedNormal")
.Name(("ParameterizedTruncatedNormal_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"shape", ge::kIrInputRequired, ""},
{"means", ge::kIrInputRequired, ""},
{"stdevs", ge::kIrInputRequired, ""},
{"min", ge::kIrInputRequired, ""},
{"max", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"seed",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed))
},
{
"seed2",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed2))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(means->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(stdevs->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(min->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(max->GetAnchor(), node->GetInDataAnchor(4)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsParseTensor(EsbTensor *serialized, ge::DataType out_type) {
GE_ASSERT_NOTNULL(serialized);
auto &graph = serialized->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ParseTensor")
.Name(("ParseTensor_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"serialized", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"out_type",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(out_type))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(serialized->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsPassThrough(EsbTensor *x, int64_t stride, bool reverse) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("PassThrough")
.Name(("PassThrough_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"stride",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(stride))
},
{
"reverse",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(reverse))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsPasteSubImg(EsbTensor *patch_img, EsbTensor *patch_coord, EsbTensor *core_area_coord, EsbTensor *combine_img, float scale) {
GE_ASSERT_NOTNULL(patch_img);
GE_ASSERT_NOTNULL(patch_coord);
GE_ASSERT_NOTNULL(core_area_coord);
GE_ASSERT_NOTNULL(combine_img);
auto &graph = patch_img->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("PasteSubImg")
.Name(("PasteSubImg_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"patch_img", ge::kIrInputRequired, ""},
{"patch_coord", ge::kIrInputRequired, ""},
{"core_area_coord", ge::kIrInputRequired, ""},
{"combine_img", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"combine_img", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"scale",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(scale))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(patch_img->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(patch_coord->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(core_area_coord->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(combine_img->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsPdist(EsbTensor *x, float p) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Pdist")
.Name(("Pdist_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"p",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(p))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsPermute(EsbTensor *x, const int64_t *order, int64_t order_num) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Permute")
.Name(("Permute_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"order",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(order, order + order_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsPhonyConcat(EsbTensor **x, int64_t x_num, const int64_t *concat_dim, int64_t concat_dim_num, const int64_t *N, int64_t N_num, bool keep_input_offset) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("PhonyConcat")
.Name(("PhonyConcat_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"concat_dim",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(concat_dim, concat_dim + concat_dim_num))
},
{
"N",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(N, N + N_num))
},
{
"keep_input_offset",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keep_input_offset))
},
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsPinverse(EsbTensor *x, float rcond) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Pinverse")
.Name(("Pinverse_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"rcond",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(rcond))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsPlaceHolder(EsbTensor *x, int64_t peerIndex, const char *parentId, const char *parentOpType, int64_t anchorIndex) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("PlaceHolder")
.Name(("PlaceHolder_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"peerIndex",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(peerIndex))
},
{
"parentId",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(parentId))
},
{
"parentOpType",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(parentOpType))
},
{
"anchorIndex",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(anchorIndex))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsPlaceholderWithDefault(EsbTensor *x, const int64_t *shape, int64_t shape_num) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("PlaceholderWithDefault")
.Name(("PlaceholderWithDefault_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"shape",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(shape, shape + shape_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsPointsInPolygons(EsbTensor *points, EsbTensor *polygons) {
GE_ASSERT_NOTNULL(points);
GE_ASSERT_NOTNULL(polygons);
auto &graph = points->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("PointsInPolygons")
.Name(("PointsInPolygons_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"points", ge::kIrInputRequired, ""},
{"polygons", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(points->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(polygons->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsPoisson(EsbTensor *x, int64_t seed) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Poisson")
.Name(("Poisson_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"seed",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsPoissonNllLoss(EsbTensor *input_x, EsbTensor *target, bool log_input, bool full, float eps, const char *reduction) {
GE_ASSERT_NOTNULL(input_x);
GE_ASSERT_NOTNULL(target);
auto &graph = input_x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("PoissonNllLoss")
.Name(("PoissonNllLoss_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_x", ge::kIrInputRequired, ""},
{"target", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"loss", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"log_input",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(log_input))
},
{
"full",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(full))
},
{
"eps",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(eps))
},
{
"reduction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduction))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(target->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsPooling(EsbTensor *x, int64_t mode, bool global_pooling, const int64_t *window, int64_t window_num, const int64_t *stride, int64_t stride_num, const int64_t *pad, int64_t pad_num, const int64_t *dilation, int64_t dilation_num, int64_t ceil_mode, const char *data_format) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Pooling")
.Name(("Pooling_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"mode",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(mode))
},
{
"global_pooling",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(global_pooling))
},
{
"window",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(window, window + window_num))
},
{
"stride",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(stride, stride + stride_num))
},
{
"pad",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pad, pad + pad_num))
},
{
"dilation",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilation, dilation + dilation_num))
},
{
"ceil_mode",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(ceil_mode))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsPopulationCount(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("PopulationCount")
.Name(("PopulationCount_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsPow(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Pow")
.Name(("Pow_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsPower(EsbTensor *x, float power, float scale, float shift) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Power")
.Name(("Power_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"power",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(power))
},
{
"scale",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(scale))
},
{
"shift",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(shift))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsPows(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Pows")
.Name(("Pows_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsPreventGradient(EsbTensor *x, const char *message) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("PreventGradient")
.Name(("PreventGradient_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"message",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(message))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsPrint(EsbTensor **x, int64_t x_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Print")
.Name(("Print_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsPrintV2(EsbTensor *x, const char *output_stream) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("PrintV2")
.Name(("PrintV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
{
"output_stream",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(output_stream))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsPrintV3(EsbTensor *x, EsbTensor **data, int64_t data_num, const char *message, int64_t first_n, int64_t summarize) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(data_num));
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("PrintV3")
.Name(("PrintV3_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"data", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"message",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(message))
},
{
"first_n",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(first_n))
},
{
"summarize",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(summarize))
},
})
.InstanceDynamicInputNum("data", static_cast<int32_t>(data_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
if ((data != nullptr) && (data_num > 0)) {
for (int64_t i = 0; i < data_num; ++i) {
auto one_data = data[i];
GE_ASSERT_NOTNULL(one_data);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_data->GetAnchor(), node->GetInDataAnchor(1 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsPriorBox(EsbTensor *x, EsbTensor *img, const float *min_size, int64_t min_size_num, const float *max_size, int64_t max_size_num, const float *aspect_ratio, int64_t aspect_ratio_num, int64_t img_h, int64_t img_w, float step_h, float step_w, bool flip, bool clip, float offset, const float *variance, int64_t variance_num) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(img);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("PriorBox")
.Name(("PriorBox_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"img", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"min_size",
ge::kAttrRequired,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(min_size, min_size + min_size_num))
},
{
"max_size",
ge::kAttrRequired,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(max_size, max_size + max_size_num))
},
{
"aspect_ratio",
ge::kAttrRequired,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(aspect_ratio, aspect_ratio + aspect_ratio_num))
},
{
"img_h",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(img_h))
},
{
"img_w",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(img_w))
},
{
"step_h",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(step_h))
},
{
"step_w",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(step_w))
},
{
"flip",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(flip))
},
{
"clip",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(clip))
},
{
"offset",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(offset))
},
{
"variance",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(variance, variance + variance_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(img->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsPriorBoxD(EsbTensor *x, EsbTensor *img, EsbTensor *data_h, EsbTensor *data_w, EsbTensor *box_height, EsbTensor *box_width, const float *min_size, int64_t min_size_num, const float *max_size, int64_t max_size_num, int64_t img_h, int64_t img_w, float step_h, float step_w, bool flip, bool clip, float offset, const float *variance, int64_t variance_num) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(img);
GE_ASSERT_NOTNULL(data_h);
GE_ASSERT_NOTNULL(data_w);
GE_ASSERT_NOTNULL(box_height);
GE_ASSERT_NOTNULL(box_width);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("PriorBoxD")
.Name(("PriorBoxD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"img", ge::kIrInputRequired, ""},
{"data_h", ge::kIrInputRequired, ""},
{"data_w", ge::kIrInputRequired, ""},
{"box_height", ge::kIrInputRequired, ""},
{"box_width", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"min_size",
ge::kAttrRequired,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(min_size, min_size + min_size_num))
},
{
"max_size",
ge::kAttrRequired,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(max_size, max_size + max_size_num))
},
{
"img_h",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(img_h))
},
{
"img_w",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(img_w))
},
{
"step_h",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(step_h))
},
{
"step_w",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(step_w))
},
{
"flip",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(flip))
},
{
"clip",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(clip))
},
{
"offset",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(offset))
},
{
"variance",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(variance, variance + variance_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(img->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(data_h->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(data_w->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(box_height->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(box_width->GetAnchor(), node->GetInDataAnchor(5)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsPriorBoxDV2(EsbTensor *x, EsbTensor *img, EsbTensor *boxes, const float *min_size, int64_t min_size_num, const float *max_size, int64_t max_size_num, int64_t img_h, int64_t img_w, float step_h, float step_w, bool flip, bool clip, float offset, const float *variance, int64_t variance_num) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(img);
GE_ASSERT_NOTNULL(boxes);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("PriorBoxDV2")
.Name(("PriorBoxDV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"img", ge::kIrInputRequired, ""},
{"boxes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"min_size",
ge::kAttrRequired,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(min_size, min_size + min_size_num))
},
{
"max_size",
ge::kAttrRequired,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(max_size, max_size + max_size_num))
},
{
"img_h",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(img_h))
},
{
"img_w",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(img_w))
},
{
"step_h",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(step_h))
},
{
"step_w",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(step_w))
},
{
"flip",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(flip))
},
{
"clip",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(clip))
},
{
"offset",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(offset))
},
{
"variance",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(variance, variance + variance_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(img->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(boxes->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsProdEnvMatAOutput EsProdEnvMatA(EsbTensor *coord, EsbTensor *type, EsbTensor *natoms, EsbTensor *box, EsbTensor *mesh, EsbTensor *davg, EsbTensor *dstd, float rcut_a, float rcut_r, float rcut_r_smth, const int64_t *sel_a, int64_t sel_a_num, const int64_t *sel_r, int64_t sel_r_num) {
GE_ASSERT_NOTNULL(coord);
GE_ASSERT_NOTNULL(type);
GE_ASSERT_NOTNULL(natoms);
GE_ASSERT_NOTNULL(box);
GE_ASSERT_NOTNULL(mesh);
GE_ASSERT_NOTNULL(davg);
GE_ASSERT_NOTNULL(dstd);
auto &graph = coord->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ProdEnvMatA")
.Name(("ProdEnvMatA_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"coord", ge::kIrInputRequired, ""},
{"type", ge::kIrInputRequired, ""},
{"natoms", ge::kIrInputRequired, ""},
{"box", ge::kIrInputRequired, ""},
{"mesh", ge::kIrInputRequired, ""},
{"davg", ge::kIrInputRequired, ""},
{"dstd", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"descrpt", ge::kIrOutputRequired, ""},
{"descrpt_deriv", ge::kIrOutputRequired, ""},
{"rij", ge::kIrOutputRequired, ""},
{"nlist", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"rcut_a",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(rcut_a))
},
{
"rcut_r",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(rcut_r))
},
{
"rcut_r_smth",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(rcut_r_smth))
},
{
"sel_a",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(sel_a, sel_a + sel_a_num))
},
{
"sel_r",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(sel_r, sel_r + sel_r_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(coord->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(type->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(natoms->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(box->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mesh->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(davg->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dstd->GetAnchor(), node->GetInDataAnchor(6)));
return EsProdEnvMatAOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsProdEnvMatACalcDescrptOutput EsProdEnvMatACalcDescrpt(EsbTensor *distance, EsbTensor *rij_x, EsbTensor *rij_y, EsbTensor *rij_z, EsbTensor *type, EsbTensor *natoms, EsbTensor *mesh, EsbTensor *davg, EsbTensor *dstd, float rcut_a, float rcut_r, float rcut_r_smth, const int64_t *sel_a, int64_t sel_a_num, const int64_t *sel_r, int64_t sel_r_num) {
GE_ASSERT_NOTNULL(distance);
GE_ASSERT_NOTNULL(rij_x);
GE_ASSERT_NOTNULL(rij_y);
GE_ASSERT_NOTNULL(rij_z);
GE_ASSERT_NOTNULL(type);
GE_ASSERT_NOTNULL(natoms);
GE_ASSERT_NOTNULL(mesh);
GE_ASSERT_NOTNULL(davg);
GE_ASSERT_NOTNULL(dstd);
auto &graph = distance->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ProdEnvMatACalcDescrpt")
.Name(("ProdEnvMatACalcDescrpt_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"distance", ge::kIrInputRequired, ""},
{"rij_x", ge::kIrInputRequired, ""},
{"rij_y", ge::kIrInputRequired, ""},
{"rij_z", ge::kIrInputRequired, ""},
{"type", ge::kIrInputRequired, ""},
{"natoms", ge::kIrInputRequired, ""},
{"mesh", ge::kIrInputRequired, ""},
{"davg", ge::kIrInputRequired, ""},
{"dstd", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"descrpt", ge::kIrOutputRequired, ""},
{"descrpt_deriv", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"rcut_a",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(rcut_a))
},
{
"rcut_r",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(rcut_r))
},
{
"rcut_r_smth",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(rcut_r_smth))
},
{
"sel_a",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(sel_a, sel_a + sel_a_num))
},
{
"sel_r",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(sel_r, sel_r + sel_r_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(distance->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rij_x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rij_y->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rij_z->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(type->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(natoms->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mesh->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(davg->GetAnchor(), node->GetInDataAnchor(7)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dstd->GetAnchor(), node->GetInDataAnchor(8)));
return EsProdEnvMatACalcDescrptOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsProdEnvMatACalcRijOutput EsProdEnvMatACalcRij(EsbTensor *coord, EsbTensor *type, EsbTensor *natoms, EsbTensor *box, EsbTensor *mesh, float rcut_a, float rcut_r, float rcut_r_smth, const int64_t *sel_a, int64_t sel_a_num, const int64_t *sel_r, int64_t sel_r_num) {
GE_ASSERT_NOTNULL(coord);
GE_ASSERT_NOTNULL(type);
GE_ASSERT_NOTNULL(natoms);
GE_ASSERT_NOTNULL(box);
GE_ASSERT_NOTNULL(mesh);
auto &graph = coord->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ProdEnvMatACalcRij")
.Name(("ProdEnvMatACalcRij_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"coord", ge::kIrInputRequired, ""},
{"type", ge::kIrInputRequired, ""},
{"natoms", ge::kIrInputRequired, ""},
{"box", ge::kIrInputRequired, ""},
{"mesh", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"rij", ge::kIrOutputRequired, ""},
{"nlist", ge::kIrOutputRequired, ""},
{"distance", ge::kIrOutputRequired, ""},
{"rij_x", ge::kIrOutputRequired, ""},
{"rij_y", ge::kIrOutputRequired, ""},
{"rij_z", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"rcut_a",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(rcut_a))
},
{
"rcut_r",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(rcut_r))
},
{
"rcut_r_smth",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(rcut_r_smth))
},
{
"sel_a",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(sel_a, sel_a + sel_a_num))
},
{
"sel_r",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(sel_r, sel_r + sel_r_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(coord->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(type->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(natoms->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(box->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mesh->GetAnchor(), node->GetInDataAnchor(4)));
return EsProdEnvMatACalcRijOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
graph.GetEsbTensorFromNode(node, 5),
};
}
EsbTensor *EsProdForceSeA(EsbTensor *net_deriv, EsbTensor *in_deriv, EsbTensor *nlist, EsbTensor *natoms, int64_t n_a_sel, int64_t n_r_sel) {
GE_ASSERT_NOTNULL(net_deriv);
GE_ASSERT_NOTNULL(in_deriv);
GE_ASSERT_NOTNULL(nlist);
GE_ASSERT_NOTNULL(natoms);
auto &graph = net_deriv->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ProdForceSeA")
.Name(("ProdForceSeA_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"net_deriv", ge::kIrInputRequired, ""},
{"in_deriv", ge::kIrInputRequired, ""},
{"nlist", ge::kIrInputRequired, ""},
{"natoms", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"atom_force", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"n_a_sel",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(n_a_sel))
},
{
"n_r_sel",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(n_r_sel))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(net_deriv->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(in_deriv->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(nlist->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(natoms->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsProdVirialSeAOutput EsProdVirialSeA(EsbTensor *net_deriv, EsbTensor *in_deriv, EsbTensor *rij, EsbTensor *nlist, EsbTensor *natoms, int64_t n_a_sel, int64_t n_r_sel) {
GE_ASSERT_NOTNULL(net_deriv);
GE_ASSERT_NOTNULL(in_deriv);
GE_ASSERT_NOTNULL(rij);
GE_ASSERT_NOTNULL(nlist);
GE_ASSERT_NOTNULL(natoms);
auto &graph = net_deriv->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ProdVirialSeA")
.Name(("ProdVirialSeA_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"net_deriv", ge::kIrInputRequired, ""},
{"in_deriv", ge::kIrInputRequired, ""},
{"rij", ge::kIrInputRequired, ""},
{"nlist", ge::kIrInputRequired, ""},
{"natoms", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"virial", ge::kIrOutputRequired, ""},
{"atom_virial", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"n_a_sel",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(n_a_sel))
},
{
"n_r_sel",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(n_r_sel))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(net_deriv->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(in_deriv->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rij->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(nlist->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(natoms->GetAnchor(), node->GetInDataAnchor(4)));
return EsProdVirialSeAOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsPromptFlashAttention(EsbTensor *query, EsbTensor *key, EsbTensor *value, EsbTensor *pse_shift, EsbTensor *atten_mask, EsbTensor *actual_seq_lengths, EsbTensor *actual_seq_lengths_kv, EsbTensor *deq_scale1, EsbTensor *quant_scale1, EsbTensor *deq_scale2, EsbTensor *quant_scale2, EsbTensor *quant_offset2, int64_t num_heads, float scale_value, int64_t pre_tokens, int64_t next_tokens, const char *input_layout, int64_t num_key_value_heads, int64_t sparse_mode, int64_t inner_precise) {
GE_ASSERT_NOTNULL(query);
GE_ASSERT_NOTNULL(key);
GE_ASSERT_NOTNULL(value);
auto &graph = query->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("PromptFlashAttention")
.Name(("PromptFlashAttention_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"query", ge::kIrInputRequired, ""},
{"key", ge::kIrInputRequired, ""},
{"value", ge::kIrInputRequired, ""},
{"pse_shift", ge::kIrInputOptional, ""},
{"atten_mask", ge::kIrInputOptional, ""},
{"actual_seq_lengths", ge::kIrInputOptional, ""},
{"actual_seq_lengths_kv", ge::kIrInputOptional, ""},
{"deq_scale1", ge::kIrInputOptional, ""},
{"quant_scale1", ge::kIrInputOptional, ""},
{"deq_scale2", ge::kIrInputOptional, ""},
{"quant_scale2", ge::kIrInputOptional, ""},
{"quant_offset2", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"attention_out", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_heads",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_heads))
},
{
"scale_value",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(scale_value))
},
{
"pre_tokens",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pre_tokens))
},
{
"next_tokens",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(next_tokens))
},
{
"input_layout",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(input_layout))
},
{
"num_key_value_heads",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_key_value_heads))
},
{
"sparse_mode",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(sparse_mode))
},
{
"inner_precise",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(inner_precise))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(query->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(key->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(2)));
if (pse_shift != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(pse_shift->GetAnchor(), node->GetInDataAnchor(3)));
}
if (atten_mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(atten_mask->GetAnchor(), node->GetInDataAnchor(4)));
}
if (actual_seq_lengths != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(actual_seq_lengths->GetAnchor(), node->GetInDataAnchor(5)));
}
if (actual_seq_lengths_kv != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(actual_seq_lengths_kv->GetAnchor(), node->GetInDataAnchor(6)));
}
if (deq_scale1 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(deq_scale1->GetAnchor(), node->GetInDataAnchor(7)));
}
if (quant_scale1 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(quant_scale1->GetAnchor(), node->GetInDataAnchor(8)));
}
if (deq_scale2 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(deq_scale2->GetAnchor(), node->GetInDataAnchor(9)));
}
if (quant_scale2 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(quant_scale2->GetAnchor(), node->GetInDataAnchor(10)));
}
if (quant_offset2 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(quant_offset2->GetAnchor(), node->GetInDataAnchor(11)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsProposalOutput EsProposal(EsbTensor *cls_prob, EsbTensor *bbox_delta, EsbTensor *im_info, float feat_stride, float base_size, float min_size, const float *ratio, int64_t ratio_num, const float *scale, int64_t scale_num, int64_t pre_nms_topn, int64_t post_nms_topn, float iou_threshold, bool output_actual_rois_num) {
GE_ASSERT_NOTNULL(cls_prob);
GE_ASSERT_NOTNULL(bbox_delta);
GE_ASSERT_NOTNULL(im_info);
auto &graph = cls_prob->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Proposal")
.Name(("Proposal_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"cls_prob", ge::kIrInputRequired, ""},
{"bbox_delta", ge::kIrInputRequired, ""},
{"im_info", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"rois", ge::kIrOutputRequired, ""},
{"actual_rois_num", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"feat_stride",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(feat_stride))
},
{
"base_size",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(base_size))
},
{
"min_size",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(min_size))
},
{
"ratio",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(ratio, ratio + ratio_num))
},
{
"scale",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(scale, scale + scale_num))
},
{
"pre_nms_topn",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pre_nms_topn))
},
{
"post_nms_topn",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(post_nms_topn))
},
{
"iou_threshold",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(iou_threshold))
},
{
"output_actual_rois_num",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(output_actual_rois_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(cls_prob->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bbox_delta->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(im_info->GetAnchor(), node->GetInDataAnchor(2)));
return EsProposalOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsProposalDOutput EsProposalD(EsbTensor *cls_prob, EsbTensor *bbox_delta, EsbTensor *im_info, EsbTensor *rpn_bbox, float feat_stride, float base_size, float min_size, const float *ratio, int64_t ratio_num, const float *scale, int64_t scale_num, int64_t pre_nms_topn, int64_t post_nms_topn, float iou_threshold, bool output_actual_rois_num) {
GE_ASSERT_NOTNULL(cls_prob);
GE_ASSERT_NOTNULL(bbox_delta);
GE_ASSERT_NOTNULL(im_info);
GE_ASSERT_NOTNULL(rpn_bbox);
auto &graph = cls_prob->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ProposalD")
.Name(("ProposalD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"cls_prob", ge::kIrInputRequired, ""},
{"bbox_delta", ge::kIrInputRequired, ""},
{"im_info", ge::kIrInputRequired, ""},
{"rpn_bbox", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"rois", ge::kIrOutputRequired, ""},
{"actual_rois_num", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"feat_stride",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(feat_stride))
},
{
"base_size",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(base_size))
},
{
"min_size",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(min_size))
},
{
"ratio",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(ratio, ratio + ratio_num))
},
{
"scale",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(scale, scale + scale_num))
},
{
"pre_nms_topn",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pre_nms_topn))
},
{
"post_nms_topn",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(post_nms_topn))
},
{
"iou_threshold",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(iou_threshold))
},
{
"output_actual_rois_num",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(output_actual_rois_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(cls_prob->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bbox_delta->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(im_info->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rpn_bbox->GetAnchor(), node->GetInDataAnchor(3)));
return EsProposalDOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsPtIou(EsbTensor *bboxes, EsbTensor *gtboxes, const char *mode) {
GE_ASSERT_NOTNULL(bboxes);
GE_ASSERT_NOTNULL(gtboxes);
auto &graph = bboxes->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("PtIou")
.Name(("PtIou_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"bboxes", ge::kIrInputRequired, ""},
{"gtboxes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"overlap", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bboxes->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gtboxes->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsQrOutput EsQr(EsbTensor *x, bool full_matrices) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Qr")
.Name(("Qr_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"q", ge::kIrOutputRequired, ""},
{"r", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"full_matrices",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(full_matrices))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return EsQrOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsQuantBatchMatmul(EsbTensor *x1, EsbTensor *x2, EsbTensor *deq_scale, EsbTensor *bias, bool adj_x1, bool adj_x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
GE_ASSERT_NOTNULL(deq_scale);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("QuantBatchMatmul")
.Name(("QuantBatchMatmul_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"deq_scale", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"adj_x1",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(adj_x1))
},
{
"adj_x2",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(adj_x2))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(deq_scale->GetAnchor(), node->GetInDataAnchor(2)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(3)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsQuantBatchMatmulV3(EsbTensor *x1, EsbTensor *x2, EsbTensor *scale, EsbTensor *offset, EsbTensor *bias, EsbTensor *pertoken_scale, int64_t dtype, bool transpose_x1, bool transpose_x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
GE_ASSERT_NOTNULL(scale);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("QuantBatchMatmulV3")
.Name(("QuantBatchMatmulV3_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"scale", ge::kIrInputRequired, ""},
{"offset", ge::kIrInputOptional, ""},
{"bias", ge::kIrInputOptional, ""},
{"pertoken_scale", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dtype))
},
{
"transpose_x1",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(transpose_x1))
},
{
"transpose_x2",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(transpose_x2))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(2)));
if (offset != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset->GetAnchor(), node->GetInDataAnchor(3)));
}
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(4)));
}
if (pertoken_scale != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(pertoken_scale->GetAnchor(), node->GetInDataAnchor(5)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsQuantConv2D(EsbTensor *x, EsbTensor *filter, EsbTensor *scale, EsbTensor *bias, EsbTensor *offset, int64_t dtype, const int64_t *strides, int64_t strides_num, const int64_t *pads, int64_t pads_num, const int64_t *dilations, int64_t dilations_num, int64_t groups, const char *data_format, int64_t offset_x, const char *round_mode) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(filter);
GE_ASSERT_NOTNULL(scale);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("QuantConv2D")
.Name(("QuantConv2D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"filter", ge::kIrInputRequired, ""},
{"scale", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
{"offset", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dtype))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"pads",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(pads, pads + pads_num))
},
{
"dilations",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dilations, dilations + dilations_num))
},
{
"groups",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(groups))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"offset_x",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(offset_x))
},
{
"round_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(round_mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(filter->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(2)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(3)));
}
if (offset != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset->GetAnchor(), node->GetInDataAnchor(4)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsQuantUpdateScatter(EsbTensor *var, EsbTensor *indices, EsbTensor *updates, EsbTensor *quant_scales, EsbTensor *quant_zero_points, const char *reduce, int64_t axis, int64_t quant_axis, bool reciprocal_scale) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(updates);
GE_ASSERT_NOTNULL(quant_scales);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("QuantUpdateScatter")
.Name(("QuantUpdateScatter_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"updates", ge::kIrInputRequired, ""},
{"quant_scales", ge::kIrInputRequired, ""},
{"quant_zero_points", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"reduce",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduce))
},
{
"axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
{
"quant_axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(quant_axis))
},
{
"reciprocal_scale",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(reciprocal_scale))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(updates->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(quant_scales->GetAnchor(), node->GetInDataAnchor(3)));
if (quant_zero_points != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(quant_zero_points->GetAnchor(), node->GetInDataAnchor(4)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsQuantize(EsbTensor *x, EsbTensor *scales, EsbTensor *zero_points, const char *dtype, int64_t axis) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(scales);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Quantize")
.Name(("Quantize_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"scales", ge::kIrInputRequired, ""},
{"zero_points", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(dtype))
},
{
"axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scales->GetAnchor(), node->GetInDataAnchor(1)));
if (zero_points != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(zero_points->GetAnchor(), node->GetInDataAnchor(2)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsQuantizeAddLayerNormOutput EsQuantizeAddLayerNorm(EsbTensor *x1, EsbTensor *x2, EsbTensor *gamma, EsbTensor *beta, EsbTensor *bias, EsbTensor *scales, EsbTensor *zero_points, int64_t dtype, int64_t axis, float epsilon, bool additional_output) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
GE_ASSERT_NOTNULL(gamma);
GE_ASSERT_NOTNULL(beta);
GE_ASSERT_NOTNULL(bias);
GE_ASSERT_NOTNULL(scales);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("QuantizeAddLayerNorm")
.Name(("QuantizeAddLayerNorm_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
{"beta", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputRequired, ""},
{"scales", ge::kIrInputRequired, ""},
{"zero_points", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"x", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dtype))
},
{
"axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
{
"additional_output",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(additional_output))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scales->GetAnchor(), node->GetInDataAnchor(5)));
if (zero_points != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(zero_points->GetAnchor(), node->GetInDataAnchor(6)));
}
return EsQuantizeAddLayerNormOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsQuantizedResizeBilinearOutput EsQuantizedResizeBilinear(EsbTensor *images, EsbTensor *size, EsbTensor *min, EsbTensor *max, bool align_corners, bool half_pixel_centers) {
GE_ASSERT_NOTNULL(images);
GE_ASSERT_NOTNULL(size);
GE_ASSERT_NOTNULL(min);
GE_ASSERT_NOTNULL(max);
auto &graph = images->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("QuantizedResizeBilinear")
.Name(("QuantizedResizeBilinear_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"images", ge::kIrInputRequired, ""},
{"size", ge::kIrInputRequired, ""},
{"min", ge::kIrInputRequired, ""},
{"max", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"resized_images", ge::kIrOutputRequired, ""},
{"y_min", ge::kIrOutputRequired, ""},
{"y_max", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"align_corners",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(align_corners))
},
{
"half_pixel_centers",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(half_pixel_centers))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(images->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(size->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(min->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(max->GetAnchor(), node->GetInDataAnchor(3)));
return EsQuantizedResizeBilinearOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsQueueClose(EsbTensor *handle, bool cancel_pending_enqueues) {
GE_ASSERT_NOTNULL(handle);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("QueueClose")
.Name(("QueueClose_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
{
"cancel_pending_enqueues",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(cancel_pending_enqueues))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsQueueEnqueue(EsbTensor *handle, EsbTensor **components, int64_t components_num, int64_t timeout_ms) {
GE_ASSERT_NOTNULL(handle);
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(components_num));
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("QueueEnqueue")
.Name(("QueueEnqueue_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
{"components", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
{
"timeout_ms",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(timeout_ms))
},
})
.InstanceDynamicInputNum("components", static_cast<int32_t>(components_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
if ((components != nullptr) && (components_num > 0)) {
for (int64_t i = 0; i < components_num; ++i) {
auto one_components = components[i];
GE_ASSERT_NOTNULL(one_components);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_components->GetAnchor(), node->GetInDataAnchor(1 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsQueueEnqueueMany(EsbTensor *handle, EsbTensor **components, int64_t components_num, int64_t timeout_ms) {
GE_ASSERT_NOTNULL(handle);
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(components_num));
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("QueueEnqueueMany")
.Name(("QueueEnqueueMany_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
{"components", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
{
"timeout_ms",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(timeout_ms))
},
})
.InstanceDynamicInputNum("components", static_cast<int32_t>(components_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
if ((components != nullptr) && (components_num > 0)) {
for (int64_t i = 0; i < components_num; ++i) {
auto one_components = components[i];
GE_ASSERT_NOTNULL(one_components);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_components->GetAnchor(), node->GetInDataAnchor(1 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsQueueIsClosed(EsbTensor *handle) {
GE_ASSERT_NOTNULL(handle);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("QueueIsClosed")
.Name(("QueueIsClosed_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"is_closed", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsQueueSize(EsbTensor *handle) {
GE_ASSERT_NOTNULL(handle);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("QueueSize")
.Name(("QueueSize_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"size", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRFFT(EsbTensor *input, EsbTensor *fft_length) {
GE_ASSERT_NOTNULL(input);
GE_ASSERT_NOTNULL(fft_length);
auto &graph = input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RFFT")
.Name(("RFFT_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input", ge::kIrInputRequired, ""},
{"fft_length", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(fft_length->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRGB2YUV422(EsbTensor *rgb) {
GE_ASSERT_NOTNULL(rgb);
auto &graph = rgb->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RGB2YUV422")
.Name(("RGB2YUV422_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"rgb", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"yuv", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rgb->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRGBToHSV(EsbTensor *images) {
GE_ASSERT_NOTNULL(images);
auto &graph = images->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RGBToHSV")
.Name(("RGBToHSV_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"images", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(images->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsRNNOutput EsRNN(EsbTensor *x, EsbTensor *cont, EsbTensor *x_static, EsbTensor *h_0, EsbTensor *w_xh, EsbTensor *bias_h, EsbTensor *w_sh, EsbTensor *w_hh, EsbTensor *w_ho, EsbTensor *bias_o, int64_t num_output, bool expose_hidden) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(cont);
GE_ASSERT_NOTNULL(w_xh);
GE_ASSERT_NOTNULL(bias_h);
GE_ASSERT_NOTNULL(w_hh);
GE_ASSERT_NOTNULL(w_ho);
GE_ASSERT_NOTNULL(bias_o);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RNN")
.Name(("RNN_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"cont", ge::kIrInputRequired, ""},
{"x_static", ge::kIrInputOptional, ""},
{"h_0", ge::kIrInputOptional, ""},
{"w_xh", ge::kIrInputRequired, ""},
{"bias_h", ge::kIrInputRequired, ""},
{"w_sh", ge::kIrInputOptional, ""},
{"w_hh", ge::kIrInputRequired, ""},
{"w_ho", ge::kIrInputRequired, ""},
{"bias_o", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"o", ge::kIrOutputRequired, ""},
{"h_t", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_output",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_output))
},
{
"expose_hidden",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(expose_hidden))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(cont->GetAnchor(), node->GetInDataAnchor(1)));
if (x_static != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x_static->GetAnchor(), node->GetInDataAnchor(2)));
}
if (h_0 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(h_0->GetAnchor(), node->GetInDataAnchor(3)));
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(w_xh->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias_h->GetAnchor(), node->GetInDataAnchor(5)));
if (w_sh != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(w_sh->GetAnchor(), node->GetInDataAnchor(6)));
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(w_hh->GetAnchor(), node->GetInDataAnchor(7)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(w_ho->GetAnchor(), node->GetInDataAnchor(8)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias_o->GetAnchor(), node->GetInDataAnchor(9)));
return EsRNNOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsRNNTLossOutput EsRNNTLoss(EsbTensor *acts, EsbTensor *labels, EsbTensor *input_lengths, EsbTensor *label_lengths, int64_t blank_label) {
GE_ASSERT_NOTNULL(acts);
GE_ASSERT_NOTNULL(labels);
GE_ASSERT_NOTNULL(input_lengths);
GE_ASSERT_NOTNULL(label_lengths);
auto &graph = acts->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RNNTLoss")
.Name(("RNNTLoss_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"acts", ge::kIrInputRequired, ""},
{"labels", ge::kIrInputRequired, ""},
{"input_lengths", ge::kIrInputRequired, ""},
{"label_lengths", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"costs", ge::kIrOutputRequired, ""},
{"grads", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"blank_label",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(blank_label))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(acts->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(labels->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_lengths->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(label_lengths->GetAnchor(), node->GetInDataAnchor(3)));
return EsRNNTLossOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsROIAlign(EsbTensor *features, EsbTensor *rois, EsbTensor *rois_n, float spatial_scale, int64_t pooled_height, int64_t pooled_width, int64_t sample_num, int64_t roi_end_mode, const char *pool_mode) {
GE_ASSERT_NOTNULL(features);
GE_ASSERT_NOTNULL(rois);
auto &graph = features->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ROIAlign")
.Name(("ROIAlign_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"features", ge::kIrInputRequired, ""},
{"rois", ge::kIrInputRequired, ""},
{"rois_n", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"spatial_scale",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(spatial_scale))
},
{
"pooled_height",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pooled_height))
},
{
"pooled_width",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pooled_width))
},
{
"sample_num",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(sample_num))
},
{
"roi_end_mode",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(roi_end_mode))
},
{
"pool_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(pool_mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(features->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rois->GetAnchor(), node->GetInDataAnchor(1)));
if (rois_n != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rois_n->GetAnchor(), node->GetInDataAnchor(2)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsROIAlignGrad(EsbTensor *ydiff, EsbTensor *rois, EsbTensor *rois_n, const int64_t *xdiff_shape, int64_t xdiff_shape_num, int64_t pooled_width, int64_t pooled_height, float spatial_scale, int64_t sample_num, int64_t roi_end_mode) {
GE_ASSERT_NOTNULL(ydiff);
GE_ASSERT_NOTNULL(rois);
auto &graph = ydiff->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ROIAlignGrad")
.Name(("ROIAlignGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"ydiff", ge::kIrInputRequired, ""},
{"rois", ge::kIrInputRequired, ""},
{"rois_n", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"xdiff", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"xdiff_shape",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(xdiff_shape, xdiff_shape + xdiff_shape_num))
},
{
"pooled_width",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pooled_width))
},
{
"pooled_height",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pooled_height))
},
{
"spatial_scale",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(spatial_scale))
},
{
"sample_num",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(sample_num))
},
{
"roi_end_mode",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(roi_end_mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(ydiff->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rois->GetAnchor(), node->GetInDataAnchor(1)));
if (rois_n != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rois_n->GetAnchor(), node->GetInDataAnchor(2)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsROIPooling(EsbTensor *x, EsbTensor *rois, EsbTensor *roi_actual_num, int64_t pooled_h, int64_t pooled_w, float spatial_scale_h, float spatial_scale_w) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(rois);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ROIPooling")
.Name(("ROIPooling_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"rois", ge::kIrInputRequired, ""},
{"roi_actual_num", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"pooled_h",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pooled_h))
},
{
"pooled_w",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pooled_w))
},
{
"spatial_scale_h",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(spatial_scale_h))
},
{
"spatial_scale_w",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(spatial_scale_w))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rois->GetAnchor(), node->GetInDataAnchor(1)));
if (roi_actual_num != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(roi_actual_num->GetAnchor(), node->GetInDataAnchor(2)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRaggedBinCount(EsbTensor *splits, EsbTensor *values, EsbTensor *size, EsbTensor *weights, bool binary_output) {
GE_ASSERT_NOTNULL(splits);
GE_ASSERT_NOTNULL(values);
GE_ASSERT_NOTNULL(size);
GE_ASSERT_NOTNULL(weights);
auto &graph = splits->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RaggedBinCount")
.Name(("RaggedBinCount_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"splits", ge::kIrInputRequired, ""},
{"values", ge::kIrInputRequired, ""},
{"size", ge::kIrInputRequired, ""},
{"weights", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"binary_output",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(binary_output))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(splits->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(values->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(size->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weights->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRaggedBincount(EsbTensor *splits, EsbTensor *values, EsbTensor *size, EsbTensor *weights, bool binary_output) {
GE_ASSERT_NOTNULL(splits);
GE_ASSERT_NOTNULL(values);
GE_ASSERT_NOTNULL(size);
GE_ASSERT_NOTNULL(weights);
auto &graph = splits->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RaggedBincount")
.Name(("RaggedBincount_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"splits", ge::kIrInputRequired, ""},
{"values", ge::kIrInputRequired, ""},
{"size", ge::kIrInputRequired, ""},
{"weights", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"binary_output",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(binary_output))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(splits->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(values->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(size->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weights->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsRaggedCountSparseOutputOutput EsRaggedCountSparseOutput(EsbTensor *splits, EsbTensor *values, EsbTensor *weights, bool binary_output, int64_t minlength, int64_t maxlength) {
GE_ASSERT_NOTNULL(splits);
GE_ASSERT_NOTNULL(values);
GE_ASSERT_NOTNULL(weights);
auto &graph = splits->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RaggedCountSparseOutput")
.Name(("RaggedCountSparseOutput_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"splits", ge::kIrInputRequired, ""},
{"values", ge::kIrInputRequired, ""},
{"weights", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_indices", ge::kIrOutputRequired, ""},
{"output_values", ge::kIrOutputRequired, ""},
{"output_dense_shape", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"binary_output",
ge::kAttrRequired,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(binary_output))
},
{
"minlength",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(minlength))
},
{
"maxlength",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(maxlength))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(splits->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(values->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weights->GetAnchor(), node->GetInDataAnchor(2)));
return EsRaggedCountSparseOutputOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsRaggedRangeOutput EsRaggedRange(EsbTensor *starts, EsbTensor *limits, EsbTensor *deltas, ge::DataType Tsplits) {
GE_ASSERT_NOTNULL(starts);
GE_ASSERT_NOTNULL(limits);
GE_ASSERT_NOTNULL(deltas);
auto &graph = starts->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RaggedRange")
.Name(("RaggedRange_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"starts", ge::kIrInputRequired, ""},
{"limits", ge::kIrInputRequired, ""},
{"deltas", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"rt_nested_splits", ge::kIrOutputRequired, ""},
{"rt_dense_values", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"Tsplits",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(Tsplits))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(starts->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(limits->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(deltas->GetAnchor(), node->GetInDataAnchor(2)));
return EsRaggedRangeOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsRaggedTensorToSparseOutput EsRaggedTensorToSparse(EsbTensor **rt_nested_splits, int64_t rt_nested_splits_num, EsbTensor *rt_dense_values, int64_t RAGGED_RANK, ge::DataType Tsplits) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(rt_nested_splits_num));
GE_ASSERT_NOTNULL(rt_dense_values);
auto &graph = rt_dense_values->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RaggedTensorToSparse")
.Name(("RaggedTensorToSparse_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"rt_nested_splits", ge::kIrInputDynamic, ""},
{"rt_dense_values", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"sparse_indices", ge::kIrOutputRequired, ""},
{"sparse_values", ge::kIrOutputRequired, ""},
{"sparse_dense_shape", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"RAGGED_RANK",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(RAGGED_RANK))
},
{
"Tsplits",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(Tsplits))
},
})
.InstanceDynamicInputNum("rt_nested_splits", static_cast<int32_t>(rt_nested_splits_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((rt_nested_splits != nullptr) && (rt_nested_splits_num > 0)) {
for (int64_t i = 0; i < rt_nested_splits_num; ++i) {
auto one_rt_nested_splits = rt_nested_splits[i];
GE_ASSERT_NOTNULL(one_rt_nested_splits);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_rt_nested_splits->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rt_dense_values->GetAnchor(), node->GetInDataAnchor(0 + rt_nested_splits_num)));
return EsRaggedTensorToSparseOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsRandomChoiceWithMaskOutput EsRandomChoiceWithMask(EsbTensor *x, int64_t count, int64_t seed, int64_t seed2) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RandomChoiceWithMask")
.Name(("RandomChoiceWithMask_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"mask", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"count",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(count))
},
{
"seed",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed))
},
{
"seed2",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed2))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return EsRandomChoiceWithMaskOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsRandomGamma(EsbTensor *shape, EsbTensor *alpha, int64_t seed, int64_t seed2) {
GE_ASSERT_NOTNULL(shape);
GE_ASSERT_NOTNULL(alpha);
auto &graph = shape->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RandomGamma")
.Name(("RandomGamma_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"shape", ge::kIrInputRequired, ""},
{"alpha", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"seed",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed))
},
{
"seed2",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed2))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(alpha->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRandomGammaGrad(EsbTensor *alpha, EsbTensor *sample) {
GE_ASSERT_NOTNULL(alpha);
GE_ASSERT_NOTNULL(sample);
auto &graph = alpha->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RandomGammaGrad")
.Name(("RandomGammaGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"alpha", ge::kIrInputRequired, ""},
{"sample", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(alpha->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sample->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRandomPoisson(EsbTensor *shape, EsbTensor *rate, ge::DataType dtype, int64_t seed, int64_t seed2) {
GE_ASSERT_NOTNULL(shape);
GE_ASSERT_NOTNULL(rate);
auto &graph = shape->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RandomPoisson")
.Name(("RandomPoisson_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"shape", ge::kIrInputRequired, ""},
{"rate", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
{
"seed",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed))
},
{
"seed2",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed2))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rate->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRandomShuffle(EsbTensor *x, int64_t seed, int64_t seed2) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RandomShuffle")
.Name(("RandomShuffle_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"seed",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed))
},
{
"seed2",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed2))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRandomStandardNormal(EsbTensor *shape, ge::DataType dtype, int64_t seed, int64_t seed2) {
GE_ASSERT_NOTNULL(shape);
auto &graph = shape->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RandomStandardNormal")
.Name(("RandomStandardNormal_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"shape", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
{
"seed",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed))
},
{
"seed2",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed2))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRandomUniform(EsbTensor *shape, ge::DataType dtype, int64_t seed, int64_t seed2) {
GE_ASSERT_NOTNULL(shape);
auto &graph = shape->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RandomUniform")
.Name(("RandomUniform_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"shape", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
{
"seed",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed))
},
{
"seed2",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed2))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRandomUniformInt(EsbTensor *shape, EsbTensor *min, EsbTensor *max, int64_t seed, int64_t seed2) {
GE_ASSERT_NOTNULL(shape);
GE_ASSERT_NOTNULL(min);
GE_ASSERT_NOTNULL(max);
auto &graph = shape->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RandomUniformInt")
.Name(("RandomUniformInt_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"shape", ge::kIrInputRequired, ""},
{"min", ge::kIrInputRequired, ""},
{"max", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"seed",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed))
},
{
"seed2",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed2))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(min->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(max->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRandperm(EsbGraph *owner_graph, int64_t n, int64_t layout, ge::DataType dtype) {
GE_ASSERT_NOTNULL(owner_graph);
EsbGraph &graph = *owner_graph;

auto desc = ge::CompliantOpDescBuilder().OpType("Randperm")
.Name(("Randperm_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
})
.IrDefOutputs({
{"out", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"n",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(n))
},
{
"layout",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(layout))
},
{
"dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRange(EsbTensor *start, EsbTensor *limit, EsbTensor *delta, bool is_closed) {
GE_ASSERT_NOTNULL(start);
GE_ASSERT_NOTNULL(limit);
GE_ASSERT_NOTNULL(delta);
auto &graph = start->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Range")
.Name(("Range_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"start", ge::kIrInputRequired, ""},
{"limit", ge::kIrInputRequired, ""},
{"delta", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"is_closed",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_closed))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(start->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(limit->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(delta->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRangeD(EsbTensor *x, float start, float limit, float delta) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RangeD")
.Name(("RangeD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"start",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(start))
},
{
"limit",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(limit))
},
{
"delta",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(delta))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRank(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Rank")
.Name(("Rank_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsReadSelect(EsbTensor *x, const int64_t *stride_list, int64_t stride_list_num) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ReadSelect")
.Name(("ReadSelect_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"stride_list",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(stride_list, stride_list + stride_list_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsReadVariableOp(EsbTensor *x, int64_t dtype) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ReadVariableOp")
.Name(("ReadVariableOp_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsReal(EsbTensor *input, int64_t Tout) {
GE_ASSERT_NOTNULL(input);
auto &graph = input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Real")
.Name(("Real_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"Tout",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(Tout))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRealDiv(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RealDiv")
.Name(("RealDiv_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsReciprocal(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Reciprocal")
.Name(("Reciprocal_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsReciprocalGrad(EsbTensor *y, EsbTensor *dy) {
GE_ASSERT_NOTNULL(y);
GE_ASSERT_NOTNULL(dy);
auto &graph = y->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ReciprocalGrad")
.Name(("ReciprocalGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"y", ge::kIrInputRequired, ""},
{"dy", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"z", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRecordInput(EsbGraph *owner_graph, const char *file_pattern, int64_t file_random_seed, float file_shuffle_shift_ratio, int64_t file_buffer_size, int64_t file_parallelism, int64_t batch_size, const char *compression_type) {
GE_ASSERT_NOTNULL(owner_graph);
EsbGraph &graph = *owner_graph;

auto desc = ge::CompliantOpDescBuilder().OpType("RecordInput")
.Name(("RecordInput_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
})
.IrDefOutputs({
{"records", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"file_pattern",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(file_pattern))
},
{
"file_random_seed",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(file_random_seed))
},
{
"file_shuffle_shift_ratio",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(file_shuffle_shift_ratio))
},
{
"file_buffer_size",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(file_buffer_size))
},
{
"file_parallelism",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(file_parallelism))
},
{
"batch_size",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(batch_size))
},
{
"compression_type",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(compression_type))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsReduceAll(EsbTensor *x, EsbTensor *axes, bool keep_dims) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(axes);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ReduceAll")
.Name(("ReduceAll_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"axes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"keep_dims",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keep_dims))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(axes->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsReduceAllD(EsbTensor *x, const int64_t *axes, int64_t axes_num, bool keep_dims) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ReduceAllD")
.Name(("ReduceAllD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axes",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(axes, axes + axes_num))
},
{
"keep_dims",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keep_dims))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsReduceAny(EsbTensor *x, EsbTensor *axes, bool keep_dims) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(axes);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ReduceAny")
.Name(("ReduceAny_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"axes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"keep_dims",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keep_dims))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(axes->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsReduceAnyD(EsbTensor *x, const int64_t *axes, int64_t axes_num, bool keep_dims) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ReduceAnyD")
.Name(("ReduceAnyD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axes",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(axes, axes + axes_num))
},
{
"keep_dims",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keep_dims))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsReduceJoin(EsbTensor *input, EsbTensor *reduction_indices, bool keep_dims, const char *separator) {
GE_ASSERT_NOTNULL(input);
GE_ASSERT_NOTNULL(reduction_indices);
auto &graph = input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ReduceJoin")
.Name(("ReduceJoin_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input", ge::kIrInputRequired, ""},
{"reduction_indices", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"keep_dims",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keep_dims))
},
{
"separator",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(separator))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(reduction_indices->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsReduceLogSum(EsbTensor *x, EsbTensor *axes, bool keep_dims) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(axes);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ReduceLogSum")
.Name(("ReduceLogSum_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"axes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"keep_dims",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keep_dims))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(axes->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsReduceLogSumExp(EsbTensor *x, EsbTensor *axes, bool keep_dims) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(axes);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ReduceLogSumExp")
.Name(("ReduceLogSumExp_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"axes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"keep_dims",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keep_dims))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(axes->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsReduceMax(EsbTensor *x, EsbTensor *axes, bool keep_dims) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(axes);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ReduceMax")
.Name(("ReduceMax_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"axes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"keep_dims",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keep_dims))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(axes->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsReduceMaxD(EsbTensor *x, const int64_t *axes, int64_t axes_num, bool keep_dims) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ReduceMaxD")
.Name(("ReduceMaxD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axes",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(axes, axes + axes_num))
},
{
"keep_dims",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keep_dims))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsReduceMean(EsbTensor *x, EsbTensor *axes, bool keep_dims, bool noop_with_empty_axes) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(axes);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ReduceMean")
.Name(("ReduceMean_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"axes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"keep_dims",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keep_dims))
},
{
"noop_with_empty_axes",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(noop_with_empty_axes))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(axes->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsReduceMeanD(EsbTensor *x, const int64_t *axes, int64_t axes_num, bool keep_dims, bool noop_with_empty_axes) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ReduceMeanD")
.Name(("ReduceMeanD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axes",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(axes, axes + axes_num))
},
{
"keep_dims",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keep_dims))
},
{
"noop_with_empty_axes",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(noop_with_empty_axes))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsReduceMeanVarianceOutput EsReduceMeanVariance(EsbTensor *x, const int64_t *axes, int64_t axes_num, bool keep_dims) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ReduceMeanVariance")
.Name(("ReduceMeanVariance_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"mean", ge::kIrOutputRequired, ""},
{"variance", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axes",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(axes, axes + axes_num))
},
{
"keep_dims",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keep_dims))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return EsReduceMeanVarianceOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsReduceMeanWithCount(EsbTensor *x, EsbTensor *count, EsbTensor *count_sum, const int64_t *axes, int64_t axes_num, bool keep_dims) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(count);
GE_ASSERT_NOTNULL(count_sum);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ReduceMeanWithCount")
.Name(("ReduceMeanWithCount_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"count", ge::kIrInputRequired, ""},
{"count_sum", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axes",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(axes, axes + axes_num))
},
{
"keep_dims",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keep_dims))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(count->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(count_sum->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsReduceMin(EsbTensor *x, EsbTensor *axes, bool keep_dims) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(axes);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ReduceMin")
.Name(("ReduceMin_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"axes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"keep_dims",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keep_dims))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(axes->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsReduceMinD(EsbTensor *x, const int64_t *axes, int64_t axes_num, bool keep_dims) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ReduceMinD")
.Name(("ReduceMinD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axes",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(axes, axes + axes_num))
},
{
"keep_dims",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keep_dims))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsReduceNansum(EsbTensor *x, EsbTensor *axes, bool keep_dims) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(axes);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ReduceNansum")
.Name(("ReduceNansum_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"axes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"keep_dims",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keep_dims))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(axes->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsReduceProd(EsbTensor *x, EsbTensor *axes, bool keep_dims) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(axes);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ReduceProd")
.Name(("ReduceProd_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"axes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"keep_dims",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keep_dims))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(axes->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsReduceProdD(EsbTensor *x, const int64_t *axes, int64_t axes_num, bool keep_dims) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ReduceProdD")
.Name(("ReduceProdD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axes",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(axes, axes + axes_num))
},
{
"keep_dims",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keep_dims))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsReduceStdOutput EsReduceStd(EsbTensor *x, const int64_t *dim, int64_t dim_num, bool unbiased, bool keepdim) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ReduceStd")
.Name(("ReduceStd_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y1", ge::kIrOutputRequired, ""},
{"y2", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dim",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dim, dim + dim_num))
},
{
"unbiased",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(unbiased))
},
{
"keepdim",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keepdim))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return EsReduceStdOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsReduceStdV2Update(EsbTensor *x, EsbTensor *mean, const int64_t *dim, int64_t dim_num, bool if_std, bool unbiased, bool keepdim, int64_t correction) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(mean);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ReduceStdV2Update")
.Name(("ReduceStdV2Update_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"mean", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dim",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dim, dim + dim_num))
},
{
"if_std",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(if_std))
},
{
"unbiased",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(unbiased))
},
{
"keepdim",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keepdim))
},
{
"correction",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(correction))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsReduceStdWithMean(EsbTensor *x, EsbTensor *mean, const int64_t *dim, int64_t dim_num, bool unbiased, bool keepdim, bool invert, float epsilon, int64_t correction) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(mean);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ReduceStdWithMean")
.Name(("ReduceStdWithMean_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"mean", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dim",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dim, dim + dim_num))
},
{
"unbiased",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(unbiased))
},
{
"keepdim",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keepdim))
},
{
"invert",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(invert))
},
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
{
"correction",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(correction))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsReduceSum(EsbTensor *x, EsbTensor *axes, bool keep_dims) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(axes);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ReduceSum")
.Name(("ReduceSum_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"axes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"keep_dims",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keep_dims))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(axes->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsReduceSumD(EsbTensor *x, const int64_t *axes, int64_t axes_num, bool keep_dims) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ReduceSumD")
.Name(("ReduceSumD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axes",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(axes, axes + axes_num))
},
{
"keep_dims",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keep_dims))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsReduction(EsbTensor *x, int64_t operation, int64_t axis, float coeff) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Reduction")
.Name(("Reduction_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"operation",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(operation))
},
{
"axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
{
"coeff",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(coeff))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRefEnter(EsbTensor *x, const char *frame_name, bool is_constant) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RefEnter")
.Name(("RefEnter_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"frame_name",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(frame_name))
},
{
"is_constant",
ge::kAttrRequired,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_constant))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRefExit(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RefExit")
.Name(("RefExit_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsRefMergeOutput EsRefMerge(EsbTensor **x, int64_t x_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RefMerge")
.Name(("RefMerge_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"value_index", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return EsRefMergeOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsRefNextIteration(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RefNextIteration")
.Name(("RefNextIteration_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsRefSwitchOutput EsRefSwitch(EsbTensor *data, EsbTensor *pred) {
GE_ASSERT_NOTNULL(data);
GE_ASSERT_NOTNULL(pred);
auto &graph = data->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RefSwitch")
.Name(("RefSwitch_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"data", ge::kIrInputRequired, ""},
{"pred", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_false", ge::kIrOutputRequired, ""},
{"output_true", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(data->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(pred->GetAnchor(), node->GetInDataAnchor(1)));
return EsRefSwitchOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsRegexFullMatch(EsbTensor *x, EsbTensor *pattern) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(pattern);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RegexFullMatch")
.Name(("RegexFullMatch_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"pattern", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(pattern->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRegexReplace(EsbTensor *x, EsbTensor *pattern, EsbTensor *rewrite, bool replace_global) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(pattern);
GE_ASSERT_NOTNULL(rewrite);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RegexReplace")
.Name(("RegexReplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"pattern", ge::kIrInputRequired, ""},
{"rewrite", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"replace_global",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(replace_global))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(pattern->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rewrite->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRelu(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Relu")
.Name(("Relu_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRelu6(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Relu6")
.Name(("Relu6_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRelu6D(EsbTensor *x, float scale) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Relu6D")
.Name(("Relu6D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"scale",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(scale))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRelu6Grad(EsbTensor *gradients, EsbTensor *features) {
GE_ASSERT_NOTNULL(gradients);
GE_ASSERT_NOTNULL(features);
auto &graph = gradients->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Relu6Grad")
.Name(("Relu6Grad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"gradients", ge::kIrInputRequired, ""},
{"features", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"backprops", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gradients->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(features->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsReluGrad(EsbTensor *gradients, EsbTensor *features) {
GE_ASSERT_NOTNULL(gradients);
GE_ASSERT_NOTNULL(features);
auto &graph = gradients->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ReluGrad")
.Name(("ReluGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"gradients", ge::kIrInputRequired, ""},
{"features", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"backprops", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gradients->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(features->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsReluGradV2(EsbTensor *gradients, EsbTensor *mask) {
GE_ASSERT_NOTNULL(gradients);
GE_ASSERT_NOTNULL(mask);
auto &graph = gradients->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ReluGradV2")
.Name(("ReluGradV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"gradients", ge::kIrInputRequired, ""},
{"mask", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"backprops", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gradients->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mask->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsReluV2Output EsReluV2(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ReluV2")
.Name(("ReluV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"mask", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return EsReluV2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsRemap(EsbTensor *img, EsbTensor *map_offset) {
GE_ASSERT_NOTNULL(img);
GE_ASSERT_NOTNULL(map_offset);
auto &graph = img->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Remap")
.Name(("Remap_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"img", ge::kIrInputRequired, ""},
{"map_offset", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"map_img", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(img->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(map_offset->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRenorm(EsbTensor *x, float p, int64_t dim, float maxnorm) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Renorm")
.Name(("Renorm_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"p",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(p))
},
{
"dim",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dim))
},
{
"maxnorm",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(maxnorm))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRepeatInterleave(EsbTensor *x, EsbTensor *repeats, int64_t axis) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(repeats);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RepeatInterleave")
.Name(("RepeatInterleave_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"repeats", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(repeats->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRepeatInterleaveGrad(EsbTensor *y_grad, EsbTensor *repeats, int64_t axis) {
GE_ASSERT_NOTNULL(y_grad);
GE_ASSERT_NOTNULL(repeats);
auto &graph = y_grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RepeatInterleaveGrad")
.Name(("RepeatInterleaveGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"y_grad", ge::kIrInputRequired, ""},
{"repeats", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"x_grad", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y_grad->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(repeats->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsReshape(EsbTensor *x, EsbTensor *shape, int64_t axis, int64_t num_axes) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(shape);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Reshape")
.Name(("Reshape_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"shape", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
{
"num_axes",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_axes))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsResize(EsbTensor *x, EsbTensor *roi, EsbTensor *scales, EsbTensor *sizes, const char *coordinate_transformation_mode, float cubic_coeff_a, int64_t exclude_outside, float extrapolation_value, const char *mode, const char *nearest_mode) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Resize")
.Name(("Resize_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"roi", ge::kIrInputOptional, ""},
{"scales", ge::kIrInputOptional, ""},
{"sizes", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"coordinate_transformation_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(coordinate_transformation_mode))
},
{
"cubic_coeff_a",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(cubic_coeff_a))
},
{
"exclude_outside",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(exclude_outside))
},
{
"extrapolation_value",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(extrapolation_value))
},
{
"mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(mode))
},
{
"nearest_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(nearest_mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
if (roi != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(roi->GetAnchor(), node->GetInDataAnchor(1)));
}
if (scales != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scales->GetAnchor(), node->GetInDataAnchor(2)));
}
if (sizes != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sizes->GetAnchor(), node->GetInDataAnchor(3)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsResizeAndClipPolysOutput EsResizeAndClipPolys(EsbTensor *polys_data, EsbTensor *polys_offset, EsbTensor *polys_size, EsbTensor *h_scale, EsbTensor *w_scale, EsbTensor *img_h, EsbTensor *img_w) {
GE_ASSERT_NOTNULL(polys_data);
GE_ASSERT_NOTNULL(polys_offset);
GE_ASSERT_NOTNULL(polys_size);
GE_ASSERT_NOTNULL(h_scale);
GE_ASSERT_NOTNULL(w_scale);
GE_ASSERT_NOTNULL(img_h);
GE_ASSERT_NOTNULL(img_w);
auto &graph = polys_data->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ResizeAndClipPolys")
.Name(("ResizeAndClipPolys_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"polys_data", ge::kIrInputRequired, ""},
{"polys_offset", ge::kIrInputRequired, ""},
{"polys_size", ge::kIrInputRequired, ""},
{"h_scale", ge::kIrInputRequired, ""},
{"w_scale", ge::kIrInputRequired, ""},
{"img_h", ge::kIrInputRequired, ""},
{"img_w", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"clipped_polys_data", ge::kIrOutputRequired, ""},
{"clipped_polys_offset", ge::kIrOutputRequired, ""},
{"clipped_polys_size", ge::kIrOutputRequired, ""},
{"clipped_polys_num", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(polys_data->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(polys_offset->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(polys_size->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(h_scale->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(w_scale->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(img_h->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(img_w->GetAnchor(), node->GetInDataAnchor(6)));
return EsResizeAndClipPolysOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsbTensor *EsResizeArea(EsbTensor *images, EsbTensor *size, bool align_corners) {
GE_ASSERT_NOTNULL(images);
GE_ASSERT_NOTNULL(size);
auto &graph = images->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ResizeArea")
.Name(("ResizeArea_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"images", ge::kIrInputRequired, ""},
{"size", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"align_corners",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(align_corners))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(images->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(size->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsResizeBicubic(EsbTensor *images, EsbTensor *size, bool align_corners, bool half_pixel_centers, ge::DataType dtype) {
GE_ASSERT_NOTNULL(images);
GE_ASSERT_NOTNULL(size);
auto &graph = images->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ResizeBicubic")
.Name(("ResizeBicubic_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"images", ge::kIrInputRequired, ""},
{"size", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"align_corners",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(align_corners))
},
{
"half_pixel_centers",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(half_pixel_centers))
},
{
"dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(images->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(size->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsResizeBicubicGrad(EsbTensor *grads, EsbTensor *original_image, bool align_corners, bool half_pixel_centers) {
GE_ASSERT_NOTNULL(grads);
GE_ASSERT_NOTNULL(original_image);
auto &graph = grads->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ResizeBicubicGrad")
.Name(("ResizeBicubicGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grads", ge::kIrInputRequired, ""},
{"original_image", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"align_corners",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(align_corners))
},
{
"half_pixel_centers",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(half_pixel_centers))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grads->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(original_image->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsResizeBilinearV2(EsbTensor *x, EsbTensor *size, bool align_corners, bool half_pixel_centers, ge::DataType dtype) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(size);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ResizeBilinearV2")
.Name(("ResizeBilinearV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"size", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"align_corners",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(align_corners))
},
{
"half_pixel_centers",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(half_pixel_centers))
},
{
"dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(size->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsResizeBilinearV2D(EsbTensor *x, const int64_t *size, int64_t size_num, bool align_corners, bool half_pixel_centers) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ResizeBilinearV2D")
.Name(("ResizeBilinearV2D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(size, size + size_num))
},
{
"align_corners",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(align_corners))
},
{
"half_pixel_centers",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(half_pixel_centers))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsResizeBilinearV2Grad(EsbTensor *grads, EsbTensor *original_image, bool align_corners, bool half_pixel_centers) {
GE_ASSERT_NOTNULL(grads);
GE_ASSERT_NOTNULL(original_image);
auto &graph = grads->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ResizeBilinearV2Grad")
.Name(("ResizeBilinearV2Grad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grads", ge::kIrInputRequired, ""},
{"original_image", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"align_corners",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(align_corners))
},
{
"half_pixel_centers",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(half_pixel_centers))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grads->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(original_image->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsResizeD(EsbTensor *x, const int64_t *sizes, int64_t sizes_num, const float *scales, int64_t scales_num, const int64_t *roi, int64_t roi_num, const char *coordinate_transformation_mode, float cubic_coeff_a, int64_t exclude_outside, float extrapolation_value, const char *mode, const char *nearest_mode, const char *data_format) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ResizeD")
.Name(("ResizeD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"sizes",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(sizes, sizes + sizes_num))
},
{
"scales",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(scales, scales + scales_num))
},
{
"roi",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(roi, roi + roi_num))
},
{
"coordinate_transformation_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(coordinate_transformation_mode))
},
{
"cubic_coeff_a",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(cubic_coeff_a))
},
{
"exclude_outside",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(exclude_outside))
},
{
"extrapolation_value",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(extrapolation_value))
},
{
"mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(mode))
},
{
"nearest_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(nearest_mode))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsResizeGrad(EsbTensor *grads, EsbTensor *roi, EsbTensor *scales, EsbTensor *original_size, const char *coordinate_transformation_mode, float cubic_coeff_a, int64_t exclude_outside, float extrapolation_value, const char *mode, const char *nearest_mode) {
GE_ASSERT_NOTNULL(grads);
GE_ASSERT_NOTNULL(original_size);
auto &graph = grads->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ResizeGrad")
.Name(("ResizeGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grads", ge::kIrInputRequired, ""},
{"roi", ge::kIrInputOptional, ""},
{"scales", ge::kIrInputOptional, ""},
{"original_size", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"coordinate_transformation_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(coordinate_transformation_mode))
},
{
"cubic_coeff_a",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(cubic_coeff_a))
},
{
"exclude_outside",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(exclude_outside))
},
{
"extrapolation_value",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(extrapolation_value))
},
{
"mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(mode))
},
{
"nearest_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(nearest_mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grads->GetAnchor(), node->GetInDataAnchor(0)));
if (roi != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(roi->GetAnchor(), node->GetInDataAnchor(1)));
}
if (scales != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scales->GetAnchor(), node->GetInDataAnchor(2)));
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(original_size->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsResizeGradD(EsbTensor *grads, const int64_t *original_size, int64_t original_size_num, const int64_t *roi, int64_t roi_num, const float *scales, int64_t scales_num, const char *coordinate_transformation_mode, float cubic_coeff_a, int64_t exclude_outside, float extrapolation_value, const char *mode, const char *nearest_mode, const char *data_format) {
GE_ASSERT_NOTNULL(grads);
auto &graph = grads->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ResizeGradD")
.Name(("ResizeGradD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grads", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"original_size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(original_size, original_size + original_size_num))
},
{
"roi",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(roi, roi + roi_num))
},
{
"scales",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(scales, scales + scales_num))
},
{
"coordinate_transformation_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(coordinate_transformation_mode))
},
{
"cubic_coeff_a",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(cubic_coeff_a))
},
{
"exclude_outside",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(exclude_outside))
},
{
"extrapolation_value",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(extrapolation_value))
},
{
"mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(mode))
},
{
"nearest_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(nearest_mode))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grads->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsResizeNearestNeighborV2(EsbTensor *x, EsbTensor *size, bool align_corners, bool half_pixel_centers) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(size);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ResizeNearestNeighborV2")
.Name(("ResizeNearestNeighborV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"size", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"align_corners",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(align_corners))
},
{
"half_pixel_centers",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(half_pixel_centers))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(size->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsResizeNearestNeighborV2D(EsbTensor *x, const int64_t *size, int64_t size_num, bool align_corners, bool half_pixel_centers) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ResizeNearestNeighborV2D")
.Name(("ResizeNearestNeighborV2D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(size, size + size_num))
},
{
"align_corners",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(align_corners))
},
{
"half_pixel_centers",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(half_pixel_centers))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsResizeNearestNeighborV2Grad(EsbTensor *grads, EsbTensor *size, bool align_corners, bool half_pixel_centers) {
GE_ASSERT_NOTNULL(grads);
GE_ASSERT_NOTNULL(size);
auto &graph = grads->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ResizeNearestNeighborV2Grad")
.Name(("ResizeNearestNeighborV2Grad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grads", ge::kIrInputRequired, ""},
{"size", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"align_corners",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(align_corners))
},
{
"half_pixel_centers",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(half_pixel_centers))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grads->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(size->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsResizeNearestNeighborV2GradD(EsbTensor *grads, const int64_t *size, int64_t size_num, bool align_corners, bool half_pixel_centers) {
GE_ASSERT_NOTNULL(grads);
auto &graph = grads->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ResizeNearestNeighborV2GradD")
.Name(("ResizeNearestNeighborV2GradD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grads", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(size, size + size_num))
},
{
"align_corners",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(align_corners))
},
{
"half_pixel_centers",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(half_pixel_centers))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grads->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsResizeTrilinear(EsbTensor *x, EsbTensor *size, bool align_corners, bool half_pixel_centers) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(size);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ResizeTrilinear")
.Name(("ResizeTrilinear_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"size", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"align_corners",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(align_corners))
},
{
"half_pixel_centers",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(half_pixel_centers))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(size->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsResizeV2(EsbTensor *x, EsbTensor *dst_size, const char *interpolation, const char *data_format) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(dst_size);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ResizeV2")
.Name(("ResizeV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"dst_size", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"interpolation",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(interpolation))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dst_size->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsResourceAccumulatorApplyGradient(EsbTensor *handle, EsbTensor *local_step, EsbTensor *gradient) {
GE_ASSERT_NOTNULL(handle);
GE_ASSERT_NOTNULL(local_step);
GE_ASSERT_NOTNULL(gradient);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ResourceAccumulatorApplyGradient")
.Name(("ResourceAccumulatorApplyGradient_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
{"local_step", ge::kIrInputRequired, ""},
{"gradient", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(local_step->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gradient->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsResourceAccumulatorNumAccumulated(EsbTensor *handle) {
GE_ASSERT_NOTNULL(handle);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ResourceAccumulatorNumAccumulated")
.Name(("ResourceAccumulatorNumAccumulated_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"num_accumulated", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsResourceAccumulatorSetGlobalStep(EsbTensor *handle, EsbTensor *new_global_step) {
GE_ASSERT_NOTNULL(handle);
GE_ASSERT_NOTNULL(new_global_step);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ResourceAccumulatorSetGlobalStep")
.Name(("ResourceAccumulatorSetGlobalStep_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
{"new_global_step", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(new_global_step->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsResourceAccumulatorTakeGradient(EsbTensor *handle, EsbTensor *num_required, ge::DataType dtype) {
GE_ASSERT_NOTNULL(handle);
GE_ASSERT_NOTNULL(num_required);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ResourceAccumulatorTakeGradient")
.Name(("ResourceAccumulatorTakeGradient_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
{"num_required", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"average", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(num_required->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsResourceConditionalAccumulator(EsbGraph *owner_graph, ge::DataType dtype, const int64_t *shape, int64_t shape_num, const char *container, const char *shared_name, const char *reduction_type) {
GE_ASSERT_NOTNULL(owner_graph);
EsbGraph &graph = *owner_graph;

auto desc = ge::CompliantOpDescBuilder().OpType("ResourceConditionalAccumulator")
.Name(("ResourceConditionalAccumulator_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
})
.IrDefOutputs({
{"handle", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
{
"shape",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(shape, shape + shape_num))
},
{
"container",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(container))
},
{
"shared_name",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(shared_name))
},
{
"reduction_type",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduction_type))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsReverseSequence(EsbTensor *x, EsbTensor *seq_lengths, int64_t seq_dim, int64_t batch_dim) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(seq_lengths);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ReverseSequence")
.Name(("ReverseSequence_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"seq_lengths", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"seq_dim",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seq_dim))
},
{
"batch_dim",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(batch_dim))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seq_lengths->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsReverseV2(EsbTensor *x, EsbTensor *axis) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(axis);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ReverseV2")
.Name(("ReverseV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"axis", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(axis->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsReverseV2D(EsbTensor *x, const int64_t *axis, int64_t axis_num) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ReverseV2D")
.Name(("ReverseV2D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(axis, axis + axis_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRgbToGrayscale(EsbTensor *images, const char *data_format, int64_t output_channels) {
GE_ASSERT_NOTNULL(images);
auto &graph = images->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RgbToGrayscale")
.Name(("RgbToGrayscale_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"images", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
{
"output_channels",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(output_channels))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(images->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRightShift(EsbTensor *x, EsbTensor *y) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(y);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RightShift")
.Name(("RightShift_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"y", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"z", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsRingAttentionUpdateOutput EsRingAttentionUpdate(EsbTensor *prev_attn_out, EsbTensor *prev_softmax_max, EsbTensor *prev_softmax_sum, EsbTensor *cur_attn_out, EsbTensor *cur_softmax_max, EsbTensor *cur_softmax_sum, EsbTensor *actual_seq_qlen, const char *input_layout) {
GE_ASSERT_NOTNULL(prev_attn_out);
GE_ASSERT_NOTNULL(prev_softmax_max);
GE_ASSERT_NOTNULL(prev_softmax_sum);
GE_ASSERT_NOTNULL(cur_attn_out);
GE_ASSERT_NOTNULL(cur_softmax_max);
GE_ASSERT_NOTNULL(cur_softmax_sum);
auto &graph = prev_attn_out->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RingAttentionUpdate")
.Name(("RingAttentionUpdate_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"prev_attn_out", ge::kIrInputRequired, ""},
{"prev_softmax_max", ge::kIrInputRequired, ""},
{"prev_softmax_sum", ge::kIrInputRequired, ""},
{"cur_attn_out", ge::kIrInputRequired, ""},
{"cur_softmax_max", ge::kIrInputRequired, ""},
{"cur_softmax_sum", ge::kIrInputRequired, ""},
{"actual_seq_qlen", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"attn_out", ge::kIrOutputRequired, ""},
{"softmax_max", ge::kIrOutputRequired, ""},
{"softmax_sum", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"input_layout",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(input_layout))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(prev_attn_out->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(prev_softmax_max->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(prev_softmax_sum->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(cur_attn_out->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(cur_softmax_max->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(cur_softmax_sum->GetAnchor(), node->GetInDataAnchor(5)));
if (actual_seq_qlen != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(actual_seq_qlen->GetAnchor(), node->GetInDataAnchor(6)));
}
return EsRingAttentionUpdateOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsRint(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Rint")
.Name(("Rint_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsRmsNormOutput EsRmsNorm(EsbTensor *x, EsbTensor *gamma, float epsilon) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(gamma);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RmsNorm")
.Name(("RmsNorm_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"rstd", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(1)));
return EsRmsNormOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsRmsNormGradOutput EsRmsNormGrad(EsbTensor *dy, EsbTensor *x, EsbTensor *rstd, EsbTensor *gamma) {
GE_ASSERT_NOTNULL(dy);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(rstd);
GE_ASSERT_NOTNULL(gamma);
auto &graph = dy->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RmsNormGrad")
.Name(("RmsNormGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"dy", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"rstd", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"dx", ge::kIrOutputRequired, ""},
{"dgamma", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rstd->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(3)));
return EsRmsNormGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsRngReadAndSkipV2(EsbTensor *value, EsbTensor *algorithm, EsbTensor *delta) {
GE_ASSERT_NOTNULL(value);
GE_ASSERT_NOTNULL(algorithm);
GE_ASSERT_NOTNULL(delta);
auto &graph = value->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RngReadAndSkipV2")
.Name(("RngReadAndSkipV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"value", ge::kIrInputRequired, ""},
{"algorithm", ge::kIrInputRequired, ""},
{"delta", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"value", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(algorithm->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(delta->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRngSkip(EsbTensor *x, EsbTensor *algorithm, EsbTensor *delta) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(algorithm);
GE_ASSERT_NOTNULL(delta);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RngSkip")
.Name(("RngSkip_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"algorithm", ge::kIrInputRequired, ""},
{"delta", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(algorithm->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(delta->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsRnnGenMask(EsbTensor *seq_length, int64_t num_step, int64_t hidden_size) {
GE_ASSERT_NOTNULL(seq_length);
auto &graph = seq_length->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RnnGenMask")
.Name(("RnnGenMask_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"seq_length", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"seq_mask", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_step",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_step))
},
{
"hidden_size",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(hidden_size))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seq_length->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRnnGenMaskV2(EsbTensor *seq_length, EsbTensor *x, int64_t hidden_size) {
GE_ASSERT_NOTNULL(seq_length);
GE_ASSERT_NOTNULL(x);
auto &graph = seq_length->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RnnGenMaskV2")
.Name(("RnnGenMaskV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"seq_length", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"seq_mask", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"hidden_size",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(hidden_size))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seq_length->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRoiAlignRotatedGrad(EsbTensor *x_grad, EsbTensor *rois, const int64_t *y_grad_shape, int64_t y_grad_shape_num, int64_t pooled_h, int64_t pooled_w, float spatial_scale, int64_t sampling_ratio, bool aligned, bool clockwise) {
GE_ASSERT_NOTNULL(x_grad);
GE_ASSERT_NOTNULL(rois);
auto &graph = x_grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RoiAlignRotatedGrad")
.Name(("RoiAlignRotatedGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x_grad", ge::kIrInputRequired, ""},
{"rois", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y_grad", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"y_grad_shape",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(y_grad_shape, y_grad_shape + y_grad_shape_num))
},
{
"pooled_h",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pooled_h))
},
{
"pooled_w",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pooled_w))
},
{
"spatial_scale",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(spatial_scale))
},
{
"sampling_ratio",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(sampling_ratio))
},
{
"aligned",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(aligned))
},
{
"clockwise",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(clockwise))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x_grad->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rois->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRoiExtractor(EsbTensor **features, int64_t features_num, EsbTensor *rois, EsbTensor *index, int64_t finest_scale, float roi_scale_factor, const float *spatial_scale, int64_t spatial_scale_num, int64_t pooled_height, int64_t pooled_width, int64_t sample_num, const char *pool_mode, bool aligned) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(features_num));
GE_ASSERT_NOTNULL(rois);
auto &graph = rois->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RoiExtractor")
.Name(("RoiExtractor_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"features", ge::kIrInputDynamic, ""},
{"rois", ge::kIrInputRequired, ""},
{"index", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"finest_scale",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(finest_scale))
},
{
"roi_scale_factor",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(roi_scale_factor))
},
{
"spatial_scale",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(spatial_scale, spatial_scale + spatial_scale_num))
},
{
"pooled_height",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pooled_height))
},
{
"pooled_width",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pooled_width))
},
{
"sample_num",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(sample_num))
},
{
"pool_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(pool_mode))
},
{
"aligned",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(aligned))
},
})
.InstanceDynamicInputNum("features", static_cast<int32_t>(features_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((features != nullptr) && (features_num > 0)) {
for (int64_t i = 0; i < features_num; ++i) {
auto one_features = features[i];
GE_ASSERT_NOTNULL(one_features);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_features->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rois->GetAnchor(), node->GetInDataAnchor(0 + features_num)));
if (index != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(index->GetAnchor(), node->GetInDataAnchor(1 + features_num)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRoiPoolingGradWithArgMax(EsbTensor *grad, EsbTensor *x, EsbTensor *rois, EsbTensor *roi_actual_num, EsbTensor *argmax, int64_t pooled_h, int64_t pooled_w, float spatial_scale_h, float spatial_scale_w, int64_t pool_channel) {
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(rois);
GE_ASSERT_NOTNULL(argmax);
auto &graph = grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RoiPoolingGradWithArgMax")
.Name(("RoiPoolingGradWithArgMax_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grad", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"rois", ge::kIrInputRequired, ""},
{"roi_actual_num", ge::kIrInputOptional, ""},
{"argmax", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"pooled_h",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pooled_h))
},
{
"pooled_w",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pooled_w))
},
{
"spatial_scale_h",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(spatial_scale_h))
},
{
"spatial_scale_w",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(spatial_scale_w))
},
{
"pool_channel",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pool_channel))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rois->GetAnchor(), node->GetInDataAnchor(2)));
if (roi_actual_num != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(roi_actual_num->GetAnchor(), node->GetInDataAnchor(3)));
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(argmax->GetAnchor(), node->GetInDataAnchor(4)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsRoiPoolingWithArgMaxOutput EsRoiPoolingWithArgMax(EsbTensor *x, EsbTensor *rois, EsbTensor *roi_actual_num, int64_t pooled_h, int64_t pooled_w, float spatial_scale_h, float spatial_scale_w, int64_t pool_channel) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(rois);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RoiPoolingWithArgMax")
.Name(("RoiPoolingWithArgMax_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"rois", ge::kIrInputRequired, ""},
{"roi_actual_num", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"argmax", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"pooled_h",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pooled_h))
},
{
"pooled_w",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pooled_w))
},
{
"spatial_scale_h",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(spatial_scale_h))
},
{
"spatial_scale_w",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(spatial_scale_w))
},
{
"pool_channel",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pool_channel))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rois->GetAnchor(), node->GetInDataAnchor(1)));
if (roi_actual_num != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(roi_actual_num->GetAnchor(), node->GetInDataAnchor(2)));
}
return EsRoiPoolingWithArgMaxOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsRoll(EsbTensor *x, const int64_t *shifts, int64_t shifts_num, const int64_t *dims, int64_t dims_num) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Roll")
.Name(("Roll_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"shifts",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(shifts, shifts + shifts_num))
},
{
"dims",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(dims, dims + dims_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRollV2(EsbTensor *input, EsbTensor *shift, EsbTensor *axes) {
GE_ASSERT_NOTNULL(input);
GE_ASSERT_NOTNULL(shift);
GE_ASSERT_NOTNULL(axes);
auto &graph = input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RollV2")
.Name(("RollV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input", ge::kIrInputRequired, ""},
{"shift", ge::kIrInputRequired, ""},
{"axes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shift->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(axes->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsRopeQuantKvcacheOutput EsRopeQuantKvcache(EsbTensor *qkv, EsbTensor *cos, EsbTensor *sin, EsbTensor *quant_scale, EsbTensor *quant_offset, EsbTensor *k_cache, EsbTensor *v_cache, EsbTensor *indice, const int64_t *size_splits, int64_t size_splits_num, const char *layout, bool kv_output) {
GE_ASSERT_NOTNULL(qkv);
GE_ASSERT_NOTNULL(cos);
GE_ASSERT_NOTNULL(sin);
GE_ASSERT_NOTNULL(quant_scale);
GE_ASSERT_NOTNULL(quant_offset);
GE_ASSERT_NOTNULL(k_cache);
GE_ASSERT_NOTNULL(v_cache);
GE_ASSERT_NOTNULL(indice);
auto &graph = qkv->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RopeQuantKvcache")
.Name(("RopeQuantKvcache_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"qkv", ge::kIrInputRequired, ""},
{"cos", ge::kIrInputRequired, ""},
{"sin", ge::kIrInputRequired, ""},
{"quant_scale", ge::kIrInputRequired, ""},
{"quant_offset", ge::kIrInputRequired, ""},
{"k_cache", ge::kIrInputRequired, ""},
{"v_cache", ge::kIrInputRequired, ""},
{"indice", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"q", ge::kIrOutputRequired, ""},
{"k", ge::kIrOutputRequired, ""},
{"v", ge::kIrOutputRequired, ""},
{"k_cache", ge::kIrOutputRequired, ""},
{"v_cache", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"size_splits",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(size_splits, size_splits + size_splits_num))
},
{
"layout",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(layout))
},
{
"kv_output",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(kv_output))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(qkv->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(cos->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sin->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(quant_scale->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(quant_offset->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(k_cache->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(v_cache->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indice->GetAnchor(), node->GetInDataAnchor(7)));
return EsRopeQuantKvcacheOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
};
}
EsbTensor *EsRotaryMul(EsbTensor *x, EsbTensor *r1, EsbTensor *r2) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(r1);
GE_ASSERT_NOTNULL(r2);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RotaryMul")
.Name(("RotaryMul_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"r1", ge::kIrInputRequired, ""},
{"r2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(r1->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(r2->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsRotaryMulGradOutput EsRotaryMulGrad(EsbTensor *x, EsbTensor *r1, EsbTensor *r2, EsbTensor *dy, bool need_backward) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(r1);
GE_ASSERT_NOTNULL(r2);
GE_ASSERT_NOTNULL(dy);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RotaryMulGrad")
.Name(("RotaryMulGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"r1", ge::kIrInputRequired, ""},
{"r2", ge::kIrInputRequired, ""},
{"dy", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"dx", ge::kIrOutputRequired, ""},
{"dr1", ge::kIrOutputRequired, ""},
{"dr2", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"need_backward",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(need_backward))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(r1->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(r2->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(3)));
return EsRotaryMulGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsRotaryPositionEmbedding(EsbTensor *x, EsbTensor *cos, EsbTensor *sin, int64_t mode) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(cos);
GE_ASSERT_NOTNULL(sin);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RotaryPositionEmbedding")
.Name(("RotaryPositionEmbedding_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"cos", ge::kIrInputRequired, ""},
{"sin", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"mode",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(cos->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sin->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsRotaryPositionEmbeddingGradOutput EsRotaryPositionEmbeddingGrad(EsbTensor *dy, EsbTensor *cos, EsbTensor *sin, EsbTensor *x, int64_t mode) {
GE_ASSERT_NOTNULL(dy);
GE_ASSERT_NOTNULL(cos);
GE_ASSERT_NOTNULL(sin);
auto &graph = dy->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RotaryPositionEmbeddingGrad")
.Name(("RotaryPositionEmbeddingGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"dy", ge::kIrInputRequired, ""},
{"cos", ge::kIrInputRequired, ""},
{"sin", ge::kIrInputRequired, ""},
{"x", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"dx", ge::kIrOutputRequired, ""},
{"dcos", ge::kIrOutputRequired, ""},
{"dsin", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"mode",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(cos->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sin->GetAnchor(), node->GetInDataAnchor(2)));
if (x != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(3)));
}
return EsRotaryPositionEmbeddingGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsRotate(EsbTensor *x, float angle, const int64_t *center, int64_t center_num, bool expand, const char *interpolation, const char *padding_mode, float padding_value, const char *data_format) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Rotate")
.Name(("Rotate_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"angle",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(angle))
},
{
"center",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(center, center + center_num))
},
{
"expand",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(expand))
},
{
"interpolation",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(interpolation))
},
{
"padding_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(padding_mode))
},
{
"padding_value",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(padding_value))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRotatedBoxDecode(EsbTensor *anchor_box, EsbTensor *deltas, const float *weight, int64_t weight_num) {
GE_ASSERT_NOTNULL(anchor_box);
GE_ASSERT_NOTNULL(deltas);
auto &graph = anchor_box->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RotatedBoxDecode")
.Name(("RotatedBoxDecode_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"anchor_box", ge::kIrInputRequired, ""},
{"deltas", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"weight",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(weight, weight + weight_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(anchor_box->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(deltas->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRotatedBoxEncode(EsbTensor *anchor_box, EsbTensor *gt_box, const float *weight, int64_t weight_num) {
GE_ASSERT_NOTNULL(anchor_box);
GE_ASSERT_NOTNULL(gt_box);
auto &graph = anchor_box->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RotatedBoxEncode")
.Name(("RotatedBoxEncode_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"anchor_box", ge::kIrInputRequired, ""},
{"gt_box", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"weight",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(weight, weight + weight_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(anchor_box->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gt_box->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRotatedFeatureAlign(EsbTensor *x, EsbTensor *bboxes, float spatial_scale, int64_t points) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(bboxes);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RotatedFeatureAlign")
.Name(("RotatedFeatureAlign_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"bboxes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"spatial_scale",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(spatial_scale))
},
{
"points",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(points))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bboxes->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRotatedFeatureAlignGrad(EsbTensor *dy, EsbTensor *bboxes, float spatial_scale, int64_t points) {
GE_ASSERT_NOTNULL(dy);
GE_ASSERT_NOTNULL(bboxes);
auto &graph = dy->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RotatedFeatureAlignGrad")
.Name(("RotatedFeatureAlignGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"dy", ge::kIrInputRequired, ""},
{"bboxes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"dx", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"spatial_scale",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(spatial_scale))
},
{
"points",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(points))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bboxes->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRotatedIou(EsbTensor *boxes, EsbTensor *query_boxes, bool trans, const char *mode, bool is_cross, float v_threshold, float e_threshold) {
GE_ASSERT_NOTNULL(boxes);
GE_ASSERT_NOTNULL(query_boxes);
auto &graph = boxes->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RotatedIou")
.Name(("RotatedIou_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"boxes", ge::kIrInputRequired, ""},
{"query_boxes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"iou", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"trans",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(trans))
},
{
"mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(mode))
},
{
"is_cross",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_cross))
},
{
"v_threshold",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(v_threshold))
},
{
"e_threshold",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(e_threshold))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(boxes->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(query_boxes->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsRotatedNMSOutput EsRotatedNMS(EsbTensor *boxes, EsbTensor *scores, EsbTensor *labels, float iou_threshold, bool is_angle) {
GE_ASSERT_NOTNULL(boxes);
GE_ASSERT_NOTNULL(scores);
GE_ASSERT_NOTNULL(labels);
auto &graph = boxes->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RotatedNMS")
.Name(("RotatedNMS_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"boxes", ge::kIrInputRequired, ""},
{"scores", ge::kIrInputRequired, ""},
{"labels", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"selected_detections", ge::kIrOutputRequired, ""},
{"keep_indices", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"iou_threshold",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(iou_threshold))
},
{
"is_angle",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_angle))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(boxes->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scores->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(labels->GetAnchor(), node->GetInDataAnchor(2)));
return EsRotatedNMSOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsRotatedOverlaps(EsbTensor *boxes, EsbTensor *query_boxes, bool trans) {
GE_ASSERT_NOTNULL(boxes);
GE_ASSERT_NOTNULL(query_boxes);
auto &graph = boxes->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RotatedOverlaps")
.Name(("RotatedOverlaps_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"boxes", ge::kIrInputRequired, ""},
{"query_boxes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"overlaps", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"trans",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(trans))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(boxes->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(query_boxes->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRound(EsbTensor *x, int64_t decimals) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Round")
.Name(("Round_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"decimals",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(decimals))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRpnProposalPostProcessing(EsbTensor *sorted_proposal, EsbTensor *proposal_num, const int64_t *img_size, int64_t img_size_num, float score_threshold, int64_t k, float min_size, float nms_threshold, int64_t post_nms_num, bool box_filter, int64_t core_max_num) {
GE_ASSERT_NOTNULL(sorted_proposal);
GE_ASSERT_NOTNULL(proposal_num);
auto &graph = sorted_proposal->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RpnProposalPostProcessing")
.Name(("RpnProposalPostProcessing_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"sorted_proposal", ge::kIrInputRequired, ""},
{"proposal_num", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"sorted_box", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"img_size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(img_size, img_size + img_size_num))
},
{
"score_threshold",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(score_threshold))
},
{
"k",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(k))
},
{
"min_size",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(min_size))
},
{
"nms_threshold",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(nms_threshold))
},
{
"post_nms_num",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(post_nms_num))
},
{
"box_filter",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(box_filter))
},
{
"core_max_num",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(core_max_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sorted_proposal->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(proposal_num->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRpnProposals(EsbTensor *rois, EsbTensor *cls_bg_prob, EsbTensor *img_size, float score_threshold, int64_t k, float min_size, float nms_threshold, int64_t post_nms_num, bool score_filter, bool box_filter, bool score_sigmoid) {
GE_ASSERT_NOTNULL(rois);
GE_ASSERT_NOTNULL(cls_bg_prob);
GE_ASSERT_NOTNULL(img_size);
auto &graph = rois->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RpnProposals")
.Name(("RpnProposals_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"rois", ge::kIrInputRequired, ""},
{"cls_bg_prob", ge::kIrInputRequired, ""},
{"img_size", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"sorted_box", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"score_threshold",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(score_threshold))
},
{
"k",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(k))
},
{
"min_size",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(min_size))
},
{
"nms_threshold",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(nms_threshold))
},
{
"post_nms_num",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(post_nms_num))
},
{
"score_filter",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(score_filter))
},
{
"box_filter",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(box_filter))
},
{
"score_sigmoid",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(score_sigmoid))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rois->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(cls_bg_prob->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(img_size->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRpnProposalsD(EsbTensor *rois, EsbTensor *cls_bg_prob, const int64_t *img_size, int64_t img_size_num, float score_threshold, int64_t k, float min_size, float nms_threshold, int64_t post_nms_num, bool score_filter, bool box_filter, bool score_sigmoid) {
GE_ASSERT_NOTNULL(rois);
GE_ASSERT_NOTNULL(cls_bg_prob);
auto &graph = rois->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RpnProposalsD")
.Name(("RpnProposalsD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"rois", ge::kIrInputRequired, ""},
{"cls_bg_prob", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"sorted_box", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"img_size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(img_size, img_size + img_size_num))
},
{
"score_threshold",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(score_threshold))
},
{
"k",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(k))
},
{
"min_size",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(min_size))
},
{
"nms_threshold",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(nms_threshold))
},
{
"post_nms_num",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(post_nms_num))
},
{
"score_filter",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(score_filter))
},
{
"box_filter",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(box_filter))
},
{
"score_sigmoid",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(score_sigmoid))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rois->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(cls_bg_prob->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRsqrt(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Rsqrt")
.Name(("Rsqrt_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsRsqrtGrad(EsbTensor *y, EsbTensor *dy) {
GE_ASSERT_NOTNULL(y);
GE_ASSERT_NOTNULL(dy);
auto &graph = y->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("RsqrtGrad")
.Name(("RsqrtGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"y", ge::kIrInputRequired, ""},
{"dy", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"z", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSGD(EsbTensor *parameters, EsbTensor *gradient, EsbTensor *learning_rate, EsbTensor *accum, EsbTensor *momentum, EsbTensor *stat, float dampening, float weight_decay, bool nesterov) {
GE_ASSERT_NOTNULL(parameters);
GE_ASSERT_NOTNULL(gradient);
GE_ASSERT_NOTNULL(learning_rate);
GE_ASSERT_NOTNULL(accum);
GE_ASSERT_NOTNULL(momentum);
GE_ASSERT_NOTNULL(stat);
auto &graph = parameters->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SGD")
.Name(("SGD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"parameters", ge::kIrInputRequired, ""},
{"gradient", ge::kIrInputRequired, ""},
{"learning_rate", ge::kIrInputRequired, ""},
{"accum", ge::kIrInputRequired, ""},
{"momentum", ge::kIrInputRequired, ""},
{"stat", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"parameters", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dampening",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(dampening))
},
{
"weight_decay",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(weight_decay))
},
{
"nesterov",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(nesterov))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(parameters->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gradient->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(learning_rate->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(momentum->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(stat->GetAnchor(), node->GetInDataAnchor(5)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSPP(EsbTensor *x, int64_t pyramid_height, int64_t pool_method) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SPP")
.Name(("SPP_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"pyramid_height",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pyramid_height))
},
{
"pool_method",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pool_method))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsSSDDetectionOutputOutput EsSSDDetectionOutput(EsbTensor *bbox_delta, EsbTensor *score, EsbTensor *anchors, int64_t num_classes, bool share_location, int64_t background_label_id, float iou_threshold, int64_t top_k, float eta, bool variance_encoded_in_target, int64_t code_type, int64_t keep_top_k, float confidence_threshold) {
GE_ASSERT_NOTNULL(bbox_delta);
GE_ASSERT_NOTNULL(score);
GE_ASSERT_NOTNULL(anchors);
auto &graph = bbox_delta->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SSDDetectionOutput")
.Name(("SSDDetectionOutput_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"bbox_delta", ge::kIrInputRequired, ""},
{"score", ge::kIrInputRequired, ""},
{"anchors", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"out_boxnum", ge::kIrOutputRequired, ""},
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_classes",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_classes))
},
{
"share_location",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(share_location))
},
{
"background_label_id",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(background_label_id))
},
{
"iou_threshold",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(iou_threshold))
},
{
"top_k",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(top_k))
},
{
"eta",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(eta))
},
{
"variance_encoded_in_target",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(variance_encoded_in_target))
},
{
"code_type",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(code_type))
},
{
"keep_top_k",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(keep_top_k))
},
{
"confidence_threshold",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(confidence_threshold))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bbox_delta->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(score->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(anchors->GetAnchor(), node->GetInDataAnchor(2)));
return EsSSDDetectionOutputOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsSTFT(EsbTensor *x, EsbTensor *window, int64_t n_fft, int64_t hop_length, int64_t win_length, bool normalized, bool onesided, bool return_complex) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("STFT")
.Name(("STFT_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"window", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"n_fft",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(n_fft))
},
{
"hop_length",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(hop_length))
},
{
"win_length",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(win_length))
},
{
"normalized",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(normalized))
},
{
"onesided",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(onesided))
},
{
"return_complex",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(return_complex))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
if (window != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(window->GetAnchor(), node->GetInDataAnchor(1)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsSampleDistortedBoundingBoxOutput EsSampleDistortedBoundingBox(EsbTensor *image_size, EsbTensor *bounding_boxes, int64_t seed, int64_t seed2, float min_object_covered, const float *aspect_ratio_range, int64_t aspect_ratio_range_num, const float *area_range, int64_t area_range_num, int64_t max_attempts, bool use_image_if_no_bounding_boxes) {
GE_ASSERT_NOTNULL(image_size);
GE_ASSERT_NOTNULL(bounding_boxes);
auto &graph = image_size->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SampleDistortedBoundingBox")
.Name(("SampleDistortedBoundingBox_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"image_size", ge::kIrInputRequired, ""},
{"bounding_boxes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"begin", ge::kIrOutputRequired, ""},
{"size", ge::kIrOutputRequired, ""},
{"bboxes", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"seed",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed))
},
{
"seed2",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed2))
},
{
"min_object_covered",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(min_object_covered))
},
{
"aspect_ratio_range",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(aspect_ratio_range, aspect_ratio_range + aspect_ratio_range_num))
},
{
"area_range",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(area_range, area_range + area_range_num))
},
{
"max_attempts",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(max_attempts))
},
{
"use_image_if_no_bounding_boxes",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_image_if_no_bounding_boxes))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(image_size->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bounding_boxes->GetAnchor(), node->GetInDataAnchor(1)));
return EsSampleDistortedBoundingBoxOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsSampleDistortedBoundingBoxExt2Output EsSampleDistortedBoundingBoxExt2(EsbTensor *image_size, EsbTensor *bounding_boxes, EsbTensor *min_object_covered, int64_t seed, int64_t seed2, const float *aspect_ratio_range, int64_t aspect_ratio_range_num, const float *area_range, int64_t area_range_num, int64_t max_attempts, bool use_image_if_no_bounding_boxes) {
GE_ASSERT_NOTNULL(image_size);
GE_ASSERT_NOTNULL(bounding_boxes);
GE_ASSERT_NOTNULL(min_object_covered);
auto &graph = image_size->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SampleDistortedBoundingBoxExt2")
.Name(("SampleDistortedBoundingBoxExt2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"image_size", ge::kIrInputRequired, ""},
{"bounding_boxes", ge::kIrInputRequired, ""},
{"min_object_covered", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"begin", ge::kIrOutputRequired, ""},
{"size", ge::kIrOutputRequired, ""},
{"bboxes", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"seed",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed))
},
{
"seed2",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed2))
},
{
"aspect_ratio_range",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(aspect_ratio_range, aspect_ratio_range + aspect_ratio_range_num))
},
{
"area_range",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(area_range, area_range + area_range_num))
},
{
"max_attempts",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(max_attempts))
},
{
"use_image_if_no_bounding_boxes",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_image_if_no_bounding_boxes))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(image_size->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bounding_boxes->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(min_object_covered->GetAnchor(), node->GetInDataAnchor(2)));
return EsSampleDistortedBoundingBoxExt2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsScale(EsbTensor *x, EsbTensor *scale, EsbTensor *bias, int64_t axis, int64_t num_axes, bool scale_from_blob) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(scale);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Scale")
.Name(("Scale_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"scale", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
{
"num_axes",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_axes))
},
{
"scale_from_blob",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(scale_from_blob))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(1)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(2)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsScaleAndTranslate(EsbTensor *images, EsbTensor *size, EsbTensor *scale, EsbTensor *translation, const char *kernel_type, bool antialias) {
GE_ASSERT_NOTNULL(images);
GE_ASSERT_NOTNULL(size);
GE_ASSERT_NOTNULL(scale);
GE_ASSERT_NOTNULL(translation);
auto &graph = images->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ScaleAndTranslate")
.Name(("ScaleAndTranslate_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"images", ge::kIrInputRequired, ""},
{"size", ge::kIrInputRequired, ""},
{"scale", ge::kIrInputRequired, ""},
{"translation", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"kernel_type",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(kernel_type))
},
{
"antialias",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(antialias))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(images->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(size->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(translation->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsScaleAndTranslateGrad(EsbTensor *grads, EsbTensor *original_image, EsbTensor *scale, EsbTensor *translation, const char *kernel_type, bool antialias) {
GE_ASSERT_NOTNULL(grads);
GE_ASSERT_NOTNULL(original_image);
GE_ASSERT_NOTNULL(scale);
GE_ASSERT_NOTNULL(translation);
auto &graph = grads->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ScaleAndTranslateGrad")
.Name(("ScaleAndTranslateGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grads", ge::kIrInputRequired, ""},
{"original_image", ge::kIrInputRequired, ""},
{"scale", ge::kIrInputRequired, ""},
{"translation", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"kernel_type",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(kernel_type))
},
{
"antialias",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(antialias))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grads->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(original_image->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(translation->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsScaledMaskedSoftmax(EsbTensor *x, EsbTensor *mask, float scale, bool fixed_triu_mask) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ScaledMaskedSoftmax")
.Name(("ScaledMaskedSoftmax_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"mask", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"scale",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(scale))
},
{
"fixed_triu_mask",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(fixed_triu_mask))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
if (mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mask->GetAnchor(), node->GetInDataAnchor(1)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsScaledMaskedSoftmaxGrad(EsbTensor *y_grad, EsbTensor *y, EsbTensor *mask, float scale, bool fixed_triu_mask) {
GE_ASSERT_NOTNULL(y_grad);
GE_ASSERT_NOTNULL(y);
auto &graph = y_grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ScaledMaskedSoftmaxGrad")
.Name(("ScaledMaskedSoftmaxGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"y_grad", ge::kIrInputRequired, ""},
{"y", ge::kIrInputRequired, ""},
{"mask", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"x_grad", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"scale",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(scale))
},
{
"fixed_triu_mask",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(fixed_triu_mask))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y_grad->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y->GetAnchor(), node->GetInDataAnchor(1)));
if (mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mask->GetAnchor(), node->GetInDataAnchor(2)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsScanPQCodesOutput EsScanPQCodes(EsbTensor *ivf, EsbTensor *bucket_list, EsbTensor *bucket_base_distance, EsbTensor *bucket_limits, EsbTensor *bucket_offsets, EsbTensor *adc_tables, int64_t total_limit, int64_t group_size, int64_t extreme_mode, int64_t split_count, int64_t split_index) {
GE_ASSERT_NOTNULL(ivf);
GE_ASSERT_NOTNULL(bucket_list);
GE_ASSERT_NOTNULL(bucket_base_distance);
GE_ASSERT_NOTNULL(bucket_limits);
GE_ASSERT_NOTNULL(bucket_offsets);
GE_ASSERT_NOTNULL(adc_tables);
auto &graph = ivf->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ScanPQCodes")
.Name(("ScanPQCodes_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"ivf", ge::kIrInputRequired, ""},
{"bucket_list", ge::kIrInputRequired, ""},
{"bucket_base_distance", ge::kIrInputRequired, ""},
{"bucket_limits", ge::kIrInputRequired, ""},
{"bucket_offsets", ge::kIrInputRequired, ""},
{"adc_tables", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"actual_count", ge::kIrOutputRequired, ""},
{"pq_distance", ge::kIrOutputRequired, ""},
{"grouped_extreme_distance", ge::kIrOutputRequired, ""},
{"pq_ivf", ge::kIrOutputRequired, ""},
{"pq_index", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"total_limit",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(total_limit))
},
{
"group_size",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(group_size))
},
{
"extreme_mode",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(extreme_mode))
},
{
"split_count",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(split_count))
},
{
"split_index",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(split_index))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(ivf->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bucket_list->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bucket_base_distance->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bucket_limits->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bucket_offsets->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(adc_tables->GetAnchor(), node->GetInDataAnchor(5)));
return EsScanPQCodesOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
};
}
EsScanSQCodesOutput EsScanSQCodes(EsbTensor *ivf, EsbTensor *query, EsbTensor *bucket_list, EsbTensor *bucket_limits, EsbTensor *bucket_offsets, EsbTensor *vmin, EsbTensor *vdiff, int64_t total_limit, int64_t group_size, int64_t extreme_mode) {
GE_ASSERT_NOTNULL(ivf);
GE_ASSERT_NOTNULL(query);
GE_ASSERT_NOTNULL(bucket_list);
GE_ASSERT_NOTNULL(bucket_limits);
GE_ASSERT_NOTNULL(bucket_offsets);
GE_ASSERT_NOTNULL(vmin);
GE_ASSERT_NOTNULL(vdiff);
auto &graph = ivf->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ScanSQCodes")
.Name(("ScanSQCodes_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"ivf", ge::kIrInputRequired, ""},
{"query", ge::kIrInputRequired, ""},
{"bucket_list", ge::kIrInputRequired, ""},
{"bucket_limits", ge::kIrInputRequired, ""},
{"bucket_offsets", ge::kIrInputRequired, ""},
{"vmin", ge::kIrInputRequired, ""},
{"vdiff", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"actual_count", ge::kIrOutputRequired, ""},
{"sq_distance", ge::kIrOutputRequired, ""},
{"grouped_extreme_distance", ge::kIrOutputRequired, ""},
{"sq_ivf", ge::kIrOutputRequired, ""},
{"sq_index", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"total_limit",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(total_limit))
},
{
"group_size",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(group_size))
},
{
"extreme_mode",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(extreme_mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(ivf->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(query->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bucket_list->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bucket_limits->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bucket_offsets->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(vmin->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(vdiff->GetAnchor(), node->GetInDataAnchor(6)));
return EsScanSQCodesOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
};
}
EsbTensor *EsScatter(EsbTensor *var, EsbTensor *indices, EsbTensor *updates, const char *reduce, int64_t axis) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(updates);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Scatter")
.Name(("Scatter_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"updates", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"reduce",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduce))
},
{
"axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(updates->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsScatterAdd(EsbTensor *var, EsbTensor *indices, EsbTensor *updates, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(updates);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ScatterAdd")
.Name(("ScatterAdd_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"updates", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(updates->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsScatterAddWithAxis(EsbTensor *var, EsbTensor *indices, EsbTensor *updates, int64_t axis) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(updates);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ScatterAddWithAxis")
.Name(("ScatterAddWithAxis_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"updates", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(updates->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsScatterDiv(EsbTensor *var, EsbTensor *indices, EsbTensor *updates, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(updates);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ScatterDiv")
.Name(("ScatterDiv_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"updates", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(updates->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsScatterElements(EsbTensor *data, EsbTensor *indices, EsbTensor *updates, int64_t axis, const char *reduction) {
GE_ASSERT_NOTNULL(data);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(updates);
auto &graph = data->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ScatterElements")
.Name(("ScatterElements_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"data", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"updates", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
{
"reduction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduction))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(data->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(updates->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsScatterElementsV2(EsbTensor *var, EsbTensor *indices, EsbTensor *updates, int64_t axis, const char *reduction) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(updates);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ScatterElementsV2")
.Name(("ScatterElementsV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"updates", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
{
"reduction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduction))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(updates->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsScatterMax(EsbTensor *var, EsbTensor *indices, EsbTensor *updates, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(updates);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ScatterMax")
.Name(("ScatterMax_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"updates", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(updates->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsScatterMaxWithArgmaxOutput EsScatterMaxWithArgmax(EsbTensor *x, EsbTensor *indices, EsbTensor *updates) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(updates);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ScatterMaxWithArgmax")
.Name(("ScatterMaxWithArgmax_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"updates", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"argmax", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(updates->GetAnchor(), node->GetInDataAnchor(2)));
return EsScatterMaxWithArgmaxOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsScatterMin(EsbTensor *var, EsbTensor *indices, EsbTensor *updates, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(updates);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ScatterMin")
.Name(("ScatterMin_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"updates", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(updates->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsScatterMul(EsbTensor *var, EsbTensor *indices, EsbTensor *updates, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(updates);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ScatterMul")
.Name(("ScatterMul_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"updates", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(updates->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsScatterNd(EsbTensor *indices, EsbTensor *x, EsbTensor *shape) {
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(shape);
auto &graph = indices->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ScatterNd")
.Name(("ScatterNd_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"indices", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"shape", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsScatterNdAdd(EsbTensor *var, EsbTensor *indices, EsbTensor *updates, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(updates);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ScatterNdAdd")
.Name(("ScatterNdAdd_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"updates", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(updates->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsScatterNdD(EsbTensor *indices, EsbTensor *x, const int64_t *shape, int64_t shape_num) {
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(x);
auto &graph = indices->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ScatterNdD")
.Name(("ScatterNdD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"indices", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"shape",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(shape, shape + shape_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsScatterNdMax(EsbTensor *var, EsbTensor *indices, EsbTensor *updates, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(updates);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ScatterNdMax")
.Name(("ScatterNdMax_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"updates", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(updates->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsScatterNdMin(EsbTensor *var, EsbTensor *indices, EsbTensor *updates, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(updates);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ScatterNdMin")
.Name(("ScatterNdMin_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"updates", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(updates->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsScatterNdSub(EsbTensor *var, EsbTensor *indices, EsbTensor *updates, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(updates);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ScatterNdSub")
.Name(("ScatterNdSub_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"updates", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(updates->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsScatterNdUpdate(EsbTensor *var, EsbTensor *indices, EsbTensor *updates, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(updates);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ScatterNdUpdate")
.Name(("ScatterNdUpdate_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"updates", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(updates->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsScatterNonAliasingAdd(EsbTensor *x, EsbTensor *indices, EsbTensor *updates) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(updates);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ScatterNonAliasingAdd")
.Name(("ScatterNonAliasingAdd_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"updates", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(updates->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsScatterSub(EsbTensor *var, EsbTensor *indices, EsbTensor *updates, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(updates);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ScatterSub")
.Name(("ScatterSub_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"updates", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(updates->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsScatterUpdate(EsbTensor *var, EsbTensor *indices, EsbTensor *updates, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(updates);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ScatterUpdate")
.Name(("ScatterUpdate_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"updates", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(updates->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSearchN(EsbTensor *x, EsbTensor *scale_d, EsbTensor *scale_w) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(scale_d);
GE_ASSERT_NOTNULL(scale_w);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SearchN")
.Name(("SearchN_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"scale_d", ge::kIrInputRequired, ""},
{"scale_w", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"n", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale_d->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale_w->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSearchSorted(EsbTensor *sorted_sequence, EsbTensor *values, EsbTensor *sorter, ge::DataType dtype, bool right) {
GE_ASSERT_NOTNULL(sorted_sequence);
GE_ASSERT_NOTNULL(values);
auto &graph = sorted_sequence->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SearchSorted")
.Name(("SearchSorted_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"sorted_sequence", ge::kIrInputRequired, ""},
{"values", ge::kIrInputRequired, ""},
{"sorter", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"out", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
{
"right",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(right))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sorted_sequence->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(values->GetAnchor(), node->GetInDataAnchor(1)));
if (sorter != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sorter->GetAnchor(), node->GetInDataAnchor(2)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSegmentMax(EsbTensor *x, EsbTensor *segment_ids) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(segment_ids);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SegmentMax")
.Name(("SegmentMax_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"segment_ids", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(segment_ids->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSegmentMaxD(EsbTensor *x, const int64_t *segment_ids, int64_t segment_ids_num) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SegmentMaxD")
.Name(("SegmentMaxD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"segment_ids",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(segment_ids, segment_ids + segment_ids_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSegmentSort(EsbTensor *input_data, EsbTensor *input_index, int64_t k_num, bool largest) {
GE_ASSERT_NOTNULL(input_data);
GE_ASSERT_NOTNULL(input_index);
auto &graph = input_data->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SegmentSort")
.Name(("SegmentSort_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_data", ge::kIrInputRequired, ""},
{"input_index", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_proposal", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"k_num",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(k_num))
},
{
"largest",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(largest))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_data->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_index->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSegmentSum(EsbTensor *x, EsbTensor *segment_ids) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(segment_ids);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SegmentSum")
.Name(("SegmentSum_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"segment_ids", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(segment_ids->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSelect(EsbTensor *condition, EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(condition);
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = condition->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Select")
.Name(("Select_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"condition", ge::kIrInputRequired, ""},
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(condition->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSelectV2(EsbTensor *condition, EsbTensor *then, EsbTensor *in_else) {
GE_ASSERT_NOTNULL(condition);
GE_ASSERT_NOTNULL(then);
GE_ASSERT_NOTNULL(in_else);
auto &graph = condition->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SelectV2")
.Name(("SelectV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"condition", ge::kIrInputRequired, ""},
{"then", ge::kIrInputRequired, ""},
{"else", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"result", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(condition->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(then->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(in_else->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsSelfAdjointEigOutput EsSelfAdjointEig(EsbTensor *x, bool compute_v) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SelfAdjointEig")
.Name(("SelfAdjointEig_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"eigen_value", ge::kIrOutputRequired, ""},
{"eigen_vector", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"compute_v",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(compute_v))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return EsSelfAdjointEigOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsSelu(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Selu")
.Name(("Selu_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSeluGrad(EsbTensor *gradients, EsbTensor *outputs) {
GE_ASSERT_NOTNULL(gradients);
GE_ASSERT_NOTNULL(outputs);
auto &graph = gradients->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SeluGrad")
.Name(("SeluGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"gradients", ge::kIrInputRequired, ""},
{"outputs", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gradients->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(outputs->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSequenceAt(EsbTensor *handle, EsbTensor *index) {
GE_ASSERT_NOTNULL(handle);
GE_ASSERT_NOTNULL(index);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SequenceAt")
.Name(("SequenceAt_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
{"index", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(index->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSequenceConstruct(EsbTensor **inputs, int64_t inputs_num) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(inputs_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < inputs_num; ++i) {
if (inputs[i] != nullptr) {
non_null_in = inputs[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SequenceConstruct")
.Name(("SequenceConstruct_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"inputs", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
{"handle", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.InstanceDynamicInputNum("inputs", static_cast<int32_t>(inputs_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((inputs != nullptr) && (inputs_num > 0)) {
for (int64_t i = 0; i < inputs_num; ++i) {
auto one_inputs = inputs[i];
GE_ASSERT_NOTNULL(one_inputs);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_inputs->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSequenceEmpty(EsbGraph *owner_graph, ge::DataType dtype) {
GE_ASSERT_NOTNULL(owner_graph);
EsbGraph &graph = *owner_graph;

auto desc = ge::CompliantOpDescBuilder().OpType("SequenceEmpty")
.Name(("SequenceEmpty_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
})
.IrDefOutputs({
{"handle", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSequenceErase(EsbTensor *handle, EsbTensor *index) {
GE_ASSERT_NOTNULL(handle);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SequenceErase")
.Name(("SequenceErase_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
{"index", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"handle_y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
if (index != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(index->GetAnchor(), node->GetInDataAnchor(1)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSequenceInsert(EsbTensor *handle, EsbTensor *value, EsbTensor *index) {
GE_ASSERT_NOTNULL(handle);
GE_ASSERT_NOTNULL(value);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SequenceInsert")
.Name(("SequenceInsert_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
{"value", ge::kIrInputRequired, ""},
{"index", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"handle_y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(1)));
if (index != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(index->GetAnchor(), node->GetInDataAnchor(2)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSequenceLength(EsbTensor *handle) {
GE_ASSERT_NOTNULL(handle);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SequenceLength")
.Name(("SequenceLength_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"length", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSerializeManySparse(EsbTensor *indices, EsbTensor *values, EsbTensor *shape, ge::DataType out_type) {
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(values);
GE_ASSERT_NOTNULL(shape);
auto &graph = indices->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SerializeManySparse")
.Name(("SerializeManySparse_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"indices", ge::kIrInputRequired, ""},
{"values", ge::kIrInputRequired, ""},
{"shape", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"serialized_sparse", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"out_type",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(out_type))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(values->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSerializeSparse(EsbTensor *indices, EsbTensor *values, EsbTensor *shape, ge::DataType out_type) {
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(values);
GE_ASSERT_NOTNULL(shape);
auto &graph = indices->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SerializeSparse")
.Name(("SerializeSparse_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"indices", ge::kIrInputRequired, ""},
{"values", ge::kIrInputRequired, ""},
{"shape", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"serialized_sparse", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"out_type",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(out_type))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(values->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSetSize(EsbTensor *set_indices, EsbTensor *set_values, EsbTensor *set_shape, bool validate_indices) {
GE_ASSERT_NOTNULL(set_indices);
GE_ASSERT_NOTNULL(set_values);
GE_ASSERT_NOTNULL(set_shape);
auto &graph = set_indices->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SetSize")
.Name(("SetSize_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"set_indices", ge::kIrInputRequired, ""},
{"set_values", ge::kIrInputRequired, ""},
{"set_shape", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"size", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"validate_indices",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(validate_indices))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(set_indices->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(set_values->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(set_shape->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsShape(EsbTensor *x, int64_t dtype) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Shape")
.Name(("Shape_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsShrink(EsbTensor *input_x, float lambd, float bias) {
GE_ASSERT_NOTNULL(input_x);
auto &graph = input_x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Shrink")
.Name(("Shrink_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"lambd",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(lambd))
},
{
"bias",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(bias))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsShuffleChannel(EsbTensor *x, int64_t group) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ShuffleChannel")
.Name(("ShuffleChannel_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"group",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(group))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSigmoid(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Sigmoid")
.Name(("Sigmoid_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSigmoidCrossEntropyWithLogits(EsbTensor *predict, EsbTensor *target) {
GE_ASSERT_NOTNULL(predict);
GE_ASSERT_NOTNULL(target);
auto &graph = predict->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SigmoidCrossEntropyWithLogits")
.Name(("SigmoidCrossEntropyWithLogits_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"predict", ge::kIrInputRequired, ""},
{"target", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"loss", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(predict->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(target->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSigmoidCrossEntropyWithLogitsGrad(EsbTensor *predict, EsbTensor *target, EsbTensor *dout) {
GE_ASSERT_NOTNULL(predict);
GE_ASSERT_NOTNULL(target);
GE_ASSERT_NOTNULL(dout);
auto &graph = predict->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SigmoidCrossEntropyWithLogitsGrad")
.Name(("SigmoidCrossEntropyWithLogitsGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"predict", ge::kIrInputRequired, ""},
{"target", ge::kIrInputRequired, ""},
{"dout", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"gradient", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(predict->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(target->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dout->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSigmoidCrossEntropyWithLogitsGradV2(EsbTensor *predict, EsbTensor *target, EsbTensor *dout, EsbTensor *weight, EsbTensor *pos_weight, const char *reduction) {
GE_ASSERT_NOTNULL(predict);
GE_ASSERT_NOTNULL(target);
GE_ASSERT_NOTNULL(dout);
auto &graph = predict->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SigmoidCrossEntropyWithLogitsGradV2")
.Name(("SigmoidCrossEntropyWithLogitsGradV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"predict", ge::kIrInputRequired, ""},
{"target", ge::kIrInputRequired, ""},
{"dout", ge::kIrInputRequired, ""},
{"weight", ge::kIrInputOptional, ""},
{"pos_weight", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"gradient", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"reduction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduction))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(predict->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(target->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dout->GetAnchor(), node->GetInDataAnchor(2)));
if (weight != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight->GetAnchor(), node->GetInDataAnchor(3)));
}
if (pos_weight != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(pos_weight->GetAnchor(), node->GetInDataAnchor(4)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSigmoidCrossEntropyWithLogitsV2(EsbTensor *predict, EsbTensor *target, EsbTensor *weight, EsbTensor *pos_weight, const char *reduction) {
GE_ASSERT_NOTNULL(predict);
GE_ASSERT_NOTNULL(target);
auto &graph = predict->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SigmoidCrossEntropyWithLogitsV2")
.Name(("SigmoidCrossEntropyWithLogitsV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"predict", ge::kIrInputRequired, ""},
{"target", ge::kIrInputRequired, ""},
{"weight", ge::kIrInputOptional, ""},
{"pos_weight", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"loss", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"reduction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduction))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(predict->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(target->GetAnchor(), node->GetInDataAnchor(1)));
if (weight != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight->GetAnchor(), node->GetInDataAnchor(2)));
}
if (pos_weight != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(pos_weight->GetAnchor(), node->GetInDataAnchor(3)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSigmoidFocalLoss(EsbTensor *pred, EsbTensor *target, EsbTensor *weight, float gamma, float alpha, const char *reduction) {
GE_ASSERT_NOTNULL(pred);
GE_ASSERT_NOTNULL(target);
auto &graph = pred->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SigmoidFocalLoss")
.Name(("SigmoidFocalLoss_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"pred", ge::kIrInputRequired, ""},
{"target", ge::kIrInputRequired, ""},
{"weight", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"gamma",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(gamma))
},
{
"alpha",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(alpha))
},
{
"reduction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduction))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(pred->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(target->GetAnchor(), node->GetInDataAnchor(1)));
if (weight != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight->GetAnchor(), node->GetInDataAnchor(2)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSigmoidFocalLossGrad(EsbTensor *pred, EsbTensor *target, EsbTensor *dout, EsbTensor *weight, float alpha, float gamma, const char *reduction) {
GE_ASSERT_NOTNULL(pred);
GE_ASSERT_NOTNULL(target);
GE_ASSERT_NOTNULL(dout);
auto &graph = pred->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SigmoidFocalLossGrad")
.Name(("SigmoidFocalLossGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"pred", ge::kIrInputRequired, ""},
{"target", ge::kIrInputRequired, ""},
{"dout", ge::kIrInputRequired, ""},
{"weight", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"grad", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"alpha",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(alpha))
},
{
"gamma",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(gamma))
},
{
"reduction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduction))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(pred->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(target->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dout->GetAnchor(), node->GetInDataAnchor(2)));
if (weight != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight->GetAnchor(), node->GetInDataAnchor(3)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSigmoidGrad(EsbTensor *y, EsbTensor *dy, bool complex_conj) {
GE_ASSERT_NOTNULL(y);
GE_ASSERT_NOTNULL(dy);
auto &graph = y->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SigmoidGrad")
.Name(("SigmoidGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"y", ge::kIrInputRequired, ""},
{"dy", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"z", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"complex_conj",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(complex_conj))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSign(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Sign")
.Name(("Sign_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSignBitsPack(EsbTensor *x, int64_t size) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SignBitsPack")
.Name(("SignBitsPack_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"size",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(size))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSignBitsUnpack(EsbTensor *x, int64_t size, ge::DataType dtype) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SignBitsUnpack")
.Name(("SignBitsUnpack_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"size",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(size))
},
{
"dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsSilentCheckOutput EsSilentCheck(EsbTensor *val, EsbTensor *input_grad, EsbTensor *pre_val, EsbTensor *min_val, EsbTensor *max_val, EsbTensor *val_counter, int64_t c_min_steps, float c_thresh_l1, float c_coeff_l1, float c_thresh_l2, float c_coeff_l2) {
GE_ASSERT_NOTNULL(val);
GE_ASSERT_NOTNULL(input_grad);
GE_ASSERT_NOTNULL(pre_val);
GE_ASSERT_NOTNULL(min_val);
GE_ASSERT_NOTNULL(max_val);
GE_ASSERT_NOTNULL(val_counter);
auto &graph = val->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SilentCheck")
.Name(("SilentCheck_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"val", ge::kIrInputRequired, ""},
{"input_grad", ge::kIrInputRequired, ""},
{"pre_val", ge::kIrInputRequired, ""},
{"min_val", ge::kIrInputRequired, ""},
{"max_val", ge::kIrInputRequired, ""},
{"val_counter", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"input_grad", ge::kIrOutputRequired, ""},
{"pre_val", ge::kIrOutputRequired, ""},
{"min_val", ge::kIrOutputRequired, ""},
{"max_val", ge::kIrOutputRequired, ""},
{"result", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"c_min_steps",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(c_min_steps))
},
{
"c_thresh_l1",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(c_thresh_l1))
},
{
"c_coeff_l1",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(c_coeff_l1))
},
{
"c_thresh_l2",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(c_thresh_l2))
},
{
"c_coeff_l2",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(c_coeff_l2))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(val->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_grad->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(pre_val->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(min_val->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(max_val->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(val_counter->GetAnchor(), node->GetInDataAnchor(5)));
return EsSilentCheckOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
graph.GetEsbTensorFromNode(node, 4),
};
}
EsSilentCheckV2Output EsSilentCheckV2(EsbTensor *val, EsbTensor *input_grad, EsbTensor *sfda, EsbTensor *step, int64_t c_min_steps, float c_thresh_l1, float c_coeff_l1, float c_thresh_l2, float c_coeff_l2, int64_t npu_asd_detect) {
GE_ASSERT_NOTNULL(val);
GE_ASSERT_NOTNULL(input_grad);
GE_ASSERT_NOTNULL(sfda);
GE_ASSERT_NOTNULL(step);
auto &graph = val->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SilentCheckV2")
.Name(("SilentCheckV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"val", ge::kIrInputRequired, ""},
{"input_grad", ge::kIrInputRequired, ""},
{"sfda", ge::kIrInputRequired, ""},
{"step", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"input_grad", ge::kIrOutputRequired, ""},
{"sfda", ge::kIrOutputRequired, ""},
{"step", ge::kIrOutputRequired, ""},
{"result", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"c_min_steps",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(c_min_steps))
},
{
"c_thresh_l1",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(c_thresh_l1))
},
{
"c_coeff_l1",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(c_coeff_l1))
},
{
"c_thresh_l2",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(c_thresh_l2))
},
{
"c_coeff_l2",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(c_coeff_l2))
},
{
"npu_asd_detect",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(npu_asd_detect))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(val->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_grad->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sfda->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(step->GetAnchor(), node->GetInDataAnchor(3)));
return EsSilentCheckV2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsSilentCheckV3Output EsSilentCheckV3(EsbTensor *val, EsbTensor *max, EsbTensor *avg, EsbTensor *input_grad, EsbTensor *step, EsbTensor *dst_size, EsbTensor *dst_stride, EsbTensor *dst_offset, float c_thresh_l1, float c_thresh_l2, float beta1, int64_t npu_asd_detect) {
GE_ASSERT_NOTNULL(val);
GE_ASSERT_NOTNULL(max);
GE_ASSERT_NOTNULL(avg);
GE_ASSERT_NOTNULL(input_grad);
GE_ASSERT_NOTNULL(step);
GE_ASSERT_NOTNULL(dst_size);
GE_ASSERT_NOTNULL(dst_stride);
GE_ASSERT_NOTNULL(dst_offset);
auto &graph = val->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SilentCheckV3")
.Name(("SilentCheckV3_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"val", ge::kIrInputRequired, ""},
{"max", ge::kIrInputRequired, ""},
{"avg", ge::kIrInputRequired, ""},
{"input_grad", ge::kIrInputRequired, ""},
{"step", ge::kIrInputRequired, ""},
{"dst_size", ge::kIrInputRequired, ""},
{"dst_stride", ge::kIrInputRequired, ""},
{"dst_offset", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"avg", ge::kIrOutputRequired, ""},
{"input_grad", ge::kIrOutputRequired, ""},
{"step", ge::kIrOutputRequired, ""},
{"result", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"c_thresh_l1",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(c_thresh_l1))
},
{
"c_thresh_l2",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(c_thresh_l2))
},
{
"beta1",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(beta1))
},
{
"npu_asd_detect",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(npu_asd_detect))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(val->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(max->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(avg->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_grad->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(step->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dst_size->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dst_stride->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dst_offset->GetAnchor(), node->GetInDataAnchor(7)));
return EsSilentCheckV3Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsbTensor *EsSiluGrad(EsbTensor *dy, EsbTensor *x) {
GE_ASSERT_NOTNULL(dy);
GE_ASSERT_NOTNULL(x);
auto &graph = dy->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SiluGrad")
.Name(("SiluGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"dy", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"dx", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSin(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Sin")
.Name(("Sin_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsSingleMergeOutput EsSingleMerge(EsbTensor *input_proposal, int64_t k_num, bool largest) {
GE_ASSERT_NOTNULL(input_proposal);
auto &graph = input_proposal->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SingleMerge")
.Name(("SingleMerge_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_proposal", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_data", ge::kIrOutputRequired, ""},
{"output_index", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"k_num",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(k_num))
},
{
"largest",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(largest))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_proposal->GetAnchor(), node->GetInDataAnchor(0)));
return EsSingleMergeOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsSinh(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Sinh")
.Name(("Sinh_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSize(EsbTensor *x, int64_t dtype) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Size")
.Name(("Size_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSlice(EsbTensor *x, EsbTensor *offsets, EsbTensor *size) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(offsets);
GE_ASSERT_NOTNULL(size);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Slice")
.Name(("Slice_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"offsets", ge::kIrInputRequired, ""},
{"size", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offsets->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(size->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSliceD(EsbTensor *x, const int64_t *offsets, int64_t offsets_num, const int64_t *size, int64_t size_num) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SliceD")
.Name(("SliceD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"offsets",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(offsets, offsets + offsets_num))
},
{
"size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(size, size + size_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSliceDV2(EsbTensor *x, EsbTensor *offsets, const int64_t *size, int64_t size_num) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(offsets);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SliceDV2")
.Name(("SliceDV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"offsets", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(size, size + size_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offsets->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSliceLastDim(EsbTensor *x, int64_t start, int64_t end, int64_t stride) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SliceLastDim")
.Name(("SliceLastDim_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"start",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(start))
},
{
"end",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(end))
},
{
"stride",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(stride))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSliceWithAxes(EsbTensor *x, EsbTensor *offsets, EsbTensor *size, const int64_t *axes, int64_t axes_num) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(offsets);
GE_ASSERT_NOTNULL(size);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SliceWithAxes")
.Name(("SliceWithAxes_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"offsets", ge::kIrInputRequired, ""},
{"size", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axes",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(axes, axes + axes_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offsets->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(size->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSliceWrite(EsbTensor *x, EsbTensor *begin, EsbTensor *value) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(begin);
GE_ASSERT_NOTNULL(value);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SliceWrite")
.Name(("SliceWrite_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"begin", ge::kIrInputRequired, ""},
{"value", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"x", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(begin->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsSlogdetOutput EsSlogdet(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Slogdet")
.Name(("Slogdet_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"sign", ge::kIrOutputRequired, ""},
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return EsSlogdetOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsSmoothL1Loss(EsbTensor *predict, EsbTensor *label, float sigma) {
GE_ASSERT_NOTNULL(predict);
GE_ASSERT_NOTNULL(label);
auto &graph = predict->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SmoothL1Loss")
.Name(("SmoothL1Loss_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"predict", ge::kIrInputRequired, ""},
{"label", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"loss", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"sigma",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(sigma))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(predict->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(label->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSmoothL1LossGrad(EsbTensor *predict, EsbTensor *label, EsbTensor *dout, float sigma) {
GE_ASSERT_NOTNULL(predict);
GE_ASSERT_NOTNULL(label);
GE_ASSERT_NOTNULL(dout);
auto &graph = predict->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SmoothL1LossGrad")
.Name(("SmoothL1LossGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"predict", ge::kIrInputRequired, ""},
{"label", ge::kIrInputRequired, ""},
{"dout", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"gradient", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"sigma",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(sigma))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(predict->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(label->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dout->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSmoothL1LossGradV2(EsbTensor *predict, EsbTensor *label, EsbTensor *dout, float sigma, const char *reduction) {
GE_ASSERT_NOTNULL(predict);
GE_ASSERT_NOTNULL(label);
GE_ASSERT_NOTNULL(dout);
auto &graph = predict->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SmoothL1LossGradV2")
.Name(("SmoothL1LossGradV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"predict", ge::kIrInputRequired, ""},
{"label", ge::kIrInputRequired, ""},
{"dout", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"gradient", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"sigma",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(sigma))
},
{
"reduction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduction))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(predict->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(label->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dout->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSmoothL1LossV2(EsbTensor *predict, EsbTensor *label, float sigma, const char *reduction) {
GE_ASSERT_NOTNULL(predict);
GE_ASSERT_NOTNULL(label);
auto &graph = predict->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SmoothL1LossV2")
.Name(("SmoothL1LossV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"predict", ge::kIrInputRequired, ""},
{"label", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"loss", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"sigma",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(sigma))
},
{
"reduction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduction))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(predict->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(label->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSnapshot(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Snapshot")
.Name(("Snapshot_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSobolSample(EsbTensor *dim, EsbTensor *num_results, EsbTensor *skip, ge::DataType dtype) {
GE_ASSERT_NOTNULL(dim);
GE_ASSERT_NOTNULL(num_results);
GE_ASSERT_NOTNULL(skip);
auto &graph = dim->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SobolSample")
.Name(("SobolSample_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"dim", ge::kIrInputRequired, ""},
{"num_results", ge::kIrInputRequired, ""},
{"skip", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"samples", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dim->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(num_results->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(skip->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSoftMarginLoss(EsbTensor *input_x, EsbTensor *input_y, const char *reduction) {
GE_ASSERT_NOTNULL(input_x);
GE_ASSERT_NOTNULL(input_y);
auto &graph = input_x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SoftMarginLoss")
.Name(("SoftMarginLoss_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_x", ge::kIrInputRequired, ""},
{"input_y", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_z", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"reduction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduction))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_y->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSoftMarginLossGrad(EsbTensor *predict, EsbTensor *label, EsbTensor *dout, const char *reduction) {
GE_ASSERT_NOTNULL(predict);
GE_ASSERT_NOTNULL(label);
GE_ASSERT_NOTNULL(dout);
auto &graph = predict->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SoftMarginLossGrad")
.Name(("SoftMarginLossGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"predict", ge::kIrInputRequired, ""},
{"label", ge::kIrInputRequired, ""},
{"dout", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"gradient", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"reduction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduction))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(predict->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(label->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dout->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSoftShrink(EsbTensor *input_x, float lambd) {
GE_ASSERT_NOTNULL(input_x);
auto &graph = input_x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SoftShrink")
.Name(("SoftShrink_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"lambd",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(lambd))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSoftShrinkGrad(EsbTensor *input_grad, EsbTensor *input_x, float lambd) {
GE_ASSERT_NOTNULL(input_grad);
GE_ASSERT_NOTNULL(input_x);
auto &graph = input_grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SoftShrinkGrad")
.Name(("SoftShrinkGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_grad", ge::kIrInputRequired, ""},
{"input_x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"lambd",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(lambd))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_grad->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_x->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsSoftmaxCrossEntropyLossOutput EsSoftmaxCrossEntropyLoss(EsbTensor *scores, EsbTensor *labels, EsbTensor *weights, int64_t ignore_index, const char *reduction) {
GE_ASSERT_NOTNULL(scores);
GE_ASSERT_NOTNULL(labels);
auto &graph = scores->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SoftmaxCrossEntropyLoss")
.Name(("SoftmaxCrossEntropyLoss_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"scores", ge::kIrInputRequired, ""},
{"labels", ge::kIrInputRequired, ""},
{"weights", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"loss", ge::kIrOutputRequired, ""},
{"log_prop", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ignore_index",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(ignore_index))
},
{
"reduction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduction))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scores->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(labels->GetAnchor(), node->GetInDataAnchor(1)));
if (weights != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weights->GetAnchor(), node->GetInDataAnchor(2)));
}
return EsSoftmaxCrossEntropyLossOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsSoftmaxCrossEntropyWithLogitsOutput EsSoftmaxCrossEntropyWithLogits(EsbTensor *features, EsbTensor *labels) {
GE_ASSERT_NOTNULL(features);
GE_ASSERT_NOTNULL(labels);
auto &graph = features->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SoftmaxCrossEntropyWithLogits")
.Name(("SoftmaxCrossEntropyWithLogits_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"features", ge::kIrInputRequired, ""},
{"labels", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"loss", ge::kIrOutputRequired, ""},
{"backprop", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(features->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(labels->GetAnchor(), node->GetInDataAnchor(1)));
return EsSoftmaxCrossEntropyWithLogitsOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsSoftmaxFocalLoss(EsbTensor *pred, EsbTensor *target, EsbTensor *weight, float gamma, float alpha, const char *reduction) {
GE_ASSERT_NOTNULL(pred);
GE_ASSERT_NOTNULL(target);
auto &graph = pred->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SoftmaxFocalLoss")
.Name(("SoftmaxFocalLoss_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"pred", ge::kIrInputRequired, ""},
{"target", ge::kIrInputRequired, ""},
{"weight", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"gamma",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(gamma))
},
{
"alpha",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(alpha))
},
{
"reduction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduction))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(pred->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(target->GetAnchor(), node->GetInDataAnchor(1)));
if (weight != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight->GetAnchor(), node->GetInDataAnchor(2)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSoftmaxFocalLossGrad(EsbTensor *pred, EsbTensor *target, EsbTensor *dout, EsbTensor *weight, float alpha, float gamma, const char *reduction) {
GE_ASSERT_NOTNULL(pred);
GE_ASSERT_NOTNULL(target);
GE_ASSERT_NOTNULL(dout);
auto &graph = pred->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SoftmaxFocalLossGrad")
.Name(("SoftmaxFocalLossGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"pred", ge::kIrInputRequired, ""},
{"target", ge::kIrInputRequired, ""},
{"dout", ge::kIrInputRequired, ""},
{"weight", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"grad", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"alpha",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(alpha))
},
{
"gamma",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(gamma))
},
{
"reduction",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduction))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(pred->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(target->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dout->GetAnchor(), node->GetInDataAnchor(2)));
if (weight != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight->GetAnchor(), node->GetInDataAnchor(3)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSoftmaxGrad(EsbTensor *softmax, EsbTensor *grad_softmax, const int64_t *axes, int64_t axes_num) {
GE_ASSERT_NOTNULL(softmax);
GE_ASSERT_NOTNULL(grad_softmax);
auto &graph = softmax->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SoftmaxGrad")
.Name(("SoftmaxGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"softmax", ge::kIrInputRequired, ""},
{"grad_softmax", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"grad_x", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axes",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(axes, axes + axes_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(softmax->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad_softmax->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSoftmaxGradExt(EsbTensor *grad, EsbTensor *x1, EsbTensor *x2, int64_t axes, bool keep_dims) {
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SoftmaxGradExt")
.Name(("SoftmaxGradExt_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grad", ge::kIrInputRequired, ""},
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axes",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axes))
},
{
"keep_dims",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keep_dims))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSoftmaxV2(EsbTensor *x, const int64_t *axes, int64_t axes_num, bool half_to_float) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SoftmaxV2")
.Name(("SoftmaxV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axes",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(axes, axes + axes_num))
},
{
"half_to_float",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(half_to_float))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsSoftmaxV2WithDropOutDoMaskV3DOutput EsSoftmaxV2WithDropOutDoMaskV3D(EsbTensor *x, EsbTensor *mask, float keep_prob, const int64_t *axes, int64_t axes_num) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(mask);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SoftmaxV2WithDropOutDoMaskV3D")
.Name(("SoftmaxV2WithDropOutDoMaskV3D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"mask", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y1", ge::kIrOutputRequired, ""},
{"y2", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"keep_prob",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(keep_prob))
},
{
"axes",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(axes, axes + axes_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mask->GetAnchor(), node->GetInDataAnchor(1)));
return EsSoftmaxV2WithDropOutDoMaskV3DOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsSoftplus(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Softplus")
.Name(("Softplus_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSoftplusGrad(EsbTensor *gradients, EsbTensor *features) {
GE_ASSERT_NOTNULL(gradients);
GE_ASSERT_NOTNULL(features);
auto &graph = gradients->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SoftplusGrad")
.Name(("SoftplusGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"gradients", ge::kIrInputRequired, ""},
{"features", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"backprops", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gradients->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(features->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSoftplusV2(EsbTensor *x, float beta, float threshold) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SoftplusV2")
.Name(("SoftplusV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"beta",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(beta))
},
{
"threshold",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(threshold))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSoftplusV2Grad(EsbTensor *input_gradients, EsbTensor *input_features, float beta, float threshold) {
GE_ASSERT_NOTNULL(input_gradients);
GE_ASSERT_NOTNULL(input_features);
auto &graph = input_gradients->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SoftplusV2Grad")
.Name(("SoftplusV2Grad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_gradients", ge::kIrInputRequired, ""},
{"input_features", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_backprops", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"beta",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(beta))
},
{
"threshold",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(threshold))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_gradients->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_features->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSoftsign(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Softsign")
.Name(("Softsign_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSoftsignGrad(EsbTensor *gradients, EsbTensor *features) {
GE_ASSERT_NOTNULL(gradients);
GE_ASSERT_NOTNULL(features);
auto &graph = gradients->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SoftsignGrad")
.Name(("SoftsignGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"gradients", ge::kIrInputRequired, ""},
{"features", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gradients->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(features->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsSortOutput EsSort(EsbTensor *x, int64_t axis, bool descending, bool stable) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Sort")
.Name(("Sort_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y1", ge::kIrOutputRequired, ""},
{"y2", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
{
"descending",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(descending))
},
{
"stable",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(stable))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return EsSortOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsSortV2(EsbTensor *x, int64_t axis, bool descending) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SortV2")
.Name(("SortV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
{
"descending",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(descending))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSortedNMS(EsbTensor *boxes, EsbTensor *sorted_scores, EsbTensor *input_indices, EsbTensor *max_output_size, EsbTensor *iou_threshold, EsbTensor *score_threshold, int64_t offset) {
GE_ASSERT_NOTNULL(boxes);
GE_ASSERT_NOTNULL(sorted_scores);
GE_ASSERT_NOTNULL(input_indices);
GE_ASSERT_NOTNULL(max_output_size);
GE_ASSERT_NOTNULL(iou_threshold);
GE_ASSERT_NOTNULL(score_threshold);
auto &graph = boxes->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SortedNMS")
.Name(("SortedNMS_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"boxes", ge::kIrInputRequired, ""},
{"sorted_scores", ge::kIrInputRequired, ""},
{"input_indices", ge::kIrInputRequired, ""},
{"max_output_size", ge::kIrInputRequired, ""},
{"iou_threshold", ge::kIrInputRequired, ""},
{"score_threshold", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"selected_indices", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"offset",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(offset))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(boxes->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sorted_scores->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_indices->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(max_output_size->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(iou_threshold->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(score_threshold->GetAnchor(), node->GetInDataAnchor(5)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSpaceToBatch(EsbTensor *x, EsbTensor *paddings, int64_t block_size) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(paddings);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SpaceToBatch")
.Name(("SpaceToBatch_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"paddings", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"block_size",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(block_size))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(paddings->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSpaceToBatchD(EsbTensor *x, int64_t block_size, const int64_t *paddings, int64_t paddings_num) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SpaceToBatchD")
.Name(("SpaceToBatchD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"block_size",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(block_size))
},
{
"paddings",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(paddings, paddings + paddings_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSpaceToBatchND(EsbTensor *x, EsbTensor *block_shape, EsbTensor *paddings) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(block_shape);
GE_ASSERT_NOTNULL(paddings);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SpaceToBatchND")
.Name(("SpaceToBatchND_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"block_shape", ge::kIrInputRequired, ""},
{"paddings", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(block_shape->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(paddings->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSpaceToBatchNDD(EsbTensor *x, const int64_t *block_shape, int64_t block_shape_num, const int64_t *paddings, int64_t paddings_num) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SpaceToBatchNDD")
.Name(("SpaceToBatchNDD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"block_shape",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(block_shape, block_shape + block_shape_num))
},
{
"paddings",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(paddings, paddings + paddings_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSpaceToDepth(EsbTensor *x, int64_t block_size, const char *data_format) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SpaceToDepth")
.Name(("SpaceToDepth_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"block_size",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(block_size))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSparseAccumulatorApplyGradient(EsbTensor *handle, EsbTensor *local_step, EsbTensor *indices, EsbTensor *values, EsbTensor *shape, bool has_known_shape, ge::DataType dtype) {
GE_ASSERT_NOTNULL(handle);
GE_ASSERT_NOTNULL(local_step);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(values);
GE_ASSERT_NOTNULL(shape);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseAccumulatorApplyGradient")
.Name(("SparseAccumulatorApplyGradient_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
{"local_step", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"values", ge::kIrInputRequired, ""},
{"shape", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
{
"has_known_shape",
ge::kAttrRequired,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(has_known_shape))
},
{
"dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(local_step->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(values->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(4)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsSparseAccumulatorTakeGradientOutput EsSparseAccumulatorTakeGradient(EsbTensor *handle, EsbTensor *num_required, ge::DataType dtype) {
GE_ASSERT_NOTNULL(handle);
GE_ASSERT_NOTNULL(num_required);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseAccumulatorTakeGradient")
.Name(("SparseAccumulatorTakeGradient_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
{"num_required", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"indices", ge::kIrOutputRequired, ""},
{"values", ge::kIrOutputRequired, ""},
{"shape", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(num_required->GetAnchor(), node->GetInDataAnchor(1)));
return EsSparseAccumulatorTakeGradientOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsSparseAddOutput EsSparseAdd(EsbTensor *x1_indices, EsbTensor *x1_values, EsbTensor *x1_shape, EsbTensor *x2_indices, EsbTensor *x2_values, EsbTensor *x2_shape, EsbTensor *thresh) {
GE_ASSERT_NOTNULL(x1_indices);
GE_ASSERT_NOTNULL(x1_values);
GE_ASSERT_NOTNULL(x1_shape);
GE_ASSERT_NOTNULL(x2_indices);
GE_ASSERT_NOTNULL(x2_values);
GE_ASSERT_NOTNULL(x2_shape);
GE_ASSERT_NOTNULL(thresh);
auto &graph = x1_indices->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseAdd")
.Name(("SparseAdd_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1_indices", ge::kIrInputRequired, ""},
{"x1_values", ge::kIrInputRequired, ""},
{"x1_shape", ge::kIrInputRequired, ""},
{"x2_indices", ge::kIrInputRequired, ""},
{"x2_values", ge::kIrInputRequired, ""},
{"x2_shape", ge::kIrInputRequired, ""},
{"thresh", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"sum_indices", ge::kIrOutputRequired, ""},
{"sum_values", ge::kIrOutputRequired, ""},
{"sum_shape", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1_indices->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1_values->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1_shape->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2_indices->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2_values->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2_shape->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(thresh->GetAnchor(), node->GetInDataAnchor(6)));
return EsSparseAddOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsSparseAddGradOutput EsSparseAddGrad(EsbTensor *backprop_val_grad, EsbTensor *x1_indices, EsbTensor *x2_indices, EsbTensor *sum_indices) {
GE_ASSERT_NOTNULL(backprop_val_grad);
GE_ASSERT_NOTNULL(x1_indices);
GE_ASSERT_NOTNULL(x2_indices);
GE_ASSERT_NOTNULL(sum_indices);
auto &graph = backprop_val_grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseAddGrad")
.Name(("SparseAddGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"backprop_val_grad", ge::kIrInputRequired, ""},
{"x1_indices", ge::kIrInputRequired, ""},
{"x2_indices", ge::kIrInputRequired, ""},
{"sum_indices", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"x1_val_grad", ge::kIrOutputRequired, ""},
{"x2_val_grad", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(backprop_val_grad->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1_indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2_indices->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sum_indices->GetAnchor(), node->GetInDataAnchor(3)));
return EsSparseAddGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsSparseApplyAdadeltaOutput EsSparseApplyAdadelta(EsbTensor *var, EsbTensor *accum, EsbTensor *accum_update, EsbTensor *lr, EsbTensor *rho, EsbTensor *epsilon, EsbTensor *grad, EsbTensor *indices, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(accum);
GE_ASSERT_NOTNULL(accum_update);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(rho);
GE_ASSERT_NOTNULL(epsilon);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(indices);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseApplyAdadelta")
.Name(("SparseApplyAdadelta_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"accum", ge::kIrInputRequired, ""},
{"accum_update", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"rho", ge::kIrInputRequired, ""},
{"epsilon", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"accum", ge::kIrOutputRequired, ""},
{"accum_update", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum_update->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rho->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(epsilon->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(7)));
return EsSparseApplyAdadeltaOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsSparseApplyAdadeltaDOutput EsSparseApplyAdadeltaD(EsbTensor *var, EsbTensor *accum, EsbTensor *accum_update, EsbTensor *lr, EsbTensor *rho, EsbTensor *grad, EsbTensor *indices, float epsilon, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(accum);
GE_ASSERT_NOTNULL(accum_update);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(rho);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(indices);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseApplyAdadeltaD")
.Name(("SparseApplyAdadeltaD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"accum", ge::kIrInputRequired, ""},
{"accum_update", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"rho", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"accum", ge::kIrOutputRequired, ""},
{"accum_update", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"epsilon",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum_update->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rho->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(6)));
return EsSparseApplyAdadeltaDOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsSparseApplyAdagradOutput EsSparseApplyAdagrad(EsbTensor *var, EsbTensor *accum, EsbTensor *lr, EsbTensor *grad, EsbTensor *indices, bool use_locking, bool update_slots) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(accum);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(indices);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseApplyAdagrad")
.Name(("SparseApplyAdagrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"accum", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"accum", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
{
"update_slots",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(update_slots))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(4)));
return EsSparseApplyAdagradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsSparseApplyAdagradDOutput EsSparseApplyAdagradD(EsbTensor *var, EsbTensor *accum, EsbTensor *grad, EsbTensor *indices, float lr, bool use_locking, bool update_slots) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(accum);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(indices);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseApplyAdagradD")
.Name(("SparseApplyAdagradD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"accum", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"accum", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"lr",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(lr))
},
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
{
"update_slots",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(update_slots))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(3)));
return EsSparseApplyAdagradDOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsSparseApplyAdagradV2Output EsSparseApplyAdagradV2(EsbTensor *var, EsbTensor *accum, EsbTensor *lr, EsbTensor *epsilon, EsbTensor *grad, EsbTensor *indices, bool use_locking, bool update_slots) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(accum);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(epsilon);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(indices);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseApplyAdagradV2")
.Name(("SparseApplyAdagradV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"accum", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"epsilon", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"accum", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
{
"update_slots",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(update_slots))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(epsilon->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(5)));
return EsSparseApplyAdagradV2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsSparseApplyAdagradV2DOutput EsSparseApplyAdagradV2D(EsbTensor *var, EsbTensor *accum, EsbTensor *grad, EsbTensor *indices, float lr, float epsilon, bool use_locking, bool update_slots) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(accum);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(indices);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseApplyAdagradV2D")
.Name(("SparseApplyAdagradV2D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"accum", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"accum", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"lr",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(lr))
},
{
"epsilon",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
{
"update_slots",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(update_slots))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(3)));
return EsSparseApplyAdagradV2DOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsSparseApplyFtrlOutput EsSparseApplyFtrl(EsbTensor *var, EsbTensor *accum, EsbTensor *linear, EsbTensor *grad, EsbTensor *indices, EsbTensor *lr, EsbTensor *l1, EsbTensor *l2, EsbTensor *lr_power, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(accum);
GE_ASSERT_NOTNULL(linear);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(l1);
GE_ASSERT_NOTNULL(l2);
GE_ASSERT_NOTNULL(lr_power);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseApplyFtrl")
.Name(("SparseApplyFtrl_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"accum", ge::kIrInputRequired, ""},
{"linear", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"l1", ge::kIrInputRequired, ""},
{"l2", ge::kIrInputRequired, ""},
{"lr_power", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"accum", ge::kIrOutputRequired, ""},
{"linear", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(linear->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(l1->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(l2->GetAnchor(), node->GetInDataAnchor(7)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr_power->GetAnchor(), node->GetInDataAnchor(8)));
return EsSparseApplyFtrlOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsSparseApplyFtrlDOutput EsSparseApplyFtrlD(EsbTensor *var, EsbTensor *accum, EsbTensor *linear, EsbTensor *grad, EsbTensor *indices, float lr, float l1, float l2, float lr_power, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(accum);
GE_ASSERT_NOTNULL(linear);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(indices);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseApplyFtrlD")
.Name(("SparseApplyFtrlD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"accum", ge::kIrInputRequired, ""},
{"linear", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"accum", ge::kIrOutputRequired, ""},
{"linear", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"lr",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(lr))
},
{
"l1",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(l1))
},
{
"l2",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(l2))
},
{
"lr_power",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(lr_power))
},
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(linear->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(4)));
return EsSparseApplyFtrlDOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsSparseApplyFtrlV2Output EsSparseApplyFtrlV2(EsbTensor *var, EsbTensor *accum, EsbTensor *linear, EsbTensor *grad, EsbTensor *indices, EsbTensor *lr, EsbTensor *l1, EsbTensor *l2, EsbTensor *l2_shrinkage, EsbTensor *lr_power, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(accum);
GE_ASSERT_NOTNULL(linear);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(l1);
GE_ASSERT_NOTNULL(l2);
GE_ASSERT_NOTNULL(l2_shrinkage);
GE_ASSERT_NOTNULL(lr_power);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseApplyFtrlV2")
.Name(("SparseApplyFtrlV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"accum", ge::kIrInputRequired, ""},
{"linear", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"l1", ge::kIrInputRequired, ""},
{"l2", ge::kIrInputRequired, ""},
{"l2_shrinkage", ge::kIrInputRequired, ""},
{"lr_power", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"accum", ge::kIrOutputRequired, ""},
{"linear", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(linear->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(l1->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(l2->GetAnchor(), node->GetInDataAnchor(7)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(l2_shrinkage->GetAnchor(), node->GetInDataAnchor(8)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr_power->GetAnchor(), node->GetInDataAnchor(9)));
return EsSparseApplyFtrlV2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsSparseApplyFtrlV2DOutput EsSparseApplyFtrlV2D(EsbTensor *var, EsbTensor *accum, EsbTensor *linear, EsbTensor *grad, EsbTensor *indices, float lr, float l1, float l2, float l2_shrinkage, float lr_power, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(accum);
GE_ASSERT_NOTNULL(linear);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(indices);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseApplyFtrlV2D")
.Name(("SparseApplyFtrlV2D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"accum", ge::kIrInputRequired, ""},
{"linear", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"accum", ge::kIrOutputRequired, ""},
{"linear", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"lr",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(lr))
},
{
"l1",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(l1))
},
{
"l2",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(l2))
},
{
"l2_shrinkage",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(l2_shrinkage))
},
{
"lr_power",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(lr_power))
},
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(linear->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(4)));
return EsSparseApplyFtrlV2DOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsSparseApplyProximalAdagradOutput EsSparseApplyProximalAdagrad(EsbTensor *var, EsbTensor *accum, EsbTensor *lr, EsbTensor *l1, EsbTensor *l2, EsbTensor *grad, EsbTensor *indices, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(accum);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(l1);
GE_ASSERT_NOTNULL(l2);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(indices);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseApplyProximalAdagrad")
.Name(("SparseApplyProximalAdagrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"accum", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"l1", ge::kIrInputRequired, ""},
{"l2", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"accum", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(l1->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(l2->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(6)));
return EsSparseApplyProximalAdagradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsSparseApplyProximalAdagradDOutput EsSparseApplyProximalAdagradD(EsbTensor *var, EsbTensor *accum, EsbTensor *lr, EsbTensor *l1, EsbTensor *l2, EsbTensor *grad, EsbTensor *indices, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(accum);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(l1);
GE_ASSERT_NOTNULL(l2);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(indices);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseApplyProximalAdagradD")
.Name(("SparseApplyProximalAdagradD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"accum", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"l1", ge::kIrInputRequired, ""},
{"l2", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"accum", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(accum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(l1->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(l2->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(6)));
return EsSparseApplyProximalAdagradDOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsSparseApplyRMSPropOutput EsSparseApplyRMSProp(EsbTensor *var, EsbTensor *ms, EsbTensor *mom, EsbTensor *lr, EsbTensor *rho, EsbTensor *momentum, EsbTensor *epsilon, EsbTensor *grad, EsbTensor *indices, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(ms);
GE_ASSERT_NOTNULL(mom);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(rho);
GE_ASSERT_NOTNULL(momentum);
GE_ASSERT_NOTNULL(epsilon);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(indices);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseApplyRMSProp")
.Name(("SparseApplyRMSProp_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"ms", ge::kIrInputRequired, ""},
{"mom", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"rho", ge::kIrInputRequired, ""},
{"momentum", ge::kIrInputRequired, ""},
{"epsilon", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"ms", ge::kIrOutputRequired, ""},
{"mom", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(ms->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mom->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rho->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(momentum->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(epsilon->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(7)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(8)));
return EsSparseApplyRMSPropOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsSparseApplyRMSPropDOutput EsSparseApplyRMSPropD(EsbTensor *var, EsbTensor *ms, EsbTensor *mom, EsbTensor *lr, EsbTensor *grad, EsbTensor *indices, float rho, float momentum, float epsilon, bool use_locking) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(ms);
GE_ASSERT_NOTNULL(mom);
GE_ASSERT_NOTNULL(lr);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(indices);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseApplyRMSPropD")
.Name(("SparseApplyRMSPropD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"ms", ge::kIrInputRequired, ""},
{"mom", ge::kIrInputRequired, ""},
{"lr", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
{"ms", ge::kIrOutputRequired, ""},
{"mom", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"rho",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(rho))
},
{
"momentum",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(momentum))
},
{
"epsilon",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
{
"use_locking",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_locking))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(ms->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mom->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lr->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(5)));
return EsSparseApplyRMSPropDOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsSparseBincount(EsbTensor *indices, EsbTensor *values, EsbTensor *dense_shape, EsbTensor *size, EsbTensor *weights, bool binary_output) {
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(values);
GE_ASSERT_NOTNULL(dense_shape);
GE_ASSERT_NOTNULL(size);
GE_ASSERT_NOTNULL(weights);
auto &graph = indices->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseBincount")
.Name(("SparseBincount_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"indices", ge::kIrInputRequired, ""},
{"values", ge::kIrInputRequired, ""},
{"dense_shape", ge::kIrInputRequired, ""},
{"size", ge::kIrInputRequired, ""},
{"weights", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"binary_output",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(binary_output))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(values->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dense_shape->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(size->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weights->GetAnchor(), node->GetInDataAnchor(4)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsSparseConcatOutput EsSparseConcat(EsbTensor **indices, int64_t indices_num, EsbTensor **values, int64_t values_num, EsbTensor **shapes, int64_t shapes_num, int64_t concat_dim, int64_t N) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(indices_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(values_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(shapes_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < indices_num; ++i) {
if (indices[i] != nullptr) {
non_null_in = indices[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
if (non_null_in == nullptr) {
for (int64_t i = 0; i < values_num; ++i) {
if (values[i] != nullptr) {
non_null_in = values[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
if (non_null_in == nullptr) {
for (int64_t i = 0; i < shapes_num; ++i) {
if (shapes[i] != nullptr) {
non_null_in = shapes[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseConcat")
.Name(("SparseConcat_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"indices", ge::kIrInputDynamic, ""},
{"values", ge::kIrInputDynamic, ""},
{"shapes", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
{"y_indices", ge::kIrOutputRequired, ""},
{"y_values", ge::kIrOutputRequired, ""},
{"y_shape", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"concat_dim",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(concat_dim))
},
{
"N",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(N))
},
})
.InstanceDynamicInputNum("indices", static_cast<int32_t>(indices_num))
.InstanceDynamicInputNum("values", static_cast<int32_t>(values_num))
.InstanceDynamicInputNum("shapes", static_cast<int32_t>(shapes_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((indices != nullptr) && (indices_num > 0)) {
for (int64_t i = 0; i < indices_num; ++i) {
auto one_indices = indices[i];
GE_ASSERT_NOTNULL(one_indices);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_indices->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
if ((values != nullptr) && (values_num > 0)) {
for (int64_t i = 0; i < values_num; ++i) {
auto one_values = values[i];
GE_ASSERT_NOTNULL(one_values);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_values->GetAnchor(), node->GetInDataAnchor(0 + indices_num + i)));
}
}
if ((shapes != nullptr) && (shapes_num > 0)) {
for (int64_t i = 0; i < shapes_num; ++i) {
auto one_shapes = shapes[i];
GE_ASSERT_NOTNULL(one_shapes);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_shapes->GetAnchor(), node->GetInDataAnchor(0 + indices_num + values_num + i)));
}
}
return EsSparseConcatOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsSparseConditionalAccumulator(EsbGraph *owner_graph, const int64_t *shape, int64_t shape_num, ge::DataType dtype, const char *container, const char *shared_name, const char *reduction_type) {
GE_ASSERT_NOTNULL(owner_graph);
EsbGraph &graph = *owner_graph;

auto desc = ge::CompliantOpDescBuilder().OpType("SparseConditionalAccumulator")
.Name(("SparseConditionalAccumulator_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
})
.IrDefOutputs({
{"handle", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"shape",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(shape, shape + shape_num))
},
{
"dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
{
"container",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(container))
},
{
"shared_name",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(shared_name))
},
{
"reduction_type",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(reduction_type))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsSparseCountSparseOutputOutput EsSparseCountSparseOutput(EsbTensor *indices, EsbTensor *values, EsbTensor *dense_shape, EsbTensor *weights, bool binary_output, int64_t minlength, int64_t maxlength) {
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(values);
GE_ASSERT_NOTNULL(dense_shape);
GE_ASSERT_NOTNULL(weights);
auto &graph = indices->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseCountSparseOutput")
.Name(("SparseCountSparseOutput_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"indices", ge::kIrInputRequired, ""},
{"values", ge::kIrInputRequired, ""},
{"dense_shape", ge::kIrInputRequired, ""},
{"weights", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_indices", ge::kIrOutputRequired, ""},
{"output_values", ge::kIrOutputRequired, ""},
{"output_dense_shape", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"binary_output",
ge::kAttrRequired,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(binary_output))
},
{
"minlength",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(minlength))
},
{
"maxlength",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(maxlength))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(values->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dense_shape->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weights->GetAnchor(), node->GetInDataAnchor(3)));
return EsSparseCountSparseOutputOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsSparseCrossOutput EsSparseCross(EsbTensor **indices, int64_t indices_num, EsbTensor **values, int64_t values_num, EsbTensor **shapes, int64_t shapes_num, EsbTensor **dense_inputs, int64_t dense_inputs_num, bool hashed_output, int64_t hash_key, ge::DataType out_type, ge::DataType internal_type, int64_t N, int64_t num_buckets) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(indices_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(values_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(shapes_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(dense_inputs_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < indices_num; ++i) {
if (indices[i] != nullptr) {
non_null_in = indices[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
if (non_null_in == nullptr) {
for (int64_t i = 0; i < values_num; ++i) {
if (values[i] != nullptr) {
non_null_in = values[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
if (non_null_in == nullptr) {
for (int64_t i = 0; i < shapes_num; ++i) {
if (shapes[i] != nullptr) {
non_null_in = shapes[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
if (non_null_in == nullptr) {
for (int64_t i = 0; i < dense_inputs_num; ++i) {
if (dense_inputs[i] != nullptr) {
non_null_in = dense_inputs[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseCross")
.Name(("SparseCross_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"indices", ge::kIrInputDynamic, ""},
{"values", ge::kIrInputDynamic, ""},
{"shapes", ge::kIrInputDynamic, ""},
{"dense_inputs", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
{"output_indices", ge::kIrOutputRequired, ""},
{"output_values", ge::kIrOutputRequired, ""},
{"output_shape", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"hashed_output",
ge::kAttrRequired,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(hashed_output))
},
{
"hash_key",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(hash_key))
},
{
"out_type",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(out_type))
},
{
"internal_type",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(internal_type))
},
{
"N",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(N))
},
{
"num_buckets",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_buckets))
},
})
.InstanceDynamicInputNum("indices", static_cast<int32_t>(indices_num))
.InstanceDynamicInputNum("values", static_cast<int32_t>(values_num))
.InstanceDynamicInputNum("shapes", static_cast<int32_t>(shapes_num))
.InstanceDynamicInputNum("dense_inputs", static_cast<int32_t>(dense_inputs_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((indices != nullptr) && (indices_num > 0)) {
for (int64_t i = 0; i < indices_num; ++i) {
auto one_indices = indices[i];
GE_ASSERT_NOTNULL(one_indices);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_indices->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
if ((values != nullptr) && (values_num > 0)) {
for (int64_t i = 0; i < values_num; ++i) {
auto one_values = values[i];
GE_ASSERT_NOTNULL(one_values);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_values->GetAnchor(), node->GetInDataAnchor(0 + indices_num + i)));
}
}
if ((shapes != nullptr) && (shapes_num > 0)) {
for (int64_t i = 0; i < shapes_num; ++i) {
auto one_shapes = shapes[i];
GE_ASSERT_NOTNULL(one_shapes);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_shapes->GetAnchor(), node->GetInDataAnchor(0 + indices_num + values_num + i)));
}
}
if ((dense_inputs != nullptr) && (dense_inputs_num > 0)) {
for (int64_t i = 0; i < dense_inputs_num; ++i) {
auto one_dense_inputs = dense_inputs[i];
GE_ASSERT_NOTNULL(one_dense_inputs);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_dense_inputs->GetAnchor(), node->GetInDataAnchor(0 + indices_num + values_num + shapes_num + i)));
}
}
return EsSparseCrossOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsSparseDenseCwiseAdd(EsbTensor *x1_indices, EsbTensor *x1_values, EsbTensor *x1_shape, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1_indices);
GE_ASSERT_NOTNULL(x1_values);
GE_ASSERT_NOTNULL(x1_shape);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1_indices->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseDenseCwiseAdd")
.Name(("SparseDenseCwiseAdd_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1_indices", ge::kIrInputRequired, ""},
{"x1_values", ge::kIrInputRequired, ""},
{"x1_shape", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1_indices->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1_values->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1_shape->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSparseDenseCwiseDiv(EsbTensor *x1_indices, EsbTensor *x1_values, EsbTensor *x1_shape, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1_indices);
GE_ASSERT_NOTNULL(x1_values);
GE_ASSERT_NOTNULL(x1_shape);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1_indices->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseDenseCwiseDiv")
.Name(("SparseDenseCwiseDiv_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1_indices", ge::kIrInputRequired, ""},
{"x1_values", ge::kIrInputRequired, ""},
{"x1_shape", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1_indices->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1_values->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1_shape->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSparseDenseCwiseMul(EsbTensor *x1_indices, EsbTensor *x1_values, EsbTensor *x1_shape, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1_indices);
GE_ASSERT_NOTNULL(x1_values);
GE_ASSERT_NOTNULL(x1_shape);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1_indices->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseDenseCwiseMul")
.Name(("SparseDenseCwiseMul_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1_indices", ge::kIrInputRequired, ""},
{"x1_values", ge::kIrInputRequired, ""},
{"x1_shape", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1_indices->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1_values->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1_shape->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsSparseFillEmptyRowsOutput EsSparseFillEmptyRows(EsbTensor *indices, EsbTensor *values, EsbTensor *dense_shape, EsbTensor *default_value) {
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(values);
GE_ASSERT_NOTNULL(dense_shape);
GE_ASSERT_NOTNULL(default_value);
auto &graph = indices->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseFillEmptyRows")
.Name(("SparseFillEmptyRows_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"indices", ge::kIrInputRequired, ""},
{"values", ge::kIrInputRequired, ""},
{"dense_shape", ge::kIrInputRequired, ""},
{"default_value", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y_indices", ge::kIrOutputRequired, ""},
{"y_values", ge::kIrOutputRequired, ""},
{"empty_row_indicator", ge::kIrOutputRequired, ""},
{"reverse_index_map", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(values->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dense_shape->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(default_value->GetAnchor(), node->GetInDataAnchor(3)));
return EsSparseFillEmptyRowsOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsSparseFillEmptyRowsGradOutput EsSparseFillEmptyRowsGrad(EsbTensor *reverse_index_map, EsbTensor *grad_values) {
GE_ASSERT_NOTNULL(reverse_index_map);
GE_ASSERT_NOTNULL(grad_values);
auto &graph = reverse_index_map->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseFillEmptyRowsGrad")
.Name(("SparseFillEmptyRowsGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"reverse_index_map", ge::kIrInputRequired, ""},
{"grad_values", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y_value", ge::kIrOutputRequired, ""},
{"y_default_value", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(reverse_index_map->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad_values->GetAnchor(), node->GetInDataAnchor(1)));
return EsSparseFillEmptyRowsGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsSparseReduceMax(EsbTensor *x_indices, EsbTensor *x_values, EsbTensor *x_shape, EsbTensor *reduction_axes, bool keep_dims) {
GE_ASSERT_NOTNULL(x_indices);
GE_ASSERT_NOTNULL(x_values);
GE_ASSERT_NOTNULL(x_shape);
GE_ASSERT_NOTNULL(reduction_axes);
auto &graph = x_indices->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseReduceMax")
.Name(("SparseReduceMax_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x_indices", ge::kIrInputRequired, ""},
{"x_values", ge::kIrInputRequired, ""},
{"x_shape", ge::kIrInputRequired, ""},
{"reduction_axes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"keep_dims",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keep_dims))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x_indices->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x_values->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x_shape->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(reduction_axes->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsSparseReduceMaxSparseOutput EsSparseReduceMaxSparse(EsbTensor *x_indices, EsbTensor *x_values, EsbTensor *x_shape, EsbTensor *reduction_axes, bool keep_dims) {
GE_ASSERT_NOTNULL(x_indices);
GE_ASSERT_NOTNULL(x_values);
GE_ASSERT_NOTNULL(x_shape);
GE_ASSERT_NOTNULL(reduction_axes);
auto &graph = x_indices->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseReduceMaxSparse")
.Name(("SparseReduceMaxSparse_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x_indices", ge::kIrInputRequired, ""},
{"x_values", ge::kIrInputRequired, ""},
{"x_shape", ge::kIrInputRequired, ""},
{"reduction_axes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y_indices", ge::kIrOutputRequired, ""},
{"y_values", ge::kIrOutputRequired, ""},
{"y_shape", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"keep_dims",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keep_dims))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x_indices->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x_values->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x_shape->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(reduction_axes->GetAnchor(), node->GetInDataAnchor(3)));
return EsSparseReduceMaxSparseOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsSparseReduceSum(EsbTensor *x_indices, EsbTensor *x_values, EsbTensor *x_shape, EsbTensor *reduction_axes, bool keep_dims) {
GE_ASSERT_NOTNULL(x_indices);
GE_ASSERT_NOTNULL(x_values);
GE_ASSERT_NOTNULL(x_shape);
GE_ASSERT_NOTNULL(reduction_axes);
auto &graph = x_indices->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseReduceSum")
.Name(("SparseReduceSum_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x_indices", ge::kIrInputRequired, ""},
{"x_values", ge::kIrInputRequired, ""},
{"x_shape", ge::kIrInputRequired, ""},
{"reduction_axes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"keep_dims",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keep_dims))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x_indices->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x_values->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x_shape->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(reduction_axes->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsSparseReduceSumSparseOutput EsSparseReduceSumSparse(EsbTensor *x_indices, EsbTensor *x_values, EsbTensor *x_shape, EsbTensor *reduction_axes, bool keep_dims) {
GE_ASSERT_NOTNULL(x_indices);
GE_ASSERT_NOTNULL(x_values);
GE_ASSERT_NOTNULL(x_shape);
GE_ASSERT_NOTNULL(reduction_axes);
auto &graph = x_indices->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseReduceSumSparse")
.Name(("SparseReduceSumSparse_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x_indices", ge::kIrInputRequired, ""},
{"x_values", ge::kIrInputRequired, ""},
{"x_shape", ge::kIrInputRequired, ""},
{"reduction_axes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y_indices", ge::kIrOutputRequired, ""},
{"y_values", ge::kIrOutputRequired, ""},
{"y_shape", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"keep_dims",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keep_dims))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x_indices->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x_values->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x_shape->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(reduction_axes->GetAnchor(), node->GetInDataAnchor(3)));
return EsSparseReduceSumSparseOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsSparseReorderOutput EsSparseReorder(EsbTensor *indices, EsbTensor *values, EsbTensor *shape) {
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(values);
GE_ASSERT_NOTNULL(shape);
auto &graph = indices->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseReorder")
.Name(("SparseReorder_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"indices", ge::kIrInputRequired, ""},
{"values", ge::kIrInputRequired, ""},
{"shape", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y_indices", ge::kIrOutputRequired, ""},
{"y_values", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(values->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(2)));
return EsSparseReorderOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsSparseReshapeOutput EsSparseReshape(EsbTensor *indices, EsbTensor *shape, EsbTensor *new_shape) {
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(shape);
GE_ASSERT_NOTNULL(new_shape);
auto &graph = indices->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseReshape")
.Name(("SparseReshape_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"indices", ge::kIrInputRequired, ""},
{"shape", ge::kIrInputRequired, ""},
{"new_shape", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y_indices", ge::kIrOutputRequired, ""},
{"y_shape", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(new_shape->GetAnchor(), node->GetInDataAnchor(2)));
return EsSparseReshapeOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsSparseSegmentMean(EsbTensor *x, EsbTensor *indices, EsbTensor *segment_ids) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(segment_ids);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseSegmentMean")
.Name(("SparseSegmentMean_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"segment_ids", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(segment_ids->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSparseSegmentMeanGrad(EsbTensor *x, EsbTensor *indices, EsbTensor *segment_ids, EsbTensor *output_dim0) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(segment_ids);
GE_ASSERT_NOTNULL(output_dim0);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseSegmentMeanGrad")
.Name(("SparseSegmentMeanGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"segment_ids", ge::kIrInputRequired, ""},
{"output_dim0", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(segment_ids->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(output_dim0->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSparseSegmentSum(EsbTensor *x, EsbTensor *indices, EsbTensor *segment_ids) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(segment_ids);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseSegmentSum")
.Name(("SparseSegmentSum_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"segment_ids", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(segment_ids->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSparseSegmentSumGrad(EsbTensor *grad, EsbTensor *indices, EsbTensor *segment_ids, EsbTensor *output_dim0) {
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(segment_ids);
GE_ASSERT_NOTNULL(output_dim0);
auto &graph = grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseSegmentSumGrad")
.Name(("SparseSegmentSumGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grad", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"segment_ids", ge::kIrInputRequired, ""},
{"output_dim0", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(segment_ids->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(output_dim0->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsSparseSliceOutput EsSparseSlice(EsbTensor *indices, EsbTensor *values, EsbTensor *shape, EsbTensor *start, EsbTensor *size) {
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(values);
GE_ASSERT_NOTNULL(shape);
GE_ASSERT_NOTNULL(start);
GE_ASSERT_NOTNULL(size);
auto &graph = indices->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseSlice")
.Name(("SparseSlice_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"indices", ge::kIrInputRequired, ""},
{"values", ge::kIrInputRequired, ""},
{"shape", ge::kIrInputRequired, ""},
{"start", ge::kIrInputRequired, ""},
{"size", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y_indices", ge::kIrOutputRequired, ""},
{"y_values", ge::kIrOutputRequired, ""},
{"y_shape", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(values->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(start->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(size->GetAnchor(), node->GetInDataAnchor(4)));
return EsSparseSliceOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsSparseSliceGrad(EsbTensor *backprop_val_grad, EsbTensor *indices, EsbTensor *start, EsbTensor *new_indices) {
GE_ASSERT_NOTNULL(backprop_val_grad);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(start);
GE_ASSERT_NOTNULL(new_indices);
auto &graph = backprop_val_grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseSliceGrad")
.Name(("SparseSliceGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"backprop_val_grad", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"start", ge::kIrInputRequired, ""},
{"new_indices", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y_grad", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(backprop_val_grad->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(start->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(new_indices->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSparseSoftmax(EsbTensor *indices, EsbTensor *values, EsbTensor *shape) {
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(values);
GE_ASSERT_NOTNULL(shape);
auto &graph = indices->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseSoftmax")
.Name(("SparseSoftmax_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"indices", ge::kIrInputRequired, ""},
{"values", ge::kIrInputRequired, ""},
{"shape", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(values->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsSparseSoftmaxCrossEntropyWithLogitsOutput EsSparseSoftmaxCrossEntropyWithLogits(EsbTensor *features, EsbTensor *labels) {
GE_ASSERT_NOTNULL(features);
GE_ASSERT_NOTNULL(labels);
auto &graph = features->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseSoftmaxCrossEntropyWithLogits")
.Name(("SparseSoftmaxCrossEntropyWithLogits_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"features", ge::kIrInputRequired, ""},
{"labels", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"loss", ge::kIrOutputRequired, ""},
{"backprop", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(features->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(labels->GetAnchor(), node->GetInDataAnchor(1)));
return EsSparseSoftmaxCrossEntropyWithLogitsOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsSparseSparseMaximumOutput EsSparseSparseMaximum(EsbTensor *x1_indices, EsbTensor *x1_values, EsbTensor *x1_shape, EsbTensor *x2_indices, EsbTensor *x2_values, EsbTensor *x2_shape) {
GE_ASSERT_NOTNULL(x1_indices);
GE_ASSERT_NOTNULL(x1_values);
GE_ASSERT_NOTNULL(x1_shape);
GE_ASSERT_NOTNULL(x2_indices);
GE_ASSERT_NOTNULL(x2_values);
GE_ASSERT_NOTNULL(x2_shape);
auto &graph = x1_indices->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseSparseMaximum")
.Name(("SparseSparseMaximum_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1_indices", ge::kIrInputRequired, ""},
{"x1_values", ge::kIrInputRequired, ""},
{"x1_shape", ge::kIrInputRequired, ""},
{"x2_indices", ge::kIrInputRequired, ""},
{"x2_values", ge::kIrInputRequired, ""},
{"x2_shape", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y_indices", ge::kIrOutputRequired, ""},
{"y_values", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1_indices->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1_values->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1_shape->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2_indices->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2_values->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2_shape->GetAnchor(), node->GetInDataAnchor(5)));
return EsSparseSparseMaximumOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsSparseSparseMinimumOutput EsSparseSparseMinimum(EsbTensor *x1_indices, EsbTensor *x1_values, EsbTensor *x1_shape, EsbTensor *x2_indices, EsbTensor *x2_values, EsbTensor *x2_shape) {
GE_ASSERT_NOTNULL(x1_indices);
GE_ASSERT_NOTNULL(x1_values);
GE_ASSERT_NOTNULL(x1_shape);
GE_ASSERT_NOTNULL(x2_indices);
GE_ASSERT_NOTNULL(x2_values);
GE_ASSERT_NOTNULL(x2_shape);
auto &graph = x1_indices->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseSparseMinimum")
.Name(("SparseSparseMinimum_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1_indices", ge::kIrInputRequired, ""},
{"x1_values", ge::kIrInputRequired, ""},
{"x1_shape", ge::kIrInputRequired, ""},
{"x2_indices", ge::kIrInputRequired, ""},
{"x2_values", ge::kIrInputRequired, ""},
{"x2_shape", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y_indices", ge::kIrOutputRequired, ""},
{"y_values", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1_indices->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1_values->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1_shape->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2_indices->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2_values->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2_shape->GetAnchor(), node->GetInDataAnchor(5)));
return EsSparseSparseMinimumOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsSparseTensorDenseAdd(EsbTensor *x1_indices, EsbTensor *x1_values, EsbTensor *x1_shape, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1_indices);
GE_ASSERT_NOTNULL(x1_values);
GE_ASSERT_NOTNULL(x1_shape);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1_indices->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseTensorDenseAdd")
.Name(("SparseTensorDenseAdd_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1_indices", ge::kIrInputRequired, ""},
{"x1_values", ge::kIrInputRequired, ""},
{"x1_shape", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1_indices->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1_values->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1_shape->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSparseTensorDenseMatMul(EsbTensor *x1_indices, EsbTensor *x1_values, EsbTensor *x1_shape, EsbTensor *x2, bool adjoint_a, bool adjoint_b) {
GE_ASSERT_NOTNULL(x1_indices);
GE_ASSERT_NOTNULL(x1_values);
GE_ASSERT_NOTNULL(x1_shape);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1_indices->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseTensorDenseMatMul")
.Name(("SparseTensorDenseMatMul_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1_indices", ge::kIrInputRequired, ""},
{"x1_values", ge::kIrInputRequired, ""},
{"x1_shape", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"adjoint_a",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(adjoint_a))
},
{
"adjoint_b",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(adjoint_b))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1_indices->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1_values->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1_shape->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSparseToDense(EsbTensor *indices, EsbTensor *output_shape, EsbTensor *values, EsbTensor *default_value, bool validate_indices) {
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(output_shape);
GE_ASSERT_NOTNULL(values);
GE_ASSERT_NOTNULL(default_value);
auto &graph = indices->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseToDense")
.Name(("SparseToDense_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"indices", ge::kIrInputRequired, ""},
{"output_shape", ge::kIrInputRequired, ""},
{"values", ge::kIrInputRequired, ""},
{"default_value", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"validate_indices",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(validate_indices))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(output_shape->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(values->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(default_value->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsSparseToSparseSetOperationOutput EsSparseToSparseSetOperation(EsbTensor *x1_indices, EsbTensor *x1_values, EsbTensor *x1_shape, EsbTensor *x2_indices, EsbTensor *x2_values, EsbTensor *x2_shape, const char *set_operation, bool validate_indices) {
GE_ASSERT_NOTNULL(x1_indices);
GE_ASSERT_NOTNULL(x1_values);
GE_ASSERT_NOTNULL(x1_shape);
GE_ASSERT_NOTNULL(x2_indices);
GE_ASSERT_NOTNULL(x2_values);
GE_ASSERT_NOTNULL(x2_shape);
auto &graph = x1_indices->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SparseToSparseSetOperation")
.Name(("SparseToSparseSetOperation_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1_indices", ge::kIrInputRequired, ""},
{"x1_values", ge::kIrInputRequired, ""},
{"x1_shape", ge::kIrInputRequired, ""},
{"x2_indices", ge::kIrInputRequired, ""},
{"x2_values", ge::kIrInputRequired, ""},
{"x2_shape", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y_indices", ge::kIrOutputRequired, ""},
{"y_values", ge::kIrOutputRequired, ""},
{"y_shape", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"set_operation",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(set_operation))
},
{
"validate_indices",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(validate_indices))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1_indices->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1_values->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1_shape->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2_indices->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2_values->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2_shape->GetAnchor(), node->GetInDataAnchor(5)));
return EsSparseToSparseSetOperationOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsSpatialTransformer(EsbTensor *x, EsbTensor *theta, const int64_t *output_size, int64_t output_size_num, const float *default_theta, int64_t default_theta_num, bool align_corners, const int64_t *use_default_theta, int64_t use_default_theta_num) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SpatialTransformer")
.Name(("SpatialTransformer_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"theta", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"output_size",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(output_size, output_size + output_size_num))
},
{
"default_theta",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(default_theta, default_theta + default_theta_num))
},
{
"align_corners",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(align_corners))
},
{
"use_default_theta",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(use_default_theta, use_default_theta + use_default_theta_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
if (theta != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(theta->GetAnchor(), node->GetInDataAnchor(1)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSpatialTransformerD(EsbTensor *x, EsbTensor *theta, const int64_t *output_size, int64_t output_size_num, const float *default_theta, int64_t default_theta_num, bool align_corners, const bool *use_default_theta, int64_t use_default_theta_num) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SpatialTransformerD")
.Name(("SpatialTransformerD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"theta", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"output_size",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(output_size, output_size + output_size_num))
},
{
"default_theta",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(default_theta, default_theta + default_theta_num))
},
{
"align_corners",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(align_corners))
},
{
"use_default_theta",
ge::kAttrOptional,
"VT_LIST_BOOL",
ge::AnyValue::CreateFrom(std::vector<bool>(use_default_theta, use_default_theta + use_default_theta_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
if (theta != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(theta->GetAnchor(), node->GetInDataAnchor(1)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSpence(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Spence")
.Name(("Spence_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSplitToSequence(EsbTensor *x, EsbTensor *split, int64_t axis, bool keepdims) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SplitToSequence")
.Name(("SplitToSequence_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"split", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"handle", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
{
"keepdims",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keepdims))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
if (split != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(split->GetAnchor(), node->GetInDataAnchor(1)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSqrt(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Sqrt")
.Name(("Sqrt_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSqrtGrad(EsbTensor *y, EsbTensor *dy) {
GE_ASSERT_NOTNULL(y);
GE_ASSERT_NOTNULL(dy);
auto &graph = y->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SqrtGrad")
.Name(("SqrtGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"y", ge::kIrInputRequired, ""},
{"dy", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"z", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSquare(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Square")
.Name(("Square_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsSquareSumAllOutput EsSquareSumAll(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SquareSumAll")
.Name(("SquareSumAll_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y1", ge::kIrOutputRequired, ""},
{"y2", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return EsSquareSumAllOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsSquareSumV1(EsbTensor *x, const int64_t *axis, int64_t axis_num, bool keep_dims) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SquareSumV1")
.Name(("SquareSumV1_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(axis, axis + axis_num))
},
{
"keep_dims",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keep_dims))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsSquareSumV2Output EsSquareSumV2(EsbTensor *x, const int64_t *axis, int64_t axis_num, bool keep_dims) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SquareSumV2")
.Name(("SquareSumV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y1", ge::kIrOutputRequired, ""},
{"y2", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(axis, axis + axis_num))
},
{
"keep_dims",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(keep_dims))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return EsSquareSumV2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsSquaredDifference(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SquaredDifference")
.Name(("SquaredDifference_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSqueeze(EsbTensor *x, const int64_t *axis, int64_t axis_num) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Squeeze")
.Name(("Squeeze_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(axis, axis + axis_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSqueezeV2(EsbTensor *x, const int64_t *axis, int64_t axis_num) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SqueezeV2")
.Name(("SqueezeV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(axis, axis + axis_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSqueezeV3(EsbTensor *x, EsbTensor *axes) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SqueezeV3")
.Name(("SqueezeV3_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"axes", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
if (axes != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(axes->GetAnchor(), node->GetInDataAnchor(1)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStack(EsbTensor *max_size, ge::DataType elem_type, const char *stack_name) {
GE_ASSERT_NOTNULL(max_size);
auto &graph = max_size->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Stack")
.Name(("Stack_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"max_size", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"handle", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"elem_type",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(elem_type))
},
{
"stack_name",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(stack_name))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(max_size->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStackBallQuery(EsbTensor *xyz, EsbTensor *center_xyz, EsbTensor *xyz_batch_cnt, EsbTensor *center_xyz_batch_cnt, float max_radius, int64_t sample_num) {
GE_ASSERT_NOTNULL(xyz);
GE_ASSERT_NOTNULL(center_xyz);
GE_ASSERT_NOTNULL(xyz_batch_cnt);
GE_ASSERT_NOTNULL(center_xyz_batch_cnt);
auto &graph = xyz->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StackBallQuery")
.Name(("StackBallQuery_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"xyz", ge::kIrInputRequired, ""},
{"center_xyz", ge::kIrInputRequired, ""},
{"xyz_batch_cnt", ge::kIrInputRequired, ""},
{"center_xyz_batch_cnt", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"idx", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"max_radius",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(max_radius))
},
{
"sample_num",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(sample_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(xyz->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(center_xyz->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(xyz_batch_cnt->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(center_xyz_batch_cnt->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStackClose(EsbTensor *handle) {
GE_ASSERT_NOTNULL(handle);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StackClose")
.Name(("StackClose_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsStackGroupPoints(EsbTensor *features, EsbTensor *features_batch_cnt, EsbTensor *indices, EsbTensor *indices_batch_cnt) {
GE_ASSERT_NOTNULL(features);
GE_ASSERT_NOTNULL(features_batch_cnt);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(indices_batch_cnt);
auto &graph = features->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StackGroupPoints")
.Name(("StackGroupPoints_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"features", ge::kIrInputRequired, ""},
{"features_batch_cnt", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"indices_batch_cnt", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(features->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(features_batch_cnt->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices_batch_cnt->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStackPop(EsbTensor *handle, ge::DataType elem_type) {
GE_ASSERT_NOTNULL(handle);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StackPop")
.Name(("StackPop_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"element", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"elem_type",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(elem_type))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStackPush(EsbTensor *handle, EsbTensor *element, bool swap_memory) {
GE_ASSERT_NOTNULL(handle);
GE_ASSERT_NOTNULL(element);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StackPush")
.Name(("StackPush_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
{"element", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"swap_memory",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(swap_memory))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(element->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStage(EsbTensor **values, int64_t values_num, int64_t capacity, int64_t memory_limit, const char *container, const char *shared_name) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(values_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < values_num; ++i) {
if (values[i] != nullptr) {
non_null_in = values[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Stage")
.Name(("Stage_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"values", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
{
"capacity",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(capacity))
},
{
"memory_limit",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(memory_limit))
},
{
"container",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(container))
},
{
"shared_name",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(shared_name))
},
})
.InstanceDynamicInputNum("values", static_cast<int32_t>(values_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((values != nullptr) && (values_num > 0)) {
for (int64_t i = 0; i < values_num; ++i) {
auto one_values = values[i];
GE_ASSERT_NOTNULL(one_values);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_values->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsStatefulRandomBinomial(EsbTensor *x, EsbTensor *algorithm, EsbTensor *shape, EsbTensor *counts, EsbTensor *probs, ge::DataType dtype) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(algorithm);
GE_ASSERT_NOTNULL(shape);
GE_ASSERT_NOTNULL(counts);
GE_ASSERT_NOTNULL(probs);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StatefulRandomBinomial")
.Name(("StatefulRandomBinomial_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"algorithm", ge::kIrInputRequired, ""},
{"shape", ge::kIrInputRequired, ""},
{"counts", ge::kIrInputRequired, ""},
{"probs", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(algorithm->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(counts->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(probs->GetAnchor(), node->GetInDataAnchor(4)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStatefulStandardNormalV2(EsbTensor *x, EsbTensor *algorithm, EsbTensor *shape) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(algorithm);
GE_ASSERT_NOTNULL(shape);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StatefulStandardNormalV2")
.Name(("StatefulStandardNormalV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"algorithm", ge::kIrInputRequired, ""},
{"shape", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(algorithm->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStatefulTruncatedNormal(EsbTensor *x, EsbTensor *algorithm, EsbTensor *shape) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(algorithm);
GE_ASSERT_NOTNULL(shape);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StatefulTruncatedNormal")
.Name(("StatefulTruncatedNormal_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"algorithm", ge::kIrInputRequired, ""},
{"shape", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(algorithm->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStatefulUniform(EsbTensor *x, EsbTensor *algorithm, EsbTensor *shape) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(algorithm);
GE_ASSERT_NOTNULL(shape);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StatefulUniform")
.Name(("StatefulUniform_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"algorithm", ge::kIrInputRequired, ""},
{"shape", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(algorithm->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStatefulUniformFullInt(EsbTensor *x, EsbTensor *algorithm, EsbTensor *shape) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(algorithm);
GE_ASSERT_NOTNULL(shape);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StatefulUniformFullInt")
.Name(("StatefulUniformFullInt_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"algorithm", ge::kIrInputRequired, ""},
{"shape", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(algorithm->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStatefulUniformInt(EsbTensor *x, EsbTensor *algorithm, EsbTensor *shape, EsbTensor *minval, EsbTensor *maxval) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(algorithm);
GE_ASSERT_NOTNULL(shape);
GE_ASSERT_NOTNULL(minval);
GE_ASSERT_NOTNULL(maxval);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StatefulUniformInt")
.Name(("StatefulUniformInt_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"algorithm", ge::kIrInputRequired, ""},
{"shape", ge::kIrInputRequired, ""},
{"minval", ge::kIrInputRequired, ""},
{"maxval", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(algorithm->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(minval->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(maxval->GetAnchor(), node->GetInDataAnchor(4)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStatelessBernoulli(EsbTensor *shape, EsbTensor *prob, EsbTensor *seed, EsbTensor *offset, ge::DataType dtype) {
GE_ASSERT_NOTNULL(shape);
GE_ASSERT_NOTNULL(prob);
GE_ASSERT_NOTNULL(seed);
GE_ASSERT_NOTNULL(offset);
auto &graph = shape->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StatelessBernoulli")
.Name(("StatelessBernoulli_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"shape", ge::kIrInputRequired, ""},
{"prob", ge::kIrInputRequired, ""},
{"seed", ge::kIrInputRequired, ""},
{"offset", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(prob->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seed->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStatelessBernoulliV2(EsbTensor *x, EsbTensor *seed, EsbTensor *offset, ge::DataType dtype) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(seed);
GE_ASSERT_NOTNULL(offset);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StatelessBernoulliV2")
.Name(("StatelessBernoulliV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"seed", ge::kIrInputRequired, ""},
{"offset", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seed->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStatelessDropOutGenMask(EsbTensor *shape, EsbTensor *prob, EsbTensor *seed, EsbTensor *seed1, EsbTensor *offset) {
GE_ASSERT_NOTNULL(shape);
GE_ASSERT_NOTNULL(prob);
GE_ASSERT_NOTNULL(seed);
GE_ASSERT_NOTNULL(seed1);
auto &graph = shape->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StatelessDropOutGenMask")
.Name(("StatelessDropOutGenMask_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"shape", ge::kIrInputRequired, ""},
{"prob", ge::kIrInputRequired, ""},
{"seed", ge::kIrInputRequired, ""},
{"seed1", ge::kIrInputRequired, ""},
{"offset", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(prob->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seed->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seed1->GetAnchor(), node->GetInDataAnchor(3)));
if (offset != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset->GetAnchor(), node->GetInDataAnchor(4)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStatelessMultinomial(EsbTensor *logits, EsbTensor *num_samples, EsbTensor *seed, ge::DataType output_dtype) {
GE_ASSERT_NOTNULL(logits);
GE_ASSERT_NOTNULL(num_samples);
GE_ASSERT_NOTNULL(seed);
auto &graph = logits->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StatelessMultinomial")
.Name(("StatelessMultinomial_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"logits", ge::kIrInputRequired, ""},
{"num_samples", ge::kIrInputRequired, ""},
{"seed", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"output_dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(output_dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(logits->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(num_samples->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seed->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStatelessParameterizedTruncatedNormal(EsbTensor *shape, EsbTensor *seed, EsbTensor *means, EsbTensor *stdevs, EsbTensor *min, EsbTensor *max) {
GE_ASSERT_NOTNULL(shape);
GE_ASSERT_NOTNULL(seed);
GE_ASSERT_NOTNULL(means);
GE_ASSERT_NOTNULL(stdevs);
GE_ASSERT_NOTNULL(min);
GE_ASSERT_NOTNULL(max);
auto &graph = shape->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StatelessParameterizedTruncatedNormal")
.Name(("StatelessParameterizedTruncatedNormal_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"shape", ge::kIrInputRequired, ""},
{"seed", ge::kIrInputRequired, ""},
{"means", ge::kIrInputRequired, ""},
{"stdevs", ge::kIrInputRequired, ""},
{"min", ge::kIrInputRequired, ""},
{"max", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seed->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(means->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(stdevs->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(min->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(max->GetAnchor(), node->GetInDataAnchor(5)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStatelessRandomBinomial(EsbTensor *shape, EsbTensor *seed, EsbTensor *counts, EsbTensor *probs, ge::DataType dtype) {
GE_ASSERT_NOTNULL(shape);
GE_ASSERT_NOTNULL(seed);
GE_ASSERT_NOTNULL(counts);
GE_ASSERT_NOTNULL(probs);
auto &graph = shape->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StatelessRandomBinomial")
.Name(("StatelessRandomBinomial_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"shape", ge::kIrInputRequired, ""},
{"seed", ge::kIrInputRequired, ""},
{"counts", ge::kIrInputRequired, ""},
{"probs", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seed->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(counts->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(probs->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStatelessRandomGammaV2(EsbTensor *shape, EsbTensor *seed, EsbTensor *alpha) {
GE_ASSERT_NOTNULL(shape);
GE_ASSERT_NOTNULL(seed);
GE_ASSERT_NOTNULL(alpha);
auto &graph = shape->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StatelessRandomGammaV2")
.Name(("StatelessRandomGammaV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"shape", ge::kIrInputRequired, ""},
{"seed", ge::kIrInputRequired, ""},
{"alpha", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seed->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(alpha->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStatelessRandomGetAlg(EsbGraph *owner_graph) {
GE_ASSERT_NOTNULL(owner_graph);
EsbGraph &graph = *owner_graph;

auto desc = ge::CompliantOpDescBuilder().OpType("StatelessRandomGetAlg")
.Name(("StatelessRandomGetAlg_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
})
.IrDefOutputs({
{"alg", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsStatelessRandomGetKeyCounterOutput EsStatelessRandomGetKeyCounter(EsbTensor *seed) {
GE_ASSERT_NOTNULL(seed);
auto &graph = seed->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StatelessRandomGetKeyCounter")
.Name(("StatelessRandomGetKeyCounter_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"seed", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"key", ge::kIrOutputRequired, ""},
{"counter", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seed->GetAnchor(), node->GetInDataAnchor(0)));
return EsStatelessRandomGetKeyCounterOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsStatelessRandomGetKeyCounterAlgOutput EsStatelessRandomGetKeyCounterAlg(EsbTensor *seed) {
GE_ASSERT_NOTNULL(seed);
auto &graph = seed->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StatelessRandomGetKeyCounterAlg")
.Name(("StatelessRandomGetKeyCounterAlg_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"seed", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"key", ge::kIrOutputRequired, ""},
{"counter", ge::kIrOutputRequired, ""},
{"alg", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seed->GetAnchor(), node->GetInDataAnchor(0)));
return EsStatelessRandomGetKeyCounterAlgOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsStatelessRandomNormalV2(EsbTensor *shape, EsbTensor *key, EsbTensor *counter, EsbTensor *alg, ge::DataType dtype) {
GE_ASSERT_NOTNULL(shape);
GE_ASSERT_NOTNULL(key);
GE_ASSERT_NOTNULL(counter);
GE_ASSERT_NOTNULL(alg);
auto &graph = shape->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StatelessRandomNormalV2")
.Name(("StatelessRandomNormalV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"shape", ge::kIrInputRequired, ""},
{"key", ge::kIrInputRequired, ""},
{"counter", ge::kIrInputRequired, ""},
{"alg", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(key->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(counter->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(alg->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStatelessRandomPoisson(EsbTensor *shape, EsbTensor *seed, EsbTensor *lam, ge::DataType dtype) {
GE_ASSERT_NOTNULL(shape);
GE_ASSERT_NOTNULL(seed);
GE_ASSERT_NOTNULL(lam);
auto &graph = shape->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StatelessRandomPoisson")
.Name(("StatelessRandomPoisson_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"shape", ge::kIrInputRequired, ""},
{"seed", ge::kIrInputRequired, ""},
{"lam", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seed->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lam->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStatelessRandomUniformFullInt(EsbTensor *shape, EsbTensor *seed, ge::DataType dtype) {
GE_ASSERT_NOTNULL(shape);
GE_ASSERT_NOTNULL(seed);
auto &graph = shape->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StatelessRandomUniformFullInt")
.Name(("StatelessRandomUniformFullInt_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"shape", ge::kIrInputRequired, ""},
{"seed", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seed->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStatelessRandomUniformFullIntV2(EsbTensor *shape, EsbTensor *key, EsbTensor *counter, EsbTensor *alg, ge::DataType dtype) {
GE_ASSERT_NOTNULL(shape);
GE_ASSERT_NOTNULL(key);
GE_ASSERT_NOTNULL(counter);
GE_ASSERT_NOTNULL(alg);
auto &graph = shape->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StatelessRandomUniformFullIntV2")
.Name(("StatelessRandomUniformFullIntV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"shape", ge::kIrInputRequired, ""},
{"key", ge::kIrInputRequired, ""},
{"counter", ge::kIrInputRequired, ""},
{"alg", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(key->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(counter->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(alg->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStatelessRandomUniformInt(EsbTensor *shape, EsbTensor *seed, EsbTensor *minval, EsbTensor *maxval) {
GE_ASSERT_NOTNULL(shape);
GE_ASSERT_NOTNULL(seed);
GE_ASSERT_NOTNULL(minval);
GE_ASSERT_NOTNULL(maxval);
auto &graph = shape->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StatelessRandomUniformInt")
.Name(("StatelessRandomUniformInt_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"shape", ge::kIrInputRequired, ""},
{"seed", ge::kIrInputRequired, ""},
{"minval", ge::kIrInputRequired, ""},
{"maxval", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seed->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(minval->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(maxval->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStatelessRandomUniformIntV2(EsbTensor *shape, EsbTensor *key, EsbTensor *counter, EsbTensor *alg, EsbTensor *minval, EsbTensor *maxval) {
GE_ASSERT_NOTNULL(shape);
GE_ASSERT_NOTNULL(key);
GE_ASSERT_NOTNULL(counter);
GE_ASSERT_NOTNULL(alg);
GE_ASSERT_NOTNULL(minval);
GE_ASSERT_NOTNULL(maxval);
auto &graph = shape->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StatelessRandomUniformIntV2")
.Name(("StatelessRandomUniformIntV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"shape", ge::kIrInputRequired, ""},
{"key", ge::kIrInputRequired, ""},
{"counter", ge::kIrInputRequired, ""},
{"alg", ge::kIrInputRequired, ""},
{"minval", ge::kIrInputRequired, ""},
{"maxval", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(key->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(counter->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(alg->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(minval->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(maxval->GetAnchor(), node->GetInDataAnchor(5)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStatelessRandomUniformV2(EsbTensor *shape, EsbTensor *key, EsbTensor *counter, EsbTensor *alg, ge::DataType dtype) {
GE_ASSERT_NOTNULL(shape);
GE_ASSERT_NOTNULL(key);
GE_ASSERT_NOTNULL(counter);
GE_ASSERT_NOTNULL(alg);
auto &graph = shape->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StatelessRandomUniformV2")
.Name(("StatelessRandomUniformV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"shape", ge::kIrInputRequired, ""},
{"key", ge::kIrInputRequired, ""},
{"counter", ge::kIrInputRequired, ""},
{"alg", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(key->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(counter->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(alg->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStatelessRandperm(EsbTensor *n, EsbTensor *seed, EsbTensor *offset, int64_t layout, ge::DataType dtype) {
GE_ASSERT_NOTNULL(n);
GE_ASSERT_NOTNULL(seed);
GE_ASSERT_NOTNULL(offset);
auto &graph = n->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StatelessRandperm")
.Name(("StatelessRandperm_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"n", ge::kIrInputRequired, ""},
{"seed", ge::kIrInputRequired, ""},
{"offset", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"layout",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(layout))
},
{
"dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(n->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seed->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsStatelessSampleDistortedBoundingBoxOutput EsStatelessSampleDistortedBoundingBox(EsbTensor *image_size, EsbTensor *bounding_boxes, EsbTensor *min_object_covered, EsbTensor *seed, const float *aspect_ratio_range, int64_t aspect_ratio_range_num, const float *area_range, int64_t area_range_num, int64_t max_attempts, bool use_image_if_no_bounding_boxes) {
GE_ASSERT_NOTNULL(image_size);
GE_ASSERT_NOTNULL(bounding_boxes);
GE_ASSERT_NOTNULL(min_object_covered);
GE_ASSERT_NOTNULL(seed);
auto &graph = image_size->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StatelessSampleDistortedBoundingBox")
.Name(("StatelessSampleDistortedBoundingBox_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"image_size", ge::kIrInputRequired, ""},
{"bounding_boxes", ge::kIrInputRequired, ""},
{"min_object_covered", ge::kIrInputRequired, ""},
{"seed", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"begin", ge::kIrOutputRequired, ""},
{"size", ge::kIrOutputRequired, ""},
{"bboxes", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"aspect_ratio_range",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(aspect_ratio_range, aspect_ratio_range + aspect_ratio_range_num))
},
{
"area_range",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(area_range, area_range + area_range_num))
},
{
"max_attempts",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(max_attempts))
},
{
"use_image_if_no_bounding_boxes",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(use_image_if_no_bounding_boxes))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(image_size->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bounding_boxes->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(min_object_covered->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(seed->GetAnchor(), node->GetInDataAnchor(3)));
return EsStatelessSampleDistortedBoundingBoxOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsStatelessTruncatedNormalV2(EsbTensor *shape, EsbTensor *key, EsbTensor *counter, EsbTensor *alg, ge::DataType dtype) {
GE_ASSERT_NOTNULL(shape);
GE_ASSERT_NOTNULL(key);
GE_ASSERT_NOTNULL(counter);
GE_ASSERT_NOTNULL(alg);
auto &graph = shape->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StatelessTruncatedNormalV2")
.Name(("StatelessTruncatedNormalV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"shape", ge::kIrInputRequired, ""},
{"key", ge::kIrInputRequired, ""},
{"counter", ge::kIrInputRequired, ""},
{"alg", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(key->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(counter->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(alg->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStaticRegexFullMatch(EsbTensor *input, const char *pattern) {
GE_ASSERT_NOTNULL(input);
auto &graph = input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StaticRegexFullMatch")
.Name(("StaticRegexFullMatch_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"pattern",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(pattern))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStaticRegexReplace(EsbTensor *input, const char *pattern, const char *rewrite, bool replace_global) {
GE_ASSERT_NOTNULL(input);
auto &graph = input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StaticRegexReplace")
.Name(("StaticRegexReplace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"pattern",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(pattern))
},
{
"rewrite",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(rewrite))
},
{
"replace_global",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(replace_global))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStopGradient(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StopGradient")
.Name(("StopGradient_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStrideAdd(EsbTensor *x1, EsbTensor *x2, int64_t x1_c1_offset, int64_t x2_c1_offset, int64_t c1_len) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StrideAdd")
.Name(("StrideAdd_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"x1_c1_offset",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(x1_c1_offset))
},
{
"x2_c1_offset",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(x2_c1_offset))
},
{
"c1_len",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(c1_len))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStridedRead(EsbTensor *x, int64_t axis, int64_t stride) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StridedRead")
.Name(("StridedRead_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
{
"stride",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(stride))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStridedSlice(EsbTensor *x, EsbTensor *begin, EsbTensor *end, EsbTensor *strides, int64_t begin_mask, int64_t end_mask, int64_t ellipsis_mask, int64_t new_axis_mask, int64_t shrink_axis_mask) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(begin);
GE_ASSERT_NOTNULL(end);
GE_ASSERT_NOTNULL(strides);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StridedSlice")
.Name(("StridedSlice_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"begin", ge::kIrInputRequired, ""},
{"end", ge::kIrInputRequired, ""},
{"strides", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"begin_mask",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(begin_mask))
},
{
"end_mask",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(end_mask))
},
{
"ellipsis_mask",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(ellipsis_mask))
},
{
"new_axis_mask",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(new_axis_mask))
},
{
"shrink_axis_mask",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(shrink_axis_mask))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(begin->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(end->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(strides->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStridedSliceAssign(EsbTensor *var, EsbTensor *begin, EsbTensor *end, EsbTensor *strides, EsbTensor *input_value, int64_t begin_mask, int64_t end_mask, int64_t ellipsis_mask, int64_t new_axis_mask, int64_t shrink_axis_mask) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(begin);
GE_ASSERT_NOTNULL(end);
GE_ASSERT_NOTNULL(strides);
GE_ASSERT_NOTNULL(input_value);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StridedSliceAssign")
.Name(("StridedSliceAssign_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"begin", ge::kIrInputRequired, ""},
{"end", ge::kIrInputRequired, ""},
{"strides", ge::kIrInputRequired, ""},
{"input_value", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"begin_mask",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(begin_mask))
},
{
"end_mask",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(end_mask))
},
{
"ellipsis_mask",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(ellipsis_mask))
},
{
"new_axis_mask",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(new_axis_mask))
},
{
"shrink_axis_mask",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(shrink_axis_mask))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(begin->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(end->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(strides->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_value->GetAnchor(), node->GetInDataAnchor(4)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStridedSliceAssignD(EsbTensor *var, EsbTensor *input_value, const int64_t *begin, int64_t begin_num, const int64_t *end, int64_t end_num, const int64_t *strides, int64_t strides_num, int64_t begin_mask, int64_t end_mask, int64_t ellipsis_mask, int64_t new_axis_mask, int64_t shrink_axis_mask) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(input_value);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StridedSliceAssignD")
.Name(("StridedSliceAssignD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"input_value", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"begin",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(begin, begin + begin_num))
},
{
"end",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(end, end + end_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"begin_mask",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(begin_mask))
},
{
"end_mask",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(end_mask))
},
{
"ellipsis_mask",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(ellipsis_mask))
},
{
"new_axis_mask",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(new_axis_mask))
},
{
"shrink_axis_mask",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(shrink_axis_mask))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_value->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStridedSliceAssignV2(EsbTensor *var, EsbTensor *input_value, EsbTensor *begin, EsbTensor *end, EsbTensor *strides, EsbTensor *axes) {
GE_ASSERT_NOTNULL(var);
GE_ASSERT_NOTNULL(input_value);
GE_ASSERT_NOTNULL(begin);
GE_ASSERT_NOTNULL(end);
GE_ASSERT_NOTNULL(strides);
auto &graph = var->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StridedSliceAssignV2")
.Name(("StridedSliceAssignV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"var", ge::kIrInputRequired, ""},
{"input_value", ge::kIrInputRequired, ""},
{"begin", ge::kIrInputRequired, ""},
{"end", ge::kIrInputRequired, ""},
{"strides", ge::kIrInputRequired, ""},
{"axes", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"var", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(var->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_value->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(begin->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(end->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(strides->GetAnchor(), node->GetInDataAnchor(4)));
if (axes != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(axes->GetAnchor(), node->GetInDataAnchor(5)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStridedSliceD(EsbTensor *x, const int64_t *begin, int64_t begin_num, const int64_t *end, int64_t end_num, const int64_t *strides, int64_t strides_num, int64_t begin_mask, int64_t end_mask, int64_t ellipsis_mask, int64_t new_axis_mask, int64_t shrink_axis_mask) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StridedSliceD")
.Name(("StridedSliceD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"begin",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(begin, begin + begin_num))
},
{
"end",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(end, end + end_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"begin_mask",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(begin_mask))
},
{
"end_mask",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(end_mask))
},
{
"ellipsis_mask",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(ellipsis_mask))
},
{
"new_axis_mask",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(new_axis_mask))
},
{
"shrink_axis_mask",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(shrink_axis_mask))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStridedSliceGrad(EsbTensor *shape, EsbTensor *begin, EsbTensor *end, EsbTensor *strides, EsbTensor *dy, int64_t begin_mask, int64_t end_mask, int64_t ellipsis_mask, int64_t new_axis_mask, int64_t shrink_axis_mask) {
GE_ASSERT_NOTNULL(shape);
GE_ASSERT_NOTNULL(begin);
GE_ASSERT_NOTNULL(end);
GE_ASSERT_NOTNULL(strides);
GE_ASSERT_NOTNULL(dy);
auto &graph = shape->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StridedSliceGrad")
.Name(("StridedSliceGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"shape", ge::kIrInputRequired, ""},
{"begin", ge::kIrInputRequired, ""},
{"end", ge::kIrInputRequired, ""},
{"strides", ge::kIrInputRequired, ""},
{"dy", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"begin_mask",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(begin_mask))
},
{
"end_mask",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(end_mask))
},
{
"ellipsis_mask",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(ellipsis_mask))
},
{
"new_axis_mask",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(new_axis_mask))
},
{
"shrink_axis_mask",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(shrink_axis_mask))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(begin->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(end->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(strides->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(4)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStridedSliceGradD(EsbTensor *dy, const int64_t *shape, int64_t shape_num, const int64_t *begin, int64_t begin_num, const int64_t *end, int64_t end_num, const int64_t *strides, int64_t strides_num, int64_t begin_mask, int64_t end_mask, int64_t ellipsis_mask, int64_t new_axis_mask, int64_t shrink_axis_mask) {
GE_ASSERT_NOTNULL(dy);
auto &graph = dy->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StridedSliceGradD")
.Name(("StridedSliceGradD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"dy", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"shape",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(shape, shape + shape_num))
},
{
"begin",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(begin, begin + begin_num))
},
{
"end",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(end, end + end_num))
},
{
"strides",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(strides, strides + strides_num))
},
{
"begin_mask",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(begin_mask))
},
{
"end_mask",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(end_mask))
},
{
"ellipsis_mask",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(ellipsis_mask))
},
{
"new_axis_mask",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(new_axis_mask))
},
{
"shrink_axis_mask",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(shrink_axis_mask))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStridedSliceV2(EsbTensor *x, EsbTensor *begin, EsbTensor *end, EsbTensor *axes, EsbTensor *strides, int64_t begin_mask, int64_t end_mask, int64_t ellipsis_mask, int64_t new_axis_mask, int64_t shrink_axis_mask) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(begin);
GE_ASSERT_NOTNULL(end);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StridedSliceV2")
.Name(("StridedSliceV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"begin", ge::kIrInputRequired, ""},
{"end", ge::kIrInputRequired, ""},
{"axes", ge::kIrInputOptional, ""},
{"strides", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"begin_mask",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(begin_mask))
},
{
"end_mask",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(end_mask))
},
{
"ellipsis_mask",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(ellipsis_mask))
},
{
"new_axis_mask",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(new_axis_mask))
},
{
"shrink_axis_mask",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(shrink_axis_mask))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(begin->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(end->GetAnchor(), node->GetInDataAnchor(2)));
if (axes != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(axes->GetAnchor(), node->GetInDataAnchor(3)));
}
if (strides != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(strides->GetAnchor(), node->GetInDataAnchor(4)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStridedSliceV3(EsbTensor *x, EsbTensor *begin, EsbTensor *end, EsbTensor *axes, EsbTensor *strides) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(begin);
GE_ASSERT_NOTNULL(end);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StridedSliceV3")
.Name(("StridedSliceV3_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"begin", ge::kIrInputRequired, ""},
{"end", ge::kIrInputRequired, ""},
{"axes", ge::kIrInputOptional, ""},
{"strides", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(begin->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(end->GetAnchor(), node->GetInDataAnchor(2)));
if (axes != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(axes->GetAnchor(), node->GetInDataAnchor(3)));
}
if (strides != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(strides->GetAnchor(), node->GetInDataAnchor(4)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStridedWrite(EsbTensor *x, int64_t axis, int64_t stride) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StridedWrite")
.Name(("StridedWrite_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
{
"stride",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(stride))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStringFormat(EsbTensor **x, int64_t x_num, const char *attr_template, const char *placeholder, int64_t summarize) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StringFormat")
.Name(("StringFormat_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"template",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(attr_template))
},
{
"placeholder",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(placeholder))
},
{
"summarize",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(summarize))
},
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStringJoin(EsbTensor **x, int64_t x_num, int64_t N, const char *separator) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StringJoin")
.Name(("StringJoin_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"N",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(N))
},
{
"separator",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(separator))
},
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStringLength(EsbTensor *x, const char *unit) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StringLength")
.Name(("StringLength_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"unit",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(unit))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStringLower(EsbTensor *input, const char *encoding) {
GE_ASSERT_NOTNULL(input);
auto &graph = input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StringLower")
.Name(("StringLower_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"encoding",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(encoding))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsStringNGramsOutput EsStringNGrams(EsbTensor *data, EsbTensor *data_splits, const char *separator, const char *left_pad, const char *right_pad, int64_t pad_width, bool preserve_short_sequences, const int64_t *ngram_widths, int64_t ngram_widths_num) {
GE_ASSERT_NOTNULL(data);
GE_ASSERT_NOTNULL(data_splits);
auto &graph = data->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StringNGrams")
.Name(("StringNGrams_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"data", ge::kIrInputRequired, ""},
{"data_splits", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"ngrams", ge::kIrOutputRequired, ""},
{"ngrams_splits", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"separator",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(separator))
},
{
"left_pad",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(left_pad))
},
{
"right_pad",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(right_pad))
},
{
"pad_width",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pad_width))
},
{
"preserve_short_sequences",
ge::kAttrRequired,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(preserve_short_sequences))
},
{
"ngram_widths",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ngram_widths, ngram_widths + ngram_widths_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(data->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(data_splits->GetAnchor(), node->GetInDataAnchor(1)));
return EsStringNGramsOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsStringSplitOutput EsStringSplit(EsbTensor *input, EsbTensor *delimiter, bool skip_empty) {
GE_ASSERT_NOTNULL(input);
GE_ASSERT_NOTNULL(delimiter);
auto &graph = input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StringSplit")
.Name(("StringSplit_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input", ge::kIrInputRequired, ""},
{"delimiter", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"indices", ge::kIrOutputRequired, ""},
{"values", ge::kIrOutputRequired, ""},
{"shape", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"skip_empty",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(skip_empty))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(delimiter->GetAnchor(), node->GetInDataAnchor(1)));
return EsStringSplitOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsStringSplitV2Output EsStringSplitV2(EsbTensor *input, EsbTensor *sep, int64_t maxsplit) {
GE_ASSERT_NOTNULL(input);
GE_ASSERT_NOTNULL(sep);
auto &graph = input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StringSplitV2")
.Name(("StringSplitV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input", ge::kIrInputRequired, ""},
{"sep", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"indices", ge::kIrOutputRequired, ""},
{"values", ge::kIrOutputRequired, ""},
{"shape", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"maxsplit",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(maxsplit))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sep->GetAnchor(), node->GetInDataAnchor(1)));
return EsStringSplitV2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsStringStrip(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StringStrip")
.Name(("StringStrip_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStringToHashBucket(EsbTensor *string_tensor, int64_t num_buckets) {
GE_ASSERT_NOTNULL(string_tensor);
auto &graph = string_tensor->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StringToHashBucket")
.Name(("StringToHashBucket_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"string_tensor", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_buckets",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_buckets))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(string_tensor->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStringToHashBucketFast(EsbTensor *x, int64_t num_buckets) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StringToHashBucketFast")
.Name(("StringToHashBucketFast_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_buckets",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_buckets))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStringToHashBucketStrong(EsbTensor *x, const int64_t *key, int64_t key_num, int64_t num_buckets) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StringToHashBucketStrong")
.Name(("StringToHashBucketStrong_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"key",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(key, key + key_num))
},
{
"num_buckets",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_buckets))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStringToNumber(EsbTensor *x, ge::DataType out_type) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StringToNumber")
.Name(("StringToNumber_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"out_type",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(out_type))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsStringUpper(EsbTensor *input, const char *encoding) {
GE_ASSERT_NOTNULL(input);
auto &graph = input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("StringUpper")
.Name(("StringUpper_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"encoding",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(encoding))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSub(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Sub")
.Name(("Sub_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSubSample(EsbTensor *labels, int64_t batch_size_per_images, float positive_fraction) {
GE_ASSERT_NOTNULL(labels);
auto &graph = labels->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SubSample")
.Name(("SubSample_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"labels", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"batch_size_per_images",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(batch_size_per_images))
},
{
"positive_fraction",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(positive_fraction))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(labels->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSubSampleLabels(EsbTensor *labels, EsbTensor *shuffle_matrix, int64_t batch_size_per_images, float positive_fraction) {
GE_ASSERT_NOTNULL(labels);
GE_ASSERT_NOTNULL(shuffle_matrix);
auto &graph = labels->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SubSampleLabels")
.Name(("SubSampleLabels_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"labels", ge::kIrInputRequired, ""},
{"shuffle_matrix", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"batch_size_per_images",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(batch_size_per_images))
},
{
"positive_fraction",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(positive_fraction))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(labels->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shuffle_matrix->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSubstr(EsbTensor *input, EsbTensor *pos, EsbTensor *len) {
GE_ASSERT_NOTNULL(input);
GE_ASSERT_NOTNULL(pos);
GE_ASSERT_NOTNULL(len);
auto &graph = input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Substr")
.Name(("Substr_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input", ge::kIrInputRequired, ""},
{"pos", ge::kIrInputRequired, ""},
{"len", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(pos->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(len->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSummary(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Summary")
.Name(("Summary_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsSvdOutput EsSvd(EsbTensor *x, bool compute_uv, bool full_matrices) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Svd")
.Name(("Svd_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"sigma", ge::kIrOutputRequired, ""},
{"u", ge::kIrOutputRequired, ""},
{"v", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"compute_uv",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(compute_uv))
},
{
"full_matrices",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(full_matrices))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return EsSvdOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsSwinAttentionFFN(EsbTensor *x1, EsbTensor *x2, EsbTensor *bias, EsbTensor *x3, const int64_t *shifts, int64_t shifts_num) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
GE_ASSERT_NOTNULL(bias);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SwinAttentionFFN")
.Name(("SwinAttentionFFN_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputRequired, ""},
{"x3", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"shifts",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(shifts, shifts + shifts_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(2)));
if (x3 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x3->GetAnchor(), node->GetInDataAnchor(3)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsSwinAttentionScoreOutput EsSwinAttentionScore(EsbTensor *query, EsbTensor *key, EsbTensor *value, EsbTensor *padding_mask1, EsbTensor *padding_mask2, EsbTensor *scale, EsbTensor *drop_mask, float keep_prob, bool query_transpose, bool key_transpose, bool bmm_score_transpose_a, bool bmm_score_transpose_b, const int64_t *softmax_axes, int64_t softmax_axes_num) {
GE_ASSERT_NOTNULL(query);
GE_ASSERT_NOTNULL(key);
GE_ASSERT_NOTNULL(value);
GE_ASSERT_NOTNULL(scale);
auto &graph = query->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SwinAttentionScore")
.Name(("SwinAttentionScore_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"query", ge::kIrInputRequired, ""},
{"key", ge::kIrInputRequired, ""},
{"value", ge::kIrInputRequired, ""},
{"padding_mask1", ge::kIrInputOptional, ""},
{"padding_mask2", ge::kIrInputOptional, ""},
{"scale", ge::kIrInputRequired, ""},
{"drop_mask", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"attention_score", ge::kIrOutputRequired, ""},
{"softmax", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"keep_prob",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(keep_prob))
},
{
"query_transpose",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(query_transpose))
},
{
"key_transpose",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(key_transpose))
},
{
"bmm_score_transpose_a",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(bmm_score_transpose_a))
},
{
"bmm_score_transpose_b",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(bmm_score_transpose_b))
},
{
"softmax_axes",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(softmax_axes, softmax_axes + softmax_axes_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(query->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(key->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(2)));
if (padding_mask1 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(padding_mask1->GetAnchor(), node->GetInDataAnchor(3)));
}
if (padding_mask2 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(padding_mask2->GetAnchor(), node->GetInDataAnchor(4)));
}
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(5)));
if (drop_mask != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(drop_mask->GetAnchor(), node->GetInDataAnchor(6)));
}
return EsSwinAttentionScoreOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsSwinAttentionScoreQuant(EsbTensor *query, EsbTensor *key, EsbTensor *value, EsbTensor *scale_quant, EsbTensor *scale_dequant1, EsbTensor *scale_dequant2, EsbTensor *bias_quant, EsbTensor *bias_dequant1, EsbTensor *bias_dequant2, EsbTensor *padding_mask1, EsbTensor *padding_mask2, bool query_transpose, bool key_transpose, bool value_transpose, int64_t softmax_axes) {
GE_ASSERT_NOTNULL(query);
GE_ASSERT_NOTNULL(key);
GE_ASSERT_NOTNULL(value);
GE_ASSERT_NOTNULL(scale_quant);
GE_ASSERT_NOTNULL(scale_dequant1);
GE_ASSERT_NOTNULL(scale_dequant2);
auto &graph = query->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SwinAttentionScoreQuant")
.Name(("SwinAttentionScoreQuant_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"query", ge::kIrInputRequired, ""},
{"key", ge::kIrInputRequired, ""},
{"value", ge::kIrInputRequired, ""},
{"scale_quant", ge::kIrInputRequired, ""},
{"scale_dequant1", ge::kIrInputRequired, ""},
{"scale_dequant2", ge::kIrInputRequired, ""},
{"bias_quant", ge::kIrInputOptional, ""},
{"bias_dequant1", ge::kIrInputOptional, ""},
{"bias_dequant2", ge::kIrInputOptional, ""},
{"padding_mask1", ge::kIrInputOptional, ""},
{"padding_mask2", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"attention_score", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"query_transpose",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(query_transpose))
},
{
"key_transpose",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(key_transpose))
},
{
"value_transpose",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(value_transpose))
},
{
"softmax_axes",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(softmax_axes))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(query->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(key->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale_quant->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale_dequant1->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale_dequant2->GetAnchor(), node->GetInDataAnchor(5)));
if (bias_quant != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias_quant->GetAnchor(), node->GetInDataAnchor(6)));
}
if (bias_dequant1 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias_dequant1->GetAnchor(), node->GetInDataAnchor(7)));
}
if (bias_dequant2 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias_dequant2->GetAnchor(), node->GetInDataAnchor(8)));
}
if (padding_mask1 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(padding_mask1->GetAnchor(), node->GetInDataAnchor(9)));
}
if (padding_mask2 != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(padding_mask2->GetAnchor(), node->GetInDataAnchor(10)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsSwinTransformerLnQKVOutput EsSwinTransformerLnQKV(EsbTensor *x, EsbTensor *gamma, EsbTensor *beta, EsbTensor *weight, EsbTensor *bias, int64_t head_num, int64_t head_dim, int64_t seq_length, const int64_t *shifts, int64_t shifts_num, float epsilon) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(gamma);
GE_ASSERT_NOTNULL(beta);
GE_ASSERT_NOTNULL(weight);
GE_ASSERT_NOTNULL(bias);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SwinTransformerLnQKV")
.Name(("SwinTransformerLnQKV_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
{"beta", ge::kIrInputRequired, ""},
{"weight", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"query_output", ge::kIrOutputRequired, ""},
{"key_output", ge::kIrOutputRequired, ""},
{"value_output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"head_num",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(head_num))
},
{
"head_dim",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(head_dim))
},
{
"seq_length",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seq_length))
},
{
"shifts",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(shifts, shifts + shifts_num))
},
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(4)));
return EsSwinTransformerLnQKVOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsSwinTransformerLnQkvQuantOutput EsSwinTransformerLnQkvQuant(EsbTensor *x, EsbTensor *gamma, EsbTensor *beta, EsbTensor *weight, EsbTensor *bias, EsbTensor *quant_scale, EsbTensor *quant_offset, EsbTensor *dequant_scale, int64_t head_num, int64_t seq_length, float epsilon, int64_t ori_height, int64_t ori_weight, int64_t h_win_szie, int64_t w_win_size, bool weight_transpose) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(gamma);
GE_ASSERT_NOTNULL(beta);
GE_ASSERT_NOTNULL(weight);
GE_ASSERT_NOTNULL(bias);
GE_ASSERT_NOTNULL(quant_scale);
GE_ASSERT_NOTNULL(quant_offset);
GE_ASSERT_NOTNULL(dequant_scale);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SwinTransformerLnQkvQuant")
.Name(("SwinTransformerLnQkvQuant_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"gamma", ge::kIrInputRequired, ""},
{"beta", ge::kIrInputRequired, ""},
{"weight", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputRequired, ""},
{"quant_scale", ge::kIrInputRequired, ""},
{"quant_offset", ge::kIrInputRequired, ""},
{"dequant_scale", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"query_output", ge::kIrOutputRequired, ""},
{"key_output", ge::kIrOutputRequired, ""},
{"value_output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"head_num",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(head_num))
},
{
"seq_length",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seq_length))
},
{
"epsilon",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
{
"ori_height",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(ori_height))
},
{
"ori_weight",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(ori_weight))
},
{
"h_win_szie",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(h_win_szie))
},
{
"w_win_size",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(w_win_size))
},
{
"weight_transpose",
ge::kAttrRequired,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(weight_transpose))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gamma->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(beta->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(quant_scale->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(quant_offset->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dequant_scale->GetAnchor(), node->GetInDataAnchor(7)));
return EsSwinTransformerLnQkvQuantOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsSwish(EsbTensor *x, float scale) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Swish")
.Name(("Swish_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"scale",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(scale))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSwishGrad(EsbTensor *grad, EsbTensor *x, EsbTensor *y, float scale) {
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(y);
auto &graph = grad->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SwishGrad")
.Name(("SwishGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grad", ge::kIrInputRequired, ""},
{"x", ge::kIrInputRequired, ""},
{"y", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"grad_x", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"scale",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(scale))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsSwitchOutput EsSwitch(EsbTensor *data, EsbTensor *pred) {
GE_ASSERT_NOTNULL(data);
GE_ASSERT_NOTNULL(pred);
auto &graph = data->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Switch")
.Name(("Switch_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"data", ge::kIrInputRequired, ""},
{"pred", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_false", ge::kIrOutputRequired, ""},
{"output_true", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(data->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(pred->GetAnchor(), node->GetInDataAnchor(1)));
return EsSwitchOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsSwitchByIndex(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SwitchByIndex")
.Name(("SwitchByIndex_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsSxpy(EsbTensor *x1, EsbTensor *x2, EsbTensor *alpha) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Sxpy")
.Name(("Sxpy_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"alpha", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
if (alpha != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(alpha->GetAnchor(), node->GetInDataAnchor(2)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSyncBNTrainingUpdate(EsbTensor *mean, EsbTensor *running_mean, float momentum) {
GE_ASSERT_NOTNULL(mean);
GE_ASSERT_NOTNULL(running_mean);
auto &graph = mean->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SyncBNTrainingUpdate")
.Name(("SyncBNTrainingUpdate_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"mean", ge::kIrInputRequired, ""},
{"running_mean", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"running_mean_update", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"momentum",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(momentum))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(running_mean->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSyncBatchNormBackwardElemt(EsbTensor *grad_output, EsbTensor *save_input, EsbTensor *mean, EsbTensor *invstd, EsbTensor *weight, EsbTensor *mean_dy, EsbTensor *mean_dy_xmu) {
GE_ASSERT_NOTNULL(grad_output);
GE_ASSERT_NOTNULL(save_input);
GE_ASSERT_NOTNULL(mean);
GE_ASSERT_NOTNULL(invstd);
GE_ASSERT_NOTNULL(weight);
GE_ASSERT_NOTNULL(mean_dy);
GE_ASSERT_NOTNULL(mean_dy_xmu);
auto &graph = grad_output->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SyncBatchNormBackwardElemt")
.Name(("SyncBatchNormBackwardElemt_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grad_output", ge::kIrInputRequired, ""},
{"save_input", ge::kIrInputRequired, ""},
{"mean", ge::kIrInputRequired, ""},
{"invstd", ge::kIrInputRequired, ""},
{"weight", ge::kIrInputRequired, ""},
{"mean_dy", ge::kIrInputRequired, ""},
{"mean_dy_xmu", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"grad_input", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad_output->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(save_input->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(invstd->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean_dy->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean_dy_xmu->GetAnchor(), node->GetInDataAnchor(6)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsSyncBatchNormBackwardReduceOutput EsSyncBatchNormBackwardReduce(EsbTensor *sum_dy, EsbTensor *sum_dy_dx_pad, EsbTensor *mean, EsbTensor *invert_std) {
GE_ASSERT_NOTNULL(sum_dy);
GE_ASSERT_NOTNULL(sum_dy_dx_pad);
GE_ASSERT_NOTNULL(mean);
GE_ASSERT_NOTNULL(invert_std);
auto &graph = sum_dy->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SyncBatchNormBackwardReduce")
.Name(("SyncBatchNormBackwardReduce_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"sum_dy", ge::kIrInputRequired, ""},
{"sum_dy_dx_pad", ge::kIrInputRequired, ""},
{"mean", ge::kIrInputRequired, ""},
{"invert_std", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"sum_dy_xmu", ge::kIrOutputRequired, ""},
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sum_dy->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sum_dy_dx_pad->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(invert_std->GetAnchor(), node->GetInDataAnchor(3)));
return EsSyncBatchNormBackwardReduceOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsSyncBatchNormGatherStatsOutput EsSyncBatchNormGatherStats(EsbTensor *total_sum, EsbTensor *total_square_sum, EsbTensor *sample_count, EsbTensor *mean, EsbTensor *variance, float momentum, float eps) {
GE_ASSERT_NOTNULL(total_sum);
GE_ASSERT_NOTNULL(total_square_sum);
GE_ASSERT_NOTNULL(sample_count);
GE_ASSERT_NOTNULL(mean);
GE_ASSERT_NOTNULL(variance);
auto &graph = total_sum->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SyncBatchNormGatherStats")
.Name(("SyncBatchNormGatherStats_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"total_sum", ge::kIrInputRequired, ""},
{"total_square_sum", ge::kIrInputRequired, ""},
{"sample_count", ge::kIrInputRequired, ""},
{"mean", ge::kIrInputRequired, ""},
{"variance", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"batch_mean", ge::kIrOutputRequired, ""},
{"batch_invstd", ge::kIrOutputRequired, ""},
{"mean", ge::kIrOutputRequired, ""},
{"variance", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"momentum",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(momentum))
},
{
"eps",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(eps))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(total_sum->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(total_square_sum->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sample_count->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(variance->GetAnchor(), node->GetInDataAnchor(4)));
return EsSyncBatchNormGatherStatsOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsSyncBatchNormGatherStatsWithCountsOutput EsSyncBatchNormGatherStatsWithCounts(EsbTensor *mean_all, EsbTensor *invert_std_all, EsbTensor *count_all, EsbTensor *mean_broadcast, EsbTensor *count_sum, EsbTensor *running_var, float momentum, float epsilon) {
GE_ASSERT_NOTNULL(mean_all);
GE_ASSERT_NOTNULL(invert_std_all);
GE_ASSERT_NOTNULL(count_all);
GE_ASSERT_NOTNULL(mean_broadcast);
GE_ASSERT_NOTNULL(count_sum);
GE_ASSERT_NOTNULL(running_var);
auto &graph = mean_all->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SyncBatchNormGatherStatsWithCounts")
.Name(("SyncBatchNormGatherStatsWithCounts_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"mean_all", ge::kIrInputRequired, ""},
{"invert_std_all", ge::kIrInputRequired, ""},
{"count_all", ge::kIrInputRequired, ""},
{"mean_broadcast", ge::kIrInputRequired, ""},
{"count_sum", ge::kIrInputRequired, ""},
{"running_var", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"invert_std", ge::kIrOutputRequired, ""},
{"running_var_update", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"momentum",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(momentum))
},
{
"epsilon",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(epsilon))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean_all->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(invert_std_all->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(count_all->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mean_broadcast->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(count_sum->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(running_var->GetAnchor(), node->GetInDataAnchor(5)));
return EsSyncBatchNormGatherStatsWithCountsOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsSyncResizeBilinearV2(EsbTensor *x, EsbTensor *size, const int64_t *ori_image_size, int64_t ori_image_size_num, const int64_t *split_size, int64_t split_size_num, int64_t src_start_w, int64_t dst_start_w, bool align_corners, bool half_pixel_centers) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(size);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SyncResizeBilinearV2")
.Name(("SyncResizeBilinearV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"size", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"ori_image_size",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ori_image_size, ori_image_size + ori_image_size_num))
},
{
"split_size",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(split_size, split_size + split_size_num))
},
{
"src_start_w",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(src_start_w))
},
{
"dst_start_w",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dst_start_w))
},
{
"align_corners",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(align_corners))
},
{
"half_pixel_centers",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(half_pixel_centers))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(size->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsSyncResizeBilinearV2Grad(EsbTensor *grads, EsbTensor *original_image, const int64_t *size, int64_t size_num, const int64_t *ori_image_size, int64_t ori_image_size_num, int64_t src_start_w, int64_t dst_start_w, bool align_corners, bool half_pixel_centers) {
GE_ASSERT_NOTNULL(grads);
GE_ASSERT_NOTNULL(original_image);
auto &graph = grads->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("SyncResizeBilinearV2Grad")
.Name(("SyncResizeBilinearV2Grad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grads", ge::kIrInputRequired, ""},
{"original_image", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"size",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(size, size + size_num))
},
{
"ori_image_size",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(ori_image_size, ori_image_size + ori_image_size_num))
},
{
"src_start_w",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(src_start_w))
},
{
"dst_start_w",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dst_start_w))
},
{
"align_corners",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(align_corners))
},
{
"half_pixel_centers",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(half_pixel_centers))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grads->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(original_image->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTableToResource(EsbTensor *table_id) {
GE_ASSERT_NOTNULL(table_id);
auto &graph = table_id->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TableToResource")
.Name(("TableToResource_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"table_id", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"table_handle", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(table_id->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTableToResourceV2(EsbTensor *table_id) {
GE_ASSERT_NOTNULL(table_id);
auto &graph = table_id->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TableToResourceV2")
.Name(("TableToResourceV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"table_id", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"table_handle", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(table_id->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTabulateFusion(EsbTensor *table, EsbTensor *table_info, EsbTensor *em_x, EsbTensor *em, int64_t last_layer_size) {
GE_ASSERT_NOTNULL(table);
GE_ASSERT_NOTNULL(table_info);
GE_ASSERT_NOTNULL(em_x);
GE_ASSERT_NOTNULL(em);
auto &graph = table->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TabulateFusion")
.Name(("TabulateFusion_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"table", ge::kIrInputRequired, ""},
{"table_info", ge::kIrInputRequired, ""},
{"em_x", ge::kIrInputRequired, ""},
{"em", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"descriptor", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"last_layer_size",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(last_layer_size))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(table->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(table_info->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(em_x->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(em->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsTabulateFusionGradOutput EsTabulateFusionGrad(EsbTensor *table, EsbTensor *table_info, EsbTensor *em_x, EsbTensor *em, EsbTensor *dy, EsbTensor *descriptor) {
GE_ASSERT_NOTNULL(table);
GE_ASSERT_NOTNULL(table_info);
GE_ASSERT_NOTNULL(em_x);
GE_ASSERT_NOTNULL(em);
GE_ASSERT_NOTNULL(dy);
GE_ASSERT_NOTNULL(descriptor);
auto &graph = table->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TabulateFusionGrad")
.Name(("TabulateFusionGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"table", ge::kIrInputRequired, ""},
{"table_info", ge::kIrInputRequired, ""},
{"em_x", ge::kIrInputRequired, ""},
{"em", ge::kIrInputRequired, ""},
{"dy", ge::kIrInputRequired, ""},
{"descriptor", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"dy_dem_x", ge::kIrOutputRequired, ""},
{"dy_dem", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(table->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(table_info->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(em_x->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(em->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(descriptor->GetAnchor(), node->GetInDataAnchor(5)));
return EsTabulateFusionGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsTakeManySparseFromTensorsMapOutput EsTakeManySparseFromTensorsMap(EsbTensor *handles, ge::DataType dtype, const char *container, const char *shared_name) {
GE_ASSERT_NOTNULL(handles);
auto &graph = handles->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TakeManySparseFromTensorsMap")
.Name(("TakeManySparseFromTensorsMap_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handles", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"indices", ge::kIrOutputRequired, ""},
{"values", ge::kIrOutputRequired, ""},
{"shape", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
{
"container",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(container))
},
{
"shared_name",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(shared_name))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handles->GetAnchor(), node->GetInDataAnchor(0)));
return EsTakeManySparseFromTensorsMapOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsTan(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Tan")
.Name(("Tan_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTanh(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Tanh")
.Name(("Tanh_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTanhGrad(EsbTensor *y, EsbTensor *dy, bool complex_conj) {
GE_ASSERT_NOTNULL(y);
GE_ASSERT_NOTNULL(dy);
auto &graph = y->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TanhGrad")
.Name(("TanhGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"y", ge::kIrInputRequired, ""},
{"dy", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"z", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"complex_conj",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(complex_conj))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dy->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTargetCropAndResize(EsbTensor *x, EsbTensor *boxes, EsbTensor *box_index, int64_t output_h, int64_t output_w, const char *input_format) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(boxes);
GE_ASSERT_NOTNULL(box_index);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TargetCropAndResize")
.Name(("TargetCropAndResize_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"boxes", ge::kIrInputRequired, ""},
{"box_index", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"output_h",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(output_h))
},
{
"output_w",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(output_w))
},
{
"input_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(input_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(boxes->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(box_index->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTemporaryVariable(EsbGraph *owner_graph, const int64_t *shape, int64_t shape_num, int64_t dtype, const char *var_name) {
GE_ASSERT_NOTNULL(owner_graph);
EsbGraph &graph = *owner_graph;

auto desc = ge::CompliantOpDescBuilder().OpType("TemporaryVariable")
.Name(("TemporaryVariable_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"shape",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(shape, shape + shape_num))
},
{
"dtype",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dtype))
},
{
"var_name",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(var_name))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsTensorArrayOutput EsTensorArray(EsbTensor *size, ge::DataType dtype, const int64_t *element_shape, int64_t element_shape_num, bool dynamic_size, bool clear_after_read, bool identical_element_shapes, const char *tensor_array_name) {
GE_ASSERT_NOTNULL(size);
auto &graph = size->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorArray")
.Name(("TensorArray_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"size", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"handle", ge::kIrOutputRequired, ""},
{"flow", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
{
"element_shape",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(element_shape, element_shape + element_shape_num))
},
{
"dynamic_size",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(dynamic_size))
},
{
"clear_after_read",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(clear_after_read))
},
{
"identical_element_shapes",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(identical_element_shapes))
},
{
"tensor_array_name",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(tensor_array_name))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(size->GetAnchor(), node->GetInDataAnchor(0)));
return EsTensorArrayOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsTensorArrayClose(EsbTensor *handle) {
GE_ASSERT_NOTNULL(handle);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorArrayClose")
.Name(("TensorArrayClose_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsTensorArrayConcatOutput EsTensorArrayConcat(EsbTensor *handle, EsbTensor *flow_in, ge::DataType dtype, const int64_t *element_shape_except0, int64_t element_shape_except0_num) {
GE_ASSERT_NOTNULL(handle);
GE_ASSERT_NOTNULL(flow_in);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorArrayConcat")
.Name(("TensorArrayConcat_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
{"flow_in", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"value", ge::kIrOutputRequired, ""},
{"lengths", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
{
"element_shape_except0",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(element_shape_except0, element_shape_except0 + element_shape_except0_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(flow_in->GetAnchor(), node->GetInDataAnchor(1)));
return EsTensorArrayConcatOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsTensorArrayGather(EsbTensor *handle, EsbTensor *indices, EsbTensor *flow_in, ge::DataType dtype, const int64_t *element_shape, int64_t element_shape_num) {
GE_ASSERT_NOTNULL(handle);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(flow_in);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorArrayGather")
.Name(("TensorArrayGather_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"flow_in", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"value", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
{
"element_shape",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(element_shape, element_shape + element_shape_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(flow_in->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsTensorArrayGradOutput EsTensorArrayGrad(EsbTensor *handle, EsbTensor *flow_in, const char *source) {
GE_ASSERT_NOTNULL(handle);
GE_ASSERT_NOTNULL(flow_in);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorArrayGrad")
.Name(("TensorArrayGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
{"flow_in", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"grad_handle", ge::kIrOutputRequired, ""},
{"flow_out", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"source",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(source))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(flow_in->GetAnchor(), node->GetInDataAnchor(1)));
return EsTensorArrayGradOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsTensorArrayGradWithShapeOutput EsTensorArrayGradWithShape(EsbTensor *handle, EsbTensor *flow_in, EsbTensor *shape_to_prepend, const char *source) {
GE_ASSERT_NOTNULL(handle);
GE_ASSERT_NOTNULL(flow_in);
GE_ASSERT_NOTNULL(shape_to_prepend);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorArrayGradWithShape")
.Name(("TensorArrayGradWithShape_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
{"flow_in", ge::kIrInputRequired, ""},
{"shape_to_prepend", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"grad_handle", ge::kIrOutputRequired, ""},
{"flow_out", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"source",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(source))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(flow_in->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape_to_prepend->GetAnchor(), node->GetInDataAnchor(2)));
return EsTensorArrayGradWithShapeOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsTensorArrayRead(EsbTensor *handle, EsbTensor *index, EsbTensor *flow_in, ge::DataType dtype) {
GE_ASSERT_NOTNULL(handle);
GE_ASSERT_NOTNULL(index);
GE_ASSERT_NOTNULL(flow_in);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorArrayRead")
.Name(("TensorArrayRead_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
{"index", ge::kIrInputRequired, ""},
{"flow_in", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(index->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(flow_in->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTensorArrayScatter(EsbTensor *handle, EsbTensor *indices, EsbTensor *value, EsbTensor *flow_in) {
GE_ASSERT_NOTNULL(handle);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(value);
GE_ASSERT_NOTNULL(flow_in);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorArrayScatter")
.Name(("TensorArrayScatter_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"value", ge::kIrInputRequired, ""},
{"flow_in", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"flow_out", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(flow_in->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTensorArraySize(EsbTensor *handle, EsbTensor *flow_in) {
GE_ASSERT_NOTNULL(handle);
GE_ASSERT_NOTNULL(flow_in);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorArraySize")
.Name(("TensorArraySize_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
{"flow_in", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"size", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(flow_in->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTensorArraySplit(EsbTensor *handle, EsbTensor *value, EsbTensor *lengths, EsbTensor *flow_in) {
GE_ASSERT_NOTNULL(handle);
GE_ASSERT_NOTNULL(value);
GE_ASSERT_NOTNULL(lengths);
GE_ASSERT_NOTNULL(flow_in);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorArraySplit")
.Name(("TensorArraySplit_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
{"value", ge::kIrInputRequired, ""},
{"lengths", ge::kIrInputRequired, ""},
{"flow_in", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"flow_out", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lengths->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(flow_in->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTensorArrayWrite(EsbTensor *handle, EsbTensor *index, EsbTensor *value, EsbTensor *flow_in) {
GE_ASSERT_NOTNULL(handle);
GE_ASSERT_NOTNULL(index);
GE_ASSERT_NOTNULL(value);
GE_ASSERT_NOTNULL(flow_in);
auto &graph = handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorArrayWrite")
.Name(("TensorArrayWrite_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"handle", ge::kIrInputRequired, ""},
{"index", ge::kIrInputRequired, ""},
{"value", ge::kIrInputRequired, ""},
{"flow_in", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"flow_out", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(index->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(flow_in->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTensorEqual(EsbTensor *input_x, EsbTensor *input_y) {
GE_ASSERT_NOTNULL(input_x);
GE_ASSERT_NOTNULL(input_y);
auto &graph = input_x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorEqual")
.Name(("TensorEqual_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_x", ge::kIrInputRequired, ""},
{"input_y", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_z", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_y->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTensorListConcatLists(EsbTensor *input_a, EsbTensor *input_b, ge::DataType element_dtype) {
GE_ASSERT_NOTNULL(input_a);
GE_ASSERT_NOTNULL(input_b);
auto &graph = input_a->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorListConcatLists")
.Name(("TensorListConcatLists_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_a", ge::kIrInputRequired, ""},
{"input_b", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"element_dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(element_dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_a->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_b->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsTensorListConcatV2Output EsTensorListConcatV2(EsbTensor *input_handle, EsbTensor *element_shape, EsbTensor *leading_dims, ge::DataType element_dtype) {
GE_ASSERT_NOTNULL(input_handle);
GE_ASSERT_NOTNULL(element_shape);
GE_ASSERT_NOTNULL(leading_dims);
auto &graph = input_handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorListConcatV2")
.Name(("TensorListConcatV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_handle", ge::kIrInputRequired, ""},
{"element_shape", ge::kIrInputRequired, ""},
{"leading_dims", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"tensor", ge::kIrOutputRequired, ""},
{"lengths", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"element_dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(element_dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(element_shape->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(leading_dims->GetAnchor(), node->GetInDataAnchor(2)));
return EsTensorListConcatV2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsTensorListElementShape(EsbTensor *input_handle, ge::DataType shape_type) {
GE_ASSERT_NOTNULL(input_handle);
auto &graph = input_handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorListElementShape")
.Name(("TensorListElementShape_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_handle", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"element_shape", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"shape_type",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(shape_type))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_handle->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTensorListFromTensor(EsbTensor *tensor, EsbTensor *element_shape, ge::DataType element_dtype) {
GE_ASSERT_NOTNULL(tensor);
GE_ASSERT_NOTNULL(element_shape);
auto &graph = tensor->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorListFromTensor")
.Name(("TensorListFromTensor_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"tensor", ge::kIrInputRequired, ""},
{"element_shape", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_handle", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"element_dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(element_dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(tensor->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(element_shape->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTensorListGather(EsbTensor *input_handle, EsbTensor *indices, EsbTensor *element_shape, ge::DataType element_dtype) {
GE_ASSERT_NOTNULL(input_handle);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(element_shape);
auto &graph = input_handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorListGather")
.Name(("TensorListGather_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_handle", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"element_shape", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"values", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"element_dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(element_dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(element_shape->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTensorListGetItem(EsbTensor *input_handle, EsbTensor *index, EsbTensor *element_shape, ge::DataType element_dtype) {
GE_ASSERT_NOTNULL(input_handle);
GE_ASSERT_NOTNULL(index);
GE_ASSERT_NOTNULL(element_shape);
auto &graph = input_handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorListGetItem")
.Name(("TensorListGetItem_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_handle", ge::kIrInputRequired, ""},
{"index", ge::kIrInputRequired, ""},
{"element_shape", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"item", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"element_dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(element_dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(index->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(element_shape->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTensorListLength(EsbTensor *input_handle) {
GE_ASSERT_NOTNULL(input_handle);
auto &graph = input_handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorListLength")
.Name(("TensorListLength_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_handle", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"length", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_handle->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsTensorListPopBackOutput EsTensorListPopBack(EsbTensor *input_handle, EsbTensor *element_shape, ge::DataType element_dtype) {
GE_ASSERT_NOTNULL(input_handle);
GE_ASSERT_NOTNULL(element_shape);
auto &graph = input_handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorListPopBack")
.Name(("TensorListPopBack_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_handle", ge::kIrInputRequired, ""},
{"element_shape", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_handle", ge::kIrOutputRequired, ""},
{"tensor", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"element_dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(element_dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(element_shape->GetAnchor(), node->GetInDataAnchor(1)));
return EsTensorListPopBackOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsTensorListPushBack(EsbTensor *input_handle, EsbTensor *tensor, ge::DataType element_dtype) {
GE_ASSERT_NOTNULL(input_handle);
GE_ASSERT_NOTNULL(tensor);
auto &graph = input_handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorListPushBack")
.Name(("TensorListPushBack_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_handle", ge::kIrInputRequired, ""},
{"tensor", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_handle", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"element_dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(element_dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(tensor->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTensorListPushBackBatch(EsbTensor *input_handles, EsbTensor *tensor, ge::DataType element_dtype) {
GE_ASSERT_NOTNULL(input_handles);
GE_ASSERT_NOTNULL(tensor);
auto &graph = input_handles->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorListPushBackBatch")
.Name(("TensorListPushBackBatch_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_handles", ge::kIrInputRequired, ""},
{"tensor", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_handles", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"element_dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(element_dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_handles->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(tensor->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTensorListReserve(EsbTensor *element_shape, EsbTensor *num_elements, ge::DataType element_dtype, ge::DataType shape_type) {
GE_ASSERT_NOTNULL(element_shape);
GE_ASSERT_NOTNULL(num_elements);
auto &graph = element_shape->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorListReserve")
.Name(("TensorListReserve_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"element_shape", ge::kIrInputRequired, ""},
{"num_elements", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"handle", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"element_dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(element_dtype))
},
{
"shape_type",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(shape_type))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(element_shape->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(num_elements->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTensorListResize(EsbTensor *input_handle, EsbTensor *size) {
GE_ASSERT_NOTNULL(input_handle);
GE_ASSERT_NOTNULL(size);
auto &graph = input_handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorListResize")
.Name(("TensorListResize_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_handle", ge::kIrInputRequired, ""},
{"size", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_handle", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(size->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTensorListScatterIntoExistingList(EsbTensor *input_handle, EsbTensor *tensor, EsbTensor *indices, ge::DataType element_dtype) {
GE_ASSERT_NOTNULL(input_handle);
GE_ASSERT_NOTNULL(tensor);
GE_ASSERT_NOTNULL(indices);
auto &graph = input_handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorListScatterIntoExistingList")
.Name(("TensorListScatterIntoExistingList_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_handle", ge::kIrInputRequired, ""},
{"tensor", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_handle", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"element_dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(element_dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(tensor->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTensorListScatterV2(EsbTensor *tensor, EsbTensor *indices, EsbTensor *element_shape, EsbTensor *num_elements, ge::DataType element_dtype) {
GE_ASSERT_NOTNULL(tensor);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(element_shape);
GE_ASSERT_NOTNULL(num_elements);
auto &graph = tensor->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorListScatterV2")
.Name(("TensorListScatterV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"tensor", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"element_shape", ge::kIrInputRequired, ""},
{"num_elements", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_handle", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"element_dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(element_dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(tensor->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(element_shape->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(num_elements->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTensorListSetItem(EsbTensor *input_handle, EsbTensor *index, EsbTensor *item, ge::DataType element_dtype) {
GE_ASSERT_NOTNULL(input_handle);
GE_ASSERT_NOTNULL(index);
GE_ASSERT_NOTNULL(item);
auto &graph = input_handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorListSetItem")
.Name(("TensorListSetItem_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_handle", ge::kIrInputRequired, ""},
{"index", ge::kIrInputRequired, ""},
{"item", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_handle", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"element_dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(element_dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(index->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(item->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTensorListSplit(EsbTensor *tensor, EsbTensor *element_shape, EsbTensor *lengths, ge::DataType element_dtype) {
GE_ASSERT_NOTNULL(tensor);
GE_ASSERT_NOTNULL(element_shape);
GE_ASSERT_NOTNULL(lengths);
auto &graph = tensor->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorListSplit")
.Name(("TensorListSplit_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"tensor", ge::kIrInputRequired, ""},
{"element_shape", ge::kIrInputRequired, ""},
{"lengths", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_handle", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"element_dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(element_dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(tensor->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(element_shape->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(lengths->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTensorListStack(EsbTensor *input_handle, EsbTensor *element_shape, ge::DataType element_dtype, int64_t num_elements) {
GE_ASSERT_NOTNULL(input_handle);
GE_ASSERT_NOTNULL(element_shape);
auto &graph = input_handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorListStack")
.Name(("TensorListStack_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_handle", ge::kIrInputRequired, ""},
{"element_shape", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"tensor", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"element_dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(element_dtype))
},
{
"num_elements",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_elements))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(element_shape->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTensorMapErase(EsbTensor *input_handle, EsbTensor *key) {
GE_ASSERT_NOTNULL(input_handle);
GE_ASSERT_NOTNULL(key);
auto &graph = input_handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorMapErase")
.Name(("TensorMapErase_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_handle", ge::kIrInputRequired, ""},
{"key", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_handle", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(key->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTensorMapHasKey(EsbTensor *input_handle, EsbTensor *key) {
GE_ASSERT_NOTNULL(input_handle);
GE_ASSERT_NOTNULL(key);
auto &graph = input_handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorMapHasKey")
.Name(("TensorMapHasKey_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_handle", ge::kIrInputRequired, ""},
{"key", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"has_key", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(key->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTensorMapInsert(EsbTensor *input_handle, EsbTensor *key, EsbTensor *value) {
GE_ASSERT_NOTNULL(input_handle);
GE_ASSERT_NOTNULL(key);
GE_ASSERT_NOTNULL(value);
auto &graph = input_handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorMapInsert")
.Name(("TensorMapInsert_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_handle", ge::kIrInputRequired, ""},
{"key", ge::kIrInputRequired, ""},
{"value", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_handle", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(key->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTensorMapLookup(EsbTensor *input_handle, EsbTensor *key, ge::DataType value_dtype) {
GE_ASSERT_NOTNULL(input_handle);
GE_ASSERT_NOTNULL(key);
auto &graph = input_handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorMapLookup")
.Name(("TensorMapLookup_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_handle", ge::kIrInputRequired, ""},
{"key", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"value", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"value_dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(value_dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_handle->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(key->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTensorMapSize(EsbTensor *input_handle) {
GE_ASSERT_NOTNULL(input_handle);
auto &graph = input_handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorMapSize")
.Name(("TensorMapSize_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_handle", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"size", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_handle->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTensorMapStackKeys(EsbTensor *input_handle, ge::DataType key_dtype) {
GE_ASSERT_NOTNULL(input_handle);
auto &graph = input_handle->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorMapStackKeys")
.Name(("TensorMapStackKeys_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_handle", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"keys", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"key_dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(key_dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_handle->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTensorMove(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorMove")
.Name(("TensorMove_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTensorRedirect(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorRedirect")
.Name(("TensorRedirect_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_x", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTensorScatterAdd(EsbTensor *x, EsbTensor *indices, EsbTensor *updates) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(updates);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorScatterAdd")
.Name(("TensorScatterAdd_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"updates", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(updates->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTensorScatterMax(EsbTensor *input, EsbTensor *indices, EsbTensor *updates) {
GE_ASSERT_NOTNULL(input);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(updates);
auto &graph = input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorScatterMax")
.Name(("TensorScatterMax_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"updates", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(updates->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTensorScatterMin(EsbTensor *input, EsbTensor *indices, EsbTensor *updates) {
GE_ASSERT_NOTNULL(input);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(updates);
auto &graph = input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorScatterMin")
.Name(("TensorScatterMin_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"updates", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(updates->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTensorScatterSub(EsbTensor *x, EsbTensor *indices, EsbTensor *updates) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(updates);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorScatterSub")
.Name(("TensorScatterSub_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"updates", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(updates->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTensorScatterUpdate(EsbTensor *x, EsbTensor *indices, EsbTensor *updates) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(updates);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TensorScatterUpdate")
.Name(("TensorScatterUpdate_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"indices", ge::kIrInputRequired, ""},
{"updates", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(updates->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsThreadUnsafeUnigramCandidateSamplerOutput EsThreadUnsafeUnigramCandidateSampler(EsbTensor *true_classes, int64_t num_true, int64_t num_sampled, bool unique, int64_t range_max, int64_t seed, int64_t seed2) {
GE_ASSERT_NOTNULL(true_classes);
auto &graph = true_classes->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ThreadUnsafeUnigramCandidateSampler")
.Name(("ThreadUnsafeUnigramCandidateSampler_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"true_classes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"sampled_candidates", ge::kIrOutputRequired, ""},
{"true_expected_count", ge::kIrOutputRequired, ""},
{"sampled_expected_count", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_true",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_true))
},
{
"num_sampled",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_sampled))
},
{
"unique",
ge::kAttrRequired,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(unique))
},
{
"range_max",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(range_max))
},
{
"seed",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed))
},
{
"seed2",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed2))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(true_classes->GetAnchor(), node->GetInDataAnchor(0)));
return EsThreadUnsafeUnigramCandidateSamplerOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsThreeInterpolate(EsbTensor *features, EsbTensor *idx, EsbTensor *weight) {
GE_ASSERT_NOTNULL(features);
GE_ASSERT_NOTNULL(idx);
GE_ASSERT_NOTNULL(weight);
auto &graph = features->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ThreeInterpolate")
.Name(("ThreeInterpolate_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"features", ge::kIrInputRequired, ""},
{"idx", ge::kIrInputRequired, ""},
{"weight", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(features->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(idx->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsThreeInterpolateBackward(EsbTensor *grad_x, EsbTensor *idx, EsbTensor *weight, int64_t m) {
GE_ASSERT_NOTNULL(grad_x);
GE_ASSERT_NOTNULL(idx);
GE_ASSERT_NOTNULL(weight);
auto &graph = grad_x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ThreeInterpolateBackward")
.Name(("ThreeInterpolateBackward_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grad_x", ge::kIrInputRequired, ""},
{"idx", ge::kIrInputRequired, ""},
{"weight", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"grad_y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"m",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(m))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad_x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(idx->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsThreeNNOutput EsThreeNN(EsbTensor *xyz1, EsbTensor *xyz2) {
GE_ASSERT_NOTNULL(xyz1);
GE_ASSERT_NOTNULL(xyz2);
auto &graph = xyz1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ThreeNN")
.Name(("ThreeNN_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"xyz1", ge::kIrInputRequired, ""},
{"xyz2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"dist", ge::kIrOutputRequired, ""},
{"idx", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(xyz1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(xyz2->GetAnchor(), node->GetInDataAnchor(1)));
return EsThreeNNOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsThreshold(EsbTensor *x, float threshold) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Threshold")
.Name(("Threshold_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"threshold",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(threshold))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsThresholdGradV2D(EsbTensor *gradients, EsbTensor *features, float threshold) {
GE_ASSERT_NOTNULL(gradients);
GE_ASSERT_NOTNULL(features);
auto &graph = gradients->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ThresholdGradV2D")
.Name(("ThresholdGradV2D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"gradients", ge::kIrInputRequired, ""},
{"features", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"backprops", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"threshold",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(threshold))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gradients->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(features->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsThresholdV2(EsbTensor *x, EsbTensor *threshold, EsbTensor *value) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(threshold);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ThresholdV2")
.Name(("ThresholdV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"threshold", ge::kIrInputRequired, ""},
{"value", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(threshold->GetAnchor(), node->GetInDataAnchor(1)));
if (value != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(value->GetAnchor(), node->GetInDataAnchor(2)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsThresholdV2D(EsbTensor *x, float threshold, float value) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ThresholdV2D")
.Name(("ThresholdV2D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"threshold",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(threshold))
},
{
"value",
ge::kAttrRequired,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(value))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsThresholdedRelu(EsbTensor *x, float alpha) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ThresholdedRelu")
.Name(("ThresholdedRelu_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"alpha",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(alpha))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTile(EsbTensor *x, EsbTensor *multiples) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(multiples);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Tile")
.Name(("Tile_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"multiples", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(multiples->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTileD(EsbTensor *x, const int64_t *multiples, int64_t multiples_num) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TileD")
.Name(("TileD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"multiples",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(multiples, multiples + multiples_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTileWithAxis(EsbTensor *x, int64_t tiles, int64_t axis) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TileWithAxis")
.Name(("TileWithAxis_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"tiles",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(tiles))
},
{
"axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTimestamp(EsbGraph *owner_graph) {
GE_ASSERT_NOTNULL(owner_graph);
EsbGraph &graph = *owner_graph;

auto desc = ge::CompliantOpDescBuilder().OpType("Timestamp")
.Name(("Timestamp_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsToAbsoluteBBox(EsbTensor *normalized_boxes, EsbTensor *shape_hw, bool reversed_box) {
GE_ASSERT_NOTNULL(normalized_boxes);
GE_ASSERT_NOTNULL(shape_hw);
auto &graph = normalized_boxes->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ToAbsoluteBBox")
.Name(("ToAbsoluteBBox_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"normalized_boxes", ge::kIrInputRequired, ""},
{"shape_hw", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"reversed_box",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(reversed_box))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(normalized_boxes->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape_hw->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsToBool(EsbTensor *input) {
GE_ASSERT_NOTNULL(input);
auto &graph = input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ToBool")
.Name(("ToBool_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsTomeMergeOutput EsTomeMerge(EsbTensor *token_a, EsbTensor *token_b, EsbTensor *topk_indice, EsbTensor *arg_max, float top_rate) {
GE_ASSERT_NOTNULL(token_a);
GE_ASSERT_NOTNULL(token_b);
GE_ASSERT_NOTNULL(topk_indice);
GE_ASSERT_NOTNULL(arg_max);
auto &graph = token_a->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TomeMerge")
.Name(("TomeMerge_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"token_a", ge::kIrInputRequired, ""},
{"token_b", ge::kIrInputRequired, ""},
{"topk_indice", ge::kIrInputRequired, ""},
{"arg_max", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"unmerge_token_a", ge::kIrOutputRequired, ""},
{"unreduce_token_b", ge::kIrOutputRequired, ""},
{"unreduce_count", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"top_rate",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(top_rate))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(token_a->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(token_b->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(topk_indice->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(arg_max->GetAnchor(), node->GetInDataAnchor(3)));
return EsTomeMergeOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsTomeUnmerge(EsbTensor *attention, EsbTensor *ori_index_a, EsbTensor *ori_index_b, EsbTensor *topk_indice, EsbTensor *arg_max, float top_rate) {
GE_ASSERT_NOTNULL(attention);
GE_ASSERT_NOTNULL(ori_index_a);
GE_ASSERT_NOTNULL(ori_index_b);
GE_ASSERT_NOTNULL(topk_indice);
GE_ASSERT_NOTNULL(arg_max);
auto &graph = attention->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TomeUnmerge")
.Name(("TomeUnmerge_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"attention", ge::kIrInputRequired, ""},
{"ori_index_a", ge::kIrInputRequired, ""},
{"ori_index_b", ge::kIrInputRequired, ""},
{"topk_indice", ge::kIrInputRequired, ""},
{"arg_max", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"unzip_token", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"top_rate",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(top_rate))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(attention->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(ori_index_a->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(ori_index_b->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(topk_indice->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(arg_max->GetAnchor(), node->GetInDataAnchor(4)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsTopKOutput EsTopK(EsbTensor *x, EsbTensor *k, bool sorted, bool largest, int64_t dim) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(k);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TopK")
.Name(("TopK_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"k", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"values", ge::kIrOutputRequired, ""},
{"indices", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"sorted",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(sorted))
},
{
"largest",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(largest))
},
{
"dim",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dim))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(k->GetAnchor(), node->GetInDataAnchor(1)));
return EsTopKOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsTopKDOutput EsTopKD(EsbTensor *x, EsbTensor *assist_seq, int64_t k, bool sorted, int64_t dim, bool largest) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(assist_seq);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TopKD")
.Name(("TopKD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"assist_seq", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"values", ge::kIrOutputRequired, ""},
{"indices", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"k",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(k))
},
{
"sorted",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(sorted))
},
{
"dim",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dim))
},
{
"largest",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(largest))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(assist_seq->GetAnchor(), node->GetInDataAnchor(1)));
return EsTopKDOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsTopKPQDistanceOutput EsTopKPQDistance(EsbTensor **actual_count, int64_t actual_count_num, EsbTensor **pq_distance, int64_t pq_distance_num, EsbTensor **grouped_extreme_distance, int64_t grouped_extreme_distance_num, EsbTensor **pq_ivf, int64_t pq_ivf_num, EsbTensor **pq_index, int64_t pq_index_num, int64_t k, int64_t group_size, const char *order) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(actual_count_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(pq_distance_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(grouped_extreme_distance_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(pq_ivf_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(pq_index_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < actual_count_num; ++i) {
if (actual_count[i] != nullptr) {
non_null_in = actual_count[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
if (non_null_in == nullptr) {
for (int64_t i = 0; i < pq_distance_num; ++i) {
if (pq_distance[i] != nullptr) {
non_null_in = pq_distance[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
if (non_null_in == nullptr) {
for (int64_t i = 0; i < grouped_extreme_distance_num; ++i) {
if (grouped_extreme_distance[i] != nullptr) {
non_null_in = grouped_extreme_distance[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
if (non_null_in == nullptr) {
for (int64_t i = 0; i < pq_ivf_num; ++i) {
if (pq_ivf[i] != nullptr) {
non_null_in = pq_ivf[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
if (non_null_in == nullptr) {
for (int64_t i = 0; i < pq_index_num; ++i) {
if (pq_index[i] != nullptr) {
non_null_in = pq_index[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TopKPQDistance")
.Name(("TopKPQDistance_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"actual_count", ge::kIrInputDynamic, ""},
{"pq_distance", ge::kIrInputDynamic, ""},
{"grouped_extreme_distance", ge::kIrInputDynamic, ""},
{"pq_ivf", ge::kIrInputDynamic, ""},
{"pq_index", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
{"topk_distance", ge::kIrOutputRequired, ""},
{"topk_ivf", ge::kIrOutputRequired, ""},
{"topk_index", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"k",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(k))
},
{
"group_size",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(group_size))
},
{
"order",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(order))
},
})
.InstanceDynamicInputNum("actual_count", static_cast<int32_t>(actual_count_num))
.InstanceDynamicInputNum("pq_distance", static_cast<int32_t>(pq_distance_num))
.InstanceDynamicInputNum("grouped_extreme_distance", static_cast<int32_t>(grouped_extreme_distance_num))
.InstanceDynamicInputNum("pq_ivf", static_cast<int32_t>(pq_ivf_num))
.InstanceDynamicInputNum("pq_index", static_cast<int32_t>(pq_index_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((actual_count != nullptr) && (actual_count_num > 0)) {
for (int64_t i = 0; i < actual_count_num; ++i) {
auto one_actual_count = actual_count[i];
GE_ASSERT_NOTNULL(one_actual_count);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_actual_count->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
if ((pq_distance != nullptr) && (pq_distance_num > 0)) {
for (int64_t i = 0; i < pq_distance_num; ++i) {
auto one_pq_distance = pq_distance[i];
GE_ASSERT_NOTNULL(one_pq_distance);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_pq_distance->GetAnchor(), node->GetInDataAnchor(0 + actual_count_num + i)));
}
}
if ((grouped_extreme_distance != nullptr) && (grouped_extreme_distance_num > 0)) {
for (int64_t i = 0; i < grouped_extreme_distance_num; ++i) {
auto one_grouped_extreme_distance = grouped_extreme_distance[i];
GE_ASSERT_NOTNULL(one_grouped_extreme_distance);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_grouped_extreme_distance->GetAnchor(), node->GetInDataAnchor(0 + actual_count_num + pq_distance_num + i)));
}
}
if ((pq_ivf != nullptr) && (pq_ivf_num > 0)) {
for (int64_t i = 0; i < pq_ivf_num; ++i) {
auto one_pq_ivf = pq_ivf[i];
GE_ASSERT_NOTNULL(one_pq_ivf);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_pq_ivf->GetAnchor(), node->GetInDataAnchor(0 + actual_count_num + pq_distance_num + grouped_extreme_distance_num + i)));
}
}
if ((pq_index != nullptr) && (pq_index_num > 0)) {
for (int64_t i = 0; i < pq_index_num; ++i) {
auto one_pq_index = pq_index[i];
GE_ASSERT_NOTNULL(one_pq_index);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_pq_index->GetAnchor(), node->GetInDataAnchor(0 + actual_count_num + pq_distance_num + grouped_extreme_distance_num + pq_ivf_num + i)));
}
}
return EsTopKPQDistanceOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsTopKPQDistanceMergeOutput EsTopKPQDistanceMerge(EsbTensor *sorted_distance, EsbTensor *pq_ivf, EsbTensor *pq_index, int64_t k) {
GE_ASSERT_NOTNULL(sorted_distance);
GE_ASSERT_NOTNULL(pq_ivf);
GE_ASSERT_NOTNULL(pq_index);
auto &graph = sorted_distance->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TopKPQDistanceMerge")
.Name(("TopKPQDistanceMerge_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"sorted_distance", ge::kIrInputRequired, ""},
{"pq_ivf", ge::kIrInputRequired, ""},
{"pq_index", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"topk_distance", ge::kIrOutputRequired, ""},
{"topk_ivf", ge::kIrOutputRequired, ""},
{"topk_index", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"k",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(k))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sorted_distance->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(pq_ivf->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(pq_index->GetAnchor(), node->GetInDataAnchor(2)));
return EsTopKPQDistanceMergeOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsTopKPQDistanceV2Output EsTopKPQDistanceV2(EsbTensor *pq_distance, EsbTensor *grouped_extreme_distance, int64_t k, int64_t group_size, const char *order) {
GE_ASSERT_NOTNULL(pq_distance);
GE_ASSERT_NOTNULL(grouped_extreme_distance);
auto &graph = pq_distance->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TopKPQDistanceV2")
.Name(("TopKPQDistanceV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"pq_distance", ge::kIrInputRequired, ""},
{"grouped_extreme_distance", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"topk_distance", ge::kIrOutputRequired, ""},
{"topk_index", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"k",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(k))
},
{
"group_size",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(group_size))
},
{
"order",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(order))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(pq_distance->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grouped_extreme_distance->GetAnchor(), node->GetInDataAnchor(1)));
return EsTopKPQDistanceV2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsTopKV2Output EsTopKV2(EsbTensor *x, EsbTensor *k, bool sorted, int64_t dim, bool largest) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(k);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TopKV2")
.Name(("TopKV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"k", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"values", ge::kIrOutputRequired, ""},
{"indices", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"sorted",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(sorted))
},
{
"dim",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dim))
},
{
"largest",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(largest))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(k->GetAnchor(), node->GetInDataAnchor(1)));
return EsTopKV2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsTopKV2DOutput EsTopKV2D(EsbTensor *x, EsbTensor *k, EsbTensor *assist_seq, bool sorted, int64_t dim, bool largest) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(k);
GE_ASSERT_NOTNULL(assist_seq);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TopKV2D")
.Name(("TopKV2D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"k", ge::kIrInputRequired, ""},
{"assist_seq", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"values", ge::kIrOutputRequired, ""},
{"indices", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"sorted",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(sorted))
},
{
"dim",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dim))
},
{
"largest",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(largest))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(k->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(assist_seq->GetAnchor(), node->GetInDataAnchor(2)));
return EsTopKV2DOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsTopKV3Output EsTopKV3(EsbTensor *x, EsbTensor *k, bool sorted, int64_t dim, bool largest) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(k);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TopKV3")
.Name(("TopKV3_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"k", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"values", ge::kIrOutputRequired, ""},
{"indices", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"sorted",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(sorted))
},
{
"dim",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dim))
},
{
"largest",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(largest))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(k->GetAnchor(), node->GetInDataAnchor(1)));
return EsTopKV3Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsTrace(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Trace")
.Name(("Trace_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTransArgb(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TransArgb")
.Name(("TransArgb_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTransData(EsbTensor *src, const char *src_format, const char *dst_format, int64_t src_subformat, int64_t dst_subformat, int64_t groups) {
GE_ASSERT_NOTNULL(src);
auto &graph = src->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TransData")
.Name(("TransData_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"src", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"dst", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"src_format",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(src_format))
},
{
"dst_format",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(dst_format))
},
{
"src_subformat",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(src_subformat))
},
{
"dst_subformat",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dst_subformat))
},
{
"groups",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(groups))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(src->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTransDataRNN(EsbTensor *src, const char *src_format, const char *dst_format, int64_t input_size, int64_t hidden_size) {
GE_ASSERT_NOTNULL(src);
auto &graph = src->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TransDataRNN")
.Name(("TransDataRNN_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"src", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"dst", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"src_format",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(src_format))
},
{
"dst_format",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(dst_format))
},
{
"input_size",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(input_size))
},
{
"hidden_size",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(hidden_size))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(src->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTransQuantParamV2(EsbTensor *scale, EsbTensor *offset) {
GE_ASSERT_NOTNULL(scale);
auto &graph = scale->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TransQuantParamV2")
.Name(("TransQuantParamV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"scale", ge::kIrInputRequired, ""},
{"offset", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(scale->GetAnchor(), node->GetInDataAnchor(0)));
if (offset != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset->GetAnchor(), node->GetInDataAnchor(1)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTransShape(EsbTensor *x, const int64_t *outShape, int64_t outShape_num) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TransShape")
.Name(("TransShape_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"outShape",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(outShape, outShape + outShape_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTranspose(EsbTensor *x, EsbTensor *perm) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(perm);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Transpose")
.Name(("Transpose_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"perm", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(perm->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTransposeBatchMatMul(EsbTensor *x1, EsbTensor *x2, EsbTensor *bias, EsbTensor *offset_w, const int64_t *perm_x1, int64_t perm_x1_num, const int64_t *perm_x2, int64_t perm_x2_num, const int64_t *perm_y, int64_t perm_y_num, int64_t offset_x) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TransposeBatchMatMul")
.Name(("TransposeBatchMatMul_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
{"offset_w", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"perm_x1",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(perm_x1, perm_x1 + perm_x1_num))
},
{
"perm_x2",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(perm_x2, perm_x2 + perm_x2_num))
},
{
"perm_y",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(perm_y, perm_y + perm_y_num))
},
{
"offset_x",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(offset_x))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(2)));
}
if (offset_w != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(offset_w->GetAnchor(), node->GetInDataAnchor(3)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTransposeD(EsbTensor *x, const int64_t *perm, int64_t perm_num) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TransposeD")
.Name(("TransposeD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"perm",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(perm, perm + perm_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTridiagonalSolve(EsbTensor *diagonals, EsbTensor *rhs, bool partial_pivoting) {
GE_ASSERT_NOTNULL(diagonals);
GE_ASSERT_NOTNULL(rhs);
auto &graph = diagonals->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TridiagonalSolve")
.Name(("TridiagonalSolve_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"diagonals", ge::kIrInputRequired, ""},
{"rhs", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"partial_pivoting",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(partial_pivoting))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(diagonals->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(rhs->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTril(EsbTensor *x, int64_t diagonal) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Tril")
.Name(("Tril_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"diagonal",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(diagonal))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTriu(EsbTensor *x, int64_t diagonal) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Triu")
.Name(("Triu_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"diagonal",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(diagonal))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTrunc(EsbTensor *input_x) {
GE_ASSERT_NOTNULL(input_x);
auto &graph = input_x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Trunc")
.Name(("Trunc_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output_y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTruncateDiv(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TruncateDiv")
.Name(("TruncateDiv_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTruncateMod(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TruncateMod")
.Name(("TruncateMod_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsTruncatedNormal(EsbTensor *shape, int64_t seed, int64_t seed2, ge::DataType dtype) {
GE_ASSERT_NOTNULL(shape);
auto &graph = shape->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("TruncatedNormal")
.Name(("TruncatedNormal_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"shape", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"seed",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed))
},
{
"seed2",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed2))
},
{
"dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(shape->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsUnbatch(EsbTensor *x_tensor, EsbTensor *index, EsbTensor *id, int64_t timeout_micros, const char *container, const char *shared_name) {
GE_ASSERT_NOTNULL(x_tensor);
GE_ASSERT_NOTNULL(index);
GE_ASSERT_NOTNULL(id);
auto &graph = x_tensor->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Unbatch")
.Name(("Unbatch_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x_tensor", ge::kIrInputRequired, ""},
{"index", ge::kIrInputRequired, ""},
{"id", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y_tensor", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"timeout_micros",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(timeout_micros))
},
{
"container",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(container))
},
{
"shared_name",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(shared_name))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x_tensor->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(index->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(id->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsUnbatchGrad(EsbTensor *x_input, EsbTensor *index, EsbTensor *grad, EsbTensor *id, const char *container, const char *shared_name) {
GE_ASSERT_NOTNULL(x_input);
GE_ASSERT_NOTNULL(index);
GE_ASSERT_NOTNULL(grad);
GE_ASSERT_NOTNULL(id);
auto &graph = x_input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("UnbatchGrad")
.Name(("UnbatchGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x_input", ge::kIrInputRequired, ""},
{"index", ge::kIrInputRequired, ""},
{"grad", ge::kIrInputRequired, ""},
{"id", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y_grad", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"container",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(container))
},
{
"shared_name",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(shared_name))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x_input->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(index->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(id->GetAnchor(), node->GetInDataAnchor(3)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsUnicodeDecodeOutput EsUnicodeDecode(EsbTensor *input, const char *input_encoding, const char *errors, int64_t replacement_char, bool replace_control_characters, ge::DataType Tsplits) {
GE_ASSERT_NOTNULL(input);
auto &graph = input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("UnicodeDecode")
.Name(("UnicodeDecode_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"row_splits", ge::kIrOutputRequired, ""},
{"char_values", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"input_encoding",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(input_encoding))
},
{
"errors",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(errors))
},
{
"replacement_char",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(replacement_char))
},
{
"replace_control_characters",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(replace_control_characters))
},
{
"Tsplits",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(Tsplits))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input->GetAnchor(), node->GetInDataAnchor(0)));
return EsUnicodeDecodeOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsUnicodeDecodeWithOffsetsOutput EsUnicodeDecodeWithOffsets(EsbTensor *input, const char *input_encoding, const char *errors, int64_t replacement_char, bool replace_control_characters, ge::DataType Tsplits) {
GE_ASSERT_NOTNULL(input);
auto &graph = input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("UnicodeDecodeWithOffsets")
.Name(("UnicodeDecodeWithOffsets_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"row_splits", ge::kIrOutputRequired, ""},
{"char_values", ge::kIrOutputRequired, ""},
{"char_to_byte_starts", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"input_encoding",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(input_encoding))
},
{
"errors",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(errors))
},
{
"replacement_char",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(replacement_char))
},
{
"replace_control_characters",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(replace_control_characters))
},
{
"Tsplits",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(Tsplits))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input->GetAnchor(), node->GetInDataAnchor(0)));
return EsUnicodeDecodeWithOffsetsOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsUnicodeEncode(EsbTensor *input_values, EsbTensor *input_splits, const char *errors, const char *output_encoding, int64_t replacement_char) {
GE_ASSERT_NOTNULL(input_values);
GE_ASSERT_NOTNULL(input_splits);
auto &graph = input_values->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("UnicodeEncode")
.Name(("UnicodeEncode_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_values", ge::kIrInputRequired, ""},
{"input_splits", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"errors",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(errors))
},
{
"output_encoding",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(output_encoding))
},
{
"replacement_char",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(replacement_char))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_values->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_splits->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsUnicodeScript(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("UnicodeScript")
.Name(("UnicodeScript_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsUnicodeTranscode(EsbTensor *input, const char *input_encoding, const char *output_encoding, const char *errors, int64_t replacement_char, bool replace_control_characters) {
GE_ASSERT_NOTNULL(input);
auto &graph = input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("UnicodeTranscode")
.Name(("UnicodeTranscode_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"input_encoding",
ge::kAttrRequired,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(input_encoding))
},
{
"output_encoding",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(output_encoding))
},
{
"errors",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(errors))
},
{
"replacement_char",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(replacement_char))
},
{
"replace_control_characters",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(replace_control_characters))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsUniform(EsbTensor *x, float from, float to) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Uniform")
.Name(("Uniform_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"from",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(from))
},
{
"to",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(to))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsUniformCandidateSamplerOutput EsUniformCandidateSampler(EsbTensor *true_classes, int64_t num_true, int64_t num_sampled, bool unique, int64_t range_max, int64_t seed, int64_t seed2) {
GE_ASSERT_NOTNULL(true_classes);
auto &graph = true_classes->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("UniformCandidateSampler")
.Name(("UniformCandidateSampler_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"true_classes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"sampled_candidates", ge::kIrOutputRequired, ""},
{"true_expected_count", ge::kIrOutputRequired, ""},
{"sampled_expected_count", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_true",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_true))
},
{
"num_sampled",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_sampled))
},
{
"unique",
ge::kAttrRequired,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(unique))
},
{
"range_max",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(range_max))
},
{
"seed",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed))
},
{
"seed2",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(seed2))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(true_classes->GetAnchor(), node->GetInDataAnchor(0)));
return EsUniformCandidateSamplerOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsUninitEmbeddingHashmap(EsbTensor *table_id) {
GE_ASSERT_NOTNULL(table_id);
auto &graph = table_id->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("UninitEmbeddingHashmap")
.Name(("UninitEmbeddingHashmap_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"table_id", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(table_id->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsbTensor *EsUninitPartitionMap(EsbGraph *owner_graph) {
GE_ASSERT_NOTNULL(owner_graph);
EsbGraph &graph = *owner_graph;

auto desc = ge::CompliantOpDescBuilder().OpType("UninitPartitionMap")
.Name(("UninitPartitionMap_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
})
.IrDefOutputs({
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

return graph.GetEsbTensorFromNode(std::move(node), -1);
}
EsUniqueOutput EsUnique(EsbTensor *x, ge::DataType out_idx) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Unique")
.Name(("Unique_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"idx", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"out_idx",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(out_idx))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return EsUniqueOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsUniqueConsecutiveOutput EsUniqueConsecutive(EsbTensor *x, bool return_idx, bool return_counts, int64_t axis) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("UniqueConsecutive")
.Name(("UniqueConsecutive_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"idx", ge::kIrOutputRequired, ""},
{"count", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"return_idx",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(return_idx))
},
{
"return_counts",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(return_counts))
},
{
"axis",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(axis))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return EsUniqueConsecutiveOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsUniqueExt2Output EsUniqueExt2(EsbTensor *x, EsbTensor *axis, ge::DataType out_idx) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(axis);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("UniqueExt2")
.Name(("UniqueExt2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"axis", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"idx", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"out_idx",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(out_idx))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(axis->GetAnchor(), node->GetInDataAnchor(1)));
return EsUniqueExt2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsUniqueWithCountsOutput EsUniqueWithCounts(EsbTensor *x, ge::DataType out_idx) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("UniqueWithCounts")
.Name(("UniqueWithCounts_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"idx", ge::kIrOutputRequired, ""},
{"count", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"out_idx",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(out_idx))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return EsUniqueWithCountsOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsUniqueWithCountsAndSortingOutput EsUniqueWithCountsAndSorting(EsbTensor *x, bool return_inverse, bool return_counts, bool sorted) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("UniqueWithCountsAndSorting")
.Name(("UniqueWithCountsAndSorting_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"indices", ge::kIrOutputRequired, ""},
{"counts", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"return_inverse",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(return_inverse))
},
{
"return_counts",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(return_counts))
},
{
"sorted",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(sorted))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return EsUniqueWithCountsAndSortingOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsUniqueWithCountsExt2Output EsUniqueWithCountsExt2(EsbTensor *x, EsbTensor *axis, ge::DataType out_idx, bool sorted, bool return_inverse) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(axis);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("UniqueWithCountsExt2")
.Name(("UniqueWithCountsExt2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"axis", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
{"idx", ge::kIrOutputRequired, ""},
{"count", ge::kIrOutputRequired, ""},
{"inverse_idx", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"out_idx",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(out_idx))
},
{
"sorted",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(sorted))
},
{
"return_inverse",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(return_inverse))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(axis->GetAnchor(), node->GetInDataAnchor(1)));
return EsUniqueWithCountsExt2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsbTensor *EsUnravelIndex(EsbTensor *indices, EsbTensor *dims) {
GE_ASSERT_NOTNULL(indices);
GE_ASSERT_NOTNULL(dims);
auto &graph = indices->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("UnravelIndex")
.Name(("UnravelIndex_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"indices", ge::kIrInputRequired, ""},
{"dims", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(indices->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dims->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsUnsortedSegmentJoin(EsbTensor *input, EsbTensor *segment_ids, EsbTensor *num_segments, const char *separator) {
GE_ASSERT_NOTNULL(input);
GE_ASSERT_NOTNULL(segment_ids);
GE_ASSERT_NOTNULL(num_segments);
auto &graph = input->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("UnsortedSegmentJoin")
.Name(("UnsortedSegmentJoin_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input", ge::kIrInputRequired, ""},
{"segment_ids", ge::kIrInputRequired, ""},
{"num_segments", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"output", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"separator",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(separator))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(segment_ids->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(num_segments->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsUnsortedSegmentMax(EsbTensor *x, EsbTensor *segment_ids, EsbTensor *num_segments) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(segment_ids);
GE_ASSERT_NOTNULL(num_segments);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("UnsortedSegmentMax")
.Name(("UnsortedSegmentMax_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"segment_ids", ge::kIrInputRequired, ""},
{"num_segments", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(segment_ids->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(num_segments->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsUnsortedSegmentMaxD(EsbTensor *x, EsbTensor *segment_ids, int64_t num_segments) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(segment_ids);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("UnsortedSegmentMaxD")
.Name(("UnsortedSegmentMaxD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"segment_ids", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_segments",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_segments))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(segment_ids->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsUnsortedSegmentMin(EsbTensor *x, EsbTensor *segment_ids, EsbTensor *num_segments) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(segment_ids);
GE_ASSERT_NOTNULL(num_segments);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("UnsortedSegmentMin")
.Name(("UnsortedSegmentMin_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"segment_ids", ge::kIrInputRequired, ""},
{"num_segments", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(segment_ids->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(num_segments->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsUnsortedSegmentMinD(EsbTensor *x, EsbTensor *segment_ids, int64_t num_segments) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(segment_ids);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("UnsortedSegmentMinD")
.Name(("UnsortedSegmentMinD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"segment_ids", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_segments",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_segments))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(segment_ids->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsUnsortedSegmentProd(EsbTensor *x, EsbTensor *segment_ids, EsbTensor *num_segments) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(segment_ids);
GE_ASSERT_NOTNULL(num_segments);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("UnsortedSegmentProd")
.Name(("UnsortedSegmentProd_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"segment_ids", ge::kIrInputRequired, ""},
{"num_segments", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(segment_ids->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(num_segments->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsUnsortedSegmentProdD(EsbTensor *x, EsbTensor *segment_ids, int64_t num_segments) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(segment_ids);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("UnsortedSegmentProdD")
.Name(("UnsortedSegmentProdD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"segment_ids", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_segments",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_segments))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(segment_ids->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsUnsortedSegmentSum(EsbTensor *x, EsbTensor *segment_ids, EsbTensor *num_segments, bool is_preprocessed, bool check_ids) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(segment_ids);
GE_ASSERT_NOTNULL(num_segments);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("UnsortedSegmentSum")
.Name(("UnsortedSegmentSum_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"segment_ids", ge::kIrInputRequired, ""},
{"num_segments", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"is_preprocessed",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(is_preprocessed))
},
{
"check_ids",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(check_ids))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(segment_ids->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(num_segments->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsUnsortedSegmentSumD(EsbTensor *x, EsbTensor *segment_ids, int64_t num_segments) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(segment_ids);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("UnsortedSegmentSumD")
.Name(("UnsortedSegmentSumD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"segment_ids", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_segments",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_segments))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(segment_ids->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsUnsqueeze(EsbTensor *x, const int64_t *axes, int64_t axes_num) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Unsqueeze")
.Name(("Unsqueeze_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axes",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(axes, axes + axes_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsUnsqueezeV2(EsbTensor *x, const int64_t *axis, int64_t axis_num) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("UnsqueezeV2")
.Name(("UnsqueezeV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"axis",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(axis, axis + axis_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsUnsqueezeV3(EsbTensor *x, EsbTensor *axes) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(axes);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("UnsqueezeV3")
.Name(("UnsqueezeV3_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"axes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(axes->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsUpdateTensorDesc(EsbTensor *x, const int64_t *shape, int64_t shape_num) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("UpdateTensorDesc")
.Name(("UpdateTensorDesc_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"shape",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(shape, shape + shape_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsUpperBound(EsbTensor *sorted_x, EsbTensor *values, ge::DataType out_type) {
GE_ASSERT_NOTNULL(sorted_x);
GE_ASSERT_NOTNULL(values);
auto &graph = sorted_x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("UpperBound")
.Name(("UpperBound_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"sorted_x", ge::kIrInputRequired, ""},
{"values", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"out_type",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(out_type))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(sorted_x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(values->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsUpsample(EsbTensor *x, float scale, int64_t stride_h, int64_t stride_w) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Upsample")
.Name(("Upsample_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"scale",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(scale))
},
{
"stride_h",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(stride_h))
},
{
"stride_w",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(stride_w))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsUpsampleNearest1d(EsbTensor *x, const int64_t *output_size, int64_t output_size_num, const float *scales, int64_t scales_num) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("UpsampleNearest1d")
.Name(("UpsampleNearest1d_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"output_size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(output_size, output_size + output_size_num))
},
{
"scales",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(scales, scales + scales_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsUpsampleNearest1dGrad(EsbTensor *grad_output, const int64_t *input_size, int64_t input_size_num, const int64_t *output_size, int64_t output_size_num, const float *scales, int64_t scales_num) {
GE_ASSERT_NOTNULL(grad_output);
auto &graph = grad_output->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("UpsampleNearest1dGrad")
.Name(("UpsampleNearest1dGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grad_output", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"input_size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(input_size, input_size + input_size_num))
},
{
"output_size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(output_size, output_size + output_size_num))
},
{
"scales",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(scales, scales + scales_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad_output->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsUpsampleNearest3d(EsbTensor *x, const int64_t *output_size, int64_t output_size_num, const float *scales, int64_t scales_num) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("UpsampleNearest3d")
.Name(("UpsampleNearest3d_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"output_size",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(output_size, output_size + output_size_num))
},
{
"scales",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(scales, scales + scales_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsUpsampleNearest3dGrad(EsbTensor *grad_output, const int64_t *input_size, int64_t input_size_num, const int64_t *output_size, int64_t output_size_num, const float *scales, int64_t scales_num) {
GE_ASSERT_NOTNULL(grad_output);
auto &graph = grad_output->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("UpsampleNearest3dGrad")
.Name(("UpsampleNearest3dGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grad_output", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"input_size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(input_size, input_size + input_size_num))
},
{
"output_size",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(output_size, output_size + output_size_num))
},
{
"scales",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(scales, scales + scales_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad_output->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsUpsampleNearestExact3d(EsbTensor *x, const int64_t *output_size, int64_t output_size_num, const float *scales, int64_t scales_num) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("UpsampleNearestExact3d")
.Name(("UpsampleNearestExact3d_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"output_size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(output_size, output_size + output_size_num))
},
{
"scales",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(scales, scales + scales_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsUpsampleNearestExact3dGrad(EsbTensor *grad_output, const int64_t *input_size, int64_t input_size_num, const int64_t *output_size, int64_t output_size_num, const float *scales, int64_t scales_num) {
GE_ASSERT_NOTNULL(grad_output);
auto &graph = grad_output->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("UpsampleNearestExact3dGrad")
.Name(("UpsampleNearestExact3dGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grad_output", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"input_size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(input_size, input_size + input_size_num))
},
{
"output_size",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(output_size, output_size + output_size_num))
},
{
"scales",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(scales, scales + scales_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad_output->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsUpsampleTrilinear3d(EsbTensor *x, const int64_t *output_size, int64_t output_size_num, const float *scales, int64_t scales_num, bool align_corners) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("UpsampleTrilinear3d")
.Name(("UpsampleTrilinear3d_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"output_size",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(output_size, output_size + output_size_num))
},
{
"scales",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(scales, scales + scales_num))
},
{
"align_corners",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(align_corners))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsUpsampleTrilinear3dGrad(EsbTensor *grad_output, const int64_t *input_size, int64_t input_size_num, const int64_t *output_size, int64_t output_size_num, const float *scales, int64_t scales_num, bool align_corners) {
GE_ASSERT_NOTNULL(grad_output);
auto &graph = grad_output->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("UpsampleTrilinear3dGrad")
.Name(("UpsampleTrilinear3dGrad_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"grad_output", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"input_size",
ge::kAttrRequired,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(input_size, input_size + input_size_num))
},
{
"output_size",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(output_size, output_size + output_size_num))
},
{
"scales",
ge::kAttrOptional,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(scales, scales + scales_num))
},
{
"align_corners",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(align_corners))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(grad_output->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsVarHandleOp(EsbGraph *owner_graph, ge::DataType dtype, const char *container, const char *shared_name, const int64_t *shape, int64_t shape_num) {
GE_ASSERT_NOTNULL(owner_graph);
EsbGraph &graph = *owner_graph;

auto desc = ge::CompliantOpDescBuilder().OpType("VarHandleOp")
.Name(("VarHandleOp_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrRequired,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
{
"container",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(container))
},
{
"shared_name",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(shared_name))
},
{
"shape",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(shape, shape + shape_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsVarIsInitializedOp(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("VarIsInitializedOp")
.Name(("VarIsInitializedOp_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsViewCopy(EsbTensor *dst, EsbTensor *dst_size, EsbTensor *dst_stride, EsbTensor *dst_storage_offset, EsbTensor *src, EsbTensor *src_size, EsbTensor *src_stride, EsbTensor *src_storage_offset) {
GE_ASSERT_NOTNULL(dst);
GE_ASSERT_NOTNULL(dst_size);
GE_ASSERT_NOTNULL(dst_stride);
GE_ASSERT_NOTNULL(dst_storage_offset);
GE_ASSERT_NOTNULL(src);
GE_ASSERT_NOTNULL(src_size);
GE_ASSERT_NOTNULL(src_stride);
GE_ASSERT_NOTNULL(src_storage_offset);
auto &graph = dst->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ViewCopy")
.Name(("ViewCopy_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"dst", ge::kIrInputRequired, ""},
{"dst_size", ge::kIrInputRequired, ""},
{"dst_stride", ge::kIrInputRequired, ""},
{"dst_storage_offset", ge::kIrInputRequired, ""},
{"src", ge::kIrInputRequired, ""},
{"src_size", ge::kIrInputRequired, ""},
{"src_stride", ge::kIrInputRequired, ""},
{"src_storage_offset", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"dst", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dst->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dst_size->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dst_stride->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dst_storage_offset->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(src->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(src_size->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(src_stride->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(src_storage_offset->GetAnchor(), node->GetInDataAnchor(7)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsVoxelizationOutput EsVoxelization(EsbTensor *points, EsbTensor *voxel_size, EsbTensor *coors_range, int64_t max_points, int64_t max_voxels, bool deterministic) {
GE_ASSERT_NOTNULL(points);
GE_ASSERT_NOTNULL(voxel_size);
GE_ASSERT_NOTNULL(coors_range);
auto &graph = points->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Voxelization")
.Name(("Voxelization_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"points", ge::kIrInputRequired, ""},
{"voxel_size", ge::kIrInputRequired, ""},
{"coors_range", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"voxels", ge::kIrOutputRequired, ""},
{"coors", ge::kIrOutputRequired, ""},
{"num_points_per_voxel", ge::kIrOutputRequired, ""},
{"voxel_num", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"max_points",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(max_points))
},
{
"max_voxels",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(max_voxels))
},
{
"deterministic",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(deterministic))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(points->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(voxel_size->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(coors_range->GetAnchor(), node->GetInDataAnchor(2)));
return EsVoxelizationOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
graph.GetEsbTensorFromNode(node, 3),
};
}
EsbTensor *EsWarpAffine(EsbTensor *x, EsbTensor *matrix, int64_t out_height, int64_t out_width, const char *interpolation_mode, const char *padding_mode, int64_t padding_value) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(matrix);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("WarpAffine")
.Name(("WarpAffine_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"matrix", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"out_height",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(out_height))
},
{
"out_width",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(out_width))
},
{
"interpolation_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(interpolation_mode))
},
{
"padding_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(padding_mode))
},
{
"padding_value",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(padding_value))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(matrix->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsWarpAffineV2(EsbTensor *x, EsbTensor *matrix, EsbTensor *dst_size, const char *interpolation, const char *border_type, float border_value, const char *data_format) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(matrix);
GE_ASSERT_NOTNULL(dst_size);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("WarpAffineV2")
.Name(("WarpAffineV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"matrix", ge::kIrInputRequired, ""},
{"dst_size", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"interpolation",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(interpolation))
},
{
"border_type",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(border_type))
},
{
"border_value",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(border_value))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(matrix->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(dst_size->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsWarpPerspective(EsbTensor *x, EsbTensor *matrix, int64_t out_height, int64_t out_width, const char *interpolation_mode, const char *border_type, float constant, const char *data_format) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(matrix);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("WarpPerspective")
.Name(("WarpPerspective_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"matrix", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"out_height",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(out_height))
},
{
"out_width",
ge::kAttrRequired,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(out_width))
},
{
"interpolation_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(interpolation_mode))
},
{
"border_type",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(border_type))
},
{
"constant",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(constant))
},
{
"data_format",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(data_format))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(matrix->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsWeightQuantBatchMatmulV2(EsbTensor *x, EsbTensor *weight, EsbTensor *antiquant_scale, EsbTensor *antiquant_offset, EsbTensor *quant_scale, EsbTensor *quant_offset, EsbTensor *bias, bool transpose_x, bool transpose_weight, int64_t antiquant_group_size, int64_t dtype, int64_t inner_precise) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(weight);
GE_ASSERT_NOTNULL(antiquant_scale);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("WeightQuantBatchMatmulV2")
.Name(("WeightQuantBatchMatmulV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"weight", ge::kIrInputRequired, ""},
{"antiquant_scale", ge::kIrInputRequired, ""},
{"antiquant_offset", ge::kIrInputOptional, ""},
{"quant_scale", ge::kIrInputOptional, ""},
{"quant_offset", ge::kIrInputOptional, ""},
{"bias", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"transpose_x",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(transpose_x))
},
{
"transpose_weight",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(transpose_weight))
},
{
"antiquant_group_size",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(antiquant_group_size))
},
{
"dtype",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(dtype))
},
{
"inner_precise",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(inner_precise))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(weight->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(antiquant_scale->GetAnchor(), node->GetInDataAnchor(2)));
if (antiquant_offset != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(antiquant_offset->GetAnchor(), node->GetInDataAnchor(3)));
}
if (quant_scale != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(quant_scale->GetAnchor(), node->GetInDataAnchor(4)));
}
if (quant_offset != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(quant_offset->GetAnchor(), node->GetInDataAnchor(5)));
}
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(6)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsWeightQuantBatchmatmul(EsbTensor *input_x, EsbTensor *input_y, EsbTensor *diagonal_matrix, EsbTensor *q_bias, EsbTensor *deq_scale, EsbTensor *bias, bool adj_x1, bool adj_x2) {
GE_ASSERT_NOTNULL(input_x);
GE_ASSERT_NOTNULL(input_y);
GE_ASSERT_NOTNULL(diagonal_matrix);
GE_ASSERT_NOTNULL(q_bias);
GE_ASSERT_NOTNULL(deq_scale);
auto &graph = input_x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("WeightQuantBatchmatmul")
.Name(("WeightQuantBatchmatmul_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_x", ge::kIrInputRequired, ""},
{"input_y", ge::kIrInputRequired, ""},
{"diagonal_matrix", ge::kIrInputRequired, ""},
{"q_bias", ge::kIrInputRequired, ""},
{"deq_scale", ge::kIrInputRequired, ""},
{"bias", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"adj_x1",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(adj_x1))
},
{
"adj_x2",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(adj_x2))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_y->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(diagonal_matrix->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(q_bias->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(deq_scale->GetAnchor(), node->GetInDataAnchor(4)));
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(5)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsWeightQuantBatchmatmulV3(EsbTensor *input_x, EsbTensor *input_y, EsbTensor *diagonal_matrix, EsbTensor *q_bias, EsbTensor *deq_scale, EsbTensor *mul_scale, EsbTensor *add_offset, EsbTensor *bias, bool adj_x1, bool adj_x2, float scale, float offset) {
GE_ASSERT_NOTNULL(input_x);
GE_ASSERT_NOTNULL(input_y);
GE_ASSERT_NOTNULL(diagonal_matrix);
GE_ASSERT_NOTNULL(q_bias);
GE_ASSERT_NOTNULL(deq_scale);
auto &graph = input_x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("WeightQuantBatchmatmulV3")
.Name(("WeightQuantBatchmatmulV3_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"input_x", ge::kIrInputRequired, ""},
{"input_y", ge::kIrInputRequired, ""},
{"diagonal_matrix", ge::kIrInputRequired, ""},
{"q_bias", ge::kIrInputRequired, ""},
{"deq_scale", ge::kIrInputRequired, ""},
{"mul_scale", ge::kIrInputOptional, ""},
{"add_offset", ge::kIrInputOptional, ""},
{"bias", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"adj_x1",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(adj_x1))
},
{
"adj_x2",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(adj_x2))
},
{
"scale",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(scale))
},
{
"offset",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(offset))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(input_y->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(diagonal_matrix->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(q_bias->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(deq_scale->GetAnchor(), node->GetInDataAnchor(4)));
if (mul_scale != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(mul_scale->GetAnchor(), node->GetInDataAnchor(5)));
}
if (add_offset != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(add_offset->GetAnchor(), node->GetInDataAnchor(6)));
}
if (bias != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bias->GetAnchor(), node->GetInDataAnchor(7)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsWhere(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Where")
.Name(("Where_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsWriteSelect(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("WriteSelect")
.Name(("WriteSelect_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsWtsARQ(EsbTensor *w, EsbTensor *w_min, EsbTensor *w_max, int64_t num_bits, bool offset_flag) {
GE_ASSERT_NOTNULL(w);
GE_ASSERT_NOTNULL(w_min);
GE_ASSERT_NOTNULL(w_max);
auto &graph = w->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("WtsARQ")
.Name(("WtsARQ_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"w", ge::kIrInputRequired, ""},
{"w_min", ge::kIrInputRequired, ""},
{"w_max", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"num_bits",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(num_bits))
},
{
"offset_flag",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(offset_flag))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(w->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(w_min->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(w_max->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsXdivy(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Xdivy")
.Name(("Xdivy_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsXlog1py(EsbTensor *x, EsbTensor *y) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(y);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Xlog1py")
.Name(("Xlog1py_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"y", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"z", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(y->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsXlogy(EsbTensor *x1, EsbTensor *x2) {
GE_ASSERT_NOTNULL(x1);
GE_ASSERT_NOTNULL(x2);
auto &graph = x1->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Xlogy")
.Name(("Xlogy_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x1", ge::kIrInputRequired, ""},
{"x2", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x1->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x2->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsYUV4442YUV422(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("YUV4442YUV422")
.Name(("YUV4442YUV422_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsYUVToRGB(EsbTensor *x, EsbTensor *matrix, int64_t matrix_type, int64_t rb_swap) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("YUVToRGB")
.Name(("YUVToRGB_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"matrix", ge::kIrInputOptional, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"matrix_type",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(matrix_type))
},
{
"rb_swap",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(rb_swap))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
if (matrix != nullptr) {
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(matrix->GetAnchor(), node->GetInDataAnchor(1)));
}
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsYoloOutput EsYolo(EsbTensor *x, int64_t boxes, int64_t coords, int64_t classes, const char *yolo_version, bool softmax, bool background, bool softmaxtree) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Yolo")
.Name(("Yolo_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"coord_data", ge::kIrOutputRequired, ""},
{"obj_prob", ge::kIrOutputRequired, ""},
{"classes_prob", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"boxes",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(boxes))
},
{
"coords",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(coords))
},
{
"classes",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(classes))
},
{
"yolo_version",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(yolo_version))
},
{
"softmax",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(softmax))
},
{
"background",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(background))
},
{
"softmaxtree",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(softmaxtree))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return EsYoloOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsbTensor *EsYoloBoxesEncode(EsbTensor *anchor_boxes, EsbTensor *gt_bboxes, EsbTensor *stride, const char *performance_mode) {
GE_ASSERT_NOTNULL(anchor_boxes);
GE_ASSERT_NOTNULL(gt_bboxes);
GE_ASSERT_NOTNULL(stride);
auto &graph = anchor_boxes->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("YoloBoxesEncode")
.Name(("YoloBoxesEncode_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"anchor_boxes", ge::kIrInputRequired, ""},
{"gt_bboxes", ge::kIrInputRequired, ""},
{"stride", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"encoded_bboxes", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"performance_mode",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(performance_mode))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(anchor_boxes->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(gt_bboxes->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(stride->GetAnchor(), node->GetInDataAnchor(2)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsYoloPreDetectionOutput EsYoloPreDetection(EsbTensor *x, int64_t boxes, int64_t coords, int64_t classes, const char *yolo_version, bool softmax, bool background, bool softmaxtree) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("YoloPreDetection")
.Name(("YoloPreDetection_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"coord_data", ge::kIrOutputRequired, ""},
{"obj_prob", ge::kIrOutputRequired, ""},
{"classes_prob", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"boxes",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(boxes))
},
{
"coords",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(coords))
},
{
"classes",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(classes))
},
{
"yolo_version",
ge::kAttrOptional,
"VT_STRING",
ge::AnyValue::CreateFrom(std::string(yolo_version))
},
{
"softmax",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(softmax))
},
{
"background",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(background))
},
{
"softmaxtree",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(softmaxtree))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return EsYoloPreDetectionOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
graph.GetEsbTensorFromNode(node, 2),
};
}
EsYoloV2DetectionOutputOutput EsYoloV2DetectionOutput(EsbTensor *coord_data, EsbTensor *obj_prob, EsbTensor *classes_prob, EsbTensor *img_info, const float *biases, int64_t biases_num, int64_t boxes, int64_t coords, int64_t classes, bool relative, float obj_threshold, int64_t post_nms_topn, float score_threshold, float iou_threshold, int64_t pre_nms_topn) {
GE_ASSERT_NOTNULL(coord_data);
GE_ASSERT_NOTNULL(obj_prob);
GE_ASSERT_NOTNULL(classes_prob);
GE_ASSERT_NOTNULL(img_info);
auto &graph = coord_data->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("YoloV2DetectionOutput")
.Name(("YoloV2DetectionOutput_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"coord_data", ge::kIrInputRequired, ""},
{"obj_prob", ge::kIrInputRequired, ""},
{"classes_prob", ge::kIrInputRequired, ""},
{"img_info", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"box_out", ge::kIrOutputRequired, ""},
{"box_out_num", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"biases",
ge::kAttrRequired,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(biases, biases + biases_num))
},
{
"boxes",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(boxes))
},
{
"coords",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(coords))
},
{
"classes",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(classes))
},
{
"relative",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(relative))
},
{
"obj_threshold",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(obj_threshold))
},
{
"post_nms_topn",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(post_nms_topn))
},
{
"score_threshold",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(score_threshold))
},
{
"iou_threshold",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(iou_threshold))
},
{
"pre_nms_topn",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pre_nms_topn))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(coord_data->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(obj_prob->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(classes_prob->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(img_info->GetAnchor(), node->GetInDataAnchor(3)));
return EsYoloV2DetectionOutputOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsYoloV2DetectionOutputDOutput EsYoloV2DetectionOutputD(EsbTensor *coord_data, EsbTensor *obj_prob, EsbTensor *classes_prob, EsbTensor *img_info, EsbTensor *windex, EsbTensor *hindex, const float *biases, int64_t biases_num, int64_t boxes, int64_t coords, int64_t classes, bool relative, float obj_threshold, int64_t post_nms_topn, float score_threshold, float iou_threshold, int64_t pre_nms_topn) {
GE_ASSERT_NOTNULL(coord_data);
GE_ASSERT_NOTNULL(obj_prob);
GE_ASSERT_NOTNULL(classes_prob);
GE_ASSERT_NOTNULL(img_info);
GE_ASSERT_NOTNULL(windex);
GE_ASSERT_NOTNULL(hindex);
auto &graph = coord_data->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("YoloV2DetectionOutputD")
.Name(("YoloV2DetectionOutputD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"coord_data", ge::kIrInputRequired, ""},
{"obj_prob", ge::kIrInputRequired, ""},
{"classes_prob", ge::kIrInputRequired, ""},
{"img_info", ge::kIrInputRequired, ""},
{"windex", ge::kIrInputRequired, ""},
{"hindex", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"box_out", ge::kIrOutputRequired, ""},
{"box_out_num", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"biases",
ge::kAttrRequired,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(biases, biases + biases_num))
},
{
"boxes",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(boxes))
},
{
"coords",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(coords))
},
{
"classes",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(classes))
},
{
"relative",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(relative))
},
{
"obj_threshold",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(obj_threshold))
},
{
"post_nms_topn",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(post_nms_topn))
},
{
"score_threshold",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(score_threshold))
},
{
"iou_threshold",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(iou_threshold))
},
{
"pre_nms_topn",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pre_nms_topn))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(coord_data->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(obj_prob->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(classes_prob->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(img_info->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(windex->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(hindex->GetAnchor(), node->GetInDataAnchor(5)));
return EsYoloV2DetectionOutputDOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsYoloV3DetectionOutputOutput EsYoloV3DetectionOutput(EsbTensor *coord_data_low, EsbTensor *coord_data_mid, EsbTensor *coord_data_high, EsbTensor *obj_prob_low, EsbTensor *obj_prob_mid, EsbTensor *obj_prob_high, EsbTensor *classes_prob_low, EsbTensor *classes_prob_mid, EsbTensor *classes_prob_high, EsbTensor *img_info, const float *biases_low, int64_t biases_low_num, const float *biases_mid, int64_t biases_mid_num, const float *biases_high, int64_t biases_high_num, int64_t boxes, int64_t coords, int64_t classes, bool relative, float obj_threshold, int64_t post_nms_topn, float score_threshold, float iou_threshold, int64_t pre_nms_topn) {
GE_ASSERT_NOTNULL(coord_data_low);
GE_ASSERT_NOTNULL(coord_data_mid);
GE_ASSERT_NOTNULL(coord_data_high);
GE_ASSERT_NOTNULL(obj_prob_low);
GE_ASSERT_NOTNULL(obj_prob_mid);
GE_ASSERT_NOTNULL(obj_prob_high);
GE_ASSERT_NOTNULL(classes_prob_low);
GE_ASSERT_NOTNULL(classes_prob_mid);
GE_ASSERT_NOTNULL(classes_prob_high);
GE_ASSERT_NOTNULL(img_info);
auto &graph = coord_data_low->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("YoloV3DetectionOutput")
.Name(("YoloV3DetectionOutput_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"coord_data_low", ge::kIrInputRequired, ""},
{"coord_data_mid", ge::kIrInputRequired, ""},
{"coord_data_high", ge::kIrInputRequired, ""},
{"obj_prob_low", ge::kIrInputRequired, ""},
{"obj_prob_mid", ge::kIrInputRequired, ""},
{"obj_prob_high", ge::kIrInputRequired, ""},
{"classes_prob_low", ge::kIrInputRequired, ""},
{"classes_prob_mid", ge::kIrInputRequired, ""},
{"classes_prob_high", ge::kIrInputRequired, ""},
{"img_info", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"box_out", ge::kIrOutputRequired, ""},
{"box_out_num", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"biases_low",
ge::kAttrRequired,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(biases_low, biases_low + biases_low_num))
},
{
"biases_mid",
ge::kAttrRequired,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(biases_mid, biases_mid + biases_mid_num))
},
{
"biases_high",
ge::kAttrRequired,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(biases_high, biases_high + biases_high_num))
},
{
"boxes",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(boxes))
},
{
"coords",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(coords))
},
{
"classes",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(classes))
},
{
"relative",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(relative))
},
{
"obj_threshold",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(obj_threshold))
},
{
"post_nms_topn",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(post_nms_topn))
},
{
"score_threshold",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(score_threshold))
},
{
"iou_threshold",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(iou_threshold))
},
{
"pre_nms_topn",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pre_nms_topn))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(coord_data_low->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(coord_data_mid->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(coord_data_high->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(obj_prob_low->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(obj_prob_mid->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(obj_prob_high->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(classes_prob_low->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(classes_prob_mid->GetAnchor(), node->GetInDataAnchor(7)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(classes_prob_high->GetAnchor(), node->GetInDataAnchor(8)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(img_info->GetAnchor(), node->GetInDataAnchor(9)));
return EsYoloV3DetectionOutputOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsYoloV3DetectionOutputDOutput EsYoloV3DetectionOutputD(EsbTensor *coord_data_low, EsbTensor *coord_data_mid, EsbTensor *coord_data_high, EsbTensor *obj_prob_low, EsbTensor *obj_prob_mid, EsbTensor *obj_prob_high, EsbTensor *classes_prob_low, EsbTensor *classes_prob_mid, EsbTensor *classes_prob_high, EsbTensor *img_info, EsbTensor *windex1, EsbTensor *windex2, EsbTensor *windex3, EsbTensor *hindex1, EsbTensor *hindex2, EsbTensor *hindex3, const float *biases_low, int64_t biases_low_num, const float *biases_mid, int64_t biases_mid_num, const float *biases_high, int64_t biases_high_num, int64_t boxes, int64_t coords, int64_t classes, bool relative, float obj_threshold, int64_t post_nms_topn, float score_threshold, float iou_threshold, int64_t pre_nms_topn) {
GE_ASSERT_NOTNULL(coord_data_low);
GE_ASSERT_NOTNULL(coord_data_mid);
GE_ASSERT_NOTNULL(coord_data_high);
GE_ASSERT_NOTNULL(obj_prob_low);
GE_ASSERT_NOTNULL(obj_prob_mid);
GE_ASSERT_NOTNULL(obj_prob_high);
GE_ASSERT_NOTNULL(classes_prob_low);
GE_ASSERT_NOTNULL(classes_prob_mid);
GE_ASSERT_NOTNULL(classes_prob_high);
GE_ASSERT_NOTNULL(img_info);
GE_ASSERT_NOTNULL(windex1);
GE_ASSERT_NOTNULL(windex2);
GE_ASSERT_NOTNULL(windex3);
GE_ASSERT_NOTNULL(hindex1);
GE_ASSERT_NOTNULL(hindex2);
GE_ASSERT_NOTNULL(hindex3);
auto &graph = coord_data_low->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("YoloV3DetectionOutputD")
.Name(("YoloV3DetectionOutputD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"coord_data_low", ge::kIrInputRequired, ""},
{"coord_data_mid", ge::kIrInputRequired, ""},
{"coord_data_high", ge::kIrInputRequired, ""},
{"obj_prob_low", ge::kIrInputRequired, ""},
{"obj_prob_mid", ge::kIrInputRequired, ""},
{"obj_prob_high", ge::kIrInputRequired, ""},
{"classes_prob_low", ge::kIrInputRequired, ""},
{"classes_prob_mid", ge::kIrInputRequired, ""},
{"classes_prob_high", ge::kIrInputRequired, ""},
{"img_info", ge::kIrInputRequired, ""},
{"windex1", ge::kIrInputRequired, ""},
{"windex2", ge::kIrInputRequired, ""},
{"windex3", ge::kIrInputRequired, ""},
{"hindex1", ge::kIrInputRequired, ""},
{"hindex2", ge::kIrInputRequired, ""},
{"hindex3", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"box_out", ge::kIrOutputRequired, ""},
{"box_out_num", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"biases_low",
ge::kAttrRequired,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(biases_low, biases_low + biases_low_num))
},
{
"biases_mid",
ge::kAttrRequired,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(biases_mid, biases_mid + biases_mid_num))
},
{
"biases_high",
ge::kAttrRequired,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(biases_high, biases_high + biases_high_num))
},
{
"boxes",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(boxes))
},
{
"coords",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(coords))
},
{
"classes",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(classes))
},
{
"relative",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(relative))
},
{
"obj_threshold",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(obj_threshold))
},
{
"post_nms_topn",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(post_nms_topn))
},
{
"score_threshold",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(score_threshold))
},
{
"iou_threshold",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(iou_threshold))
},
{
"pre_nms_topn",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pre_nms_topn))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(coord_data_low->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(coord_data_mid->GetAnchor(), node->GetInDataAnchor(1)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(coord_data_high->GetAnchor(), node->GetInDataAnchor(2)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(obj_prob_low->GetAnchor(), node->GetInDataAnchor(3)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(obj_prob_mid->GetAnchor(), node->GetInDataAnchor(4)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(obj_prob_high->GetAnchor(), node->GetInDataAnchor(5)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(classes_prob_low->GetAnchor(), node->GetInDataAnchor(6)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(classes_prob_mid->GetAnchor(), node->GetInDataAnchor(7)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(classes_prob_high->GetAnchor(), node->GetInDataAnchor(8)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(img_info->GetAnchor(), node->GetInDataAnchor(9)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(windex1->GetAnchor(), node->GetInDataAnchor(10)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(windex2->GetAnchor(), node->GetInDataAnchor(11)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(windex3->GetAnchor(), node->GetInDataAnchor(12)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(hindex1->GetAnchor(), node->GetInDataAnchor(13)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(hindex2->GetAnchor(), node->GetInDataAnchor(14)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(hindex3->GetAnchor(), node->GetInDataAnchor(15)));
return EsYoloV3DetectionOutputDOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsYoloV3DetectionOutputV2Output EsYoloV3DetectionOutputV2(EsbTensor **x, int64_t x_num, const float *biases, int64_t biases_num, int64_t boxes, int64_t coords, int64_t classes, bool relative, float obj_threshold, int64_t post_nms_topn, float score_threshold, float iou_threshold, int64_t pre_nms_topn, int64_t N, bool resize_origin_img_to_net, int64_t out_box_dim) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("YoloV3DetectionOutputV2")
.Name(("YoloV3DetectionOutputV2_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
{"box_out", ge::kIrOutputRequired, ""},
{"box_out_num", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"biases",
ge::kAttrRequired,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(biases, biases + biases_num))
},
{
"boxes",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(boxes))
},
{
"coords",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(coords))
},
{
"classes",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(classes))
},
{
"relative",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(relative))
},
{
"obj_threshold",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(obj_threshold))
},
{
"post_nms_topn",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(post_nms_topn))
},
{
"score_threshold",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(score_threshold))
},
{
"iou_threshold",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(iou_threshold))
},
{
"pre_nms_topn",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pre_nms_topn))
},
{
"N",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(N))
},
{
"resize_origin_img_to_net",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(resize_origin_img_to_net))
},
{
"out_box_dim",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(out_box_dim))
},
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return EsYoloV3DetectionOutputV2Output{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsYoloV3DetectionOutputV2DOutput EsYoloV3DetectionOutputV2D(EsbTensor **x, int64_t x_num, EsbTensor **windex, int64_t windex_num, EsbTensor **hindex, int64_t hindex_num, const float *biases, int64_t biases_num, int64_t boxes, int64_t coords, int64_t classes, bool relative, float obj_threshold, int64_t post_nms_topn, float score_threshold, float iou_threshold, int64_t pre_nms_topn, int64_t N, bool resize_origin_img_to_net, int64_t out_box_dim) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(windex_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(hindex_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
if (non_null_in == nullptr) {
for (int64_t i = 0; i < windex_num; ++i) {
if (windex[i] != nullptr) {
non_null_in = windex[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
if (non_null_in == nullptr) {
for (int64_t i = 0; i < hindex_num; ++i) {
if (hindex[i] != nullptr) {
non_null_in = hindex[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("YoloV3DetectionOutputV2D")
.Name(("YoloV3DetectionOutputV2D_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
{"windex", ge::kIrInputDynamic, ""},
{"hindex", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
{"box_out", ge::kIrOutputRequired, ""},
{"box_out_num", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"biases",
ge::kAttrRequired,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(biases, biases + biases_num))
},
{
"boxes",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(boxes))
},
{
"coords",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(coords))
},
{
"classes",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(classes))
},
{
"relative",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(relative))
},
{
"obj_threshold",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(obj_threshold))
},
{
"post_nms_topn",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(post_nms_topn))
},
{
"score_threshold",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(score_threshold))
},
{
"iou_threshold",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(iou_threshold))
},
{
"pre_nms_topn",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pre_nms_topn))
},
{
"N",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(N))
},
{
"resize_origin_img_to_net",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(resize_origin_img_to_net))
},
{
"out_box_dim",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(out_box_dim))
},
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.InstanceDynamicInputNum("windex", static_cast<int32_t>(windex_num))
.InstanceDynamicInputNum("hindex", static_cast<int32_t>(hindex_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
if ((windex != nullptr) && (windex_num > 0)) {
for (int64_t i = 0; i < windex_num; ++i) {
auto one_windex = windex[i];
GE_ASSERT_NOTNULL(one_windex);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_windex->GetAnchor(), node->GetInDataAnchor(0 + x_num + i)));
}
}
if ((hindex != nullptr) && (hindex_num > 0)) {
for (int64_t i = 0; i < hindex_num; ++i) {
auto one_hindex = hindex[i];
GE_ASSERT_NOTNULL(one_hindex);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_hindex->GetAnchor(), node->GetInDataAnchor(0 + x_num + windex_num + i)));
}
}
return EsYoloV3DetectionOutputV2DOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsYoloV5DetectionOutputOutput EsYoloV5DetectionOutput(EsbTensor **x, int64_t x_num, const float *biases, int64_t biases_num, int64_t boxes, int64_t coords, int64_t classes, bool relative, float obj_threshold, int64_t post_nms_topn, float score_threshold, float iou_threshold, int64_t pre_nms_topn, int64_t N, bool resize_origin_img_to_net, int64_t out_box_dim, float alpha) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("YoloV5DetectionOutput")
.Name(("YoloV5DetectionOutput_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
{"box_out", ge::kIrOutputRequired, ""},
{"box_out_num", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"biases",
ge::kAttrRequired,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(biases, biases + biases_num))
},
{
"boxes",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(boxes))
},
{
"coords",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(coords))
},
{
"classes",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(classes))
},
{
"relative",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(relative))
},
{
"obj_threshold",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(obj_threshold))
},
{
"post_nms_topn",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(post_nms_topn))
},
{
"score_threshold",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(score_threshold))
},
{
"iou_threshold",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(iou_threshold))
},
{
"pre_nms_topn",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pre_nms_topn))
},
{
"N",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(N))
},
{
"resize_origin_img_to_net",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(resize_origin_img_to_net))
},
{
"out_box_dim",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(out_box_dim))
},
{
"alpha",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(alpha))
},
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
return EsYoloV5DetectionOutputOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsYoloV5DetectionOutputDOutput EsYoloV5DetectionOutputD(EsbTensor **x, int64_t x_num, EsbTensor **windex, int64_t windex_num, EsbTensor **hindex, int64_t hindex_num, const float *biases, int64_t biases_num, int64_t boxes, int64_t coords, int64_t classes, bool relative, float obj_threshold, int64_t post_nms_topn, float score_threshold, float iou_threshold, int64_t pre_nms_topn, int64_t N, bool resize_origin_img_to_net, int64_t out_box_dim, float alpha) {
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(x_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(windex_num));
GE_ASSERT_TRUE(ge::IntegerChecker<int32_t>::Compat(hindex_num));
EsbTensor *non_null_in = nullptr;
if (non_null_in == nullptr) {
for (int64_t i = 0; i < x_num; ++i) {
if (x[i] != nullptr) {
non_null_in = x[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
if (non_null_in == nullptr) {
for (int64_t i = 0; i < windex_num; ++i) {
if (windex[i] != nullptr) {
non_null_in = windex[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
if (non_null_in == nullptr) {
for (int64_t i = 0; i < hindex_num; ++i) {
if (hindex[i] != nullptr) {
non_null_in = hindex[i];
break;
}
}
}
GE_ASSERT_NOTNULL(non_null_in);
auto &graph = non_null_in->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("YoloV5DetectionOutputD")
.Name(("YoloV5DetectionOutputD_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputDynamic, ""},
{"windex", ge::kIrInputDynamic, ""},
{"hindex", ge::kIrInputDynamic, ""},
})
.IrDefOutputs({
{"box_out", ge::kIrOutputRequired, ""},
{"box_out_num", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"biases",
ge::kAttrRequired,
"VT_LIST_FLOAT",
ge::AnyValue::CreateFrom(std::vector<float>(biases, biases + biases_num))
},
{
"boxes",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(boxes))
},
{
"coords",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(coords))
},
{
"classes",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(classes))
},
{
"relative",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(relative))
},
{
"obj_threshold",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(obj_threshold))
},
{
"post_nms_topn",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(post_nms_topn))
},
{
"score_threshold",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(score_threshold))
},
{
"iou_threshold",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(iou_threshold))
},
{
"pre_nms_topn",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(pre_nms_topn))
},
{
"N",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(N))
},
{
"resize_origin_img_to_net",
ge::kAttrOptional,
"VT_BOOL",
ge::AnyValue::CreateFrom(static_cast<bool>(resize_origin_img_to_net))
},
{
"out_box_dim",
ge::kAttrOptional,
"VT_INT",
ge::AnyValue::CreateFrom(static_cast<int64_t>(out_box_dim))
},
{
"alpha",
ge::kAttrOptional,
"VT_FLOAT",
ge::AnyValue::CreateFrom(static_cast<float>(alpha))
},
})
.InstanceDynamicInputNum("x", static_cast<int32_t>(x_num))
.InstanceDynamicInputNum("windex", static_cast<int32_t>(windex_num))
.InstanceDynamicInputNum("hindex", static_cast<int32_t>(hindex_num))
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

if ((x != nullptr) && (x_num > 0)) {
for (int64_t i = 0; i < x_num; ++i) {
auto one_x = x[i];
GE_ASSERT_NOTNULL(one_x);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_x->GetAnchor(), node->GetInDataAnchor(0 + i)));
}
}
if ((windex != nullptr) && (windex_num > 0)) {
for (int64_t i = 0; i < windex_num; ++i) {
auto one_windex = windex[i];
GE_ASSERT_NOTNULL(one_windex);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_windex->GetAnchor(), node->GetInDataAnchor(0 + x_num + i)));
}
}
if ((hindex != nullptr) && (hindex_num > 0)) {
for (int64_t i = 0; i < hindex_num; ++i) {
auto one_hindex = hindex[i];
GE_ASSERT_NOTNULL(one_hindex);
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(one_hindex->GetAnchor(), node->GetInDataAnchor(0 + x_num + windex_num + i)));
}
}
return EsYoloV5DetectionOutputDOutput{
graph.GetEsbTensorFromNode(node, 0),
graph.GetEsbTensorFromNode(node, 1),
};
}
EsbTensor *EsYoloxBoundingBoxDecode(EsbTensor *priors, EsbTensor *bboxes) {
GE_ASSERT_NOTNULL(priors);
GE_ASSERT_NOTNULL(bboxes);
auto &graph = priors->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("YoloxBoundingBoxDecode")
.Name(("YoloxBoundingBoxDecode_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"priors", ge::kIrInputRequired, ""},
{"bboxes", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"decoded_bboxes", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(priors->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(bboxes->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsZerosLike(EsbTensor *x) {
GE_ASSERT_NOTNULL(x);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("ZerosLike")
.Name(("ZerosLike_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *EsZeta(EsbTensor *x, EsbTensor *q) {
GE_ASSERT_NOTNULL(x);
GE_ASSERT_NOTNULL(q);
auto &graph = x->GetOwner();

auto desc = ge::CompliantOpDescBuilder().OpType("Zeta")
.Name(("Zeta_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
{"x", ge::kIrInputRequired, ""},
{"q", ge::kIrInputRequired, ""},
})
.IrDefOutputs({
{"z", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(x->GetAnchor(), node->GetInDataAnchor(0)));
GE_ASSERT_GRAPH_SUCCESS(ge::GraphUtils::AddEdge(q->GetAnchor(), node->GetInDataAnchor(1)));
return graph.GetEsbTensorFromNode(std::move(node), 0);
}
EsbTensor *Es_ParallelConcatStart(EsbGraph *owner_graph, ge::DataType dtype, const int64_t *shape, int64_t shape_num) {
GE_ASSERT_NOTNULL(owner_graph);
EsbGraph &graph = *owner_graph;

auto desc = ge::CompliantOpDescBuilder().OpType("_ParallelConcatStart")
.Name(("_ParallelConcatStart_" + std::to_string(graph.NextNodeIndex())).c_str())
.IrDefInputs({
})
.IrDefOutputs({
{"y", ge::kIrOutputRequired, ""},
})
.IrDefAttrs({
{
"dtype",
ge::kAttrOptional,
"VT_DATA_TYPE",
ge::AnyValue::CreateFrom(static_cast<ge::DataType>(dtype))
},
{
"shape",
ge::kAttrOptional,
"VT_LIST_INT",
ge::AnyValue::CreateFrom(std::vector<int64_t>(shape, shape + shape_num))
},
})
.Build();
GE_ASSERT_NOTNULL(desc);
auto node = graph.GetComputeGraph()->AddNode(desc);
GE_ASSERT_NOTNULL(node);

return graph.GetEsbTensorFromNode(std::move(node), 0);
}

#ifdef __cplusplus
}
#endif
/** Unsupported ops and reasons:
 * Unsupported attr type: VT_LIST_DATA_TYPE(13): [MapClear, MapIncompleteSize, MapSize, MapStage, MemSet, OrderedMapClear, OrderedMapIncompleteSize, OrderedMapSize, OrderedMapStage, PriorityQueue, QueueData, StageClear, StageSize, ]
 * Unsupported attr type: VT_LIST_LIST_INT(4): [GatherShapes, PadD, PadV2D, PadV3D, ]
 * Does not support op with duplicate input/output/attr names(1): [GatherD, ]
 * Unsupported attr type: VT_TENSOR(3): [Const, Constant, Variable, ]
 * Unsupported attr type: VT_LIST_STRING(14): [BasicGRUInplaceFillWindowCache, BasicLSTMInplaceFillWindowCache, CommonGRU, CommonLSTM, EmbeddingComputeVarExport, EmbeddingComputeVarImport, EmbeddingTableExport, EmbeddingTableFindAndInit, EmbeddingTableImport, FakeRemoteLookupUniqued, FixPipe, RaggedTensorToTensor, StringNormalizer, TfIdfVectorizer, ]
 * Unsupported attr type: (4): [Barrier, FIFOQueue, PaddingFIFOQueue, RandomShuffleQueue, ]
 * Does not support op with dynamic output(130): [AdpGetNext, AssistHelp, BarrierTakeMany, Batch, CTCBeamSearchDecoder, Case, ConcatOffset, ConcatOffsetD, Copy, DecodeCSV, DynamicGetNext, DynamicGetNextV2, DynamicLSTMGradCell, DynamicPartition, DynamicRNNGrad, DynamicRNNV2Grad, EmbeddingFeatureMappingFind, EmbeddingFeatureMappingImport, EmbeddingHashmapImport, FlowFunc, For, ForeachAbs, ForeachAcos, ForeachAddList, ForeachAddScalar, ForeachAddScalarList, ForeachAddcdivList, ForeachAddcdivScalar, ForeachAddcdivScalarList, ForeachAddcmulList, ForeachAddcmulScalar, ForeachAddcmulScalarList, ForeachAsin, ForeachAtan, ForeachBinaryOp, ForeachBinaryWithScalarOp, ForeachCopy, ForeachCos, ForeachCosh, ForeachDivList, ForeachDivScalar, ForeachDivScalarList, ForeachErf, ForeachErfc, ForeachExp, ForeachExpm1, ForeachLerpList, ForeachLerpScalar, ForeachLog, ForeachLog10, ForeachLog1p, ForeachLog2, ForeachMaximumList, ForeachMaximumScalar, ForeachMaximumScalarList, ForeachMinimumList, ForeachMinimumScalar, ForeachMinimumScalarList, ForeachMulList, ForeachMulScalar, ForeachMulScalarList, ForeachNeg, ForeachNorm, ForeachPowList, ForeachPowScalar, ForeachPowScalarAndTensor, ForeachPowScalarList, ForeachReciprocal, ForeachRoundOffNumber, ForeachScalarPowTensor, ForeachSigmoid, ForeachSign, ForeachSin, ForeachSinh, ForeachSqrt, ForeachSubList, ForeachSubScalar, ForeachSubScalarList, ForeachTan, ForeachTanh, ForeachTernaryOp, ForeachTernaryWithScalarOp, ForeachUnaryOp, ForeachUnaryWithScalarOp, GetNext, GetNextFromQueue, GetNextV2, GroupedMatMulAllReduce, GroupedMatmul, HcomBroadcast, IdentityN, If, MapPeek, MapUnstage, MapUnstageNoKey, MoeInitRoutingV2, OptionalGetValue, OrderedMapPeek, OrderedMapUnstage, OrderedMapUnstageNoKey, ParseExample, ParseSingleExample, ParseSingleSequenceExample, PartitionedCall, PeekData, PhonySplit, QueueDequeue, QueueDequeueMany, QueueDequeueUpTo, RaggedGather, RaggedTensorFromVariant, ScatterList, SdcaOptimizerV2, ShapeN, SparseSplit, Split, SplitD, SplitV, SplitVD, StagePeek, StatefulPartitionedCall, StatelessCase, StatelessIf, StatelessWhile, SwitchN, Unpack, Unstage, While, _If, _While, ]
 */

