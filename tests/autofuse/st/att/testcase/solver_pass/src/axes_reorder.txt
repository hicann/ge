ss << "enum class ConstraintType {\n";
ss << "  LOCAL_BUFFER = 0,\n";
ss << "  LB_MIXED = 1,\n";
ss << "  MC_MIXED = 2,\n";
ss << "};\n";
ss << "\n";
ss << "struct Variable;\n";
ss << "struct TilingVariable;\n";
ss << "struct Constraint;\n";
ss << "using ConsEvalFuncPtr = int64_t (*)(TilingVariable **rel_tiling_vars, Variable **rel_input_shapes, int64_t rel_hw_spec);\n";
ss << "using GetUpperBoundFuncPtr = int64_t (*)(Variable **rel_ori_dims);\n";
ss << "\n";
ss << "struct Variable {\n";
ss << "  int64_t value = -1;\n";
ss << "};\n";
ss << "\n";
ss << "struct Constraint {\n";
ss << "  int64_t rel_hw_spec = 0;\n";
ss << "  uint32_t rel_tiling_vars_size = 0u;\n";
ss << "  uint32_t rel_in_shapes_size = 0u;\n";
ss << "  TilingVariable **rel_tiling_vars = nullptr;\n";
ss << "  Variable **rel_in_shapes = nullptr;\n";
ss << "  ConsEvalFuncPtr eval = nullptr;\n";
ss << "  ConstraintType type;\n";
ss << "};\n";
ss << "\n";
ss << "struct TilingVariable : public Variable {\n";
ss << "  int64_t align = 1;\n";
ss << "  uint32_t rel_cons_size = 0u;\n";
ss << "  uint32_t upper_bound_vars_size = 0u;\n";
ss << "  bool notail = false;\n";
ss << "  TilingVariable *notail_var = nullptr;\n";
ss << "  Variable **upper_bound_vars = nullptr;\n";
ss << "  Constraint **rel_cons = nullptr;\n";
ss << "  GetUpperBoundFuncPtr upper_bound = nullptr;\n";
ss << "  bool SetValue(int64_t val) {\n";
ss << "    if (val <= 0) {\n";
ss << "      return false;\n";
ss << "    }\n";
ss << "    value = val;\n";
ss << "    return true;\n";
ss << "  }\n";
ss << "};\n";
ss << "\n";
ss << "struct AxesReorderSolverInput {\n";
ss << "  uint32_t core_num = 0u;\n";
ss << "  uint32_t input_vars_size = 0u;\n";
ss << "  uint32_t tiling_vars_size = 0u;\n";
ss << "  uint32_t pure_mc_vars_size = 0u;\n";
ss << "  uint32_t local_buffer_vars_size = 0u;\n";
ss << "  uint32_t all_cons_size = 0u;\n";
ss << "  double THRESHOLD = 0.8f;\n";
ss << "  Variable **input_vars = nullptr;\n";
ss << "  TilingVariable **tiling_vars = nullptr;\n";
ss << "  TilingVariable **pure_mc_vars = nullptr;\n";
ss << "  TilingVariable **local_buffer_vars = nullptr;\n";
ss << "  Constraint **all_cons = nullptr;\n";
ss << "};\n";
ss << "\n";
ss << "class AxesReorderSolver {\n";
ss << "public:\n";
ss << "  explicit AxesReorderSolver(const AxesReorderSolverInput &input) : input_(input) {}\n";
ss << "  ~AxesReorderSolver() = default;\n";
ss << "  bool Run();\n";
ss << "protected:\n";
ss << "  virtual bool CalUsedCoreNum(int32_t &used_core_num, bool &load_balance) = 0;\n";
ss << "  AxesReorderSolverInput input_;\n";
ss << "private:\n";
ss << "  bool TuneNotailVar(TilingVariable *var);\n";
ss << "  bool SatisfyCons(ConstraintType cons_type);\n";
ss << "  bool SatisfyCons(TilingVariable *var, ConstraintType cons_type);\n";
ss << "  bool SatisfyMCCons();\n";
ss << "  bool InitLocalBufferVars();\n";
ss << "  bool InitMulticoreVars();\n";
ss << "  bool MulticoreTiling();\n";
ss << "  bool LocalBufTiling();\n";
ss << "  bool TuneMulticore();\n";
ss << "  bool MulticoreTunable();\n";
ss << "  bool LBVarTunable(TilingVariable *var);\n";
ss << "};\n";
ss << "\n";
ss << "bool AxesReorderSolver::MulticoreTunable() {\n";
ss << "  int32_t used_core_num;\n";
ss << "  bool load_balance;\n";
ss << "  int64_t max_core_num = input_.core_num;\n";
ss << "  CalUsedCoreNum(used_core_num, load_balance);\n";
ss << "  return used_core_num < static_cast<int32_t>(input_.THRESHOLD * max_core_num);\n";
ss << "}\n";
ss << "bool AxesReorderSolver::LBVarTunable(TilingVariable *var) {\n";
ss << "  bool contain_lb = false;\n";
ss << "  bool contain_mc_mixed = false;\n";
ss << "  for (uint32_t i=0u; i < var->rel_cons_size; ++i) {\n";
ss << "    auto &rel_cons = var->rel_cons[i];\n";
ss << "    if (rel_cons->type == ConstraintType::LOCAL_BUFFER) {\n";
ss << "     contain_lb = true;\n";
ss << "    }\n";
ss << "    if (rel_cons->type == ConstraintType::MC_MIXED) {\n";
ss << "     contain_mc_mixed = true;\n";
ss << "    }\n";
ss << "  }\n";
ss << "  return contain_lb && contain_mc_mixed;\n";
ss << "}\n";
ss << "\n";
ss << "bool AxesReorderSolver::TuneMulticore() {\n";
ss << "  if (!MulticoreTunable()) {\n";
ss << "    return true;\n";
ss << "  }\n";
ss << "  for (uint32_t i = input_.local_buffer_vars_size - 1; i >= 0; --i) {\n";
ss << "    auto &var = input_.local_buffer_vars[i];\n";
ss << "    if (LBVarTunable(var)) {\n";
ss << "      int64_t boundary = var->align;\n";
ss << "      int64_t last_boundary = -1;\n";
ss << "      int64_t last_val = -1;\n";
ss << "      while (!(last_boundary == boundary && last_val == var->value) && var->value != var->align) {\n";
ss << "        last_boundary = boundary;\n";
ss << "        last_val = var->value;\n";
ss << "        var->value = CeilDiv((boundary + var->value) / 2, var->align) * var->align;\n";
ss << "        if (!TuneNotailVar(var)) {\n";
ss << "          return false;\n";
ss << "        }\n";
ss << "        while (!SatisfyCons(var, ConstraintType::LB_MIXED) && var->value != var->align) {\n";
ss << "          var->value -= var->align;\n";
ss << "          if (!TuneNotailVar(var)) {\n";
ss << "            return false;\n";
ss << "          }\n";
ss << "        }\n";
ss << "        if (!MulticoreTiling()) {\n";
ss << "          return false;\n";
ss << "        }\n";
ss << "        if (!MulticoreTunable()) {\n";
ss << "          boundary = var->value;\n";
ss << "          var->value = last_val;\n";
ss << "        }\n";
ss << "      }\n";
ss << "    }\n";
ss << "  }\n";
ss << "  return true;\n";
ss << "}\n";
ss << "\n";
ss << "bool AxesReorderSolver::InitLocalBufferVars() {\n";
ss << "  for (uint32_t i = 0u; i < input_.local_buffer_vars_size; ++i) {\n";
ss << "    auto &var = input_.local_buffer_vars[i];\n";
ss << "    if (!var->SetValue(var->align)) {\n";
ss << "      OP_LOGW(OP_NAME, \"Failed to init local buffer value.\");\n";
ss << "      return false;\n";
ss << "    }\n";
ss << "  }\n";
ss << "  return true;\n";
ss << "}\n";
ss << "\n";
ss << "bool AxesReorderSolver::InitMulticoreVars() {\n";
ss << "  for (uint32_t i = input_.pure_mc_vars_size - 1; i >= 0; --i) {\n";
ss << "    auto &var = input_.pure_mc_vars[i];\n";
ss << "    auto upper_bound_val = var->upper_bound(var->upper_bound_vars);\n";
ss << "    if (upper_bound_val == -1) {\n";
ss << "      return false;\n";
ss << "    }\n";
ss << "    upper_bound_val = CeilDiv(upper_bound_val, var->align) * var->align;\n";
ss << "    if (!var->SetValue(upper_bound_val)) {\n";
ss << "      OP_LOGW(OP_NAME, \"Failed to init multicore value.\");\n";
ss << "      return false;\n";
ss << "    }\n";
ss << "  }\n";
ss << "  return true;\n";
ss << "}\n";
ss << "bool AxesReorderSolver::SatisfyCons(ConstraintType cons_type) {\n";
ss << "  for (uint32_t i = 0u; i < input_.all_cons_size; i++) {\n";
ss << "    auto &cons = input_.all_cons[i];\n";
ss << "    if (cons->type != cons_type) {\n";
ss << "      continue;\n";
ss << "    }\n";
ss << "    if (cons->eval(cons->rel_tiling_vars, cons->rel_in_shapes, cons->rel_hw_spec) > 0) {\n";
ss << "      return false;\n";
ss << "    }\n";
ss << "  }\n";
ss << "  return true;\n";
ss << "}\n";
ss << "\n";
ss << "bool AxesReorderSolver::SatisfyCons(TilingVariable *var, ConstraintType cons_type) {\n";
ss << "  for (uint32_t j = 0; j < var->rel_cons_size; ++j) {\n";
ss << "    auto &cons = var->rel_cons[j];\n";
ss << "    if (cons->type != cons_type) {\n";
ss << "      continue;\n";
ss << "    }\n";
ss << "    if (cons->eval(cons->rel_tiling_vars, cons->rel_in_shapes, cons->rel_hw_spec) > 0) {\n";
ss << "      return false;\n";
ss << "    }\n";
ss << "  }\n";
ss << "  return true;\n";
ss << "}\n";
ss << "\n";
ss << "bool AxesReorderSolver::SatisfyMCCons() {\n";
ss << "  int64_t used_core_num = 0;\n";
ss << "  bool load_balance = false;\n";
ss << "  CalUsedCoreNum(used_core_num, load_balance);\n";
ss << "  return used_core_num <= static_cast<int64_t>(input_.core_num); \n";
ss << "}\n";
ss << "\n";
ss << "bool AxesReorderSolver::TuneNotailVar(TilingVariable *var) {\n";
ss << "  if (!var->notail) {\n";
ss << "    return true;\n";
ss << "  }\n";
ss << "  if (var->notail_var->value % var->value == 0) {\n";
ss << "    return true;\n";
ss << "  }\n";
ss << "  for (; var->value > 0; var->value -= var->align) {\n";
ss << "    if (var->notail_var->value % var->value != 0) {\n";
ss << "      continue;\n";
ss << "    }\n";
ss << "    break;\n";
ss << "  }\n";
ss << "  return var->value != 0;\n";
ss << "}\n";
ss << "\n";
ss << "bool AxesReorderSolver::MulticoreTiling() {\n";
ss << "  if (!InitMulticoreVars()) {\n";
ss << "    OP_LOGE(OP_NAME, \"multicore tiling failed\");\n";
ss << "    return false;\n";
ss << "  }\n";
ss << "  if (!SatisfyMCCons()) {\n";
ss << "    OP_LOGE(OP_NAME, \"Multicore Tiling Calculation failed in the first check.\");\n";
ss << "    return false;\n";
ss << "  }\n";
ss << "  for (int32_t i=input_.pure_mc_vars_size - 1; i >= 0; --i) {\n";
ss << "    auto &var = input_.pure_mc_vars[i];\n";
ss << "    int64_t boundary = var->align;\n";
ss << "    auto init_val = var->value;\n";
ss << "    var->SetValue(boundary);\n";
ss << "    if (!SatisfyMCCons()) {\n";
ss << "      var->SetValue(init_val);\n";
ss << "      int64_t last_boundary = -1;\n";
ss << "      int64_t last_val = -1;\n";
ss << "      while (!(last_boundary == boundary && last_val == var->value)) {\n";
ss << "        last_boundary = boundary;\n";
ss << "        last_val = var->value;\n";
ss << "        var->value = CeilDiv((boundary + var->value) / 2, var->align) * var->align;\n";
ss << "        if (!SatisfyMCCons()) {\n";
ss << "          boundary = var->value;\n";
ss << "          var->value = last_val;\n";
ss << "        }\n";
ss << "      }\n";
ss << "    }\n";
ss << "    while (!SatisfyCons(var, ConstraintType::MC_MIXED) && var->value != init_val) {\n";
ss << "      var->value += var->align;\n";
ss << "    }\n";
ss << "  }\n";
ss << "  if (!SatisfyMCCons() || !SatisfyCons(ConstraintType::MC_MIXED)) {\n";
ss << "    OP_LOGW(OP_NAME, \"Multicore Tiling Calculation failed in the final check.\");\n";
ss << "    return false;\n";
ss << "  }\n";
ss << "  return true;\n";
ss << "}\n";
ss << "bool AxesReorderSolver::LocalBufTiling() {\n";
ss << "  if (!InitLocalBufferVars()) {\n";
ss << "    OP_LOGE(OP_NAME, \"init local buffer failed\");\n";
ss << "    return false;\n";
ss << "  }\n";
ss << "  if (!InitMulticoreVars()) {\n";
ss << "    OP_LOGE(OP_NAME, \"multicore tiling failed\");\n";
ss << "    return false;\n";
ss << "  }\n";
ss << "  if (!SatisfyCons(ConstraintType::LOCAL_BUFFER)) {\n";
ss << "    OP_LOGE(OP_NAME, \"local buffer tiling failed in the initial check\");\n";
ss << "    return false;\n";
ss << "  }\n";
ss << "  for (uint32_t i = 0u; i < input_.local_buffer_vars_size; ++i) {\n";
ss << "    auto &var = input_.local_buffer_vars[i];\n";
ss << "    auto upper_bound = var->upper_bound(var->upper_bound_vars);\n";
ss << "    int64_t boundary = CeilDiv(upper_bound, var->align) * var->align;\n";
ss << "    int64_t init_val = var->value;\n";
ss << "    var->SetValue(boundary);\n";
ss << "    if (!SatisfyCons(var, ConstraintType::LOCAL_BUFFER)) {\n";
ss << "      var->SetValue(init_val);\n";
ss << "      int64_t last_boundary = -1;\n";
ss << "      int64_t last_val = -1;\n";
ss << "      while (!(last_boundary == boundary && last_val == var->value)) {\n";
ss << "        last_boundary = boundary;\n";
ss << "        last_val = var->value;\n";
ss << "        var->value = CeilDiv((boundary + var->value) / 2, var->align) * var->align;\n";
ss << "        if (!SatisfyCons(var, ConstraintType::LOCAL_BUFFER)) {\n";
ss << "          boundary = var->value;\n";
ss << "          var->value = last_val; \n";
ss << "        }\n";
ss << "      }\n";
ss << "    }\n";
ss << "    if (!TuneNotailVar(var)) {\n";
ss << "      return false;\n";
ss << "    }\n";
ss << "    while (!SatisfyCons(var, ConstraintType::LB_MIXED) && var->value != var->align) {\n";
ss << "      var->value -= var->align;\n";
ss << "      if (!TuneNotailVar(var)) {\n";
ss << "        return false;\n";
ss << "      }\n";
ss << "    }\n";
ss << "  }\n";
ss << "  if (!SatisfyCons(ConstraintType::LOCAL_BUFFER) || !SatisfyCons(ConstraintType::LB_MIXED)) {\n";
ss << "    OP_LOGW(OP_NAME, \"Local Tiling Calculation failed in the final check.\");\n";
ss << "    return false;\n";
ss << "  }\n";
ss << "  return true;\n";
ss << "}\n";
ss << "\n";
ss << "\n";
ss << "\n";
ss << "bool AxesReorderSolver::Run() {\n";
ss << "  if (!LocalBufTiling()) {\n";
ss << "    OP_LOGE(OP_NAME, \"local buffer tiling failed\");\n";
ss << "    return false;\n";
ss << "  }\n";
ss << "  OP_LOGI(OP_NAME, \"local buffer tiling success\");\n";
ss << "  if (!MulticoreTiling()) {\n";
ss << "    OP_LOGE(OP_NAME, \"multicore tiling failed\");\n";
ss << "    return false;\n";
ss << "  }\n";
ss << "  if (!TuneMulticore()) {\n";
ss << "    OP_LOGE(OP_NAME, \"tune multicore tiling failed\");\n";
ss << "    return false;\n";
ss << "  }\n";
ss << "  OP_LOGI(OP_NAME, \"multicore tiling success\");\n";
ss << "  return true;\n";
ss << "}\n";
";